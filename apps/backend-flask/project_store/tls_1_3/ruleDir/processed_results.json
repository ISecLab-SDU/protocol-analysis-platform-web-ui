[
    {
        "rule": "The plus symbol indicates noteworthy extensions sent in the previously noted message.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The client responds with Certificate, CertificateVerify, and Finished, after which application data can be exchanged.",
        "req_type": "",
        "req_fields": [],
        "res_type": "Certificate, CertificateVerify, Finished",
        "res_fields": []
    },
    {
        "rule": "The client then sends EndOfEarlyData and Finished, after which both parties exchange Application Data.",
        "req_type": "EndOfEarlyData, Finished",
        "req_fields": [],
        "res_type": "Application Data",
        "res_fields": []
    },
    {
        "rule": "The \"signature_algorithms_cert\" extension allows a client to indicate which signature algorithms the client can validate in X.509 certificates.",
        "req_type": "ClientHello",
        "req_fields": [
            "signature_algorithms_cert"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The \"supported_versions\" ClientHello extension can be used to negotiate the version of TLS to use, in preference to the legacy_version field of the ClientHello.",
        "req_type": "ClientHello",
        "req_fields": [
            "legacy_version",
            "extensions.supported_versions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The server then sends ServerHello with key_share, EncryptedExtensions, CertificateRequest, Certificate, CertificateVerify, and Finished.",
        "req_type": "",
        "req_fields": [],
        "res_type": "ServerHello",
        "res_fields": [
            "key_share",
            "EncryptedExtensions",
            "CertificateRequest",
            "Certificate",
            "CertificateVerify",
            "Finished"
        ]
    },
    {
        "rule": "The handshake protocol defines an enumeration of handshake types including client_hello, server_hello, new_session_ticket, end_of_early_data, encrypted_extensions, certificate, certificate_request, certificate_verify, finished, key_update, and message_hash.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The server responds with a ServerHello containing pre_shared_key and key_share extensions, followed by EncryptedExtensions with early_data, and Finished.",
        "req_type": "",
        "req_fields": [],
        "res_type": "ServerHello, EncryptedExtensions, Finished",
        "res_fields": [
            "pre_shared_key",
            "key_share",
            "early_data"
        ]
    },
    {
        "rule": "The asterisk indicates optional or situation-dependent messages or extensions that are not always sent.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The client sends a ClientHello with early_data, key_share, psk_key_exchange_modes, and pre_shared_key extensions, along with optional Application Data.",
        "req_type": "ClientHello",
        "req_fields": [
            "early_data",
            "key_share",
            "psk_key_exchange_modes",
            "pre_shared_key",
            "Application Data"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The message flow for a full handshake with mismatched parameters involves the client sending a ClientHello with key_share, the server responding with a HelloRetryRequest and key_share, followed by the client sending another ClientHello with key_share.",
        "req_type": "ClientHello",
        "req_fields": [
            "key_share"
        ],
        "res_type": "HelloRetryRequest",
        "res_fields": [
            "key_share"
        ]
    },
    {
        "rule": "If the client has not provided a sufficient \"key_share\" extension (e.g., the extension includes only DHE or ECDHE groups unacceptable to or unsupported by the server), the server corrects the mismatch with a HelloRetryRequest and the client needs to restart the handshake with an appropriate \"key_share\" extension.",
        "req_type": "ClientHello",
        "req_fields": [
            "key_share"
        ],
        "res_type": "HelloRetryRequest",
        "res_fields": [
            "key_share"
        ]
    },
    {
        "rule": "Future extensions or additions to the protocol may define new values.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Protection against replay for ordinary TLS 1.3 1-RTT data is provided via the server's Random value, but 0-RTT data does not depend on the ServerHello and therefore has weaker guarantees.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "As the server is authenticating via a PSK, it does not send a Certificate or a CertificateVerify message.",
        "req_type": "",
        "req_fields": [],
        "res_type": "ServerHello",
        "res_fields": [
            "certificate",
            "certificate_verify"
        ]
    },
    {
        "rule": "Servers MUST NOT send this extension.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The body of the \"certificate_authorities\" extension consists of a CertificateAuthoritiesExtension structure.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Servers MUST NOT send a post-handshake CertificateRequest to clients which do not offer this extension.",
        "req_type": "CertificateRequest",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "When a client offers resumption via a PSK, it SHOULD also supply a \"key_share\" extension to the server to allow the server to decline resumption and fall back to a full handshake, if needed.",
        "req_type": "ClientHello",
        "req_fields": [
            "pre_shared_key",
            "key_share"
        ],
        "res_type": "ServerHello",
        "res_fields": []
    },
    {
        "rule": "The PostHandshakeAuth structure is empty, and the extension_data field of the post_handshake_auth extension has zero length.",
        "req_type": "PostHandshakeAuth",
        "req_fields": [
            "extension_data"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The \"certificate_authorities\" extension is used to indicate the certificate authorities (CAs) which an endpoint supports and which SHOULD be used by the receiving endpoint to guide certificate selection.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The newly introduced EncryptedExtensions message allows various extensions previously sent in the clear in the ServerHello to also enjoy confidentiality protection.",
        "req_type": "ServerHello",
        "req_fields": [
            "extensions"
        ],
        "res_type": "EncryptedExtensions",
        "res_fields": [
            "extensions"
        ]
    },
    {
        "rule": "The server responds with a \"pre_shared_key\" extension to negotiate the use of PSK key establishment and can (as shown here) respond with a \"key_share\" extension to do (EC)DHE key establishment, thus providing forward secrecy.",
        "req_type": "",
        "req_fields": [],
        "res_type": "ServerHello",
        "res_fields": [
            "pre_shared_key",
            "key_share"
        ]
    },
    {
        "rule": "The CertificateAuthoritiesExtension structure contains a list of distinguished names of acceptable certificate authorities, represented in DER-encoded format as specified in X690.",
        "req_type": "CertificateAuthoritiesExtension",
        "req_fields": [
            "list of distinguished names"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The server MAY send the \"certificate_authorities\" extension in the CertificateRequest message.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "certificate_authorities"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The client MAY send the \"certificate_authorities\" extension in the ClientHello message.",
        "req_type": "ClientHello",
        "req_fields": [
            "certificate_authorities"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "When sending a HelloRetryRequest, the server MAY provide a \"cookie\" extension to the client (this cookie extension is an exception to the usual rule that the only extensions that may be sent are those that appear in the ClientHello).",
        "req_type": "HelloRetryRequest",
        "req_fields": [
            "cookie"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.",
        "req_type": "ClientHello",
        "req_fields": [
            "cookie"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "When sending the new ClientHello, the client MUST copy the contents of the extension received in the HelloRetryRequest into a \"cookie\" extension in the new ClientHello.",
        "req_type": "ClientHello",
        "req_fields": [
            "cookie extension"
        ],
        "res_type": "HelloRetryRequest",
        "res_fields": [
            "cookie extension"
        ]
    },
    {
        "rule": "A \"signature_algorithms_cert\" extension (Section 4.2.3) may also be added to indicate certificate-specific signature algorithms.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "A \"signature_algorithms\" (Section 4.2.3) extension which indicates the signature algorithms which the client can accept.",
        "req_type": "ClientHello",
        "req_fields": [
            "signature_algorithms"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "When a server is operating statelessly, it may receive an unprotected record of type change_cipher_spec between the first and second ClientHello (see Section 5).",
        "req_type": "change_cipher_spec",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In TLS, the cryptographic negotiation proceeds by the client offering the following four sets of options in its ClientHello: A list of cipher suites which indicates the AEAD algorithm/HKDF hash pairs which the client supports.",
        "req_type": "ClientHello",
        "req_fields": [
            "cipher_suites"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "A \"supported_groups\" (Section 4.2.7) extension which indicates the (EC)DHE groups which the client supports and a \"key_share\" (Section 4.2.8) extension which contains (EC)DHE shares for some or all of these groups.",
        "req_type": "ClientHello",
        "req_fields": [
            "supported_groups",
            "key_share"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "A \"pre_shared_key\" (Section 4.2.11) extension which contains a list of symmetric key identities known to the client and a \"psk_key_exchange_modes\" (Section 4.2.9) extension which indicates the key exchange modes that may be used with PSKs.",
        "req_type": "ClientHello",
        "req_fields": [
            "pre_shared_key",
            "psk_key_exchange_modes"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the server does not select a PSK, then the first three of these options are entirely orthogonal: the server independently selects a cipher suite, an (EC)DHE group and key share for key establishment, and a signature algorithm/certificate pair to authenticate itself to the client.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the server selects a PSK, then it MUST also select a key establishment mode from the set indicated by the client's \"psk_key_exchange_modes\" extension (at present, PSK alone or with (EC)DHE).",
        "req_type": "ClientHello",
        "req_fields": [
            "psk_key_exchange_modes"
        ],
        "res_type": "ServerHello",
        "res_fields": []
    },
    {
        "rule": "When (EC)DHE is in use, the server will also provide a \"key_share\" extension.",
        "req_type": "",
        "req_fields": [],
        "res_type": "ServerHello",
        "res_fields": [
            "key_share"
        ]
    },
    {
        "rule": "If there is no overlap between the received \"supported_groups\" and the groups supported by the server, then the server MUST abort the handshake with a \"handshake_failure\" or an \"insufficient_security\" alert.",
        "req_type": "ClientHello",
        "req_fields": [
            "supported_groups"
        ],
        "res_type": "Alert",
        "res_fields": [
            "handshake_failure",
            "insufficient_security"
        ]
    },
    {
        "rule": "The handshake involves ClientHello, ServerHello, EncryptedExtensions, CertificateRequest, Certificate, CertificateVerify, and Finished messages, with optional extensions and application data exchange.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "When authenticating via a certificate, the server will send the Certificate (Section 4.4.2) and CertificateVerify (Section 4.4.3) messages.",
        "req_type": "",
        "req_fields": [],
        "res_type": "Certificate and CertificateVerify",
        "res_fields": []
    },
    {
        "rule": "* Indicates optional or situation-dependent messages/extensions that are not always sent.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The combination of the ClientHello and the ServerHello determines the shared keys.",
        "req_type": "ClientHello",
        "req_fields": [],
        "res_type": "ServerHello",
        "res_fields": []
    },
    {
        "rule": "If the server selects an (EC)DHE group and the client did not offer a compatible \"key_share\" extension in the initial ClientHello, the server MUST respond with a HelloRetryRequest (Section 4.1.4) message.",
        "req_type": "ClientHello",
        "req_fields": [
            "key_share"
        ],
        "res_type": "HelloRetryRequest",
        "res_fields": []
    },
    {
        "rule": "If the server successfully selects parameters and does not require a HelloRetryRequest, the server indicates the selected parameters in the ServerHello as follows: If PSK is being used, then the server will send a \"pre_shared_key\" extension indicating the selected key.",
        "req_type": "ClientHello",
        "req_fields": [],
        "res_type": "ServerHello",
        "res_fields": [
            "pre_shared_key"
        ]
    },
    {
        "rule": "If (EC)DHE key establishment is in use, then the ServerHello contains a \"key_share\" extension with the server's ephemeral Diffie-Hellman share; the server's share MUST be in the same group as one of the client's shares.",
        "req_type": "ClientHello",
        "req_fields": [
            "key_share extension"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "key_share extension"
        ]
    },
    {
        "rule": "If PSK key establishment is in use, then the ServerHello contains a \"pre_shared_key\" extension indicating which of the client's offered PSKs was selected.",
        "req_type": "ClientHello",
        "req_fields": [
            "pre_shared_key extension"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "pre_shared_key extension"
        ]
    },
    {
        "rule": "TLS uses the same set of messages every time that certificate-based authentication is needed.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "CertificateRequest specifies desired parameters for certificate-based client authentication if it is desired.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "desired parameters for certificate-based client authentication"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Specifically, Certificate message contains the certificate of the endpoint and any per-certificate extensions.",
        "req_type": "Certificate",
        "req_fields": [
            "certificate",
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In the Key Exchange phase, the client sends the ClientHello (Section 4.1.2) message, which contains a random nonce (ClientHello.random); its offered protocol versions; a list of symmetric cipher/HKDF hash pairs; either a set of Diffie-Hellman key shares (in the \"key_share\" (Section 4.2.8) extension), a set of pre-shared key labels (in the \"pre_shared_key\" (Section 4.2.11) extension), or both; and potentially additional extensions.",
        "req_type": "ClientHello",
        "req_fields": [
            "ClientHello.random",
            "offered protocol versions",
            "list of symmetric cipher/HKDF hash pairs",
            "key_share extension",
            "pre_shared_key extension",
            "additional extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Note that implementations can use (EC)DHE and PSK together, in which case both extensions will be supplied.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "extensions"
        ]
    },
    {
        "rule": "The server then sends two messages to establish the Server Parameters: EncryptedExtensions provides responses to ClientHello extensions that are not required to determine cryptographic parameters, excluding those specific to individual certificates.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions"
        ],
        "res_type": "EncryptedExtensions",
        "res_fields": [
            "extensions"
        ]
    },
    {
        "rule": "Note that if raw public keys or the cached information extension are in use, then the Certificate message will not contain a certificate but rather some other value corresponding to the server's long-term key.",
        "req_type": "",
        "req_fields": [],
        "res_type": "Certificate",
        "res_fields": [
            "certificate"
        ]
    },
    {
        "rule": "CertificateVerify provides a signature over the entire handshake using the private key corresponding to the public key in the Certificate message.",
        "req_type": "CertificateVerify",
        "req_fields": [
            "signature"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Upon receiving the server's messages, the client responds with its Authentication messages, namely Certificate and CertificateVerify if requested, and Finished.",
        "req_type": "server's messages",
        "req_fields": [],
        "res_type": "Authentication messages",
        "res_fields": [
            "Certificate",
            "CertificateVerify",
            "Finished"
        ]
    },
    {
        "rule": "This message is omitted by the server if not authenticating with a certificate and by the client if the server did not send CertificateRequest (thus indicating that the client should not authenticate with a certificate).",
        "req_type": "CertificateRequest",
        "req_fields": [],
        "res_type": "Certificate",
        "res_fields": []
    },
    {
        "rule": "Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",
        "req_type": "Application Data",
        "req_fields": [],
        "res_type": "Finished",
        "res_fields": []
    },
    {
        "rule": "The OIDFilter structure contains certificate_extension_oid and certificate_extension_values fields.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Some certificate extension OIDs allow multiple values (e.g., Extended Key Usage).",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "This extension, if provided by the server, MUST only be sent in the CertificateRequest message.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The \"oid_filters\" extension allows servers to provide a set of OID/value pairs which the server would like the client's certificate to match.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The filters parameter is a list of certificate extension OIDs from RFC5280 Profile with their allowed values, represented in DER-encoded format as specified in X690 Canonical Encoding Rules and Distinguished Encoding Rules.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the server has included a non-empty filters list, the client certificate included in the response MUST contain all of the specified extension OIDs that the client recognizes.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "filters"
        ],
        "res_type": "Certificate",
        "res_fields": [
            "certificate_list"
        ]
    },
    {
        "rule": "However, the client MUST ignore and skip any unrecognized certificate extension OIDs.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Depending on the type, matching certificate extension values are not necessarily bitwise-equal.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "PKIX RFCs define a variety of certificate extension OIDs and their corresponding value types.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "For each extension OID recognized by the client, all of the specified values MUST be present in the client certificate (but the certificate MAY have other values as well).",
        "req_type": "Certificate",
        "req_fields": [
            "extensions",
            "OID",
            "values"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the client ignored some of the required certificate extension OIDs and supplied a certificate that does not satisfy the request, the server MAY at its discretion either continue the connection without client authentication or abort the handshake with an \"unsupported_certificate\" alert.",
        "req_type": "Certificate",
        "req_fields": [
            "extensions"
        ],
        "res_type": "Alert",
        "res_fields": [
            "description"
        ]
    },
    {
        "rule": "It is expected that TLS implementations will rely on their PKI libraries to perform certificate selection using certificate extension OIDs.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Separate specifications may define matching rules for other certificate extensions.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "This document defines matching rules for two standard certificate extensions defined in RFC5280 Profile: The Key Usage extension in a certificate matches the request when all key usage bits asserted in the request are also asserted in the Key Usage certificate extension.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The server's extensions MUST contain \"supported_versions\".",
        "req_type": "HelloRetryRequest",
        "req_fields": [
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The Extended Key Usage extension in a certificate matches the request when all key purpose OIDs present in the request are also found in the Extended Key Usage certificate extension.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "extensions",
            "oid_filters"
        ],
        "res_type": "Certificate",
        "res_fields": [
            "extensions",
            "extended_key_usage"
        ]
    },
    {
        "rule": "Additionally, the HelloRetryRequest SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair.",
        "req_type": "HelloRetryRequest",
        "req_fields": [
            "extensions"
        ],
        "res_type": "ClientHello",
        "res_fields": []
    },
    {
        "rule": "The server will send the HelloRetryRequest message in response to a ClientHello message if the server is able to find an acceptable set of parameters but the ClientHello does not contain sufficient information to proceed with the handshake.",
        "req_type": "ClientHello",
        "req_fields": [],
        "res_type": "HelloRetryRequest",
        "res_fields": []
    },
    {
        "rule": "As discussed in Section 4.1.3, the HelloRetryRequest has the same format as a ServerHello message, and the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method fields have the same meaning.",
        "req_type": "HelloRetryRequest",
        "req_fields": [
            "legacy_version",
            "legacy_session_id_echo",
            "cipher_suite",
            "legacy_compression_method"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Clients MUST abort the handshake with an \"illegal_parameter\" alert if the HelloRetryRequest would not result in any change in the ClientHello.",
        "req_type": "HelloRetryRequest",
        "req_fields": [],
        "res_type": "ClientHello",
        "res_fields": []
    },
    {
        "rule": "As with the ServerHello, a HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the \"cookie\" (see Section 4.2.2) extension.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions"
        ],
        "res_type": "HelloRetryRequest",
        "res_fields": [
            "extensions"
        ]
    },
    {
        "rule": "Otherwise, the client MUST process all extensions in the HelloRetryRequest and send a second updated ClientHello.",
        "req_type": "HelloRetryRequest",
        "req_fields": [
            "extensions"
        ],
        "res_type": "ClientHello",
        "res_fields": []
    },
    {
        "rule": "Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3 and then process the extensions, starting with determining the version using \"supported_versions\".",
        "req_type": "HelloRetryRequest",
        "req_fields": [
            "legacy_version",
            "legacy_session_id_echo",
            "cipher_suite",
            "legacy_compression_method",
            "extensions",
            "supported_versions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If a client receives a second HelloRetryRequest in the same connection (i.e., where the ClientHello was itself in response to a HelloRetryRequest), the client MUST abort the handshake with an \"unexpected_message\" alert.",
        "req_type": "HelloRetryRequest",
        "req_fields": [],
        "res_type": "alert",
        "res_fields": [
            "unexpected_message"
        ]
    },
    {
        "rule": "A client which receives a cipher suite that was not offered MUST abort the handshake.",
        "req_type": "HelloRetryRequest",
        "req_fields": [
            "cipher_suite"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The HelloRetryRequest extensions defined in this specification are: supported_versions (see Section 4.2.1), cookie (see Section 4.2.2), and key_share (see Section 4.2.8).",
        "req_type": "HelloRetryRequest",
        "req_fields": [
            "supported_versions",
            "cookie",
            "key_share"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In addition, in its updated ClientHello, the client SHOULD NOT offer any pre-shared keys associated with a hash other than that of the selected cipher suite.",
        "req_type": "ClientHello",
        "req_fields": [
            "pre_shared_keys",
            "cipher_suite"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Servers MUST ensure that they negotiate the same cipher suite when receiving a conformant updated ClientHello (if the server selects the cipher suite as the first step in the negotiation, then the same cipher suite negotiation will happen automatically).",
        "req_type": "ClientHello",
        "req_fields": [
            "cipher_suite"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Upon receiving the ServerHello, clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and otherwise abort the handshake with an \"illegal_parameter\" alert.",
        "req_type": "ServerHello",
        "req_fields": [
            "cipher_suite"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The value of selected_version in the HelloRetryRequest \"supported_versions\" extension MUST be retained in the ServerHello, and a client MUST abort the handshake with an \"illegal_parameter\" alert if the value changes.",
        "req_type": "HelloRetryRequest",
        "req_fields": [
            "supported_versions",
            "selected_version"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "supported_versions",
            "selected_version"
        ]
    },
    {
        "rule": "Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.",
        "req_type": "ClientHello",
        "req_fields": [
            "legacy_version"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Implementations of this specification MUST send this extension in the ClientHello containing all versions of TLS which the implementations are prepared to negotiate (for this specification, that means minimally 0x0304, but if previous versions of TLS are allowed to be negotiated, the previous versions MUST be present as well).",
        "req_type": "ClientHello",
        "req_fields": [
            "supported_versions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the \"supported_versions\" extension to determine client preferences.",
        "req_type": "ClientHello",
        "req_fields": [
            "legacy_version",
            "extensions.supported_versions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in RFC5246, even if ClientHello.legacy_version is 0x0304 or later.",
        "req_type": "ClientHello",
        "req_fields": [
            "legacy_version"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions",
            "supported_versions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the \"supported_versions\" extension.",
        "req_type": "",
        "req_fields": [],
        "res_type": "ServerHello",
        "res_fields": [
            "version",
            "supported_versions"
        ]
    },
    {
        "rule": "Servers MUST only select a version of TLS present in the \"supported_versions\" extension and MUST ignore any unknown versions that are present in the extension.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions",
            "supported_versions"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "legacy_version",
            "supported_versions"
        ]
    },
    {
        "rule": "A server which negotiates TLS 1.3 MUST respond by sending a \"supported_versions\" extension containing the selected version value (0x0304).",
        "req_type": "ClientHello",
        "req_fields": [
            "supported_versions"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "supported_versions"
        ]
    },
    {
        "rule": "The server MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2).",
        "req_type": "",
        "req_fields": [],
        "res_type": "ServerHello",
        "res_fields": [
            "legacy_version"
        ]
    },
    {
        "rule": "Clients MUST check for this extension prior to processing the rest of the ServerHello (although they will have to parse the ServerHello in order to read the extension).",
        "req_type": "ServerHello",
        "req_fields": [
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the \"supported_versions\" extension to determine the selected version.",
        "req_type": "ServerHello",
        "req_fields": [
            "legacy_version",
            "extensions.supported_versions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The \"extension_data\" field of this extension contains a \"NamedGroupList\" value.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "When sent by the client, the \"supported_groups\" extension indicates the named groups which the client supports for key exchange, ordered from most preferred to least preferred.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions.supported_groups"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the \"supported_versions\" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an \"illegal_parameter\" alert.",
        "req_type": "ServerHello",
        "req_fields": [
            "supported_versions"
        ],
        "res_type": "Alert",
        "res_fields": [
            "illegal_parameter"
        ]
    },
    {
        "rule": "As of TLS 1.3, servers are permitted to send the \"supported_groups\" extension to the client.",
        "req_type": "",
        "req_fields": [],
        "res_type": "ServerHello",
        "res_fields": [
            "supported_groups"
        ]
    },
    {
        "rule": "Clients MUST NOT attempt to use tickets which have ages greater than the \"ticket_lifetime\" value which was provided with the ticket.",
        "req_type": "ClientHello",
        "req_fields": [
            "pre_shared_key",
            "obfuscated_ticket_age"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The addition of the \"ticket_age_add\" value prevents passive observers from correlating connections unless tickets are reused.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Clients MUST NOT act upon any information found in \"supported_groups\" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their \"key_share\" extension in subsequent connections.",
        "req_type": "ClientHello",
        "req_fields": [
            "supported_groups",
            "key_share"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the server has a group it prefers to the ones in the \"key_share\" extension but is still willing to accept the ClientHello, it SHOULD send \"supported_groups\" to update the client's view of its preferences; this extension SHOULD contain all groups the server supports, regardless of whether they are currently supported by the client.",
        "req_type": "ClientHello",
        "req_fields": [
            "key_share"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "supported_groups"
        ]
    },
    {
        "rule": "Note that the \"ticket_lifetime\" field in the NewSessionTicket message is in seconds but the \"obfuscated_ticket_age\" is in milliseconds.",
        "req_type": "",
        "req_fields": [],
        "res_type": "NewSessionTicket",
        "res_fields": [
            "ticket_lifetime",
            "obfuscated_ticket_age"
        ]
    },
    {
        "rule": "The next two messages from the server, EncryptedExtensions and CertificateRequest, contain information from the server that determines the rest of the handshake.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Clients are permitted to \"stream\" 0-RTT data until they receive the server's Finished, only then sending the EndOfEarlyData message, followed by the rest of the handshake.",
        "req_type": "EndOfEarlyData",
        "req_fields": [],
        "res_type": "Finished",
        "res_fields": []
    },
    {
        "rule": "In order to avoid deadlocks, when accepting \"early_data\", servers MUST process the client's ClientHello and then immediately send their flight of messages, rather than waiting for the client's EndOfEarlyData message before sending the server's ServerHello.",
        "req_type": "ClientHello",
        "req_fields": [
            "early_data"
        ],
        "res_type": "ServerHello",
        "res_fields": []
    },
    {
        "rule": "In order to use PSKs, clients MUST also send a \"psk_key_exchange_modes\" extension.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions",
            "psk_key_exchange_modes"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The server MUST NOT send a \"psk_key_exchange_modes\" extension.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The semantics of this extension are that the client only supports the use of PSKs with these modes, which restricts both the use of PSKs offered in this ClientHello and those which the server might supply via NewSessionTicket.",
        "req_type": "ClientHello",
        "req_fields": [
            "pre_shared_key_exchange_modes"
        ],
        "res_type": "NewSessionTicket",
        "res_fields": []
    },
    {
        "rule": "A client MUST provide a \"psk_key_exchange_modes\" extension if it offers a \"pre_shared_key\" extension.",
        "req_type": "ClientHello",
        "req_fields": [
            "pre_shared_key",
            "psk_key_exchange_modes"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If clients offer \"pre_shared_key\" without a \"psk_key_exchange_modes\" extension, servers MUST abort the handshake.",
        "req_type": "ClientHello",
        "req_fields": [
            "pre_shared_key",
            "psk_key_exchange_modes"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In psk_dhe_ke mode, the client and server MUST supply \"key_share\" values as described in Section 4.2.8.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In psk_ke mode, the server MUST NOT supply a \"key_share\" value.",
        "req_type": "ClientHello",
        "req_fields": [
            "psk_key_exchange_modes"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "key_share"
        ]
    },
    {
        "rule": "The server will send the ServerHello message in response to a ClientHello message to proceed with the handshake if the server is able to negotiate an acceptable set of handshake parameters based on the ClientHello.",
        "req_type": "ClientHello",
        "req_fields": [],
        "res_type": "ServerHello",
        "res_fields": []
    },
    {
        "rule": "Any future values that are allocated must ensure that the transmitted protocol messages unambiguously identify which mode was selected by the server; at present, this is indicated by the presence of the \"key_share\" in the ServerHello.",
        "req_type": "",
        "req_fields": [],
        "res_type": "ServerHello",
        "res_fields": [
            "key_share"
        ]
    },
    {
        "rule": "The random structure is generated by the server and MUST be generated independently of the ClientHello.random.",
        "req_type": "ClientHello",
        "req_fields": [
            "random"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "random"
        ]
    },
    {
        "rule": "In TLS 1.3, the TLS server indicates its version using the \"supported_versions\" extension (Section 4.2.1), and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2.",
        "req_type": "Server Hello",
        "req_fields": [
            "legacy_version",
            "supported_versions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "extensions: A list of extensions.",
        "req_type": "ServerHello",
        "req_fields": [
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "A client which receives a legacy_session_id_echo field that does not match what it sent in the ClientHello MUST abort the handshake with an \"illegal_parameter\" alert.",
        "req_type": "ClientHello",
        "req_fields": [
            "legacy_session_id"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "legacy_session_id_echo"
        ]
    },
    {
        "rule": "legacy_compression_method: A single byte which MUST have the value 0.",
        "req_type": "Server Hello",
        "req_fields": [
            "legacy_compression_method"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "cipher_suite: The single cipher suite selected by the server from the list in ClientHello.cipher_suites.",
        "req_type": "ClientHello",
        "req_fields": [
            "cipher_suites"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "cipher_suite"
        ]
    },
    {
        "rule": "A client which receives a cipher suite that was not offered MUST abort the handshake with an \"illegal_parameter\" alert.",
        "req_type": "ServerHello",
        "req_fields": [
            "cipher_suite"
        ],
        "res_type": "Alert",
        "res_fields": [
            "alert_description"
        ]
    },
    {
        "rule": "Structure of the ServerHello message: struct { ProtocolVersion legacy_version = 0x0303; Random random; opaque legacy_session_id_echo<0..32>; CipherSuite cipher_suite; uint8 legacy_compression_method = 0; Extension extensions<6..2^16-1>; } ServerHello.",
        "req_type": "",
        "req_fields": [],
        "res_type": "ServerHello",
        "res_fields": [
            "ProtocolVersion legacy_version",
            "Random random",
            "opaque legacy_session_id_echo<0..32>",
            "CipherSuite cipher_suite",
            "uint8 legacy_compression_method",
            "Extension extensions<6..2^16-1>"
        ]
    },
    {
        "rule": "All TLS 1.3 ServerHello messages MUST contain the \"supported_versions\" extension.",
        "req_type": "ServerHello",
        "req_fields": [
            "supported_versions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The ServerHello MUST only include extensions which are required to establish the cryptographic context and negotiate the protocol version.",
        "req_type": "ServerHello",
        "req_fields": [
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Other extensions (see Section 4.2) are sent separately in the EncryptedExtensions message.",
        "req_type": "ServerHello",
        "req_fields": [],
        "res_type": "EncryptedExtensions",
        "res_fields": [
            "extensions"
        ]
    },
    {
        "rule": "Current ServerHello messages additionally contain either the \"pre_shared_key\" extension or the \"key_share\" extension, or both (when using a PSK with (EC)DHE key establishment).",
        "req_type": "ServerHello",
        "req_fields": [
            "pre_shared_key",
            "key_share"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Upon receiving a message with type server_hello, implementations MUST first examine the Random value and, if it matches this special value, process it as described in Section 4.1.4.",
        "req_type": "server_hello",
        "req_fields": [
            "Random"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "For reasons of backward compatibility with middleboxes (see Appendix D.4), the HelloRetryRequest message uses the same structure as the ServerHello, but with the Random field set to the special value of the SHA-256 of \"HelloRetryRequest\".",
        "req_type": "HelloRetryRequest",
        "req_fields": [
            "Random"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "TLS 1.2 clients SHOULD also check that the last 8 bytes are not equal to the second value if the ServerHello indicates TLS 1.1 or below.",
        "req_type": "ServerHello",
        "req_fields": [
            "legacy_version"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "TLS 1.3 servers which negotiate TLS 1.2 or below in response to a ClientHello MUST set the last 8 bytes of their Random value specially in their ServerHello.",
        "req_type": "ClientHello",
        "req_fields": [],
        "res_type": "ServerHello",
        "res_fields": [
            "Random"
        ]
    },
    {
        "rule": "TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below MUST check that the last 8 bytes are not equal to either of these values.",
        "req_type": "ServerHello",
        "req_fields": [
            "legacy_version",
            "random"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If negotiating TLS 1.2, TLS 1.3 servers MUST set the last 8 bytes of their Random value to the bytes: 44 4F 57 4E 47 52 44 01.",
        "req_type": "",
        "req_fields": [],
        "res_type": "ServerHello",
        "res_fields": [
            "random"
        ]
    },
    {
        "rule": "If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2 servers SHOULD, set the last 8 bytes of their ServerHello.Random value to the bytes: 44 4F 57 4E 47 52 44 00.",
        "req_type": "",
        "req_fields": [],
        "res_type": "ServerHello",
        "res_fields": [
            "Random"
        ]
    },
    {
        "rule": "The PSK binder value forms a binding between a PSK and the current handshake, as well as a binding between the handshake in which the PSK was generated (if via a NewSessionTicket message) and the current handshake.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Each entry in the binders list is computed as an HMAC over a transcript hash (see Section 4.4.1) containing a partial ClientHello up to and including the PreSharedKeyExtension.identities field.",
        "req_type": "ClientHello",
        "req_fields": [
            "PreSharedKeyExtension.identities"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "A legacy TLS client performing renegotiation with TLS 1.2 or prior and which receives a TLS 1.3 ServerHello during renegotiation MUST abort the handshake with a \"protocol_version\" alert.",
        "req_type": "ServerHello",
        "req_fields": [
            "legacy_version",
            "supported_versions"
        ],
        "res_type": "Alert",
        "res_fields": [
            "level",
            "description"
        ]
    },
    {
        "rule": "In all handshakes, the server MUST send the EncryptedExtensions message immediately after the ServerHello message.",
        "req_type": "ServerHello",
        "req_fields": [],
        "res_type": "EncryptedExtensions",
        "res_fields": []
    },
    {
        "rule": "The EncryptedExtensions message is the first message that is encrypted under keys derived from the server_handshake_traffic_secret.",
        "req_type": "EncryptedExtensions",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The length fields for the message (including the overall length, the length of the extensions block, and the length of the \"pre_shared_key\" extension) are all set as if binders of the correct lengths were present.",
        "req_type": "ClientHello",
        "req_fields": [
            "overall length",
            "extensions block length",
            "pre_shared_key extension length",
            "PSK binder"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The PskBinderEntry is computed in the same way as the Finished message (Section 4.4.4) but with the BaseKey being the binder_key derived via the key schedule from the corresponding PSK which is being offered (see Section 7.1).",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The EncryptedExtensions message contains extensions that can be protected, i.e., any which are not needed to establish the cryptographic context but which are not associated with individual certificates.",
        "req_type": "EncryptedExtensions",
        "req_fields": [
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The client MUST check EncryptedExtensions for the presence of any forbidden extensions and if any are found MUST abort the handshake with an \"illegal_parameter\" alert.",
        "req_type": "EncryptedExtensions",
        "req_fields": [
            "extensions"
        ],
        "res_type": "Alert",
        "res_fields": [
            "description"
        ]
    },
    {
        "rule": "The structure of the EncryptedExtensions message is: struct { Extension extensions<0..2^16-1>; } EncryptedExtensions; where extensions is a list of extensions.",
        "req_type": "EncryptedExtensions",
        "req_fields": [
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "When a client first connects to a server, it is REQUIRED to send the ClientHello as its first TLS message.",
        "req_type": "ClientHello",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The client may optionally add, remove, or change the length of the \"padding\" extension [RFC7685 ClientHello Padding Extension].",
        "req_type": "ClientHello",
        "req_fields": [
            "padding"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In that case, the client MUST send the same ClientHello without modification, except as follows: If a \"key_share\" extension was supplied in the HelloRetryRequest, the client must replace the list of shares with a list containing a single KeyShareEntry from the indicated group.",
        "req_type": "ClientHello",
        "req_fields": [
            "key_share",
            "list of shares",
            "KeyShareEntry"
        ],
        "res_type": "HelloRetryRequest",
        "res_fields": [
            "key_share"
        ]
    },
    {
        "rule": "The client must update the \"pre_shared_key\" extension if present by recomputing the \"obfuscated_ticket_age\" and binder values and (optionally) removing any PSKs which are incompatible with the server's indicated cipher suite.",
        "req_type": "ClientHello",
        "req_fields": [
            "pre_shared_key",
            "obfuscated_ticket_age",
            "binder"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Because TLS 1.3 forbids renegotiation, if a server has negotiated TLS 1.3 and receives a ClientHello at any other time, it MUST terminate the connection with an \"unexpected_message\" alert.",
        "req_type": "ClientHello",
        "req_fields": [],
        "res_type": "Alert",
        "res_fields": [
            "unexpected_message"
        ]
    },
    {
        "rule": "If a server established a TLS connection with a previous version of TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST retain the previous protocol version.",
        "req_type": "ClientHello",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "TLS 1.3 ClientHellos are identified as having a legacy_version of 0x0303 and a supported_versions extension present with 0x0304 as the highest version indicated therein.",
        "req_type": "ClientHello",
        "req_fields": [
            "legacy_version",
            "supported_versions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In TLS 1.3, the client indicates its version preferences in the \"supported_versions\" extension (Section 4.2.1) and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2.",
        "req_type": "Client Hello",
        "req_fields": [
            "legacy_version",
            "supported_versions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the list contains cipher suites that the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites and process the remaining ones as usual.",
        "req_type": "ClientHello",
        "req_fields": [
            "cipher_suites"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the client is attempting a PSK key establishment, it SHOULD advertise at least one cipher suite indicating a Hash associated with the PSK.",
        "req_type": "ClientHello",
        "req_fields": [
            "cipher_suites"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the \"null\" compression method in prior versions of TLS.",
        "req_type": "ClientHello",
        "req_fields": [
            "compression_methods"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If a TLS 1.3 ClientHello is received with any other value in this field, the server MUST abort the handshake with an \"illegal_parameter\" alert.",
        "req_type": "ClientHello",
        "req_fields": [
            "this field"
        ],
        "res_type": "Alert",
        "res_fields": [
            "illegal_parameter"
        ]
    },
    {
        "rule": "Servers MUST ignore unrecognized extensions.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In TLS 1.3, the use of certain extensions is mandatory, as functionality has moved into extensions to preserve ClientHello compatibility with previous versions of TLS.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "extensions: Clients request extended functionality from servers by sending data in the extensions field.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "All versions of TLS allow an extensions field to optionally follow the compression_methods field.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions",
            "compression_methods"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Note that TLS 1.3 servers might receive TLS 1.2 or prior ClientHellos which contain other compression methods and (if negotiating such a prior version) MUST follow the procedures for the appropriate prior version of TLS.",
        "req_type": "ClientHello",
        "req_fields": [
            "compression_methods"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The structure of the ClientHello message includes: uint16 ProtocolVersion; opaque Random[32]; uint8 CipherSuite[2]; struct { ProtocolVersion legacy_version = 0x0303; Random random; opaque legacy_session_id<0..32>; CipherSuite cipher_suites<2..2^16-2>; opaque legacy_compression_methods<1..2^8-1>; Extension extensions<8..2^16-1>; } ClientHello; legacy_version: In previous versions of TLS, this field was used for version negotiation and represented the highest version number supported by the client.",
        "req_type": "ClientHello",
        "req_fields": [
            "ProtocolVersion",
            "Random",
            "CipherSuite",
            "legacy_version",
            "random",
            "legacy_session_id",
            "cipher_suites",
            "legacy_compression_methods",
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "However, TLS 1.3 servers might receive ClientHello messages without an extensions field from prior versions of TLS.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The presence of extensions can be detected by determining whether there are bytes following the compression_methods field at the end of the ClientHello.",
        "req_type": "ClientHello",
        "req_fields": [
            "compression_methods"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "TLS 1.3 ClientHello messages always contain extensions (minimally \"supported_versions\", otherwise, they will be interpreted as TLS 1.2 ClientHello messages).",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions",
            "supported_versions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "TLS 1.3 servers will need to perform this check first and only attempt to negotiate TLS 1.3 if the \"supported_versions\" extension is present.",
        "req_type": "ClientHello",
        "req_fields": [
            "supported_versions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Note that this method of detecting optional data differs from the normal TLS method of having a variable-length field, but it is used for compatibility with TLS before extensions were defined.",
        "req_type": "ClientHello",
        "req_fields": [
            "optional data detection method"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The \"key_share\" extension contains the endpoint's cryptographic parameters.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If negotiating a version of TLS prior to 1.3, a server MUST check that the message either contains no data after legacy_compression_methods or that it contains a valid extensions block with no data following.",
        "req_type": "ClientHello",
        "req_fields": [
            "legacy_compression_methods",
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "After sending the ClientHello message, the client waits for a ServerHello or HelloRetryRequest message.",
        "req_type": "ClientHello",
        "req_fields": [],
        "res_type": "ServerHello or HelloRetryRequest",
        "res_fields": []
    },
    {
        "rule": "In the event that a client requests additional functionality using extensions and this functionality is not supplied by the server, the client MAY abort the handshake.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "However, the values MAY be a non-contiguous subset of the \"supported_groups\" extension and MAY omit the most preferred groups.",
        "req_type": "ClientHello",
        "req_fields": [
            "supported_groups"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "key_share"
        ]
    },
    {
        "rule": "Each KeyShareEntry value MUST correspond to a group offered in the \"supported_groups\" extension and MUST appear in the same order.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions.key_share.client_shares",
            "extensions.supported_groups"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "extensions.key_share.server_share"
        ]
    },
    {
        "rule": "In the ClientHello message, the \"extension_data\" field of the key_share extension contains a KeyShareClientHello value with client_shares: a list of offered KeyShareEntry values in descending order of client preference.",
        "req_type": "ClientHello",
        "req_fields": [
            "extension_data",
            "key_share",
            "KeyShareClientHello",
            "client_shares",
            "KeyShareEntry"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Clients MUST NOT offer any KeyShareEntry values for groups not listed in the client's \"supported_groups\" extension.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions.key_share.key_share_entries",
            "extensions.supported_groups"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "A number of TLS messages contain tag-length-value encoded extensions structures.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In a HelloRetryRequest message, the \"extension_data\" field of the key_share extension contains a KeyShareHelloRetryRequest value with selected_group: the mutually supported group the server intends to negotiate and is requesting a retried ClientHello/KeyShare for.",
        "req_type": "HelloRetryRequest",
        "req_fields": [
            "extension_data",
            "key_share extension",
            "KeyShareHelloRetryRequest",
            "selected_group"
        ],
        "res_type": "ClientHello",
        "res_fields": [
            "KeyShare"
        ]
    },
    {
        "rule": "The Extension structure contains ExtensionType extension_type and opaque extension_data<0..2^16-1>.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Upon receipt of the key_share extension in a HelloRetryRequest, the client MUST verify that (1) the selected_group field corresponds to a group which was provided in the \"supported_groups\" extension in the original ClientHello and (2) the selected_group field does not correspond to a group which was provided in the \"key_share\" extension in the original ClientHello.",
        "req_type": "HelloRetryRequest",
        "req_fields": [
            "key_share",
            "selected_group"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Otherwise, when sending the new ClientHello, the client MUST replace the original \"key_share\" extension with one containing only a new KeyShareEntry for the group indicated in the selected_group field of the triggering HelloRetryRequest.",
        "req_type": "ClientHello",
        "req_fields": [
            "key_share",
            "KeyShareEntry"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Servers MUST NOT send a KeyShareEntry for any group not indicated in the client's \"supported_groups\" extension and MUST NOT send a KeyShareEntry when using the \"psk_ke\" PskKeyExchangeMode.",
        "req_type": "ClientHello",
        "req_fields": [
            "supported_groups",
            "psk_key_exchange_modes"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "key_share"
        ]
    },
    {
        "rule": "If using (EC)DHE key establishment and a HelloRetryRequest containing a \"key_share\" extension was received by the client, the client MUST verify that the selected NamedGroup in the ServerHello is the same as the NamedGroup in the HelloRetryRequest.",
        "req_type": "HelloRetryRequest",
        "req_fields": [
            "key_share",
            "NamedGroup"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "NamedGroup"
        ]
    },
    {
        "rule": "In a ServerHello message, the \"extension_data\" field of the key_share extension contains a KeyShareServerHello value with server_share: a single KeyShareEntry value that is in the same group as one of the client's shares.",
        "req_type": "ClientHello",
        "req_fields": [
            "key_share extension",
            "client's shares"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "extension_data",
            "key_share extension",
            "KeyShareServerHello",
            "server_share",
            "KeyShareEntry"
        ]
    },
    {
        "rule": "extension_data contains information specific to the particular extension type.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Here: extension_type identifies the particular extension type.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Extensions are generally structured in a request/response fashion, though some extensions are just indications with no corresponding response.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The server sends extension requests in the CertificateRequest message which a client MAY respond to with a Certificate message.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "extensions"
        ],
        "res_type": "Certificate",
        "res_fields": []
    },
    {
        "rule": "The client sends its extension requests in the ClientHello message, and the server sends its extension responses in the ServerHello, EncryptedExtensions, HelloRetryRequest, and Certificate messages.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions"
        ],
        "res_type": "ServerHello, EncryptedExtensions, HelloRetryRequest, Certificate",
        "res_fields": [
            "extensions"
        ]
    },
    {
        "rule": "Upon receiving an extension response without a corresponding request, an endpoint MUST abort the handshake with an \"unsupported_extension\" alert.",
        "req_type": "",
        "req_fields": [],
        "res_type": "alert",
        "res_fields": [
            "unsupported_extension"
        ]
    },
    {
        "rule": "Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the \"cookie\" extension in the HelloRetryRequest.",
        "req_type": "ClientHello or ServerHello",
        "req_fields": [
            "extensions"
        ],
        "res_type": "ServerHello or EncryptedExtensions",
        "res_fields": [
            "extensions"
        ]
    },
    {
        "rule": "ExtensionType enum includes server_name(0), max_fragment_length(1), status_request(5), supported_groups(10), signature_algorithms(13), use_srtp(14), heartbeat(15), application_layer_protocol_negotiation(16), signed_certificate_timestamp(18), client_certificate_type(19), server_certificate_type(20), padding(21), pre_shared_key(41), early_data(42), supported_versions(43), cookie(44), psk_key_exchange_modes(45), certificate_authorities(47), oid_filters(48), post_handshake_auth(49), signature_algorithms_cert(50), key_share(51), and (65535).",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The table below indicates the messages where a given extension may appear, using the following notation: CH (ClientHello), SH (ServerHello), EE (EncryptedExtensions), CT (Certificate), CR (CertificateRequest), NST (NewSessionTicket), and HRR (HelloRetryRequest).",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If an implementation receives an extension which it recognizes and which is not specified for the message in which it appears, it MUST abort the handshake with an \"illegal_parameter\" alert.",
        "req_type": "",
        "req_fields": [],
        "res_type": "alert",
        "res_fields": [
            "illegal_parameter"
        ]
    },
    {
        "rule": "In TLS 1.3, unlike TLS 1.2, extensions are negotiated for each handshake even when in resumption-PSK mode.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "There MUST NOT be more than one extension of the same type in a given extension block.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of pre_shared_key which MUST be the last extension in the ClientHello but can appear anywhere in the ServerHello extensions block.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions",
            "pre_shared_key"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "extensions",
            "pre_shared_key"
        ]
    },
    {
        "rule": "Often the fact that the extension fields are included in the inputs to the Finished message hashes will be sufficient, but extreme care is needed when the extension changes the meaning of messages sent in the handshake phase.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The CertificateRequest message, if sent, MUST follow EncryptedExtensions.",
        "req_type": "CertificateRequest",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The certificate_request_context field SHALL be zero length unless used for the post-handshake authentication exchanges described in Section 4.6.2.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "certificate_request_context"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The certificate_request_context MUST be unique within the scope of this connection (thus preventing replay of client CertificateVerify messages).",
        "req_type": "CertificateRequest",
        "req_fields": [
            "certificate_request_context"
        ],
        "res_type": "CertificateVerify",
        "res_fields": []
    },
    {
        "rule": "Clients MUST ignore unrecognized extensions.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "extensions: A set of extensions describing the parameters of the certificate being requested.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "extensions"
        ],
        "res_type": "Certificate",
        "res_fields": []
    },
    {
        "rule": "The \"signature_algorithms\" extension MUST be specified, and other extensions may optionally be included if defined for this message.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "extensions",
            "signature_algorithms"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In prior versions of TLS, the CertificateRequest message carried a list of signature algorithms and certificate authorities which the server would accept.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "signature_algorithms",
            "certificate_authorities"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The structure of the CertificateRequest message is: struct { opaque certificate_request_context<0..2^8-1>; Extension extensions<2..2^16-1>; } CertificateRequest; certificate_request_context: An opaque string which identifies the certificate request and which will be echoed in the client's Certificate message.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "certificate_request_context",
            "extensions"
        ],
        "res_type": "Certificate",
        "res_fields": [
            "certificate_request_context"
        ]
    },
    {
        "rule": "When requesting post-handshake authentication, the server SHOULD make the certificate_request_context unpredictable to the client (e.g., by randomly generating it) in order to prevent an attacker who has temporary access to the client's private key from pre-computing valid CertificateVerify messages.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "certificate_request_context"
        ],
        "res_type": "CertificateVerify",
        "res_fields": []
    },
    {
        "rule": "The table indicates messages where extensions may appear: server_name in CH and EE, max_fragment_length in CH and EE, status_request in CH, CR, and CT, supported_groups in CH and EE, signature_algorithms in CH and CR, use_srtp in CH and EE, heartbeat in CH and EE, application_layer_protocol_negotiation in CH and EE, signed_certificate_timestamp in CH, CR, and CT, client_certificate_type in CH and EE, server_certificate_type in CH and EE, padding in CH, key_share in CH, SH, and HRR, pre_shared_key in CH and SH, psk_key_exchange_modes in CH, early_data in CH, EE, and NST, cookie in CH and HRR, supported_versions in CH, SH, and HRR, certificate_authorities in CH and CR, oid_filters in CR, post_handshake_auth in CH, and signature_algorithms_cert in CH and CR.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The list of certificate authorities is expressed by sending the \"certificate_authorities\" extension (see Section 4.2.4).",
        "req_type": "CertificateRequest",
        "req_fields": [
            "certificate_authorities"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In TLS 1.3, the list of signature algorithms is expressed by sending the \"signature_algorithms\" and optionally \"signature_algorithms_cert\" extensions.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "signature_algorithms",
            "signature_algorithms_cert"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Servers which are authenticating with a PSK MUST NOT send the CertificateRequest message in the main handshake, though they MAY send it in post-handshake authentication (see Section 4.6.2) provided that the client has sent the \"post_handshake_auth\" extension (see Section 4.2.6).",
        "req_type": "CertificateRequest",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The certificates MUST be signed using an acceptable signature algorithm, as described in Section 4.3.2.",
        "req_type": "Certificate",
        "req_fields": [
            "certificate_list"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Note that the requirement for certificates to be signed using an acceptable signature algorithm relaxes the constraints on certificate-signing algorithms found in prior versions of TLS.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The following rules apply to certificates sent by the client: The certificate type MUST be X.509v3 [RFC5280 Profile], unless explicitly negotiated otherwise (e.g., [RFC7250 and Datagram Transport Layer Security (DTLS)]).",
        "req_type": "Certificate",
        "req_fields": [
            "certificate_type"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The reason for this construction is to allow the server to do a stateless HelloRetryRequest by storing just the hash of ClientHello1 in the cookie, rather than requiring the server to export the entire intermediate hash state (see Section 4.2.2).",
        "req_type": "ClientHello",
        "req_fields": [
            "hash"
        ],
        "res_type": "HelloRetryRequest",
        "res_fields": [
            "cookie"
        ]
    },
    {
        "rule": "For concreteness, the transcript hash is always taken from the following sequence of handshake messages, starting at the first ClientHello and including only those messages that were sent: ClientHello, HelloRetryRequest, ClientHello, ServerHello, EncryptedExtensions, server CertificateRequest, server Certificate, server CertificateVerify, server Finished, EndOfEarlyData, client Certificate, client CertificateVerify, client Finished.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the \"certificate_authorities\" extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "certificate_authorities"
        ],
        "res_type": "Certificate",
        "res_fields": [
            "certificate_list"
        ]
    },
    {
        "rule": "[RFC6066] and [RFC6961] provide extensions to negotiate the server sending OCSP responses to the client.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In TLS 1.3, the server's OCSP information is carried in an extension in the CertificateEntry containing the associated certificate.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the CertificateRequest message contained a non-empty \"oid_filters\" extension, the end-entity certificate MUST match the extension OIDs that are recognized by the client, as described in Section 4.2.5.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "oid_filters"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Specifically, the body of the \"status_request\" extension from the server MUST be a CertificateStatus structure as defined in [RFC6066], which is interpreted as defined in [RFC6960].",
        "req_type": "status_request extension",
        "req_fields": [
            "body (CertificateStatus structure)"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "TLS 1.3 servers MUST NOT act upon the presence of the status_request_v2 extension or information in the status_request_v2 extension when processing ClientHello messages; in particular, TLS 1.3 servers MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",
        "req_type": "ClientHello",
        "req_fields": [
            "status_request_v2 extension"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The Certificate, CertificateVerify, and Finished messages are always sent as the last messages in their handshake flight.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In TLS 1.3, the server's SCT information is carried in an extension in the CertificateEntry.",
        "req_type": "",
        "req_fields": [],
        "res_type": "Certificate",
        "res_fields": [
            "CertificateEntry",
            "extensions"
        ]
    },
    {
        "rule": "As discussed in Section 2, TLS generally uses a common set of messages for authentication, key confirmation, and handshake integrity: Certificate, CertificateVerify, and Finished.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "TLS 1.3 servers MUST be able to process ClientHello messages that include the status_request_v2 extension, as the status_request_v2 extension MAY be sent by clients that wish to use the status_request_v2 extension in earlier protocol versions.",
        "req_type": "ClientHello",
        "req_fields": [
            "status_request_v2 extension"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "A server MAY request that a client present an OCSP response with its certificate by sending an empty \"status_request\" extension in its CertificateRequest message.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "status_request"
        ],
        "res_type": "Certificate",
        "res_fields": [
            "OCSP response"
        ]
    },
    {
        "rule": "If the client opts to send an OCSP response, the body of the client's \"status_request\" extension MUST be a CertificateStatus structure as defined in [RFC6066].",
        "req_type": "Certificate",
        "req_fields": [
            "status_request extension"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The Certificate and CertificateVerify messages are only sent under certain circumstances, as defined below.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The Certificate, CertificateVerify, and Finished messages are encrypted under keys derived from the sender_handshake_traffic_secret.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Based on these inputs, the messages then contain: Certificate: The certificate to be used for authentication, and any supporting certificates in the chain.",
        "req_type": "Certificate",
        "req_fields": [
            "certificate",
            "supporting certificates in the chain"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Finished: A MAC over the value Transcript-Hash(Handshake Context, Certificate, CertificateVerify) using a MAC key derived from the Base Key.",
        "req_type": "Finished",
        "req_fields": [
            "MAC"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "CertificateVerify: A signature over the value Transcript-Hash(Handshake Context, Certificate).",
        "req_type": "CertificateVerify",
        "req_fields": [
            "signature",
            "Transcript-Hash(Handshake Context, Certificate)"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The following table defines the Handshake Context and MAC Base Key for each scenario: Server mode uses ClientHello through later messages of EncryptedExtensions or CertificateRequest with server_handshake_traffic_secret as Base Key.",
        "req_type": "ClientHello",
        "req_fields": [],
        "res_type": "EncryptedExtensions or CertificateRequest",
        "res_fields": []
    },
    {
        "rule": "The \"extension_data\" field of the \"pre_shared_key\" extension contains a \"PreSharedKeyExtension\" value.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Post-Handshake mode uses ClientHello through client Finished plus CertificateRequest with client_application_traffic_secret_N as Base Key.",
        "req_type": "CertificateRequest",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Client mode uses ClientHello through later messages of server Finished or EndOfEarlyData with client_handshake_traffic_secret as Base Key.",
        "req_type": "ClientHello",
        "req_fields": [],
        "res_type": "Finished, EndOfEarlyData",
        "res_fields": []
    },
    {
        "rule": "client | client_application_traffic_ | | Handshake | Finished + | secret_N | | | CertificateRequest | | +-----------+-------------------------+-----------------------------+",
        "req_type": "CertificateRequest",
        "req_fields": [],
        "res_type": "Finished",
        "res_fields": []
    },
    {
        "rule": "The \"pre_shared_key\" extension is used to negotiate the identity of the pre-shared key to be used with a given handshake in association with PSK key establishment.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The structure includes: PskIdentity with identity (a label for a key) and obfuscated_ticket_age; PskBinderEntry; OfferedPsks with identities and binders; and PreSharedKeyExtension which varies by handshake message type.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The server MUST ensure that it selects a compatible PSK (if any) and cipher suite.",
        "req_type": "ClientHello",
        "req_fields": [
            "pre_shared_key",
            "cipher_suites"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "pre_shared_key",
            "cipher_suite"
        ]
    },
    {
        "rule": "In order to accept PSK key establishment, the server sends a \"pre_shared_key\" extension indicating the selected identity.",
        "req_type": "",
        "req_fields": [],
        "res_type": "ServerHello",
        "res_fields": [
            "pre_shared_key"
        ]
    },
    {
        "rule": "Implementor's note: When session resumption is the primary use case of PSKs, the most straightforward way to implement the PSK/cipher suite matching requirements is to negotiate the cipher suite first and then exclude any incompatible PSKs.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the server supplies an \"early_data\" extension, the client MUST verify that the server's selected_identity is 0.",
        "req_type": "ServerHello",
        "req_fields": [
            "extensions.early_data",
            "extensions.pre_shared_key.selected_identity"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Clients MUST verify that the server's selected_identity is within the range supplied by the client, that the server selected a cipher suite indicating a Hash associated with the PSK, and that a server \"key_share\" extension is present if required by the ClientHello \"psk_key_exchange_modes\" extension.",
        "req_type": "ClientHello",
        "req_fields": [
            "psk_key_exchange_modes"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "selected_identity",
            "cipher_suite",
            "key_share"
        ]
    },
    {
        "rule": "The \"pre_shared_key\" extension MUST be the last extension in the ClientHello (this facilitates implementation as described below).",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions",
            "pre_shared_key"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the server supplies an empty Certificate message, the client MUST abort the handshake with a \"decode_error\" alert.",
        "req_type": "Certificate",
        "req_fields": [],
        "res_type": "Alert",
        "res_fields": [
            "decode_error"
        ]
    },
    {
        "rule": "Any endpoint receiving any certificate which it would need to validate using any signature algorithm using an MD5 hash MUST abort the handshake with a \"bad_certificate\" alert.",
        "req_type": "Certificate",
        "req_fields": [
            "certificate",
            "signature_algorithm"
        ],
        "res_type": "Alert",
        "res_fields": [
            "alert_description"
        ]
    },
    {
        "rule": "Note that a certificate containing a key for one signature algorithm MAY be signed using a different signature algorithm (for instance, an RSA key signed with an ECDSA key).",
        "req_type": "Certificate",
        "req_fields": [
            "certificate_list"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the client does not send any certificates (i.e., it sends an empty Certificate message), the server MAY at its discretion either continue the handshake without client authentication or abort the handshake with a \"certificate_required\" alert.",
        "req_type": "Certificate",
        "req_fields": [
            "certificate_list"
        ],
        "res_type": "Alert",
        "res_fields": [
            "alert_level",
            "alert_description"
        ]
    },
    {
        "rule": "Servers MUST check that the \"pre_shared_key\" extension is the last extension and otherwise fail the handshake with an \"illegal_parameter\" alert.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions",
            "pre_shared_key"
        ],
        "res_type": "Alert",
        "res_fields": [
            "illegal_parameter"
        ]
    },
    {
        "rule": "SHA-1 is deprecated, and it is RECOMMENDED that any endpoint receiving any certificate which it would need to validate using any signature algorithm using a SHA-1 hash abort the handshake with a \"bad_certificate\" alert.",
        "req_type": "Certificate",
        "req_fields": [
            "certificate_list"
        ],
        "res_type": "Alert",
        "res_fields": [
            "alert_level",
            "alert_description"
        ]
    },
    {
        "rule": "If the server sent an \"early_data\" extension in EncryptedExtensions, the client MUST send an EndOfEarlyData message after receiving the server Finished.",
        "req_type": "EndOfEarlyData",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the server does not send an \"early_data\" extension in EncryptedExtensions, then the client MUST NOT send an EndOfEarlyData message.",
        "req_type": "EncryptedExtensions",
        "req_fields": [
            "early_data"
        ],
        "res_type": "EndOfEarlyData",
        "res_fields": []
    },
    {
        "rule": "Servers MUST NOT send the EndOfEarlyData message, and clients receiving the EndOfEarlyData message MUST terminate the connection with an \"unexpected_message\" alert.",
        "req_type": "EndOfEarlyData",
        "req_fields": [],
        "res_type": "Alert",
        "res_fields": [
            "unexpected_message"
        ]
    },
    {
        "rule": "The following rules apply to the certificates sent by the server: The certificate type MUST be X.509v3 as specified in RFC5280 Profile, unless explicitly negotiated otherwise, such as with RFC7250 and Datagram Transport Layer Security (DTLS).",
        "req_type": "",
        "req_fields": [],
        "res_type": "Certificate",
        "res_fields": [
            "certificate_type"
        ]
    },
    {
        "rule": "The server_name extension as defined in RFC6066 and the certificate_authorities extension are used to guide certificate selection.",
        "req_type": "ClientHello",
        "req_fields": [
            "server_name",
            "certificate_authorities"
        ],
        "res_type": "Certificate",
        "res_fields": []
    },
    {
        "rule": "The server's end-entity certificate's public key and associated restrictions MUST be compatible with the selected authentication algorithm from the client's signature_algorithms extension, which currently includes RSA, ECDSA, or EdDSA.",
        "req_type": "ClientHello",
        "req_fields": [
            "signature_algorithms"
        ],
        "res_type": "Certificate",
        "res_fields": [
            "certificate_list"
        ]
    },
    {
        "rule": "As servers MAY require the presence of the \"server_name\" extension, clients SHOULD send this extension, when applicable.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions.server_name"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Certificates that are self-signed or certificates that are expected to be trust anchors are not validated as part of the chain and therefore MAY be signed with any algorithm.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The certificate MUST allow the key to be used for signing, meaning the digitalSignature bit MUST be set if the Key Usage extension is present, with a signature scheme indicated in the client's signature_algorithms or signature_algorithms_cert extensions as described in Section 4.2.3.",
        "req_type": "",
        "req_fields": [],
        "res_type": "Certificate",
        "res_fields": [
            "Key Usage extension",
            "digitalSignature bit"
        ]
    },
    {
        "rule": "The \"extension_data\" field of this extension contains an \"EarlyDataIndication\" value.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the client opts to do so, it MUST supply both the \"pre_shared_key\" and \"early_data\" extensions.",
        "req_type": "ClientHello",
        "req_fields": [
            "pre_shared_key",
            "early_data"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "All certificates provided by the server MUST be signed by a signature algorithm advertised by the client if the server is able to provide such a chain, as described in Section 4.2.3.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "signature_algorithms"
        ],
        "res_type": "Certificate",
        "res_fields": [
            "certificate_list"
        ]
    },
    {
        "rule": "If the server cannot produce a certificate chain that is signed only via the indicated supported algorithms, then the server SHOULD continue the handshake by sending the client a certificate chain of its choice that may include algorithms not known to be supported by the client.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "supported_signature_algorithms"
        ],
        "res_type": "Certificate",
        "res_fields": [
            "certificate_list"
        ]
    },
    {
        "rule": "If the client cannot construct an acceptable chain using the provided certificates and decides to abort the handshake, then the client MUST abort the handshake with an appropriate certificate-related alert, such as unsupported_certificate by default, as detailed in Section 6.2.",
        "req_type": "Certificate",
        "req_fields": [
            "certificate_list"
        ],
        "res_type": "Alert",
        "res_fields": [
            "alert_level",
            "alert_description"
        ]
    },
    {
        "rule": "The EarlyDataIndication structure is defined with different cases for handshake message types: for new_session_ticket it contains a max_early_data_size field, while for client_hello and encrypted_extensions it contains an empty structure.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The PSK used to encrypt the early data MUST be the first PSK listed in the client's \"pre_shared_key\" extension.",
        "req_type": "ClientHello",
        "req_fields": [
            "pre_shared_key"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "A client MUST NOT include the \"early_data\" extension in its followup ClientHello.",
        "req_type": "ClientHello",
        "req_fields": [
            "early_data"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "After receiving the server's Finished message, if the server has accepted early data, an EndOfEarlyData message will be sent to indicate the key change.",
        "req_type": "Finished",
        "req_fields": [],
        "res_type": "EndOfEarlyData",
        "res_fields": []
    },
    {
        "rule": "A server which receives an \"early_data\" extension MUST behave in one of three ways: Ignore the extension and return a regular 1-RTT response.",
        "req_type": "ClientHello",
        "req_fields": [
            "early_data"
        ],
        "res_type": "ServerHello",
        "res_fields": []
    },
    {
        "rule": "Future extensions MUST define their interaction with 0-RTT.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "For PSKs provisioned via NewSessionTicket, a server MUST validate that the ticket age for the selected PSK identity (computed by subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32) is within a small tolerance of the time since the ticket was issued (see Section 8).",
        "req_type": "ClientHello",
        "req_fields": [
            "PskIdentity.obfuscated_ticket_age"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the ticket age is not within tolerance, the server SHOULD proceed with the handshake but reject 0-RTT, and SHOULD NOT take any other action that assumes that this ClientHello is fresh.",
        "req_type": "ClientHello",
        "req_fields": [
            "ticket_age"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Return its own \"early_data\" extension in EncryptedExtensions, indicating that it intends to process the early data.",
        "req_type": "",
        "req_fields": [],
        "res_type": "EncryptedExtensions",
        "res_fields": [
            "early_data"
        ]
    },
    {
        "rule": "In addition, the server MUST verify that the following values are the same as those associated with the selected PSK: The TLS version number, the selected cipher suite, and the selected ALPN protocol if any.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In order to accept early data, the server MUST have accepted a PSK cipher suite and selected the first key offered in the client's \"pre_shared_key\" extension.",
        "req_type": "ClientHello",
        "req_fields": [
            "pre_shared_key"
        ],
        "res_type": "ServerHello",
        "res_fields": []
    },
    {
        "rule": "If any of these checks fail, the server MUST NOT respond with the extension and must discard all the first-flight data using one of the first two mechanisms listed above (thus falling back to 1-RTT or 2-RTT).",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the server chooses to accept the \"early_data\" extension, then it MUST comply with the same error-handling requirements specified for all records when processing early data records.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Specifically, if the server fails to decrypt a 0-RTT record following an accepted \"early_data\" extension, it MUST terminate the connection with a \"bad_record_mac\" alert as per Section 5.2.",
        "req_type": "0-RTT record",
        "req_fields": [
            "early_data extension"
        ],
        "res_type": "alert",
        "res_fields": [
            "bad_record_mac"
        ]
    },
    {
        "rule": "If the client chooses to authenticate, the client MUST send Certificate, CertificateVerify, and Finished messages.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the client declines, the client MUST send a Certificate message containing no certificates followed by a Finished message.",
        "req_type": "",
        "req_fields": [],
        "res_type": "Certificate, Finished",
        "res_fields": [
            "certificate_list (empty)"
        ]
    },
    {
        "rule": "A client that receives a CertificateRequest message without having sent the \"post_handshake_auth\" extension MUST send an \"unexpected_message\" fatal alert.",
        "req_type": "CertificateRequest",
        "req_fields": [],
        "res_type": "Alert",
        "res_fields": [
            "unexpected_message"
        ]
    },
    {
        "rule": "The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK).",
        "req_type": "",
        "req_fields": [],
        "res_type": "Certificate",
        "res_fields": []
    },
    {
        "rule": "When the client has sent the \"post_handshake_auth\" extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message.",
        "req_type": "CertificateRequest",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The client MUST send a Certificate message if and only if the server has requested client authentication via a CertificateRequest message (Section 4.3.2).",
        "req_type": "CertificateRequest",
        "req_fields": [],
        "res_type": "Certificate",
        "res_fields": []
    },
    {
        "rule": "A Finished message MUST be sent regardless of whether the Certificate message is empty.",
        "req_type": "Certificate",
        "req_fields": [],
        "res_type": "Finished",
        "res_fields": []
    },
    {
        "rule": "The certificate_request_context field contains the value from the CertificateRequest message if this message is a response to one.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "certificate_request_context"
        ],
        "res_type": "Certificate",
        "res_fields": [
            "certificate_request_context"
        ]
    },
    {
        "rule": "If the server requests client authentication but no suitable certificate is available, the client MUST send a Certificate message containing no certificates (i.e., with the \"certificate_list\" field having length 0).",
        "req_type": "CertificateRequest",
        "req_fields": [],
        "res_type": "Certificate",
        "res_fields": [
            "certificate_list"
        ]
    },
    {
        "rule": "Otherwise, in the case of server authentication, the certificate_request_context field SHALL be zero length.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "certificate_request_context"
        ],
        "res_type": "Certificate",
        "res_fields": []
    },
    {
        "rule": "The certificate_list is a sequence (chain) of CertificateEntry structures, each containing a single certificate and set of extensions.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The structure of the Certificate message includes: an enumeration of certificate types (X509(0), RawPublicKey(2), and others up to 255); a CertificateEntry structure that contains either an ASN.1 subjectPublicKeyInfo for RawPublicKey or certificate data for X509, along with extensions; and a Certificate structure with certificate_request_context and certificate_list fields.",
        "req_type": "Certificate",
        "req_fields": [
            "certificate_request_context",
            "certificate_list",
            "certificate_types",
            "CertificateEntry",
            "subjectPublicKeyInfo",
            "certificate_data",
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The extensions are a set of extension values for the CertificateEntry.",
        "req_type": "Certificate",
        "req_fields": [
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Extensions in the Certificate message from the server MUST correspond to ones from the ClientHello message.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions"
        ],
        "res_type": "Certificate",
        "res_fields": [
            "extensions"
        ]
    },
    {
        "rule": "Extensions in the Certificate message from the client MUST correspond to extensions in the CertificateRequest message from the server.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "extensions"
        ],
        "res_type": "Certificate",
        "res_fields": [
            "extensions"
        ]
    },
    {
        "rule": "Valid extensions for server certificates at present include the OCSP Status extension from RFC6066 and the SignedCertificateTimestamp extension from RFC6962; future extensions may be defined for this message as well.",
        "req_type": "Certificate",
        "req_fields": [
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Each following certificate SHOULD directly certify the one immediately preceding it.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The sender's certificate MUST come in the first CertificateEntry in the list.",
        "req_type": "Certificate",
        "req_fields": [
            "certificate_list",
            "CertificateEntry"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If an extension applies to the entire chain, it SHOULD be included in the first CertificateEntry.",
        "req_type": "Certificate",
        "req_fields": [
            "CertificateEntry",
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Note: Prior to TLS 1.3, \"certificate_list\" ordering required each certificate to certify the one immediately preceding it; however, some implementations allowed some flexibility.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the corresponding certificate type extension (\"server_certificate_type\" or \"client_certificate_type\") was not negotiated in EncryptedExtensions, or the X.509 certificate type was negotiated, then each CertificateEntry contains a DER-encoded X.509 certificate.",
        "req_type": "EncryptedExtensions",
        "req_fields": [
            "server_certificate_type",
            "client_certificate_type"
        ],
        "res_type": "Certificate",
        "res_fields": [
            "CertificateEntry"
        ]
    },
    {
        "rule": "For maximum compatibility, all implementations SHOULD be prepared to handle potentially extraneous certificates and arbitrary orderings from any TLS version, with the exception of the end-entity certificate which MUST be first.",
        "req_type": "Certificate",
        "req_fields": [
            "certificate_list"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The server's certificate_list MUST always be non-empty.",
        "req_type": "",
        "req_fields": [],
        "res_type": "Certificate",
        "res_fields": [
            "certificate_list"
        ]
    },
    {
        "rule": "A client will send an empty certificate_list if it does not have an appropriate certificate to send in response to the server's authentication request.",
        "req_type": "CertificateRequest",
        "req_fields": [],
        "res_type": "Certificate",
        "res_fields": [
            "certificate_list"
        ]
    },
    {
        "rule": "TLS 1.3 provides two extensions for indicating which signature algorithms may be used in digital signatures.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the RawPublicKey certificate type was negotiated, then the certificate_list MUST contain no more than one CertificateEntry, which contains an ASN.1 subjectPublicKeyInfo value as defined in RFC7250, Section 3.",
        "req_type": "Certificate",
        "req_fields": [
            "certificate_list",
            "CertificateEntry",
            "subjectPublicKeyInfo"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The keys found in certificates MUST also be of appropriate type for the signature algorithms the keys are used with.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The \"signature_algorithms_cert\" extension applies to signatures in certificates, and the \"signature_algorithms\" extension, which originally appeared in TLS 1.2, applies to signatures in CertificateVerify messages.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Clients which desire the server to authenticate itself via a certificate MUST send the \"signature_algorithms\" extension.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions",
            "signature_algorithms"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If no \"signature_algorithms_cert\" extension is present, then the \"signature_algorithms\" extension also applies to signatures appearing in certificates.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions.signature_algorithms",
            "extensions.signature_algorithms_cert"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The \"signature_algorithms_cert\" extension was added to allow implementations which supported different sets of algorithms for certificates and in TLS itself to clearly signal their capabilities.",
        "req_type": "ClientHello",
        "req_fields": [
            "signature_algorithms_cert"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "TLS 1.2 implementations SHOULD also process the \"signature_algorithms_cert\" extension.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If a server is authenticating via a certificate and the client has not sent a \"signature_algorithms\" extension, then the server MUST abort the handshake with a \"missing_extension\" alert (seeSection 9.2).",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions",
            "signature_algorithms"
        ],
        "res_type": "Alert",
        "res_fields": [
            "alert_description",
            "missing_extension"
        ]
    },
    {
        "rule": "Implementations which have the same policy in both cases MAY omit the \"signature_algorithms_cert\" extension.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions",
            "signature_algorithms_cert"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The \"extension_data\" field of these extensions contains a SignatureSchemeList value.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the public key is carried in an X.509 certificate, the public key MUST use the rsaEncryption OID.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "When used in certificate signatures, the algorithm parameters MUST be DER encoded.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the corresponding public key's parameters are present, then the parameters in the signature MUST be identical to those in the public key.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the public key is carried in an X.509 certificate, the public key MUST use the RSASSA-PSS OID.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it (see Section 4.4.2.2).",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The signatures on certificates that are self-signed or certificates that are trust anchors are not validated, since they begin a certification path.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "A certificate that begins a certification path MAY use a signature algorithm that is not advertised as being supported in the \"signature_algorithms\" extension.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Note that TLS 1.2 defines the signature algorithm extension differently.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In TLS 1.2, the signature algorithm extension contained hash/signature pairs.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In particular: TLS 1.2 ClientHellos MAY omit the signature algorithm extension.",
        "req_type": "ClientHello",
        "req_fields": [
            "signature_algorithms"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If TLS 1.2 is negotiated, implementations MUST be prepared to accept a signature that uses any curve that they advertised in the \"supported_groups\" extension.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Implementations that advertise support for RSASSA-PSS MUST be prepared to accept a signature using that scheme even when TLS 1.2 is negotiated.",
        "req_type": "CertificateVerify",
        "req_fields": [
            "signature"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Recipients of Finished messages MUST verify that the contents are correct and if incorrect MUST terminate the connection with a \"decrypt_error\" alert.",
        "req_type": "Finished",
        "req_fields": [
            "contents"
        ],
        "res_type": "Alert",
        "res_fields": [
            "decrypt_error"
        ]
    },
    {
        "rule": "The KeyUpdate message can be sent by either peer after the peer has sent a Finished message.",
        "req_type": "KeyUpdate",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Any records following a Finished message MUST be encrypted under the appropriate application traffic key as described in Section 7.2.",
        "req_type": "Finished",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In particular, this requirement includes any alerts sent by the server in response to client Certificate and CertificateVerify messages.",
        "req_type": "Certificate, CertificateVerify",
        "req_fields": [],
        "res_type": "Alert",
        "res_fields": []
    },
    {
        "rule": "The verify_data value is computed as follows: verify_data = HMAC(finished_key, Transcript-Hash(Handshake Context, Certificate*, CertificateVerify*)), where * indicates only included if present.",
        "req_type": "Finished",
        "req_fields": [
            "verify_data"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Implementations that receive a KeyUpdate message prior to receiving a Finished message MUST terminate the connection with an \"unexpected_message\" alert.",
        "req_type": "KeyUpdate",
        "req_fields": [],
        "res_type": "Alert",
        "res_fields": [
            "unexpected_message"
        ]
    },
    {
        "rule": "Upon receiving a KeyUpdate, the receiver MUST update its receiving keys.",
        "req_type": "KeyUpdate",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "After sending a KeyUpdate message, the sender SHALL send all its traffic using the next generation of keys, computed as described in Section 7.2.",
        "req_type": "KeyUpdate",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The KeyUpdate structure contains a request_update field that indicates whether the recipient of the KeyUpdate should respond with its own KeyUpdate.",
        "req_type": "KeyUpdate",
        "req_fields": [
            "request_update"
        ],
        "res_type": "KeyUpdate",
        "res_fields": []
    },
    {
        "rule": "If an implementation receives any other value for request_update, the implementation MUST terminate the connection with an \"illegal_parameter\" alert.",
        "req_type": "KeyUpdate",
        "req_fields": [
            "request_update"
        ],
        "res_type": "Alert",
        "res_fields": [
            "illegal_parameter"
        ]
    },
    {
        "rule": "Note that implementations may receive an arbitrary number of messages between sending a KeyUpdate with request_update set to \"update_requested\" and receiving the peer's KeyUpdate, because those messages may already be in flight.",
        "req_type": "KeyUpdate",
        "req_fields": [
            "request_update"
        ],
        "res_type": "KeyUpdate",
        "res_fields": []
    },
    {
        "rule": "If the request_update field is set to \"update_requested\", then the receiver MUST send a KeyUpdate of its own with request_update set to \"update_not_requested\" prior to sending its next Application Data record.",
        "req_type": "KeyUpdate",
        "req_fields": [
            "request_update"
        ],
        "res_type": "KeyUpdate",
        "res_fields": [
            "request_update"
        ]
    },
    {
        "rule": "If implementations independently send their own KeyUpdates with request_update set to \"update_requested\" and the KeyUpdates cross in flight, then each side will also send a response, with the result that each side increments by two generations.",
        "req_type": "KeyUpdate",
        "req_fields": [
            "request_update"
        ],
        "res_type": "KeyUpdate",
        "res_fields": []
    },
    {
        "rule": "Both sender and receiver MUST encrypt their KeyUpdate messages with the old keys.",
        "req_type": "KeyUpdate",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Additionally, both sides MUST enforce that a KeyUpdate with the old key is received before accepting any messages encrypted with the new key.",
        "req_type": "KeyUpdate",
        "req_fields": [
            "old key"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Implementations MUST NOT send record types not defined in this document unless negotiated by some extension.",
        "req_type": "Record",
        "req_fields": [
            "record_type"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The CertificateVerify message also provides integrity for the handshake up to this point.",
        "req_type": "CertificateVerify",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "An implementation may receive an unencrypted record of type change_cipher_spec consisting of the single byte value 0x01 at any time after the first ClientHello message has been sent or received and before the peer's Finished message has been received and MUST simply drop the change_cipher_spec record without further processing.",
        "req_type": "change_cipher_spec",
        "req_fields": [
            "type",
            "value"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If an implementation detects a change_cipher_spec record received before the first ClientHello message or after the peer's Finished message, the change_cipher_spec record MUST be treated as an unexpected record type (though stateless servers may not be able to distinguish these cases from allowed cases).",
        "req_type": "change_cipher_spec",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Note that because the handshake transcript includes the random values from the Hello messages, any given handshake will have different traffic secrets, even if the same input secrets are used, as is the case when the same PSK is used for multiple connections.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Servers MUST send this message when authenticating via a certificate.",
        "req_type": "Certificate Verify",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Clients MUST send this message whenever authenticating via a certificate (i.e., when the Certificate message is non-empty).",
        "req_type": "CertificateVerify",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "When sent, this message MUST appear immediately after the Certificate message and immediately prior to the Finished message.",
        "req_type": "CertificateVerify",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The structure of the CertificateVerify message is: struct { SignatureScheme algorithm; opaque signature<0..2^16-1>; } CertificateVerify.",
        "req_type": "CertificateVerify",
        "req_fields": [
            "SignatureScheme algorithm",
            "opaque signature<0..2^16-1>"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The context string for a server signature is \"TLS 1.3, server CertificateVerify\".",
        "req_type": "CertificateVerify",
        "req_fields": [
            "signature"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The context string for a client signature is \"TLS 1.3, client CertificateVerify\".",
        "req_type": "CertificateVerify",
        "req_fields": [
            "signature"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The content covered under the signature is the hash output as described in Section 4.4.1, namely: Transcript-Hash(Handshake Context, Certificate).",
        "req_type": "",
        "req_fields": [],
        "res_type": "CertificateVerify",
        "res_fields": [
            "signature"
        ]
    },
    {
        "rule": "This structure is intended to prevent an attack on previous versions of TLS in which the ServerKeyExchange format meant that attackers could obtain a signature of a message with a chosen 32-byte prefix (ClientHello.random).",
        "req_type": "ServerKeyExchange",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The context string is used to provide separation between signatures made in different contexts, helping against potential cross-protocol attacks.",
        "req_type": "CertificateVerify",
        "req_fields": [
            "context string",
            "signature"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "On the sender side, the process for computing the signature field of the CertificateVerify message takes as input: the content covered by the digital signature, and the private signing key corresponding to the certificate sent in the previous message.",
        "req_type": "CertificateVerify",
        "req_fields": [
            "signature"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the CertificateVerify message is sent by a server, the signature algorithm MUST be one offered in the client's \"signature_algorithms\" extension unless no valid certificate chain can be produced without unsupported algorithms (see Section 4.2.3).",
        "req_type": "CertificateVerify",
        "req_fields": [
            "signature algorithm"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If sent by a client, the signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the \"signature_algorithms\" extension in the CertificateRequest message.",
        "req_type": "CertificateRequest",
        "req_fields": [
            "supported_signature_algorithms"
        ],
        "res_type": "CertificateVerify",
        "res_fields": [
            "signature_algorithm"
        ]
    },
    {
        "rule": "In addition, the signature algorithm MUST be compatible with the key in the sender's end-entity certificate.",
        "req_type": "CertificateVerify",
        "req_fields": [
            "signature_algorithm"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages.",
        "req_type": "CertificateVerify",
        "req_fields": [
            "signature"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in \"signature_algorithms\".",
        "req_type": "",
        "req_fields": [],
        "res_type": "CertificateVerify",
        "res_fields": [
            "signature"
        ]
    },
    {
        "rule": "The receiver of a CertificateVerify message MUST verify the signature field.",
        "req_type": "CertificateVerify",
        "req_fields": [
            "signature"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "All SHA-1 signature algorithms in this specification are defined solely for use in legacy certificates and are not valid for CertificateVerify signatures.",
        "req_type": "CertificateVerify",
        "req_fields": [
            "signature_algorithm"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "For example, if the transcript hash was 32 bytes of 01 (this length would make sense for SHA-256), the content covered by the digital signature for a server CertificateVerify would be: 2020202020202020202020202020202020202020202020202020202020202020 2020202020202020202020202020202020202020202020202020202020202020 544c5320312e332c207365727665722043657274696669636174655665726966 79 00 0101010101010101010101010101010101010101010101010101010101010101.",
        "req_type": "",
        "req_fields": [],
        "res_type": "CertificateVerify",
        "res_fields": [
            "digital signature",
            "transcript hash"
        ]
    },
    {
        "rule": "The verification process takes as input: the content covered by the digital signature, the public key contained in the end-entity certificate found in the associated Certificate message, and the digital signature received in the signature field of the CertificateVerify message.",
        "req_type": "CertificateVerify",
        "req_fields": [
            "signature"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Because the ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate messages can immediately precede a key change, implementations MUST send these messages in alignment with a record boundary.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "A TLS-compliant application MUST support digital signatures with rsa_pkcs1_sha256 (for certificates), rsa_pss_rsae_sha256 (for CertificateVerify and certificates), and ecdsa_secp256r1_sha256.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "At any time after the server has received the client Finished message, the server MAY send a NewSessionTicket message.",
        "req_type": "Finished",
        "req_fields": [],
        "res_type": "NewSessionTicket",
        "res_fields": []
    },
    {
        "rule": "legacy_record_version MUST be set to 0x0303 for all records generated by a TLS 1.3 implementation other than an initial ClientHello, which is one not generated after a HelloRetryRequest, where legacy_record_version MAY also be 0x0301 for compatibility purposes.",
        "req_type": "ClientHello",
        "req_fields": [
            "legacy_record_version"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In order to maximize backward compatibility, a record containing an initial ClientHello SHOULD have legacy_record_version 0x0301, reflecting TLS 1.0, and a record containing a second ClientHello or a ServerHello MUST have legacy_record_version 0x0303, reflecting TLS 1.2.",
        "req_type": "ClientHello, ServerHello",
        "req_fields": [
            "legacy_record_version"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The NewSessionTicket message creates a unique association between the ticket value and a secret PSK derived from the resumption master secret (see Section 7).",
        "req_type": "NewSessionTicket",
        "req_fields": [
            "ticket",
            "PSK"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The client MAY use the PSK derived from the ticket for future handshakes by including the ticket value in the \"pre_shared_key\" extension in its ClientHello (Section 4.2.11).",
        "req_type": "ClientHello",
        "req_fields": [
            "pre_shared_key"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Any ticket MUST only be resumed with a cipher suite that has the same KDF hash algorithm as that used to establish the original connection.",
        "req_type": "NewSessionTicket",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Clients MUST only resume if the new SNI value is valid for the server certificate presented in the original session and SHOULD only resume if the SNI value matches the one used in the original session.",
        "req_type": "NewSessionTicket",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If an indication is provided that different servers covered by a single certificate can accept each other's tickets (externally or by any other means), clients MAY resume with a different SNI value.",
        "req_type": "NewSessionTicket",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The AlertDescription enumeration includes various alert types such as close_notify(0), unexpected_message(10), bad_record_mac(20), record_overflow(22), handshake_failure(40), bad_certificate(42), unsupported_certificate(43), certificate_revoked(44), certificate_expired(45), certificate_unknown(46), illegal_parameter(47), unknown_ca(48), access_denied(49), decode_error(50), decrypt_error(51), protocol_version(70), insufficient_security(71), internal_error(80), inappropriate_fallback(86), user_canceled(90), missing_extension(109), unsupported_extension(110), unrecognized_name(112), bad_certificate_status_response(113), unknown_psk_identity(115), certificate_required(116), and no_application_protocol(120).",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The requirement to match the SNI value is a performance optimization: normally, there is no reason to expect that different servers covered by a single certificate would be able to accept each other's tickets; hence, attempting resumption in that case would waste a single-use ticket.",
        "req_type": "NewSessionTicket",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "On resumption, if reporting an SNI value to the calling application, implementations MUST use the value sent in the resumption ClientHello rather than the value sent in the previous session.",
        "req_type": "ClientHello",
        "req_fields": [
            "SNI"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "extensions is a set of extension values for the ticket.",
        "req_type": "NewSessionTicket",
        "req_fields": [
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "A server MAY treat a ticket as valid for a shorter period of time than what is stated in the ticket_lifetime.",
        "req_type": "NewSessionTicket",
        "req_fields": [
            "ticket_lifetime"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The NewSessionTicket structure contains: ticket_lifetime indicates the lifetime in seconds as a 32-bit unsigned integer in network byte order from the time of ticket issuance.",
        "req_type": "",
        "req_fields": [],
        "res_type": "NewSessionTicket",
        "res_fields": [
            "ticket_lifetime"
        ]
    },
    {
        "rule": "ticket_age_add is a securely generated, random 32-bit value that is used to obscure the age of the ticket that the client includes in the \"pre_shared_key\" extension.",
        "req_type": "NewSessionTicket",
        "req_fields": [
            "ticket_age_add"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Although the resumption master secret depends on the client's second flight, a server which does not request client authentication MAY compute the remainder of the transcript independently and then send a NewSessionTicket immediately upon sending its Finished rather than waiting for the client Finished.",
        "req_type": "",
        "req_fields": [],
        "res_type": "NewSessionTicket",
        "res_fields": []
    },
    {
        "rule": "Clients MUST ignore unrecognized extensions.",
        "req_type": "NewSessionTicket",
        "req_fields": [
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Because the ticket_nonce value is distinct for each NewSessionTicket message, a different PSK will be derived for each ticket.",
        "req_type": "NewSessionTicket",
        "req_fields": [
            "ticket_nonce"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The sole extension currently defined for NewSessionTicket is \"early_data\", indicating that the ticket may be used to send 0-RTT data (Section 4.2.10).",
        "req_type": "NewSessionTicket",
        "req_fields": [
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Both the NewSessionTicket and ClientHello messages might be retransmitted and therefore delayed, which might be hidden by TCP.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Note that the handshake protocol, including the ClientHello and ServerHello messages, authenticates the protocol version, so the legacy_record_version field is redundant.",
        "req_type": "ClientHello",
        "req_fields": [
            "legacy_record_version"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "legacy_record_version"
        ]
    },
    {
        "rule": "When a new ClientHello is received, the expected_arrival_time is then compared against the current server wall clock time and if the times differ by more than a certain amount, 0-RTT is rejected, though the 1-RTT handshake can be allowed to complete.",
        "req_type": "ClientHello",
        "req_fields": [
            "expected_arrival_time"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The server can determine the client's view of the age of the ticket by subtracting the ticket's \"ticket_age_add\" value from the \"obfuscated_ticket_age\" parameter in the client's \"pre_shared_key\" extension.",
        "req_type": "ClientHello",
        "req_fields": [
            "pre_shared_key",
            "obfuscated_ticket_age",
            "ticket_age_add"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "bad_certificate: A certificate was corrupt, contained signatures that did not verify correctly, etc.",
        "req_type": "",
        "req_fields": [],
        "res_type": "Alert",
        "res_fields": [
            "description",
            "level"
        ]
    },
    {
        "rule": "Such a guarantee can be accomplished by locally recording data from recently received ClientHellos and rejecting repeats, or by any other method that provides the same or a stronger guarantee.",
        "req_type": "ClientHello",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "decrypt_error: A handshake (not record layer) cryptographic operation failed, including being unable to correctly verify a signature or validate a Finished message or a PSK binder.",
        "req_type": "",
        "req_fields": [],
        "res_type": "Alert",
        "res_fields": [
            "level",
            "description"
        ]
    },
    {
        "rule": "unknown_ca: A valid certificate chain or partial chain was received, but the certificate was not accepted because the CA certificate could not be located or could not be matched with a known trust anchor.",
        "req_type": "",
        "req_fields": [],
        "res_type": "alert",
        "res_fields": [
            "description"
        ]
    },
    {
        "rule": "unrecognized_name: Sent by servers when no server exists identified by the name provided by the client via the \"server_name\" extension (see RFC6066 Extensions: Extension Definitions).",
        "req_type": "ClientHello",
        "req_fields": [
            "server_name"
        ],
        "res_type": "Alert",
        "res_fields": [
            "unrecognized_name"
        ]
    },
    {
        "rule": "unsupported_extension: Sent by endpoints receiving any handshake message containing an extension known to be prohibited for inclusion in the given handshake message, or including any extensions in a ServerHello or Certificate not first offered in the corresponding ClientHello or CertificateRequest.",
        "req_type": "handshake message, ServerHello, Certificate",
        "req_fields": [
            "extensions"
        ],
        "res_type": "Alert",
        "res_fields": [
            "unsupported_extension"
        ]
    },
    {
        "rule": "bad_certificate_status_response: Sent by clients when an invalid or unacceptable OCSP response is provided by the server via the \"status_request\" extension (see RFC6066 Extensions: Extension Definitions).",
        "req_type": "",
        "req_fields": [],
        "res_type": "alert",
        "res_fields": [
            "bad_certificate_status_response"
        ]
    },
    {
        "rule": "no_application_protocol: Sent by servers when a client \"application_layer_protocol_negotiation\" extension advertises only protocols that the server does not support (see RFC7301 Application-Layer Protocol Negotiation Extension).",
        "req_type": "ClientHello",
        "req_fields": [
            "application_layer_protocol_negotiation"
        ],
        "res_type": "Alert",
        "res_fields": [
            "no_application_protocol"
        ]
    },
    {
        "rule": "All implementations MUST send and use these extensions when offering applicable features: \"supported_versions\" is REQUIRED for all ClientHello, ServerHello, and HelloRetryRequest messages.",
        "req_type": "ClientHello, ServerHello, HelloRetryRequest",
        "req_fields": [
            "supported_versions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "\"supported_groups\" is REQUIRED for ClientHello messages using DHE or ECDHE key exchange.",
        "req_type": "ClientHello",
        "req_fields": [
            "supported_groups"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "\"signature_algorithms\" is REQUIRED for certificate authentication.",
        "req_type": "ClientHello",
        "req_fields": [
            "signature_algorithms"
        ],
        "res_type": "CertificateRequest",
        "res_fields": [
            "signature_algorithms"
        ]
    },
    {
        "rule": "\"pre_shared_key\" is REQUIRED for PSK key agreement.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "\"psk_key_exchange_modes\" is REQUIRED for PSK key agreement.",
        "req_type": "ClientHello",
        "req_fields": [
            "psk_key_exchange_modes"
        ],
        "res_type": "ServerHello",
        "res_fields": []
    },
    {
        "rule": "\"key_share\" is REQUIRED for DHE or ECDHE key exchange.",
        "req_type": "ClientHello",
        "req_fields": [
            "key_share"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "key_share"
        ]
    },
    {
        "rule": "A client is considered to be attempting to negotiate using this specification if the ClientHello contains a \"supported_versions\" extension with 0x0304 contained in its body.",
        "req_type": "ClientHello",
        "req_fields": [
            "supported_versions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If containing a \"supported_groups\" extension, it MUST also contain a \"key_share\" extension, and vice versa.",
        "req_type": "ClientHello",
        "req_fields": [
            "supported_groups",
            "key_share"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In the absence of an application profile standard specifying otherwise, a TLS-compliant application MUST implement the following TLS extensions: Supported Versions (\"supported_versions\"; Section 4.2.1), Cookie (\"cookie\"; Section 4.2.2), Signature Algorithms (\"signature_algorithms\"; Section 4.2.3), Signature Algorithms Certificate (\"signature_algorithms_cert\"; Section 4.2.3), Negotiated Groups (\"supported_groups\"; Section 4.2.7), Key Share (\"key_share\"; Section 4.2.8), and Server Name Indication (\"server_name\"; Section 3 of RFC6066).",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Servers receiving a ClientHello which does not conform to these requirements MUST abort the handshake with a \"missing_extension\" alert.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensions"
        ],
        "res_type": "Alert",
        "res_fields": [
            "description"
        ]
    },
    {
        "rule": "Additionally, all implementations MUST support the use of the \"server_name\" extension with applications capable of using it.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Such a ClientHello message MUST meet the following requirements: If not containing a \"pre_shared_key\" extension, it MUST contain both a \"signature_algorithms\" extension and a \"supported_groups\" extension.",
        "req_type": "ClientHello",
        "req_fields": [
            "pre_shared_key",
            "signature_algorithms",
            "supported_groups"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Servers MAY require clients to send a valid \"server_name\" extension.",
        "req_type": "ClientHello",
        "req_fields": [
            "server_name"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "An alternative form of anti-replay is to record a unique value derived from the ClientHello (generally either the random value or the PSK binder) and reject duplicates.",
        "req_type": "ClientHello",
        "req_fields": [
            "random",
            "PSK binder"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the expected_arrival_time is in the window, then the server checks to see if it has recorded a matching ClientHello.",
        "req_type": "ClientHello",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Servers requiring this extension SHOULD respond to a ClientHello lacking a \"server_name\" extension by terminating the connection with a \"missing_extension\" alert.",
        "req_type": "ClientHello",
        "req_fields": [
            "server_name"
        ],
        "res_type": "Alert",
        "res_fields": [
            "missing_extension"
        ]
    },
    {
        "rule": "The server MUST derive the storage key only from validated sections of the ClientHello.",
        "req_type": "ClientHello",
        "req_fields": [
            "validated sections"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If no matching ClientHello is found, then the server accepts 0-RTT and then stores the ClientHello for as long as the expected_arrival_time is inside the window.",
        "req_type": "ClientHello",
        "req_fields": [
            "expected_arrival_time"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If a matching ClientHello is found, the server either aborts the handshake with an \"illegal_parameter\" alert or accepts the PSK but rejects 0-RTT.",
        "req_type": "ClientHello",
        "req_fields": [],
        "res_type": "Alert",
        "res_fields": [
            "illegal_parameter"
        ]
    },
    {
        "rule": "If the validated binder or the ClientHello.random is used as the storage key, then this attack is not possible.",
        "req_type": "ClientHello",
        "req_fields": [
            "binder",
            "random"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the ClientHello contains multiple PSK identities, then an attacker can create multiple ClientHellos with different binder values for the less-preferred identity on the assumption that the server will not verify the less-preferred identity (as recommended by Section 4.2.11).",
        "req_type": "ClientHello",
        "req_fields": [
            "PSK identities",
            "binder values"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "If the binder for B is part of the storage key, then this ClientHello will not appear as a duplicate, which will cause the ClientHello to be accepted, and may cause side effects such as replay cache pollution, although any 0-RTT data will not be decryptable because the data will use different keys.",
        "req_type": "ClientHello",
        "req_fields": [
            "binder"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "For this to work, implementations MUST correctly handle extensible fields: A client sending a ClientHello MUST support all parameters advertised in the ClientHello.",
        "req_type": "ClientHello",
        "req_fields": [
            "extensible fields",
            "parameters"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "Because this mechanism does not require storing all outstanding tickets, it may be easier to implement in distributed systems with high rates of resumption and 0-RTT, at the cost of potentially weaker anti-replay defense because of the difficulty of reliably storing and retrieving the received ClientHello messages.",
        "req_type": "ClientHello",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In TLS 1.3, a client receiving a CertificateRequest or NewSessionTicket MUST also ignore all unrecognized extensions.",
        "req_type": "CertificateRequest, NewSessionTicket",
        "req_fields": [
            "extensions"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "A server receiving a ClientHello MUST correctly ignore all unrecognized cipher suites, extensions, and other parameters.",
        "req_type": "ClientHello",
        "req_fields": [
            "cipher_suites",
            "extensions",
            "other_parameters"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "IANA has added the cipher suites listed in Appendix B.4 to the registry.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "In particular, the middlebox MUST generate its own ClientHello containing only parameters the middlebox understands, and the middlebox MUST generate a fresh ServerHello random value, rather than forwarding the endpoint's value.",
        "req_type": "ClientHello",
        "req_fields": [
            "parameters"
        ],
        "res_type": "ServerHello",
        "res_fields": [
            "random"
        ]
    },
    {
        "rule": "A middlebox which forwards ClientHello parameters the middlebox does not understand MUST NOT process any messages beyond that ClientHello.",
        "req_type": "ClientHello",
        "req_fields": [
            "parameters"
        ],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "IANA has updated the TLS ExtensionType Values registry to include a TLS 1.3 column which lists the messages in which the extension may appear.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "IANA has updated the TLS ExtensionType Values registry to include the key_share, pre_shared_key, psk_key_exchange_modes, early_data, cookie, supported_versions, certificate_authorities, oid_filters, post_handshake_auth, and signature_algorithms_cert extensions with the values defined in this document and the Recommended value of Y.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    },
    {
        "rule": "The key derivation schedule is: PSK -> HKDF-Extract = Early Secret -> Derive-Secret(., \"ext binder\" or \"res binder\", \"\") = binder_key -> Derive-Secret(., \"c e traffic\", ClientHello) = client_early_traffic_secret -> Derive-Secret(., \"e exp master\", ClientHello) = early_exporter_master_secret -> Derive-Secret(., \"derived\", \"\") -> (EC)DHE -> HKDF-Extract = Handshake Secret -> Derive-Secret(., \"c hs traffic\", ClientHello...ServerHello) = client_handshake_traffic_secret -> Derive-Secret(., \"s hs traffic\", ClientHello...ServerHello) = server_handshake_traffic_secret -> Derive-Secret(., \"derived\", \"\") -> 0 -> HKDF-Extract = Master Secret -> Derive-Secret(., \"c ap traffic\", ClientHello...server Finished) = client_application_traffic_secret_0 -> Derive-Secret(., \"s ap traffic\", ClientHello...server Finished) = server_application_traffic_secret_0 -> Derive-Secret(., \"exp master\", ClientHello...server Finished) = exporter_master_secret -> Derive-Secret(., \"res master\", ClientHello...client Finished) = resumption_master_secret.",
        "req_type": "",
        "req_fields": [],
        "res_type": "",
        "res_fields": []
    }
]