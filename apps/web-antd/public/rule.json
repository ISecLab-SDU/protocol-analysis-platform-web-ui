{
    "Bits 3,2,1 and 0 of the Fixed Header of the AUTH packet are reserved and MUST all be set to 0.": "Function: packet__read_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:178\n    178  int packet__read_uint32(struct mosquitto__packet *packet, uint32_t *word)\n    179  {\n    184  \tif(packet->pos+4 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    194  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    94   \tpacket->command = 0;\n    97   \tpacket->remaining_length = 0;\n    102  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    313  \t\t}else if(((packet->command)&0xF0) == CMD_DISCONNECT){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    345  \t}\n    353  }\nFunction: handle__auth\nPath: /root/projects/mosquitto/src/handle_auth.c:34\n    34   int handle__auth(struct mosquitto *context)\n    35   {\n    36   \tint rc = 0;\n    37   \tuint8_t reason_code = 0;\n    39   \tchar *auth_method = NULL;\n    40   \tvoid *auth_data = NULL;\n    41   \tuint16_t auth_data_len = 0;\n    42   \tvoid *auth_data_out = NULL;\n    43   \tuint16_t auth_data_out_len = 0;\n    47   \tif(context->protocol != mosq_p_mqtt5 || context->auth_method == NULL){\n    48   \t\treturn MOSQ_ERR_PROTOCOL;\n    49   \t}\n    50   \tif(context->in_packet.command != CMD_AUTH){\n    51   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    52   \t}\n    54   \tif(context->in_packet.remaining_length > 0){\n    55   \t\tif(packet__read_byte(&context->in_packet, &reason_code)) return MOSQ_ERR_MALFORMED_PACKET;\n    56   \t\tif(reason_code != MQTT_RC_CONTINUE_AUTHENTICATION\n    57   \t\t\t\t&& reason_code != MQTT_RC_REAUTHENTICATE){\n    59   \t\t\tsend__disconnect(context, MQTT_RC_PROTOCOL_ERROR, NULL);\n    60   \t\t\treturn MOSQ_ERR_PROTOCOL;\n    61   \t\t}\n    63   \t\tif((reason_code == MQTT_RC_REAUTHENTICATE && context->state != mosq_cs_active)\n    64   \t\t\t\t|| (reason_code == MQTT_RC_CONTINUE_AUTHENTICATION\n    65   \t\t\t\t\t&& context->state != mosq_cs_authenticating && context->state != mosq_cs_reauthenticating)){\n    68   \t\t\treturn MOSQ_ERR_PROTOCOL;\n    69   \t\t}\n    71   \t\trc = property__read_all(CMD_AUTH, &context->in_packet, &properties);\n    72   \t\tif(rc){\n    74   \t\t\treturn rc;\n    75   \t\t}\n    78   \t\tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &auth_method, false) == NULL){\n    81   \t\t\treturn MOSQ_ERR_PROTOCOL;\n    82   \t\t}\n    84   \t\tif(!auth_method || strcmp(auth_method, context->auth_method)){\n    86   \t\t\tmosquitto__free(auth_method);\n    89   \t\t\treturn MOSQ_ERR_PROTOCOL;\n    90   \t\t}\n    91   \t\tmosquitto__free(auth_method);\n    96   \t}\n    98   \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Received AUTH from %s (rc%d, %s)\", context->id, reason_code, context->auth_method);\n    101  \tif(reason_code == MQTT_RC_REAUTHENTICATE){\n    104  \t\trc = mosquitto_security_auth_start(context, true, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    105  \t}else{\n    109  \t\trc = mosquitto_security_auth_continue(context, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    110  \t}\n    112  \tif(rc == MOSQ_ERR_SUCCESS){\n    113  \t\tif(context->state == mosq_cs_authenticating){\n    114  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    115  \t\t}else{\n    117  \t\t\trc = send__auth(context, MQTT_RC_SUCCESS, auth_data_out, auth_data_out_len);\n    119  \t\t\treturn rc;\n    120  \t\t}\n    121  \t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    124  \t\treturn rc;\n    125  \t}else{\n    131  \t\tif(rc == MOSQ_ERR_AUTH){\n    139  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    140  \t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    149  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    150  \t\t}else{\n    155  \t\t\treturn rc;\n    156  \t\t}\n    157  \t}\n    158  }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    138  \t\t\t}\n    188  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    211  \t\t}\n    213  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    250  \t}\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    330  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    58   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    168  }\nFunction: send__auth\nPath: /root/projects/mosquitto/src/send_auth.c:28\n    28   int send__auth(struct mosquitto *context, uint8_t reason_code, const void *auth_data, uint16_t auth_data_len)\n    29   {\n    36   \tif(context->protocol != mosq_p_mqtt5) return MOSQ_ERR_PROTOCOL;\n    81   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    51   \t\t\tif(rc){\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    58   \t\t\tif(rc){\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    65   \t\t\tif(rc){\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    72   \t\t\tif(rc){\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    79   \t}\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    105  \t}\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    66   \t}else{\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    80   \t}\n    83   }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    144  \t}\n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    161  \t}\n    164  }\nFunction: send__real_publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:137\n    137  int send__real_publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    138  {\n    153  \tif(mosq->protocol == mosq_p_mqtt5){\n    175  \t}\n    206  \tif(mosq->protocol == mosq_p_mqtt5){\n    213  \t}\n    221  }\n",
    "Including the Session Expiry Interval more than once is a Protocol Error.": "Function: bridge__on_connect\nPath: /root/projects/mosquitto/src/bridge.c:488\n    488  int bridge__on_connect(struct mosquitto *context)\n    489  {\n    490  \tint i;\n    494  \tint sub_opts;\n    496  \tuint8_t qos;\n    498  \tif(context->bridge->notifications){\n    499  \t\tif(context->max_qos == 0){\n    501  \t\t}else{\n    504  \t\tif(!context->retain_available){\n    506  \t\t}\n    508  \t\tif(context->bridge->notification_topic){\n    509  \t\t\tif(!context->bridge->notifications_local_only){\n    511  \t\t\t\t\t\tcontext->bridge->notification_topic, 1, &notification_payload, qos, retain, 0, NULL, NULL, 0)){\n    513  \t\t\t\t\treturn 1;\n    514  \t\t\t\t}\n    515  \t\t\t}\n    517  \t\t}else{\n    520  \t\t\tif(!notification_topic) return MOSQ_ERR_NOMEM;\n    524  \t\t\tif(!context->bridge->notifications_local_only){\n    526  \t\t\t\t\t\tnotification_topic, 1, &notification_payload, qos, retain, 0, NULL, NULL, 0)){\n    529  \t\t\t\t\treturn 1;\n    530  \t\t\t\t}\n    531  \t\t\t}\n    534  \t\t}\n    535  \t}\n    536  \tfor(i=0; i<context->bridge->topic_count; i++){\n    537  \t\tif(context->bridge->topics[i].direction == bd_in || context->bridge->topics[i].direction == bd_both){\n    538  \t\t\tif(context->bridge->topics[i].qos > context->max_qos){\n    539  \t\t\t\tsub_opts = context->max_qos;\n    540  \t\t\t}else{\n    541  \t\t\t\tsub_opts = context->bridge->topics[i].qos;\n    542  \t\t\t}\n    543  \t\t\tif(context->bridge->protocol_version == mosq_p_mqtt5){\n    545  \t\t\t\t\t| MQTT_SUB_OPT_NO_LOCAL\n    546  \t\t\t\t\t| MQTT_SUB_OPT_RETAIN_AS_PUBLISHED\n    547  \t\t\t\t\t| MQTT_SUB_OPT_SEND_RETAIN_ALWAYS;\n    548  \t\t\t}\n    549  \t\t\tif(send__subscribe(context, NULL, 1, &context->bridge->topics[i].remote_topic, sub_opts, NULL)){\n    550  \t\t\t\treturn 1;\n    551  \t\t\t}\n    552  \t\t}else{\n    553  \t\t\tif(context->bridge->attempt_unsubscribe){\n    554  \t\t\t\tif(send__unsubscribe(context, NULL, 1, &context->bridge->topics[i].remote_topic, NULL)){\n    558  \t\t\t\t\treturn 1;\n    559  \t\t\t\t}\n    560  \t\t\t}\n    561  \t\t}\n    562  \t}\n    563  \tfor(i=0; i<context->bridge->topic_count; i++){\n    564  \t\tif(context->bridge->topics[i].direction == bd_out || context->bridge->topics[i].direction == bd_both){\n    565  \t\t\tif(context->bridge->topics[i].qos > context->max_qos){\n    566  \t\t\t\tqos = context->max_qos;\n    567  \t\t\t}else{\n    568  \t\t\t\tqos = context->bridge->topics[i].qos;\n    569  \t\t\t}\n    570  \t\t\tretain__queue(context,\n    571  \t\t\t\t\tcontext->bridge->topics[i].local_topic,\n    573  \t\t}\n    574  \t}\n    579  }\nFunction: packet__read_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:178\n    178  int packet__read_uint32(struct mosquitto__packet *packet, uint32_t *word)\n    179  {\n    184  \tif(packet->pos+4 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    194  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    353  }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: mosquitto_property_read_int16\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1048\n    1048 const mosquitto_property *mosquitto_property_read_int16(const mosquitto_property *proplist, int identifier, uint16_t *value, bool skip_first)\n    1049 {\n    1051 \tif(!proplist) return NULL;\n    1053 \tp = property__get_property(proplist, identifier, skip_first);\n    1054 \tif(!p) return NULL;\n    1055 \tif(p->identifier != MQTT_PROP_SERVER_KEEP_ALIVE\n    1056 \t\t\t&& p->identifier != MQTT_PROP_RECEIVE_MAXIMUM\n    1057 \t\t\t&& p->identifier != MQTT_PROP_TOPIC_ALIAS_MAXIMUM\n    1058 \t\t\t&& p->identifier != MQTT_PROP_TOPIC_ALIAS){\n    1059 \t\treturn NULL;\n    1060 \t}\n    1062 \tif(value) *value = p->value.i16;\n    1065 }\nFunction: mosquitto_property_read_int32\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1068\n    1068 const mosquitto_property *mosquitto_property_read_int32(const mosquitto_property *proplist, int identifier, uint32_t *value, bool skip_first)\n    1069 {\n    1071 \tif(!proplist) return NULL;\n    1073 \tp = property__get_property(proplist, identifier, skip_first);\n    1074 \tif(!p) return NULL;\n    1075 \tif(p->identifier != MQTT_PROP_MESSAGE_EXPIRY_INTERVAL\n    1076 \t\t\t&& p->identifier != MQTT_PROP_SESSION_EXPIRY_INTERVAL\n    1077 \t\t\t&& p->identifier != MQTT_PROP_WILL_DELAY_INTERVAL\n    1078 \t\t\t&& p->identifier != MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    1080 \t\treturn NULL;\n    1081 \t}\n    1083 \tif(value) *value = p->value.i32;\n    1086 }\nFunction: handle__connack\nPath: /root/projects/mosquitto/src/handle_connack.c:31\n    31   int handle__connack(struct mosquitto *context)\n    32   {\n    35   \tuint8_t reason_code;\n    36   \tmosquitto_property *properties = NULL;\n    37   \tuint32_t maximum_packet_size;\n    38   \tuint8_t retain_available;\n    39   \tuint16_t server_keepalive;\n    40   \tuint16_t inflight_maximum;\n    41   \tuint8_t max_qos = 255;\n    49   \tif(context->in_packet.command != CMD_CONNACK){\n    50   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    51   \t}\n    54   \tif(packet__read_byte(&context->in_packet, &reason_code)) return MOSQ_ERR_MALFORMED_PACKET;\n    56   \tif(context->protocol == mosq_p_mqtt5){\n    57   \t\tif(context->in_packet.remaining_length == 2 && reason_code == CONNACK_REFUSED_PROTOCOL_VERSION){\n    67   \t\t\treturn MOSQ_ERR_PROTOCOL;\n    68   \t\t}\n    70   \t\trc = property__read_all(CMD_CONNACK, &context->in_packet, &properties);\n    71   \t\tif(rc) return rc;\n    74   \t\tmosquitto_property_read_byte(properties, MQTT_PROP_MAXIMUM_QOS,\n    78   \t\tif(mosquitto_property_read_int32(properties, MQTT_PROP_MAXIMUM_PACKET_SIZE,\n    79   \t\t\t\t\t&maximum_packet_size, false)){\n    81   \t\t\tif(context->maximum_packet_size == 0 || context->maximum_packet_size > maximum_packet_size){\n    82   \t\t\t\tcontext->maximum_packet_size = maximum_packet_size;\n    83   \t\t\t}\n    84   \t\t}\n    87   \t\tinflight_maximum = context->msgs_out.inflight_maximum;\n    88   \t\tmosquitto_property_read_int16(properties, MQTT_PROP_RECEIVE_MAXIMUM, &inflight_maximum, false);\n    89   \t\tif(context->msgs_out.inflight_maximum != inflight_maximum){\n    90   \t\t\tcontext->msgs_out.inflight_maximum = inflight_maximum;\n    91   \t\t\tdb__message_reconnect_reset(context);\n    92   \t\t}\n    95   \t\tif(mosquitto_property_read_byte(properties, MQTT_PROP_RETAIN_AVAILABLE,\n    96   \t\t\t\t\t&retain_available, false)){\n    99   \t\t\tif(context->retain_available){\n    100  \t\t\t\tcontext->retain_available = retain_available;\n    101  \t\t\t}\n    102  \t\t}\n    105  \t\tif(mosquitto_property_read_int16(properties, MQTT_PROP_SERVER_KEEP_ALIVE,\n    106  \t\t\t\t\t&server_keepalive, false)){\n    108  \t\t\tcontext->keepalive = server_keepalive;\n    109  \t\t}\n    111  \t\tmosquitto_property_free_all(&properties);\n    112  \t}\n    113  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    115  \tif(reason_code == MQTT_RC_SUCCESS){\n    117  \t\tif(context->bridge){\n    118  \t\t\trc = bridge__on_connect(context);\n    119  \t\t\tif(rc) return rc;\n    120  \t\t}\n    122  \t\tif(max_qos != 255){\n    123  \t\t\tcontext->max_qos = max_qos;\n    124  \t\t}\n    127  \t\tif(rc) return rc;\n    129  \t\treturn rc;\n    130  \t}else{\n    131  \t\tif(context->protocol == mosq_p_mqtt5){\n    132  \t\t\tswitch(reason_code){\n    133  \t\t\t\tcase MQTT_RC_RETAIN_NOT_SUPPORTED:\n    134  \t\t\t\t\tcontext->retain_available = 0;\n    136  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    137  \t\t\t\tcase MQTT_RC_QOS_NOT_SUPPORTED:\n    138  \t\t\t\t\tif(max_qos == 255){\n    139  \t\t\t\t\t\tif(context->max_qos != 0){\n    140  \t\t\t\t\t\t\tcontext->max_qos--;\n    141  \t\t\t\t\t\t}\n    142  \t\t\t\t\t}else{\n    143  \t\t\t\t\t\tcontext->max_qos = max_qos;\n    144  \t\t\t\t\t}\n    146  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    147  \t\t\t\tdefault:\n    148  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Connection Refused: %s\", mosquitto_reason_string(reason_code));\n    149  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    150  \t\t\t}\n    151  \t\t}else{\n    152  \t\t\tswitch(reason_code){\n    158  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    161  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    164  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    167  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    170  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    173  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    174  \t\t\t}\n    175  \t\t}\n    176  \t}\n    178  }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    633  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    58   }\nFunction: mosquitto_property_read_byte\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1024\n    1024 const mosquitto_property *mosquitto_property_read_byte(const mosquitto_property *proplist, int identifier, uint8_t *value, bool skip_first)\n    1025 {\n    1027 \tif(!proplist) return NULL;\n    1029 \tp = property__get_property(proplist, identifier, skip_first);\n    1030 \tif(!p) return NULL;\n    1031 \tif(p->identifier != MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    1032 \t\t\t&& p->identifier != MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    1033 \t\t\t&& p->identifier != MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    1034 \t\t\t&& p->identifier != MQTT_PROP_MAXIMUM_QOS\n    1035 \t\t\t&& p->identifier != MQTT_PROP_RETAIN_AVAILABLE\n    1036 \t\t\t&& p->identifier != MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    1037 \t\t\t&& p->identifier != MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    1038 \t\t\t&& p->identifier != MQTT_PROP_SHARED_SUB_AVAILABLE){\n    1039 \t\treturn NULL;\n    1040 \t}\n    1042 \tif(value) *value = p->value.i8;\n    1045 }\nFunction: property__get_property\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:988\n    988  static const mosquitto_property *property__get_property(const mosquitto_property *proplist, int identifier, bool skip_first)\n    989  {\n    990  \tconst mosquitto_property *p;\n    995  \twhile(p){\n    996  \t\tif(p->identifier == identifier){\n    997  \t\t\tif(!is_first || !skip_first){\n    998  \t\t\t\treturn p;\n    999  \t\t\t}\n    1001 \t\t}\n    1002 \t\tp = p->next;\n    1003 \t}\n    1005 }\n",
    "It is a Protocol Error to include the Wildcard Subscription Available Byte field more than once or to send a value other than 0 or 1.": "Function: bridge__on_connect\nPath: /root/projects/mosquitto/src/bridge.c:488\n    488  int bridge__on_connect(struct mosquitto *context)\n    489  {\n    490  \tint i;\n    494  \tint sub_opts;\n    496  \tuint8_t qos;\n    498  \tif(context->bridge->notifications){\n    499  \t\tif(context->max_qos == 0){\n    501  \t\t}else{\n    504  \t\tif(!context->retain_available){\n    506  \t\t}\n    508  \t\tif(context->bridge->notification_topic){\n    509  \t\t\tif(!context->bridge->notifications_local_only){\n    511  \t\t\t\t\t\tcontext->bridge->notification_topic, 1, &notification_payload, qos, retain, 0, NULL, NULL, 0)){\n    513  \t\t\t\t\treturn 1;\n    514  \t\t\t\t}\n    515  \t\t\t}\n    517  \t\t}else{\n    520  \t\t\tif(!notification_topic) return MOSQ_ERR_NOMEM;\n    524  \t\t\tif(!context->bridge->notifications_local_only){\n    526  \t\t\t\t\t\tnotification_topic, 1, &notification_payload, qos, retain, 0, NULL, NULL, 0)){\n    529  \t\t\t\t\treturn 1;\n    530  \t\t\t\t}\n    531  \t\t\t}\n    534  \t\t}\n    535  \t}\n    536  \tfor(i=0; i<context->bridge->topic_count; i++){\n    537  \t\tif(context->bridge->topics[i].direction == bd_in || context->bridge->topics[i].direction == bd_both){\n    538  \t\t\tif(context->bridge->topics[i].qos > context->max_qos){\n    539  \t\t\t\tsub_opts = context->max_qos;\n    540  \t\t\t}else{\n    541  \t\t\t\tsub_opts = context->bridge->topics[i].qos;\n    542  \t\t\t}\n    543  \t\t\tif(context->bridge->protocol_version == mosq_p_mqtt5){\n    545  \t\t\t\t\t| MQTT_SUB_OPT_NO_LOCAL\n    546  \t\t\t\t\t| MQTT_SUB_OPT_RETAIN_AS_PUBLISHED\n    547  \t\t\t\t\t| MQTT_SUB_OPT_SEND_RETAIN_ALWAYS;\n    548  \t\t\t}\n    549  \t\t\tif(send__subscribe(context, NULL, 1, &context->bridge->topics[i].remote_topic, sub_opts, NULL)){\n    550  \t\t\t\treturn 1;\n    551  \t\t\t}\n    552  \t\t}else{\n    553  \t\t\tif(context->bridge->attempt_unsubscribe){\n    554  \t\t\t\tif(send__unsubscribe(context, NULL, 1, &context->bridge->topics[i].remote_topic, NULL)){\n    558  \t\t\t\t\treturn 1;\n    559  \t\t\t\t}\n    560  \t\t\t}\n    561  \t\t}\n    562  \t}\n    563  \tfor(i=0; i<context->bridge->topic_count; i++){\n    564  \t\tif(context->bridge->topics[i].direction == bd_out || context->bridge->topics[i].direction == bd_both){\n    565  \t\t\tif(context->bridge->topics[i].qos > context->max_qos){\n    566  \t\t\t\tqos = context->max_qos;\n    567  \t\t\t}else{\n    568  \t\t\t\tqos = context->bridge->topics[i].qos;\n    569  \t\t\t}\n    570  \t\t\tretain__queue(context,\n    571  \t\t\t\t\tcontext->bridge->topics[i].local_topic,\n    573  \t\t}\n    574  \t}\n    579  }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    94   \tpacket->command = 0;\n    102  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    353  }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    237  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: mosquitto_property_read_int16\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1048\n    1048 const mosquitto_property *mosquitto_property_read_int16(const mosquitto_property *proplist, int identifier, uint16_t *value, bool skip_first)\n    1049 {\n    1051 \tif(!proplist) return NULL;\n    1053 \tp = property__get_property(proplist, identifier, skip_first);\n    1054 \tif(!p) return NULL;\n    1055 \tif(p->identifier != MQTT_PROP_SERVER_KEEP_ALIVE\n    1056 \t\t\t&& p->identifier != MQTT_PROP_RECEIVE_MAXIMUM\n    1057 \t\t\t&& p->identifier != MQTT_PROP_TOPIC_ALIAS_MAXIMUM\n    1058 \t\t\t&& p->identifier != MQTT_PROP_TOPIC_ALIAS){\n    1059 \t\treturn NULL;\n    1060 \t}\n    1062 \tif(value) *value = p->value.i16;\n    1065 }\nFunction: mosquitto_property_read_int32\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1068\n    1068 const mosquitto_property *mosquitto_property_read_int32(const mosquitto_property *proplist, int identifier, uint32_t *value, bool skip_first)\n    1069 {\n    1071 \tif(!proplist) return NULL;\n    1073 \tp = property__get_property(proplist, identifier, skip_first);\n    1074 \tif(!p) return NULL;\n    1075 \tif(p->identifier != MQTT_PROP_MESSAGE_EXPIRY_INTERVAL\n    1076 \t\t\t&& p->identifier != MQTT_PROP_SESSION_EXPIRY_INTERVAL\n    1077 \t\t\t&& p->identifier != MQTT_PROP_WILL_DELAY_INTERVAL\n    1078 \t\t\t&& p->identifier != MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    1080 \t\treturn NULL;\n    1081 \t}\n    1083 \tif(value) *value = p->value.i32;\n    1086 }\nFunction: handle__connack\nPath: /root/projects/mosquitto/src/handle_connack.c:31\n    31   int handle__connack(struct mosquitto *context)\n    32   {\n    35   \tuint8_t reason_code;\n    36   \tmosquitto_property *properties = NULL;\n    37   \tuint32_t maximum_packet_size;\n    38   \tuint8_t retain_available;\n    39   \tuint16_t server_keepalive;\n    40   \tuint16_t inflight_maximum;\n    41   \tuint8_t max_qos = 255;\n    49   \tif(context->in_packet.command != CMD_CONNACK){\n    50   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    51   \t}\n    54   \tif(packet__read_byte(&context->in_packet, &reason_code)) return MOSQ_ERR_MALFORMED_PACKET;\n    56   \tif(context->protocol == mosq_p_mqtt5){\n    57   \t\tif(context->in_packet.remaining_length == 2 && reason_code == CONNACK_REFUSED_PROTOCOL_VERSION){\n    67   \t\t\treturn MOSQ_ERR_PROTOCOL;\n    68   \t\t}\n    70   \t\trc = property__read_all(CMD_CONNACK, &context->in_packet, &properties);\n    71   \t\tif(rc) return rc;\n    74   \t\tmosquitto_property_read_byte(properties, MQTT_PROP_MAXIMUM_QOS,\n    78   \t\tif(mosquitto_property_read_int32(properties, MQTT_PROP_MAXIMUM_PACKET_SIZE,\n    79   \t\t\t\t\t&maximum_packet_size, false)){\n    81   \t\t\tif(context->maximum_packet_size == 0 || context->maximum_packet_size > maximum_packet_size){\n    82   \t\t\t\tcontext->maximum_packet_size = maximum_packet_size;\n    83   \t\t\t}\n    84   \t\t}\n    87   \t\tinflight_maximum = context->msgs_out.inflight_maximum;\n    88   \t\tmosquitto_property_read_int16(properties, MQTT_PROP_RECEIVE_MAXIMUM, &inflight_maximum, false);\n    89   \t\tif(context->msgs_out.inflight_maximum != inflight_maximum){\n    90   \t\t\tcontext->msgs_out.inflight_maximum = inflight_maximum;\n    91   \t\t\tdb__message_reconnect_reset(context);\n    92   \t\t}\n    95   \t\tif(mosquitto_property_read_byte(properties, MQTT_PROP_RETAIN_AVAILABLE,\n    96   \t\t\t\t\t&retain_available, false)){\n    99   \t\t\tif(context->retain_available){\n    100  \t\t\t\tcontext->retain_available = retain_available;\n    101  \t\t\t}\n    102  \t\t}\n    105  \t\tif(mosquitto_property_read_int16(properties, MQTT_PROP_SERVER_KEEP_ALIVE,\n    106  \t\t\t\t\t&server_keepalive, false)){\n    108  \t\t\tcontext->keepalive = server_keepalive;\n    109  \t\t}\n    111  \t\tmosquitto_property_free_all(&properties);\n    112  \t}\n    113  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    115  \tif(reason_code == MQTT_RC_SUCCESS){\n    117  \t\tif(context->bridge){\n    118  \t\t\trc = bridge__on_connect(context);\n    119  \t\t\tif(rc) return rc;\n    120  \t\t}\n    122  \t\tif(max_qos != 255){\n    123  \t\t\tcontext->max_qos = max_qos;\n    124  \t\t}\n    127  \t\tif(rc) return rc;\n    129  \t\treturn rc;\n    130  \t}else{\n    131  \t\tif(context->protocol == mosq_p_mqtt5){\n    132  \t\t\tswitch(reason_code){\n    133  \t\t\t\tcase MQTT_RC_RETAIN_NOT_SUPPORTED:\n    134  \t\t\t\t\tcontext->retain_available = 0;\n    136  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    137  \t\t\t\tcase MQTT_RC_QOS_NOT_SUPPORTED:\n    138  \t\t\t\t\tif(max_qos == 255){\n    139  \t\t\t\t\t\tif(context->max_qos != 0){\n    140  \t\t\t\t\t\t\tcontext->max_qos--;\n    141  \t\t\t\t\t\t}\n    142  \t\t\t\t\t}else{\n    143  \t\t\t\t\t\tcontext->max_qos = max_qos;\n    144  \t\t\t\t\t}\n    146  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    147  \t\t\t\tdefault:\n    148  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Connection Refused: %s\", mosquitto_reason_string(reason_code));\n    149  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    150  \t\t\t}\n    151  \t\t}else{\n    152  \t\t\tswitch(reason_code){\n    158  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    161  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    164  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    167  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    170  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    173  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    174  \t\t\t}\n    175  \t\t}\n    176  \t}\n    178  }\nFunction: mosquitto_property_read_byte\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1024\n    1024 const mosquitto_property *mosquitto_property_read_byte(const mosquitto_property *proplist, int identifier, uint8_t *value, bool skip_first)\n    1025 {\n    1027 \tif(!proplist) return NULL;\n    1029 \tp = property__get_property(proplist, identifier, skip_first);\n    1030 \tif(!p) return NULL;\n    1031 \tif(p->identifier != MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    1032 \t\t\t&& p->identifier != MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    1033 \t\t\t&& p->identifier != MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    1034 \t\t\t&& p->identifier != MQTT_PROP_MAXIMUM_QOS\n    1035 \t\t\t&& p->identifier != MQTT_PROP_RETAIN_AVAILABLE\n    1036 \t\t\t&& p->identifier != MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    1037 \t\t\t&& p->identifier != MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    1038 \t\t\t&& p->identifier != MQTT_PROP_SHARED_SUB_AVAILABLE){\n    1039 \t\treturn NULL;\n    1040 \t}\n    1042 \tif(value) *value = p->value.i8;\n    1045 }\nFunction: property__get_property\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:988\n    988  static const mosquitto_property *property__get_property(const mosquitto_property *proplist, int identifier, bool skip_first)\n    989  {\n    990  \tconst mosquitto_property *p;\n    995  \twhile(p){\n    996  \t\tif(p->identifier == identifier){\n    997  \t\t\tif(!is_first || !skip_first){\n    998  \t\t\t\treturn p;\n    999  \t\t\t}\n    1001 \t\t}\n    1002 \t\tp = p->next;\n    1003 \t}\n    1005 }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\n",
    "Including the Subscription Identifier Available more than once, or sending a value other than 0 or 1, is a Protocol Error.": "Function: bridge__on_connect\nPath: /root/projects/mosquitto/src/bridge.c:488\n    488  int bridge__on_connect(struct mosquitto *context)\n    489  {\n    490  \tint i;\n    494  \tint sub_opts;\n    496  \tuint8_t qos;\n    498  \tif(context->bridge->notifications){\n    499  \t\tif(context->max_qos == 0){\n    501  \t\t}else{\n    504  \t\tif(!context->retain_available){\n    506  \t\t}\n    508  \t\tif(context->bridge->notification_topic){\n    509  \t\t\tif(!context->bridge->notifications_local_only){\n    511  \t\t\t\t\t\tcontext->bridge->notification_topic, 1, &notification_payload, qos, retain, 0, NULL, NULL, 0)){\n    513  \t\t\t\t\treturn 1;\n    514  \t\t\t\t}\n    515  \t\t\t}\n    517  \t\t}else{\n    520  \t\t\tif(!notification_topic) return MOSQ_ERR_NOMEM;\n    524  \t\t\tif(!context->bridge->notifications_local_only){\n    526  \t\t\t\t\t\tnotification_topic, 1, &notification_payload, qos, retain, 0, NULL, NULL, 0)){\n    529  \t\t\t\t\treturn 1;\n    530  \t\t\t\t}\n    531  \t\t\t}\n    534  \t\t}\n    535  \t}\n    536  \tfor(i=0; i<context->bridge->topic_count; i++){\n    537  \t\tif(context->bridge->topics[i].direction == bd_in || context->bridge->topics[i].direction == bd_both){\n    538  \t\t\tif(context->bridge->topics[i].qos > context->max_qos){\n    539  \t\t\t\tsub_opts = context->max_qos;\n    540  \t\t\t}else{\n    541  \t\t\t\tsub_opts = context->bridge->topics[i].qos;\n    542  \t\t\t}\n    543  \t\t\tif(context->bridge->protocol_version == mosq_p_mqtt5){\n    545  \t\t\t\t\t| MQTT_SUB_OPT_NO_LOCAL\n    546  \t\t\t\t\t| MQTT_SUB_OPT_RETAIN_AS_PUBLISHED\n    547  \t\t\t\t\t| MQTT_SUB_OPT_SEND_RETAIN_ALWAYS;\n    548  \t\t\t}\n    549  \t\t\tif(send__subscribe(context, NULL, 1, &context->bridge->topics[i].remote_topic, sub_opts, NULL)){\n    550  \t\t\t\treturn 1;\n    551  \t\t\t}\n    552  \t\t}else{\n    553  \t\t\tif(context->bridge->attempt_unsubscribe){\n    554  \t\t\t\tif(send__unsubscribe(context, NULL, 1, &context->bridge->topics[i].remote_topic, NULL)){\n    558  \t\t\t\t\treturn 1;\n    559  \t\t\t\t}\n    560  \t\t\t}\n    561  \t\t}\n    562  \t}\n    563  \tfor(i=0; i<context->bridge->topic_count; i++){\n    564  \t\tif(context->bridge->topics[i].direction == bd_out || context->bridge->topics[i].direction == bd_both){\n    565  \t\t\tif(context->bridge->topics[i].qos > context->max_qos){\n    566  \t\t\t\tqos = context->max_qos;\n    567  \t\t\t}else{\n    568  \t\t\t\tqos = context->bridge->topics[i].qos;\n    569  \t\t\t}\n    570  \t\t\tretain__queue(context,\n    571  \t\t\t\t\tcontext->bridge->topics[i].local_topic,\n    573  \t\t}\n    574  \t}\n    579  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    94   \tpacket->command = 0;\n    97   \tpacket->remaining_length = 0;\n    102  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    353  }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    225  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    238  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: mosquitto_property_read_int16\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1048\n    1048 const mosquitto_property *mosquitto_property_read_int16(const mosquitto_property *proplist, int identifier, uint16_t *value, bool skip_first)\n    1049 {\n    1051 \tif(!proplist) return NULL;\n    1053 \tp = property__get_property(proplist, identifier, skip_first);\n    1054 \tif(!p) return NULL;\n    1055 \tif(p->identifier != MQTT_PROP_SERVER_KEEP_ALIVE\n    1056 \t\t\t&& p->identifier != MQTT_PROP_RECEIVE_MAXIMUM\n    1057 \t\t\t&& p->identifier != MQTT_PROP_TOPIC_ALIAS_MAXIMUM\n    1058 \t\t\t&& p->identifier != MQTT_PROP_TOPIC_ALIAS){\n    1059 \t\treturn NULL;\n    1060 \t}\n    1062 \tif(value) *value = p->value.i16;\n    1065 }\nFunction: mosquitto_property_read_int32\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1068\n    1068 const mosquitto_property *mosquitto_property_read_int32(const mosquitto_property *proplist, int identifier, uint32_t *value, bool skip_first)\n    1069 {\n    1071 \tif(!proplist) return NULL;\n    1073 \tp = property__get_property(proplist, identifier, skip_first);\n    1074 \tif(!p) return NULL;\n    1075 \tif(p->identifier != MQTT_PROP_MESSAGE_EXPIRY_INTERVAL\n    1076 \t\t\t&& p->identifier != MQTT_PROP_SESSION_EXPIRY_INTERVAL\n    1077 \t\t\t&& p->identifier != MQTT_PROP_WILL_DELAY_INTERVAL\n    1078 \t\t\t&& p->identifier != MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    1080 \t\treturn NULL;\n    1081 \t}\n    1083 \tif(value) *value = p->value.i32;\n    1086 }\nFunction: handle__connack\nPath: /root/projects/mosquitto/src/handle_connack.c:31\n    31   int handle__connack(struct mosquitto *context)\n    32   {\n    35   \tuint8_t reason_code;\n    36   \tmosquitto_property *properties = NULL;\n    37   \tuint32_t maximum_packet_size;\n    38   \tuint8_t retain_available;\n    39   \tuint16_t server_keepalive;\n    40   \tuint16_t inflight_maximum;\n    41   \tuint8_t max_qos = 255;\n    49   \tif(context->in_packet.command != CMD_CONNACK){\n    50   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    51   \t}\n    54   \tif(packet__read_byte(&context->in_packet, &reason_code)) return MOSQ_ERR_MALFORMED_PACKET;\n    56   \tif(context->protocol == mosq_p_mqtt5){\n    57   \t\tif(context->in_packet.remaining_length == 2 && reason_code == CONNACK_REFUSED_PROTOCOL_VERSION){\n    67   \t\t\treturn MOSQ_ERR_PROTOCOL;\n    68   \t\t}\n    70   \t\trc = property__read_all(CMD_CONNACK, &context->in_packet, &properties);\n    71   \t\tif(rc) return rc;\n    74   \t\tmosquitto_property_read_byte(properties, MQTT_PROP_MAXIMUM_QOS,\n    78   \t\tif(mosquitto_property_read_int32(properties, MQTT_PROP_MAXIMUM_PACKET_SIZE,\n    79   \t\t\t\t\t&maximum_packet_size, false)){\n    81   \t\t\tif(context->maximum_packet_size == 0 || context->maximum_packet_size > maximum_packet_size){\n    82   \t\t\t\tcontext->maximum_packet_size = maximum_packet_size;\n    83   \t\t\t}\n    84   \t\t}\n    87   \t\tinflight_maximum = context->msgs_out.inflight_maximum;\n    88   \t\tmosquitto_property_read_int16(properties, MQTT_PROP_RECEIVE_MAXIMUM, &inflight_maximum, false);\n    89   \t\tif(context->msgs_out.inflight_maximum != inflight_maximum){\n    90   \t\t\tcontext->msgs_out.inflight_maximum = inflight_maximum;\n    91   \t\t\tdb__message_reconnect_reset(context);\n    92   \t\t}\n    95   \t\tif(mosquitto_property_read_byte(properties, MQTT_PROP_RETAIN_AVAILABLE,\n    96   \t\t\t\t\t&retain_available, false)){\n    99   \t\t\tif(context->retain_available){\n    100  \t\t\t\tcontext->retain_available = retain_available;\n    101  \t\t\t}\n    102  \t\t}\n    105  \t\tif(mosquitto_property_read_int16(properties, MQTT_PROP_SERVER_KEEP_ALIVE,\n    106  \t\t\t\t\t&server_keepalive, false)){\n    108  \t\t\tcontext->keepalive = server_keepalive;\n    109  \t\t}\n    111  \t\tmosquitto_property_free_all(&properties);\n    112  \t}\n    113  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    115  \tif(reason_code == MQTT_RC_SUCCESS){\n    117  \t\tif(context->bridge){\n    118  \t\t\trc = bridge__on_connect(context);\n    119  \t\t\tif(rc) return rc;\n    120  \t\t}\n    122  \t\tif(max_qos != 255){\n    123  \t\t\tcontext->max_qos = max_qos;\n    124  \t\t}\n    127  \t\tif(rc) return rc;\n    129  \t\treturn rc;\n    130  \t}else{\n    131  \t\tif(context->protocol == mosq_p_mqtt5){\n    132  \t\t\tswitch(reason_code){\n    133  \t\t\t\tcase MQTT_RC_RETAIN_NOT_SUPPORTED:\n    134  \t\t\t\t\tcontext->retain_available = 0;\n    136  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    137  \t\t\t\tcase MQTT_RC_QOS_NOT_SUPPORTED:\n    138  \t\t\t\t\tif(max_qos == 255){\n    139  \t\t\t\t\t\tif(context->max_qos != 0){\n    140  \t\t\t\t\t\t\tcontext->max_qos--;\n    141  \t\t\t\t\t\t}\n    142  \t\t\t\t\t}else{\n    143  \t\t\t\t\t\tcontext->max_qos = max_qos;\n    144  \t\t\t\t\t}\n    146  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    147  \t\t\t\tdefault:\n    148  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Connection Refused: %s\", mosquitto_reason_string(reason_code));\n    149  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    150  \t\t\t}\n    151  \t\t}else{\n    152  \t\t\tswitch(reason_code){\n    158  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    161  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    164  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    167  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    170  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    173  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    174  \t\t\t}\n    175  \t\t}\n    176  \t}\n    178  }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    633  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    58   }\nFunction: mosquitto_property_read_byte\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1024\n    1024 const mosquitto_property *mosquitto_property_read_byte(const mosquitto_property *proplist, int identifier, uint8_t *value, bool skip_first)\n    1025 {\n    1027 \tif(!proplist) return NULL;\n    1029 \tp = property__get_property(proplist, identifier, skip_first);\n    1030 \tif(!p) return NULL;\n    1031 \tif(p->identifier != MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    1032 \t\t\t&& p->identifier != MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    1033 \t\t\t&& p->identifier != MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    1034 \t\t\t&& p->identifier != MQTT_PROP_MAXIMUM_QOS\n    1035 \t\t\t&& p->identifier != MQTT_PROP_RETAIN_AVAILABLE\n    1036 \t\t\t&& p->identifier != MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    1037 \t\t\t&& p->identifier != MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    1038 \t\t\t&& p->identifier != MQTT_PROP_SHARED_SUB_AVAILABLE){\n    1039 \t\treturn NULL;\n    1040 \t}\n    1042 \tif(value) *value = p->value.i8;\n    1045 }\nFunction: property__get_property\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:988\n    988  static const mosquitto_property *property__get_property(const mosquitto_property *proplist, int identifier, bool skip_first)\n    989  {\n    990  \tconst mosquitto_property *p;\n    995  \twhile(p){\n    996  \t\tif(p->identifier == identifier){\n    997  \t\t\tif(!is_first || !skip_first){\n    998  \t\t\t\treturn p;\n    999  \t\t\t}\n    1001 \t\t}\n    1002 \t\tp = p->next;\n    1003 \t}\n    1005 }\n",
    "Including the Topic Alias Maximum value more than once is a Protocol Error.": "Function: bridge__on_connect\nPath: /root/projects/mosquitto/src/bridge.c:488\n    488  int bridge__on_connect(struct mosquitto *context)\n    489  {\n    490  \tint i;\n    494  \tint sub_opts;\n    496  \tuint8_t qos;\n    498  \tif(context->bridge->notifications){\n    499  \t\tif(context->max_qos == 0){\n    501  \t\t}else{\n    504  \t\tif(!context->retain_available){\n    506  \t\t}\n    508  \t\tif(context->bridge->notification_topic){\n    509  \t\t\tif(!context->bridge->notifications_local_only){\n    511  \t\t\t\t\t\tcontext->bridge->notification_topic, 1, &notification_payload, qos, retain, 0, NULL, NULL, 0)){\n    513  \t\t\t\t\treturn 1;\n    514  \t\t\t\t}\n    515  \t\t\t}\n    517  \t\t}else{\n    520  \t\t\tif(!notification_topic) return MOSQ_ERR_NOMEM;\n    524  \t\t\tif(!context->bridge->notifications_local_only){\n    526  \t\t\t\t\t\tnotification_topic, 1, &notification_payload, qos, retain, 0, NULL, NULL, 0)){\n    529  \t\t\t\t\treturn 1;\n    530  \t\t\t\t}\n    531  \t\t\t}\n    534  \t\t}\n    535  \t}\n    536  \tfor(i=0; i<context->bridge->topic_count; i++){\n    537  \t\tif(context->bridge->topics[i].direction == bd_in || context->bridge->topics[i].direction == bd_both){\n    538  \t\t\tif(context->bridge->topics[i].qos > context->max_qos){\n    539  \t\t\t\tsub_opts = context->max_qos;\n    540  \t\t\t}else{\n    541  \t\t\t\tsub_opts = context->bridge->topics[i].qos;\n    542  \t\t\t}\n    543  \t\t\tif(context->bridge->protocol_version == mosq_p_mqtt5){\n    545  \t\t\t\t\t| MQTT_SUB_OPT_NO_LOCAL\n    546  \t\t\t\t\t| MQTT_SUB_OPT_RETAIN_AS_PUBLISHED\n    547  \t\t\t\t\t| MQTT_SUB_OPT_SEND_RETAIN_ALWAYS;\n    548  \t\t\t}\n    549  \t\t\tif(send__subscribe(context, NULL, 1, &context->bridge->topics[i].remote_topic, sub_opts, NULL)){\n    550  \t\t\t\treturn 1;\n    551  \t\t\t}\n    552  \t\t}else{\n    553  \t\t\tif(context->bridge->attempt_unsubscribe){\n    554  \t\t\t\tif(send__unsubscribe(context, NULL, 1, &context->bridge->topics[i].remote_topic, NULL)){\n    558  \t\t\t\t\treturn 1;\n    559  \t\t\t\t}\n    560  \t\t\t}\n    561  \t\t}\n    562  \t}\n    563  \tfor(i=0; i<context->bridge->topic_count; i++){\n    564  \t\tif(context->bridge->topics[i].direction == bd_out || context->bridge->topics[i].direction == bd_both){\n    565  \t\t\tif(context->bridge->topics[i].qos > context->max_qos){\n    566  \t\t\t\tqos = context->max_qos;\n    567  \t\t\t}else{\n    568  \t\t\t\tqos = context->bridge->topics[i].qos;\n    569  \t\t\t}\n    570  \t\t\tretain__queue(context,\n    571  \t\t\t\t\tcontext->bridge->topics[i].local_topic,\n    573  \t\t}\n    574  \t}\n    579  }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    94   \tpacket->command = 0;\n    102  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    353  }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    957  \n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    232  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: mosquitto_property_read_int16\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1048\n    1048 const mosquitto_property *mosquitto_property_read_int16(const mosquitto_property *proplist, int identifier, uint16_t *value, bool skip_first)\n    1049 {\n    1051 \tif(!proplist) return NULL;\n    1053 \tp = property__get_property(proplist, identifier, skip_first);\n    1054 \tif(!p) return NULL;\n    1055 \tif(p->identifier != MQTT_PROP_SERVER_KEEP_ALIVE\n    1056 \t\t\t&& p->identifier != MQTT_PROP_RECEIVE_MAXIMUM\n    1057 \t\t\t&& p->identifier != MQTT_PROP_TOPIC_ALIAS_MAXIMUM\n    1058 \t\t\t&& p->identifier != MQTT_PROP_TOPIC_ALIAS){\n    1059 \t\treturn NULL;\n    1060 \t}\n    1062 \tif(value) *value = p->value.i16;\n    1065 }\nFunction: mosquitto_property_read_int32\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1068\n    1068 const mosquitto_property *mosquitto_property_read_int32(const mosquitto_property *proplist, int identifier, uint32_t *value, bool skip_first)\n    1069 {\n    1071 \tif(!proplist) return NULL;\n    1073 \tp = property__get_property(proplist, identifier, skip_first);\n    1074 \tif(!p) return NULL;\n    1075 \tif(p->identifier != MQTT_PROP_MESSAGE_EXPIRY_INTERVAL\n    1076 \t\t\t&& p->identifier != MQTT_PROP_SESSION_EXPIRY_INTERVAL\n    1077 \t\t\t&& p->identifier != MQTT_PROP_WILL_DELAY_INTERVAL\n    1078 \t\t\t&& p->identifier != MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    1080 \t\treturn NULL;\n    1081 \t}\n    1083 \tif(value) *value = p->value.i32;\n    1086 }\nFunction: handle__connack\nPath: /root/projects/mosquitto/src/handle_connack.c:31\n    31   int handle__connack(struct mosquitto *context)\n    32   {\n    35   \tuint8_t reason_code;\n    36   \tmosquitto_property *properties = NULL;\n    37   \tuint32_t maximum_packet_size;\n    38   \tuint8_t retain_available;\n    39   \tuint16_t server_keepalive;\n    40   \tuint16_t inflight_maximum;\n    41   \tuint8_t max_qos = 255;\n    49   \tif(context->in_packet.command != CMD_CONNACK){\n    50   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    51   \t}\n    54   \tif(packet__read_byte(&context->in_packet, &reason_code)) return MOSQ_ERR_MALFORMED_PACKET;\n    56   \tif(context->protocol == mosq_p_mqtt5){\n    57   \t\tif(context->in_packet.remaining_length == 2 && reason_code == CONNACK_REFUSED_PROTOCOL_VERSION){\n    67   \t\t\treturn MOSQ_ERR_PROTOCOL;\n    68   \t\t}\n    70   \t\trc = property__read_all(CMD_CONNACK, &context->in_packet, &properties);\n    71   \t\tif(rc) return rc;\n    74   \t\tmosquitto_property_read_byte(properties, MQTT_PROP_MAXIMUM_QOS,\n    78   \t\tif(mosquitto_property_read_int32(properties, MQTT_PROP_MAXIMUM_PACKET_SIZE,\n    79   \t\t\t\t\t&maximum_packet_size, false)){\n    81   \t\t\tif(context->maximum_packet_size == 0 || context->maximum_packet_size > maximum_packet_size){\n    82   \t\t\t\tcontext->maximum_packet_size = maximum_packet_size;\n    83   \t\t\t}\n    84   \t\t}\n    87   \t\tinflight_maximum = context->msgs_out.inflight_maximum;\n    88   \t\tmosquitto_property_read_int16(properties, MQTT_PROP_RECEIVE_MAXIMUM, &inflight_maximum, false);\n    89   \t\tif(context->msgs_out.inflight_maximum != inflight_maximum){\n    90   \t\t\tcontext->msgs_out.inflight_maximum = inflight_maximum;\n    91   \t\t\tdb__message_reconnect_reset(context);\n    92   \t\t}\n    95   \t\tif(mosquitto_property_read_byte(properties, MQTT_PROP_RETAIN_AVAILABLE,\n    96   \t\t\t\t\t&retain_available, false)){\n    99   \t\t\tif(context->retain_available){\n    100  \t\t\t\tcontext->retain_available = retain_available;\n    101  \t\t\t}\n    102  \t\t}\n    105  \t\tif(mosquitto_property_read_int16(properties, MQTT_PROP_SERVER_KEEP_ALIVE,\n    106  \t\t\t\t\t&server_keepalive, false)){\n    108  \t\t\tcontext->keepalive = server_keepalive;\n    109  \t\t}\n    111  \t\tmosquitto_property_free_all(&properties);\n    112  \t}\n    113  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    115  \tif(reason_code == MQTT_RC_SUCCESS){\n    117  \t\tif(context->bridge){\n    118  \t\t\trc = bridge__on_connect(context);\n    119  \t\t\tif(rc) return rc;\n    120  \t\t}\n    122  \t\tif(max_qos != 255){\n    123  \t\t\tcontext->max_qos = max_qos;\n    124  \t\t}\n    127  \t\tif(rc) return rc;\n    129  \t\treturn rc;\n    130  \t}else{\n    131  \t\tif(context->protocol == mosq_p_mqtt5){\n    132  \t\t\tswitch(reason_code){\n    133  \t\t\t\tcase MQTT_RC_RETAIN_NOT_SUPPORTED:\n    134  \t\t\t\t\tcontext->retain_available = 0;\n    136  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    137  \t\t\t\tcase MQTT_RC_QOS_NOT_SUPPORTED:\n    138  \t\t\t\t\tif(max_qos == 255){\n    139  \t\t\t\t\t\tif(context->max_qos != 0){\n    140  \t\t\t\t\t\t\tcontext->max_qos--;\n    141  \t\t\t\t\t\t}\n    142  \t\t\t\t\t}else{\n    143  \t\t\t\t\t\tcontext->max_qos = max_qos;\n    144  \t\t\t\t\t}\n    146  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    147  \t\t\t\tdefault:\n    148  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Connection Refused: %s\", mosquitto_reason_string(reason_code));\n    149  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    150  \t\t\t}\n    151  \t\t}else{\n    152  \t\t\tswitch(reason_code){\n    158  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    161  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    164  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    167  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    170  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    173  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    174  \t\t\t}\n    175  \t\t}\n    176  \t}\n    178  }\nFunction: mosquitto_property_read_byte\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1024\n    1024 const mosquitto_property *mosquitto_property_read_byte(const mosquitto_property *proplist, int identifier, uint8_t *value, bool skip_first)\n    1025 {\n    1027 \tif(!proplist) return NULL;\n    1029 \tp = property__get_property(proplist, identifier, skip_first);\n    1030 \tif(!p) return NULL;\n    1031 \tif(p->identifier != MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    1032 \t\t\t&& p->identifier != MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    1033 \t\t\t&& p->identifier != MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    1034 \t\t\t&& p->identifier != MQTT_PROP_MAXIMUM_QOS\n    1035 \t\t\t&& p->identifier != MQTT_PROP_RETAIN_AVAILABLE\n    1036 \t\t\t&& p->identifier != MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    1037 \t\t\t&& p->identifier != MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    1038 \t\t\t&& p->identifier != MQTT_PROP_SHARED_SUB_AVAILABLE){\n    1039 \t\treturn NULL;\n    1040 \t}\n    1042 \tif(value) *value = p->value.i8;\n    1045 }\nFunction: property__get_property\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:988\n    988  static const mosquitto_property *property__get_property(const mosquitto_property *proplist, int identifier, bool skip_first)\n    989  {\n    990  \tconst mosquitto_property *p;\n    995  \twhile(p){\n    996  \t\tif(p->identifier == identifier){\n    997  \t\t\tif(!is_first || !skip_first){\n    998  \t\t\t\treturn p;\n    999  \t\t\t}\n    1001 \t\t}\n    1002 \t\tp = p->next;\n    1003 \t}\n    1005 }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\n",
    "Including Maximum QoS more than once, or having a value other than 0 or 1, is a Protocol Error.": "Function: bridge__on_connect\nPath: /root/projects/mosquitto/src/bridge.c:488\n    488  int bridge__on_connect(struct mosquitto *context)\n    489  {\n    490  \tint i;\n    494  \tint sub_opts;\n    496  \tuint8_t qos;\n    498  \tif(context->bridge->notifications){\n    499  \t\tif(context->max_qos == 0){\n    500  \t\t\tqos = 0;\n    501  \t\t}else{\n    502  \t\t\tqos = 1;\n    503  \t\t}\n    504  \t\tif(!context->retain_available){\n    506  \t\t}\n    508  \t\tif(context->bridge->notification_topic){\n    509  \t\t\tif(!context->bridge->notifications_local_only){\n    511  \t\t\t\t\t\tcontext->bridge->notification_topic, 1, &notification_payload, qos, retain, 0, NULL, NULL, 0)){\n    513  \t\t\t\t\treturn 1;\n    514  \t\t\t\t}\n    515  \t\t\t}\n    517  \t\t}else{\n    520  \t\t\tif(!notification_topic) return MOSQ_ERR_NOMEM;\n    524  \t\t\tif(!context->bridge->notifications_local_only){\n    526  \t\t\t\t\t\tnotification_topic, 1, &notification_payload, qos, retain, 0, NULL, NULL, 0)){\n    529  \t\t\t\t\treturn 1;\n    530  \t\t\t\t}\n    531  \t\t\t}\n    534  \t\t}\n    535  \t}\n    536  \tfor(i=0; i<context->bridge->topic_count; i++){\n    537  \t\tif(context->bridge->topics[i].direction == bd_in || context->bridge->topics[i].direction == bd_both){\n    538  \t\t\tif(context->bridge->topics[i].qos > context->max_qos){\n    539  \t\t\t\tsub_opts = context->max_qos;\n    540  \t\t\t}else{\n    541  \t\t\t\tsub_opts = context->bridge->topics[i].qos;\n    542  \t\t\t}\n    543  \t\t\tif(context->bridge->protocol_version == mosq_p_mqtt5){\n    545  \t\t\t\t\t| MQTT_SUB_OPT_NO_LOCAL\n    546  \t\t\t\t\t| MQTT_SUB_OPT_RETAIN_AS_PUBLISHED\n    547  \t\t\t\t\t| MQTT_SUB_OPT_SEND_RETAIN_ALWAYS;\n    548  \t\t\t}\n    549  \t\t\tif(send__subscribe(context, NULL, 1, &context->bridge->topics[i].remote_topic, sub_opts, NULL)){\n    550  \t\t\t\treturn 1;\n    551  \t\t\t}\n    552  \t\t}else{\n    553  \t\t\tif(context->bridge->attempt_unsubscribe){\n    554  \t\t\t\tif(send__unsubscribe(context, NULL, 1, &context->bridge->topics[i].remote_topic, NULL)){\n    558  \t\t\t\t\treturn 1;\n    559  \t\t\t\t}\n    560  \t\t\t}\n    561  \t\t}\n    562  \t}\n    563  \tfor(i=0; i<context->bridge->topic_count; i++){\n    564  \t\tif(context->bridge->topics[i].direction == bd_out || context->bridge->topics[i].direction == bd_both){\n    565  \t\t\tif(context->bridge->topics[i].qos > context->max_qos){\n    566  \t\t\t\tqos = context->max_qos;\n    567  \t\t\t}else{\n    568  \t\t\t\tqos = context->bridge->topics[i].qos;\n    569  \t\t\t}\n    570  \t\t\tretain__queue(context,\n    571  \t\t\t\t\tcontext->bridge->topics[i].local_topic,\n    573  \t\t}\n    574  \t}\n    579  }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    94   \tpacket->command = 0;\n    102  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mo",
    "Including the Shared Subscription Available more than once or sending a value other than 0 or 1 is a Protocol Error.": "Function: bridge__on_connect\nPath: /root/projects/mosquitto/src/bridge.c:488\n    488  int bridge__on_connect(struct mosquitto *context)\n    489  {\n    490  \tint i;\n    494  \tint sub_opts;\n    496  \tuint8_t qos;\n    498  \tif(context->bridge->notifications){\n    499  \t\tif(context->max_qos == 0){\n    501  \t\t}else{\n    504  \t\tif(!context->retain_available){\n    506  \t\t}\n    508  \t\tif(context->bridge->notification_topic){\n    509  \t\t\tif(!context->bridge->notifications_local_only){\n    511  \t\t\t\t\t\tcontext->bridge->notification_topic, 1, &notification_payload, qos, retain, 0, NULL, NULL, 0)){\n    513  \t\t\t\t\treturn 1;\n    514  \t\t\t\t}\n    515  \t\t\t}\n    517  \t\t}else{\n    520  \t\t\tif(!notification_topic) return MOSQ_ERR_NOMEM;\n    524  \t\t\tif(!context->bridge->notifications_local_only){\n    526  \t\t\t\t\t\tnotification_topic, 1, &notification_payload, qos, retain, 0, NULL, NULL, 0)){\n    529  \t\t\t\t\treturn 1;\n    530  \t\t\t\t}\n    531  \t\t\t}\n    534  \t\t}\n    535  \t}\n    536  \tfor(i=0; i<context->bridge->topic_count; i++){\n    537  \t\tif(context->bridge->topics[i].direction == bd_in || context->bridge->topics[i].direction == bd_both){\n    538  \t\t\tif(context->bridge->topics[i].qos > context->max_qos){\n    539  \t\t\t\tsub_opts = context->max_qos;\n    540  \t\t\t}else{\n    541  \t\t\t\tsub_opts = context->bridge->topics[i].qos;\n    542  \t\t\t}\n    543  \t\t\tif(context->bridge->protocol_version == mosq_p_mqtt5){\n    545  \t\t\t\t\t| MQTT_SUB_OPT_NO_LOCAL\n    546  \t\t\t\t\t| MQTT_SUB_OPT_RETAIN_AS_PUBLISHED\n    547  \t\t\t\t\t| MQTT_SUB_OPT_SEND_RETAIN_ALWAYS;\n    548  \t\t\t}\n    549  \t\t\tif(send__subscribe(context, NULL, 1, &context->bridge->topics[i].remote_topic, sub_opts, NULL)){\n    550  \t\t\t\treturn 1;\n    551  \t\t\t}\n    552  \t\t}else{\n    553  \t\t\tif(context->bridge->attempt_unsubscribe){\n    554  \t\t\t\tif(send__unsubscribe(context, NULL, 1, &context->bridge->topics[i].remote_topic, NULL)){\n    558  \t\t\t\t\treturn 1;\n    559  \t\t\t\t}\n    560  \t\t\t}\n    561  \t\t}\n    562  \t}\n    563  \tfor(i=0; i<context->bridge->topic_count; i++){\n    564  \t\tif(context->bridge->topics[i].direction == bd_out || context->bridge->topics[i].direction == bd_both){\n    565  \t\t\tif(context->bridge->topics[i].qos > context->max_qos){\n    566  \t\t\t\tqos = context->max_qos;\n    567  \t\t\t}else{\n    568  \t\t\t\tqos = context->bridge->topics[i].qos;\n    569  \t\t\t}\n    570  \t\t\tretain__queue(context,\n    571  \t\t\t\t\tcontext->bridge->topics[i].local_topic,\n    573  \t\t}\n    574  \t}\n    579  }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    94   \tpacket->command = 0;\n    102  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    353  }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    239  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: mosquitto_property_read_int16\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1048\n    1048 const mosquitto_property *mosquitto_property_read_int16(const mosquitto_property *proplist, int identifier, uint16_t *value, bool skip_first)\n    1049 {\n    1051 \tif(!proplist) return NULL;\n    1053 \tp = property__get_property(proplist, identifier, skip_first);\n    1054 \tif(!p) return NULL;\n    1055 \tif(p->identifier != MQTT_PROP_SERVER_KEEP_ALIVE\n    1056 \t\t\t&& p->identifier != MQTT_PROP_RECEIVE_MAXIMUM\n    1057 \t\t\t&& p->identifier != MQTT_PROP_TOPIC_ALIAS_MAXIMUM\n    1058 \t\t\t&& p->identifier != MQTT_PROP_TOPIC_ALIAS){\n    1059 \t\treturn NULL;\n    1060 \t}\n    1062 \tif(value) *value = p->value.i16;\n    1065 }\nFunction: mosquitto_property_read_int32\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1068\n    1068 const mosquitto_property *mosquitto_property_read_int32(const mosquitto_property *proplist, int identifier, uint32_t *value, bool skip_first)\n    1069 {\n    1071 \tif(!proplist) return NULL;\n    1073 \tp = property__get_property(proplist, identifier, skip_first);\n    1074 \tif(!p) return NULL;\n    1075 \tif(p->identifier != MQTT_PROP_MESSAGE_EXPIRY_INTERVAL\n    1076 \t\t\t&& p->identifier != MQTT_PROP_SESSION_EXPIRY_INTERVAL\n    1077 \t\t\t&& p->identifier != MQTT_PROP_WILL_DELAY_INTERVAL\n    1078 \t\t\t&& p->identifier != MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    1080 \t\treturn NULL;\n    1081 \t}\n    1083 \tif(value) *value = p->value.i32;\n    1086 }\nFunction: handle__connack\nPath: /root/projects/mosquitto/src/handle_connack.c:31\n    31   int handle__connack(struct mosquitto *context)\n    32   {\n    35   \tuint8_t reason_code;\n    36   \tmosquitto_property *properties = NULL;\n    37   \tuint32_t maximum_packet_size;\n    38   \tuint8_t retain_available;\n    39   \tuint16_t server_keepalive;\n    40   \tuint16_t inflight_maximum;\n    41   \tuint8_t max_qos = 255;\n    49   \tif(context->in_packet.command != CMD_CONNACK){\n    50   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    51   \t}\n    54   \tif(packet__read_byte(&context->in_packet, &reason_code)) return MOSQ_ERR_MALFORMED_PACKET;\n    56   \tif(context->protocol == mosq_p_mqtt5){\n    57   \t\tif(context->in_packet.remaining_length == 2 && reason_code == CONNACK_REFUSED_PROTOCOL_VERSION){\n    67   \t\t\treturn MOSQ_ERR_PROTOCOL;\n    68   \t\t}\n    70   \t\trc = property__read_all(CMD_CONNACK, &context->in_packet, &properties);\n    71   \t\tif(rc) return rc;\n    74   \t\tmosquitto_property_read_byte(properties, MQTT_PROP_MAXIMUM_QOS,\n    78   \t\tif(mosquitto_property_read_int32(properties, MQTT_PROP_MAXIMUM_PACKET_SIZE,\n    79   \t\t\t\t\t&maximum_packet_size, false)){\n    81   \t\t\tif(context->maximum_packet_size == 0 || context->maximum_packet_size > maximum_packet_size){\n    82   \t\t\t\tcontext->maximum_packet_size = maximum_packet_size;\n    83   \t\t\t}\n    84   \t\t}\n    87   \t\tinflight_maximum = context->msgs_out.inflight_maximum;\n    88   \t\tmosquitto_property_read_int16(properties, MQTT_PROP_RECEIVE_MAXIMUM, &inflight_maximum, false);\n    89   \t\tif(context->msgs_out.inflight_maximum != inflight_maximum){\n    90   \t\t\tcontext->msgs_out.inflight_maximum = inflight_maximum;\n    91   \t\t\tdb__message_reconnect_reset(context);\n    92   \t\t}\n    95   \t\tif(mosquitto_property_read_byte(properties, MQTT_PROP_RETAIN_AVAILABLE,\n    96   \t\t\t\t\t&retain_available, false)){\n    99   \t\t\tif(context->retain_available){\n    100  \t\t\t\tcontext->retain_available = retain_available;\n    101  \t\t\t}\n    102  \t\t}\n    105  \t\tif(mosquitto_property_read_int16(properties, MQTT_PROP_SERVER_KEEP_ALIVE,\n    106  \t\t\t\t\t&server_keepalive, false)){\n    108  \t\t\tcontext->keepalive = server_keepalive;\n    109  \t\t}\n    111  \t\tmosquitto_property_free_all(&properties);\n    112  \t}\n    113  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    115  \tif(reason_code == MQTT_RC_SUCCESS){\n    117  \t\tif(context->bridge){\n    118  \t\t\trc = bridge__on_connect(context);\n    119  \t\t\tif(rc) return rc;\n    120  \t\t}\n    122  \t\tif(max_qos != 255){\n    123  \t\t\tcontext->max_qos = max_qos;\n    124  \t\t}\n    127  \t\tif(rc) return rc;\n    129  \t\treturn rc;\n    130  \t}else{\n    131  \t\tif(context->protocol == mosq_p_mqtt5){\n    132  \t\t\tswitch(reason_code){\n    133  \t\t\t\tcase MQTT_RC_RETAIN_NOT_SUPPORTED:\n    134  \t\t\t\t\tcontext->retain_available = 0;\n    136  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    137  \t\t\t\tcase MQTT_RC_QOS_NOT_SUPPORTED:\n    138  \t\t\t\t\tif(max_qos == 255){\n    139  \t\t\t\t\t\tif(context->max_qos != 0){\n    140  \t\t\t\t\t\t\tcontext->max_qos--;\n    141  \t\t\t\t\t\t}\n    142  \t\t\t\t\t}else{\n    143  \t\t\t\t\t\tcontext->max_qos = max_qos;\n    144  \t\t\t\t\t}\n    146  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    147  \t\t\t\tdefault:\n    148  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Connection Refused: %s\", mosquitto_reason_string(reason_code));\n    149  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    150  \t\t\t}\n    151  \t\t}else{\n    152  \t\t\tswitch(reason_code){\n    158  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    161  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    164  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    167  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    170  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    173  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    174  \t\t\t}\n    175  \t\t}\n    176  \t}\n    178  }\nFunction: mosquitto_property_read_byte\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1024\n    1024 const mosquitto_property *mosquitto_property_read_byte(const mosquitto_property *proplist, int identifier, uint8_t *value, bool skip_first)\n    1025 {\n    1027 \tif(!proplist) return NULL;\n    1029 \tp = property__get_property(proplist, identifier, skip_first);\n    1030 \tif(!p) return NULL;\n    1031 \tif(p->identifier != MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    1032 \t\t\t&& p->identifier != MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    1033 \t\t\t&& p->identifier != MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    1034 \t\t\t&& p->identifier != MQTT_PROP_MAXIMUM_QOS\n    1035 \t\t\t&& p->identifier != MQTT_PROP_RETAIN_AVAILABLE\n    1036 \t\t\t&& p->identifier != MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    1037 \t\t\t&& p->identifier != MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    1038 \t\t\t&& p->identifier != MQTT_PROP_SHARED_SUB_AVAILABLE){\n    1039 \t\treturn NULL;\n    1040 \t}\n    1042 \tif(value) *value = p->value.i8;\n    1045 }\nFunction: property__get_property\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:988\n    988  static const mosquitto_property *property__get_property(const mosquitto_property *proplist, int identifier, bool skip_first)\n    989  {\n    990  \tconst mosquitto_property *p;\n    995  \twhile(p){\n    996  \t\tif(p->identifier == identifier){\n    997  \t\t\tif(!is_first || !skip_first){\n    998  \t\t\t\treturn p;\n    999  \t\t\t}\n    1001 \t\t}\n    1002 \t\tp = p->next;\n    1003 \t}\n    1005 }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\n",
    "Including the Server Reference more than once is a Protocol Error.": "Function: bridge__on_connect\nPath: /root/projects/mosquitto/src/bridge.c:488\n    488  int bridge__on_connect(struct mosquitto *context)\n    489  {\n    490  \tint i;\n    494  \tint sub_opts;\n    496  \tuint8_t qos;\n    498  \tif(context->bridge->notifications){\n    499  \t\tif(context->max_qos == 0){\n    501  \t\t}else{\n    504  \t\tif(!context->retain_available){\n    506  \t\t}\n    508  \t\tif(context->bridge->notification_topic){\n    509  \t\t\tif(!context->bridge->notifications_local_only){\n    511  \t\t\t\t\t\tcontext->bridge->notification_topic, 1, &notification_payload, qos, retain, 0, NULL, NULL, 0)){\n    513  \t\t\t\t\treturn 1;\n    514  \t\t\t\t}\n    515  \t\t\t}\n    517  \t\t}else{\n    520  \t\t\tif(!notification_topic) return MOSQ_ERR_NOMEM;\n    524  \t\t\tif(!context->bridge->notifications_local_only){\n    526  \t\t\t\t\t\tnotification_topic, 1, &notification_payload, qos, retain, 0, NULL, NULL, 0)){\n    529  \t\t\t\t\treturn 1;\n    530  \t\t\t\t}\n    531  \t\t\t}\n    534  \t\t}\n    535  \t}\n    536  \tfor(i=0; i<context->bridge->topic_count; i++){\n    537  \t\tif(context->bridge->topics[i].direction == bd_in || context->bridge->topics[i].direction == bd_both){\n    538  \t\t\tif(context->bridge->topics[i].qos > context->max_qos){\n    539  \t\t\t\tsub_opts = context->max_qos;\n    540  \t\t\t}else{\n    541  \t\t\t\tsub_opts = context->bridge->topics[i].qos;\n    542  \t\t\t}\n    543  \t\t\tif(context->bridge->protocol_version == mosq_p_mqtt5){\n    545  \t\t\t\t\t| MQTT_SUB_OPT_NO_LOCAL\n    546  \t\t\t\t\t| MQTT_SUB_OPT_RETAIN_AS_PUBLISHED\n    547  \t\t\t\t\t| MQTT_SUB_OPT_SEND_RETAIN_ALWAYS;\n    548  \t\t\t}\n    549  \t\t\tif(send__subscribe(context, NULL, 1, &context->bridge->topics[i].remote_topic, sub_opts, NULL)){\n    550  \t\t\t\treturn 1;\n    551  \t\t\t}\n    552  \t\t}else{\n    553  \t\t\tif(context->bridge->attempt_unsubscribe){\n    554  \t\t\t\tif(send__unsubscribe(context, NULL, 1, &context->bridge->topics[i].remote_topic, NULL)){\n    558  \t\t\t\t\treturn 1;\n    559  \t\t\t\t}\n    560  \t\t\t}\n    561  \t\t}\n    562  \t}\n    563  \tfor(i=0; i<context->bridge->topic_count; i++){\n    564  \t\tif(context->bridge->topics[i].direction == bd_out || context->bridge->topics[i].direction == bd_both){\n    565  \t\t\tif(context->bridge->topics[i].qos > context->max_qos){\n    566  \t\t\t\tqos = context->max_qos;\n    567  \t\t\t}else{\n    568  \t\t\t\tqos = context->bridge->topics[i].qos;\n    569  \t\t\t}\n    570  \t\t\tretain__queue(context,\n    571  \t\t\t\t\tcontext->bridge->topics[i].local_topic,\n    573  \t\t}\n    574  \t}\n    579  }\nFunction: packet__read_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:178\n    178  int packet__read_uint32(struct mosquitto__packet *packet, uint32_t *word)\n    179  {\n    184  \tif(packet->pos+4 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    194  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    94   \tpacket->command = 0;\n    97   \tpacket->remaining_length = 0;\n    102  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    353  }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: mosquitto_property_read_int16\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1048\n    1048 const mosquitto_property *mosquitto_property_read_int16(const mosquitto_property *proplist, int identifier, uint16_t *value, bool skip_first)\n    1049 {\n    1051 \tif(!proplist) return NULL;\n    1053 \tp = property__get_property(proplist, identifier, skip_first);\n    1054 \tif(!p) return NULL;\n    1055 \tif(p->identifier != MQTT_PROP_SERVER_KEEP_ALIVE\n    1056 \t\t\t&& p->identifier != MQTT_PROP_RECEIVE_MAXIMUM\n    1057 \t\t\t&& p->identifier != MQTT_PROP_TOPIC_ALIAS_MAXIMUM\n    1058 \t\t\t&& p->identifier != MQTT_PROP_TOPIC_ALIAS){\n    1059 \t\treturn NULL;\n    1060 \t}\n    1062 \tif(value) *value = p->value.i16;\n    1065 }\nFunction: mosquitto_property_read_int32\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1068\n    1068 const mosquitto_property *mosquitto_property_read_int32(const mosquitto_property *proplist, int identifier, uint32_t *value, bool skip_first)\n    1069 {\n    1071 \tif(!proplist) return NULL;\n    1073 \tp = property__get_property(proplist, identifier, skip_first);\n    1074 \tif(!p) return NULL;\n    1075 \tif(p->identifier != MQTT_PROP_MESSAGE_EXPIRY_INTERVAL\n    1076 \t\t\t&& p->identifier != MQTT_PROP_SESSION_EXPIRY_INTERVAL\n    1077 \t\t\t&& p->identifier != MQTT_PROP_WILL_DELAY_INTERVAL\n    1078 \t\t\t&& p->identifier != MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    1080 \t\treturn NULL;\n    1081 \t}\n    1083 \tif(value) *value = p->value.i32;\n    1086 }\nFunction: handle__connack\nPath: /root/projects/mosquitto/src/handle_connack.c:31\n    31   int handle__connack(struct mosquitto *context)\n    32   {\n    35   \tuint8_t reason_code;\n    36   \tmosquitto_property *properties = NULL;\n    37   \tuint32_t maximum_packet_size;\n    38   \tuint8_t retain_available;\n    39   \tuint16_t server_keepalive;\n    40   \tuint16_t inflight_maximum;\n    41   \tuint8_t max_qos = 255;\n    49   \tif(context->in_packet.command != CMD_CONNACK){\n    50   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    51   \t}\n    54   \tif(packet__read_byte(&context->in_packet, &reason_code)) return MOSQ_ERR_MALFORMED_PACKET;\n    56   \tif(context->protocol == mosq_p_mqtt5){\n    57   \t\tif(context->in_packet.remaining_length == 2 && reason_code == CONNACK_REFUSED_PROTOCOL_VERSION){\n    67   \t\t\treturn MOSQ_ERR_PROTOCOL;\n    68   \t\t}\n    70   \t\trc = property__read_all(CMD_CONNACK, &context->in_packet, &properties);\n    71   \t\tif(rc) return rc;\n    74   \t\tmosquitto_property_read_byte(properties, MQTT_PROP_MAXIMUM_QOS,\n    78   \t\tif(mosquitto_property_read_int32(properties, MQTT_PROP_MAXIMUM_PACKET_SIZE,\n    79   \t\t\t\t\t&maximum_packet_size, false)){\n    81   \t\t\tif(context->maximum_packet_size == 0 || context->maximum_packet_size > maximum_packet_size){\n    82   \t\t\t\tcontext->maximum_packet_size = maximum_packet_size;\n    83   \t\t\t}\n    84   \t\t}\n    87   \t\tinflight_maximum = context->msgs_out.inflight_maximum;\n    88   \t\tmosquitto_property_read_int16(properties, MQTT_PROP_RECEIVE_MAXIMUM, &inflight_maximum, false);\n    89   \t\tif(context->msgs_out.inflight_maximum != inflight_maximum){\n    90   \t\t\tcontext->msgs_out.inflight_maximum = inflight_maximum;\n    91   \t\t\tdb__message_reconnect_reset(context);\n    92   \t\t}\n    95   \t\tif(mosquitto_property_read_byte(properties, MQTT_PROP_RETAIN_AVAILABLE,\n    96   \t\t\t\t\t&retain_available, false)){\n    99   \t\t\tif(context->retain_available){\n    100  \t\t\t\tcontext->retain_available = retain_available;\n    101  \t\t\t}\n    102  \t\t}\n    105  \t\tif(mosquitto_property_read_int16(properties, MQTT_PROP_SERVER_KEEP_ALIVE,\n    106  \t\t\t\t\t&server_keepalive, false)){\n    108  \t\t\tcontext->keepalive = server_keepalive;\n    109  \t\t}\n    111  \t\tmosquitto_property_free_all(&properties);\n    112  \t}\n    113  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    115  \tif(reason_code == MQTT_RC_SUCCESS){\n    117  \t\tif(context->bridge){\n    118  \t\t\trc = bridge__on_connect(context);\n    119  \t\t\tif(rc) return rc;\n    120  \t\t}\n    122  \t\tif(max_qos != 255){\n    123  \t\t\tcontext->max_qos = max_qos;\n    124  \t\t}\n    127  \t\tif(rc) return rc;\n    129  \t\treturn rc;\n    130  \t}else{\n    131  \t\tif(context->protocol == mosq_p_mqtt5){\n    132  \t\t\tswitch(reason_code){\n    133  \t\t\t\tcase MQTT_RC_RETAIN_NOT_SUPPORTED:\n    134  \t\t\t\t\tcontext->retain_available = 0;\n    136  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    137  \t\t\t\tcase MQTT_RC_QOS_NOT_SUPPORTED:\n    138  \t\t\t\t\tif(max_qos == 255){\n    139  \t\t\t\t\t\tif(context->max_qos != 0){\n    140  \t\t\t\t\t\t\tcontext->max_qos--;\n    141  \t\t\t\t\t\t}\n    142  \t\t\t\t\t}else{\n    143  \t\t\t\t\t\tcontext->max_qos = max_qos;\n    144  \t\t\t\t\t}\n    146  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    147  \t\t\t\tdefault:\n    148  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Connection Refused: %s\", mosquitto_reason_string(reason_code));\n    149  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    150  \t\t\t}\n    151  \t\t}else{\n    152  \t\t\tswitch(reason_code){\n    158  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    161  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    164  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    167  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    170  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    173  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    174  \t\t\t}\n    175  \t\t}\n    176  \t}\n    178  }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    633  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    58   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    168  }\nFunction: mosquitto_property_read_byte\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1024\n    1024 const mosquitto_property *mosquitto_property_read_byte(const mosquitto_property *proplist, int identifier, uint8_t *value, bool skip_first)\n    1025 {\n    1027 \tif(!proplist) return NULL;\n    1029 \tp = property__get_property(proplist, identifier, skip_first);\n    1030 \tif(!p) return NULL;\n    1031 \tif(p->identifier != MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    1032 \t\t\t&& p->identifier != MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    1033 \t\t\t&& p->identifier != MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    1034 \t\t\t&& p->identifier != MQTT_PROP_MAXIMUM_QOS\n    1035 \t\t\t&& p->identifier != MQTT_PROP_RETAIN_AVAILABLE\n    1036 \t\t\t&& p->identifier != MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    1037 \t\t\t&& p->identifier != MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    1038 \t\t\t&& p->identifier != MQTT_PROP_SHARED_SUB_AVAILABLE){\n    1039 \t\treturn NULL;\n    1040 \t}\n    1042 \tif(value) *value = p->value.i8;\n    1045 }\nFunction: property__get_property\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:988\n    988  static const mosquitto_property *property__get_property(const mosquitto_property *proplist, int identifier, bool skip_first)\n    989  {\n    990  \tconst mosquitto_property *p;\n    995  \twhile(p){\n    996  \t\tif(p->identifier == identifier){\n    997  \t\t\tif(!is_first || !skip_first){\n    998  \t\t\t\treturn p;\n    999  \t\t\t}\n    1001 \t\t}\n    1002 \t\tp = p->next;\n    1003 \t}\n    1005 }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\n",
    "The Server MUST validate that the reserved flag in the CONNECT packet is set to 0 [MQTT-3.1.2-3].": "Function: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    94   \tpacket->command = 0;\n    97   \tpacket->remaining_length = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    150  \tpacket->pos = 0;\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    345  \t}\n    353  }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    138  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    205  \t\tfound_context->clean_start = true;\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    211  \t\t}\n    213  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    247  \t\t} else {\n    250  \t}\n    263  \tif(!context->clean_start){\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    330  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    502  \t\tcontext->protocol = mosq_p_mqtt31;\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    508  \t\t\tcontext->protocol = mosq_p_mqtt311;\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    514  \t\t\tcontext->protocol = mosq_p_mqtt5;\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    525  \t\t\t/* Reserved flags not set to 0, must disconnect. */\n    526  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    557  \t}else{\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    627  \t\t\t\t}else{\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    652  \t\t\t}else{\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    732  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    744  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    756  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    766  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    777  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    789  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    804  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    814  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    824  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    880  \t\t\t}else{\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    937  \t\t\t\t\t}else{\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    976  \tcontext->clean_start = true;\n    980  }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    350  \t\tif(rc) goto error_cleanup;\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    394  \t\t\t}else{\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    410  \twill_struct->msg.qos = will_qos;\n    424  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: send__auth\nPath: /root/projects/mosquitto/src/send_auth.c:28\n    28   int send__auth(struct mosquitto *context, uint8_t reason_code, const void *auth_data, uint16_t auth_data_len)\n    29   {\n    36   \tif(context->protocol != mosq_p_mqtt5) return MOSQ_ERR_PROTOCOL;\n    81   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    51   \t\t\tif(rc){\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    58   \t\t\tif(rc){\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    65   \t\t\tif(rc){\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    72   \t\t\tif(rc){\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    79   \t}\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    105  \t}\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    66   \t}else{\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    80   \t}\n    83   }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    144  \t}\n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    161  \t}\n    164  }\nFunction: send__real_publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:137\n    137  int send__real_publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    138  {\n    153  \tif(mosq->protocol == mosq_p_mqtt5){\n    175  \t}\n    206  \tif(mosq->protocol == mosq_p_mqtt5){\n    213  \t}\n    221  }\n",
    "If a CONNECT packet is received with Clean Start set to 1, the Client and Server MUST discard any existing Session and start a new Session [MQTT-3.1.2-4].": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    209  \t\t}\n    210  \t}\n    212  }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    205  \t\tfound_context->clean_start = true;\n    213  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    247  \t\t} else {\n    250  \t}\n    263  \tif(!context->clean_start){\n    330  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    553  \t/* session_expiry_interval will be overriden if the properties are read later */\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    555  \t\t/* v3* has clean_start == false mean the session never expires */\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgo",
    "If the Will Flag is set to 0, then Will Retain MUST be set to 0 [MQTT-3.1.2-13].": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    221  \tplugin__handle_disconnect(context, -1);\n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    226  \tif(context->bridge == NULL)\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    232  \t\t\tif(context->will_delay_interval == 0){\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    147  \tassert(mosq);\n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    153  \tpacket->next = NULL;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    187  \treturn packet__write(mosq);\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    353  }\nFunction: property__process_connect\nPath: /root/projects/mosquitto/src/property_broker.c:30\n    30   int property__process_connect(struct mosquitto *context, mosquitto_property **props)\n    31   {\n    32   \tmosquitto_property *p;\n    34   \tp = *props;\n    36   \twhile(p){\n    37   \t\tif(p->identifier == MQTT_PROP_SESSION_EXPIRY_INTERVAL){\n    38   \t\t\tcontext->session_expiry_interval = p->value.i32;\n    39   \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM){\n    40   \t\t\tif(p->value.i16 == 0){\n    41   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    42   \t\t\t}\n    44   \t\t\tcontext->msgs_out.inflight_maximum = p->value.i16;\n    45   \t\t\tcontext->msgs_out.inflight_quota = context->msgs_out.inflight_maximum;\n    46   \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    47   \t\t\tif(p->value.i32 == 0){\n    48   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    49   \t\t\t}\n    50   \t\t\tcontext->maximum_packet_size = p->value.i32;\n    51   \t\t}\n    52   \t\tp = p->next;\n    53   \t}\n    56   }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__read\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:35\n    35   static int property__read(struct mosquitto__packet *packet, uint32_t *len, mosquitto_property *property)\n    36   {\n    38   \tuint32_t property_identifier;\n    39   \tuint8_t byte;\n    40   \tuint8_t byte_count;\n    41   \tuint16_t uint16;\n    42   \tuint32_t uint32;\n    43   \tuint32_t varint;\n    44   \tchar *str1, *str2;\n    45   \tuint16_t slen1, slen2;\n    47   \tif(!property) return MOSQ_ERR_INVAL;\n    49   \trc = packet__read_varint(packet, &property_identifier, NULL);\n    50   \tif(rc){\n    51   \t\treturn rc;\n    52   \t}\n    55   \tmemset(property, 0, sizeof(mosquitto_property));\n    57   \tproperty->identifier = (int32_t)property_identifier;\n    59   \tswitch(property_identifier){\n    60   \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    61   \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    62   \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    63   \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    64   \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    65   \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    66   \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    67   \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    68   \t\t\trc = packet__read_byte(packet, &byte);\n    69   \t\t\tif(rc) return rc;\n    71   \t\t\tproperty->value.i8 = byte;\n    72   \t\t\tbreak;\n    74   \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    75   \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    76   \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    77   \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    78   \t\t\trc = packet__read_uint16(packet, &uint16);\n    79   \t\t\tif(rc) return rc;\n    81   \t\t\tproperty->value.i16 = uint16;\n    82   \t\t\tbreak;\n    84   \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    85   \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    86   \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    87   \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    88   \t\t\trc = packet__read_uint32(packet, &uint32);\n    89   \t\t\tif(rc) return rc;\n    91   \t\t\tproperty->value.i32 = uint32;\n    92   \t\t\tbreak;\n    94   \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    95   \t\t\trc = packet__read_varint(packet, &varint, &byte_count);\n    96   \t\t\tif(rc) return rc;\n    98   \t\t\tproperty->value.varint = varint;\n    99   \t\t\tbreak;\n    101  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    102  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    103  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    104  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    105  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    106  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    107  \t\tcase MQTT_PROP_REASON_STRING:\n    108  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    109  \t\t\tif(rc) return rc;\n    111  \t\t\tproperty->value.s.v = str1;\n    112  \t\t\tproperty->value.s.len = slen1;\n    113  \t\t\tbreak;\n    115  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    116  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    117  \t\t\trc = packet__read_binary(packet, (uint8_t **)&str1, &slen1);\n    118  \t\t\tif(rc) return rc;\n    120  \t\t\tproperty->value.bin.v = str1;\n    121  \t\t\tproperty->value.bin.len = slen1;\n    122  \t\t\tbreak;\n    124  \t\tcase MQTT_PROP_USER_PROPERTY:\n    125  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    126  \t\t\tif(rc) return rc;\n    129  \t\t\trc = packet__read_string(packet, &str2, &slen2);\n    130  \t\t\tif(rc){\n    131  \t\t\t\tmosquitto__free(str1);\n    132  \t\t\t\treturn rc;\n    133  \t\t\t}\n    136  \t\t\tproperty->name.v = str1;\n    137  \t\t\tproperty->name.len = slen1;\n    138  \t\t\tproperty->value.s.v = str2;\n    139  \t\t\tproperty->value.s.len = slen2;\n    140  \t\t\tbreak;\n    142  \t\tdefault:\n    144  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property_identifier);\n    146  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    147  \t}\n    150  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: mosquitto_property_read_string\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1133\n    1133 const mosquitto_property *mosquitto_property_read_string(const mosquitto_property *proplist, int identifier, char **value, bool skip_first)\n    1134 {\n    1136 \tif(!proplist) return NULL;\n    1138 \tp = property__get_property(proplist, identifier, skip_first);\n    1139 \tif(!p) return NULL;\n    1140 \tif(p->identifier != MQTT_PROP_CONTENT_TYPE\n    1141 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_TOPIC\n    1142 \t\t\t&& p->identifier != MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER\n    1143 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_METHOD\n    1144 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_INFORMATION\n    1145 \t\t\t&& p->identifier != MQTT_PROP_SERVER_REFERENCE\n    1146 \t\t\t&& p->identifier != MQTT_PROP_REASON_STRING){\n    1148 \t\treturn NULL;\n    1149 \t}\n    1151 \tif(value){\n    1152 \t\t*value = calloc(1, (size_t)p->value.s.len+1);\n    1153 \t\tif(!(*value)) return NULL;\n    1155 \t\tmemcpy(*value, p->value.s.v, p->value.s.len);\n    1156 \t}\n    1159 }\nFunction: db__expire_all_messages\nPath: /root/projects/mosquitto/src/database.c:1053\n    1053 void db__expire_all_messages(struct mosquitto *context)\n    1055 \tstruct mosquitto_client_msg *msg, *tmp;\n    1057 \tDL_FOREACH_SAFE(context->msgs_out.inflight, msg, tmp){\n    1058 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1059 \t\t\tif(msg->qos > 0){\n    1060 \t\t\t\tutil__increment_send_quota(context);\n    1062 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1065 \tDL_FOREACH_SAFE(context->msgs_out.queued, msg, tmp){\n    1066 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1067 \t\t\tdb__message_remove_from_queued(&context->msgs_out, msg);\n    1070 \tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n    1071 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1072 \t\t\tif(msg->qos > 0){\n    1073 \t\t\t\tutil__increment_receive_quota(context);\n    1075 \t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n    1078 \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n    1079 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1080 \t\t\tdb__message_remove_from_queued(&context->msgs_in, msg);\n    1083 }\nFunction: db__message_remove_from_queued\nPath: /root/projects/mosquitto/src/database.c:364\n    364  static void db__message_remove_from_queued(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    365  {\n    366  \tif(!msg_data || !item){\n    367  \t\treturn;\n    368  \t}\n    370  \tDL_DELETE(msg_data->queued, item);\n    377  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1183 \tstruct mosquitto_client_msg *tail, *tmp;\n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1190 \tDL_FOREACH_SAFE(context->msgs_out.inflight, tail, tmp){\n    1191 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1192 \t\tif(rc) return rc;\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    143  \t\t\t\tin_quota = context->msgs_in.inflight_quota;\n    144  \t\t\t\tout_quota = context->msgs_out.inflight_quota;\n    145  \t\t\t\tin_maximum = context->msgs_in.inflight_maximum;\n    146  \t\t\t\tout_maximum = context->msgs_out.inflight_maximum;\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    154  \t\t\t\tcontext->msgs_in.inflight_quota = in_quota;\n    155  \t\t\t\tcontext->msgs_out.inflight_quota = out_quota;\n    156  \t\t\t\tcontext->msgs_in.inflight_maximum = in_maximum;\n    157  \t\t\t\tcontext->msgs_out.inflight_maximum = out_maximum;\n    159  \t\t\t\tdb__message_reconnect_reset(context);\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    215  \trc = acl__find_acls(context);\n    216  \tif(rc){\n    218  \t\treturn rc;\n    219  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    250  \t}\n    252  \tcontext->ping_t = 0;\n    253  \tcontext->is_dropping = false;\n    255  \tconnection_check_acl(context, &context->msgs_in.inflight);\n    256  \tconnection_check_acl(context, &context->msgs_in.queued);\n    257  \tconnection_check_acl(context, &context->msgs_out.inflight);\n    258  \tconnection_check_acl(context, &context->msgs_out.queued);\n    260  \tcontext__add_to_by_id(context);\n    263  \tif(!context->clean_start){\n    267  \tcontext->max_qos = context->listener->max_qos;\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    315  \tkeepalive__add(context);\n    317  \tmosquitto__set_state(context, mosq_cs_active);\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    320  \tif(rc) return rc;\n    321  \tdb__expire_all_messages(context);\n    322  \trc = db__message_write_queued_out(context);\n    323  \tif(rc) return rc;\n    324  \trc = db__message_write_inflight_out_all(context);\n    330  }\nFunction: connection_check_acl\nPath: /root/projects/mosquitto/src/handle_connect.c:86\n    86   static void connection_check_acl(struct mosquitto *context, struct mosquitto_client_msg **head)\n    97   \t\tif(mosquitto_acl_check(context, msg_tail->store->topic,\n    99   \t\t\t\t\t\t\t   msg_tail->store->qos, msg_tail->store->retain, access) != MOSQ_ERR_SUCCESS){\n    101  \t\t\tDL_DELETE((*head), msg_tail);\n    107  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    248  \tmosquitto__set_state(context, mosq_cs_disused);\n    250  \tif(context->id){\n    251  \t\tcontext__remove_from_by_id(context);\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    256  \tcontext->for_free_next = db.ll_for_free;\n    257  \tdb.ll_for_free = context;\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    296  \t\tcontext->in_by_id = true;\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__msg_add_to_queued_stats\nPath: /root/projects/mosquitto/src/database.c:162\n    162  void db__msg_add_to_queued_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    163  {\n    164  \tmsg_data->queued_count++;\n    165  \tmsg_data->queued_bytes += msg->store->payloadlen;\n    166  \tif(msg->qos != 0){\n    167  \t\tmsg_data->queued_count12++;\n    168  \t\tmsg_data->queued_bytes12 += msg->store->payloadlen;\n    169  \t}\n    170  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    271  \tmosquitto__free(store->source_id);\n    272  \tmosquitto__free(store->source_username);\n    283  }\nFunction: db__message_remove_from_inflight\nPath: /root/projects/mosquitto/src/database.c:347\n    347  static void db__message_remove_from_inflight(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    348  {\n    349  \tif(!msg_data || !item){\n    350  \t\treturn;\n    351  \t}\n    353  \tDL_DELETE(msg_data->inflight, item);\n    354  \tif(item->store){\n    355  \t\tdb__msg_remove_from_inflight_stats(msg_data, item);\n    357  \t}\n    361  }\nFunction: db__message_write_inflight_out_latest\nPath: /root/projects/mosquitto/src/database.c:1198\n    1198 int db__message_write_inflight_out_latest(struct mosquitto *context)\n    1199 {\n    1200 \tstruct mosquitto_client_msg *tail, *next;\n    1203 \tif(context->state != mosq_cs_active\n    1204 \t\t\t|| context->sock == INVALID_SOCKET\n    1205 \t\t\t|| context->msgs_out.inflight == NULL){\n    1207 \t\treturn MOSQ_ERR_SUCCESS;\n    1208 \t}\n    1210 \tif(context->msgs_out.inflight->prev == context->msgs_out.inflight){\n    1212 \t\treturn db__message_write_inflight_out_single(context, context->msgs_out.inflight);\n    1213 \t}\n    1217 \ttail = context->msgs_out.inflight->prev;\n    1218 \twhile(tail != context->msgs_out.inflight &&\n    1219 \t\t\t(tail->state == mosq_ms_publish_qos0\n    1220 \t\t\t || tail->state == mosq_ms_publish_qos1\n    1221 \t\t\t || tail->state == mosq_ms_publish_qos2)){\n    1223 \t\ttail = tail->prev;\n    1224 \t}\n    1229 \tif(tail != context->msgs_out.inflight){\n    1230 \t\ttail = tail->next;\n    1231 \t}\n    1233 \twhile(tail){\n    1234 \t\tnext = tail->next;\n    1235 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1236 \t\tif(rc) return rc;\n    1238 \t}\n    1240 }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1097 \tuint32_t expiry_interval;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1103 \t\t\tif(msg->direction == mosq_md_out && msg->qos > 0){\n    1104 \t\t\t\tutil__increment_send_quota(context);\n    1105 \t\t\t}\n    1106 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1126 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1135 \t\t\t\tmsg->timestamp = db.now_s;\n    1136 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1137 \t\t\t\tmsg->state = mosq_ms_wait_for_puback;\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1139 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1148 \t\t\t\tmsg->timestamp = db.now_s;\n    1149 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1150 \t\t\t\tmsg->state = mosq_ms_wait_for_pubrec;\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1152 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1159 \t\t\trc = send__pubrel(context, mid, NULL);\n    1160 \t\t\tif(!rc){\n    1161 \t\t\t\tmsg->state = mosq_ms_wait_for_pubcomp;\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1176 \t}\n    1178 }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    449  \tstruct mosquitto_msg_data *msg_data;\n    450  \tenum mosquitto_msg_state state = mosq_ms_invalid;\n    452  \tint i;\n    457  \tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n    459  \tif(dir == mosq_md_out){\n    460  \t\tmsg_data = &context->msgs_out;\n    461  \t}else{\n    462  \t\tmsg_data = &context->msgs_in;\n    463  \t}\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    484  \tif(context->sock == INVALID_SOCKET){\n    486  \t\tif(qos == 0 && !db.config->queue_qos0_messages){\n    487  \t\t\tif(!context->bridge){\n    489  \t\t\t\treturn 2;\n    490  \t\t\t}else{\n    491  \t\t\t\tif(context->bridge->start_type != bst_lazy){\n    493  \t\t\t\t\treturn 2;\n    494  \t\t\t\t}\n    495  \t\t\t}\n    496  \t\t}\n    497  \t\tif(context->bridge && context->bridge->clean_start_local == true){\n    499  \t\t\treturn 2;\n    500  \t\t}\n    501  \t}\n    503  \tif(context->sock != INVALID_SOCKET){\n    504  \t\tif(db__ready_for_flight(context, dir, qos)){\n    517  \t\t\t}else{\n    520  \t\t\t\t}else{\n    522  \t\t\t\t\treturn 1;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n    528  \t\t}else{\n    530  \t\t\tif(context->is_dropping == false){\n    531  \t\t\t\tcontext->is_dropping = true;\n    532  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    534  \t\t\t\t\t\tcontext->id);\n    535  \t\t\t}\n    538  \t\t\treturn 2;\n    539  \t\t}\n    540  \t}else{\n    541  \t\tif (db__ready_for_queue(context, qos, msg_data)){\n    543  \t\t}else{\n    545  \t\t\tif(context->is_dropping == false){\n    546  \t\t\t\tcontext->is_dropping = true;\n    547  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    549  \t\t\t\t\t\tcontext->id);\n    550  \t\t\t}\n    552  \t\t\treturn 2;\n    553  \t\t}\n    554  \t}\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    582  \tif(state == mosq_ms_queued){\n    583  \t\tDL_APPEND(msg_data->queued, msg);\n    585  \t}else{\n    586  \t\tDL_APPEND(msg_data->inflight, msg);\n    588  \t}\n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    598  \t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n    599  \t\tif(dest_ids){\n    602  \t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t}\n    609  \t}\n    611  \tif(context->bridge && context->bridge->start_type == bst_lazy\n    612  \t\t\t&& context->sock == INVALID_SOCKET\n    613  \t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n    616  \t}\n    633  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    704  \tstruct mosquitto_msg_store *stored;\n    705  \tconst char *source_id;\n    706  \tenum mosquitto_msg_origin origin;\n    710  \tstored = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    711  \tif(stored == NULL) return MOSQ_ERR_NOMEM;\n    713  \tstored->topic = mosquitto__strdup(topic);\n    714  \tif(stored->topic == NULL){\n    715  \t\tdb__msg_store_free(stored);\n    716  \t\treturn MOSQ_ERR_INVAL;\n    717  \t}\n    719  \tstored->qos = qos;\n    720  \tif(db.config->retain_available == false){\n    721  \t\tstored->retain = 0;\n    722  \t}else{\n    723  \t\tstored->retain = retain;\n    724  \t}\n    726  \tstored->payloadlen = payloadlen;\n    727  \tif(payloadlen > 0){\n    728  \t\tstored->payload = mosquitto__malloc(stored->payloadlen+1);\n    729  \t\tif(stored->payload == NULL){\n    730  \t\t\tdb__msg_store_free(stored);\n    731  \t\t\treturn MOSQ_ERR_NOMEM;\n    732  \t\t}\n    734  \t\t((uint8_t *)stored->payload)[stored->payloadlen] = 0;\n    735  \t\tmemcpy(stored->payload, payload, stored->payloadlen);\n    736  \t}\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    746  \t}\n    748  \tif(context){\n    750  \t}else{\n    753  \tif(db__message_store(context, stored, message_expiry_interval, 0, origin)) return 1;\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    763  \tif(source && source->id){\n    764  \t\tstored->source_id = mosquitto__strdup(source->id);\n    765  \t}else{\n    766  \t\tstored->source_id = mosquitto__strdup(\"\");\n    767  \t}\n    768  \tif(!stored->source_id){\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    774  \tif(source && source->username){\n    775  \t\tstored->source_username = mosquitto__strdup(source->username);\n    776  \t\tif(!stored->source_username){\n    778  \t\t\treturn MOSQ_ERR_NOMEM;\n    779  \t\t}\n    780  \t}\n    781  \tif(source){\n    782  \t\tstored->source_listener = source->listener;\n    783  \t}\n    806  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    448  \tX509 *client_cert = NULL;\n    460  \tif(!context->listener){\n    461  \t\treturn MOSQ_ERR_INVAL;\n    462  \t}\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    502  \t\tcontext->protocol = mosq_p_mqtt31;\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    504  \t\t\tcontext->is_bridge = true;\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    508  \t\t\tcontext->protocol = mosq_p_mqtt311;\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    511  \t\t\t\tcontext->is_bridge = true;\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    514  \t\t\tcontext->protocol = mosq_p_mqtt5;\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    563  \t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid Will QoS in CONNECT from %s.\",\n    564  \t\t\t\tcontext->address);\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    666  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    724  \tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    731  \t\tif(!context->ssl){\n    732  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    741  \t\tif(context->listener->psk_hint){\n    743  \t\t\tif(!context->username){\n    744  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    754  \t\t\tclient_cert = SSL_get_peer_certificate(context->ssl);\n    755  \t\t\tif(!client_cert){\n    756  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    764  \t\t\tname = X509_get_subject_name(client_cert);\n    765  \t\t\tif(!name){\n    766  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    774  \t\t\tif (context->listener->use_identity_as_username) { /* use_identity_as_username */\n    775  \t\t\t\ti = X509_NAME_get_index_by_NID(name, NID_commonName, -1);\n    776  \t\t\t\tif(i == -1){\n    777  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    785  \t\t\t\tname_entry = X509_NAME_get_entry(name, i);\n    786  \t\t\t\tif(name_entry){\n    787  \t\t\t\t\tname_asn1 = X509_NAME_ENTRY_get_data(name_entry);\n    788  \t\t\t\t\tif (name_asn1 == NULL) {\n    789  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    801  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_get0_data(name_asn1);\n    803  \t\t\t\t\tif(mosquitto_validate_utf8(new_username, (int)strlen(new_username))){\n    804  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    809  \t\t\t\t\t\tX509_free(client_cert);\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    814  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    824  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    835  \t\t\t\tX509_NAME_print_ex(subject_bio, X509_get_subject_name(client_cert), 0, XN_FLAG_RFC2253);\n    847  \t\t\t\tcontext->username = subject;\n    849  \t\t\tif(!context->username){\n    853  \t\t\tX509_free(client_cert);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    898  \t\t\tmosquitto__set_state(context, mosq_cs_authenticating);\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    905  \t\t\twill__clear(context);\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    925  \t\tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    973  \tif(client_cert) X509_free(client_cert);\n    976  \tcontext->clean_start = true;\n    977  \tcontext->session_expiry_interval = 0;\n    978  \tcontext->will_delay_interval = 0;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    55   \tint i;\n    56   \tint pos;\n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    349  \t\trc = property__read_all(CMD_WILL, &context->in_packet, &properties);\n    350  \t\tif(rc) goto error_cleanup;\n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    356  \trc = packet__read_string(&context->in_packet, &will_struct->msg.topic, &tlen);\n    363  \tif(context->listener->mount_point){\n    364  \t\tslen = strlen(context->listener->mount_point) + strlen(will_struct->msg.topic) + 1;\n    366  \t\tif(!will_topic_mount){\n    368  \t\t\tgoto error_cleanup;\n    369  \t\t}\n    371  \t\tsnprintf(will_topic_mount, slen, \"%s%s\", context->listener->mount_point, will_struct->msg.topic);\n    374  \t\tmosquitto__free(will_struct->msg.topic);\n    375  \t\twill_struct->msg.topic = will_topic_mount;\n    376  \t}\n    378  \tif(!strncmp(will_struct->msg.topic, \"$CONTROL/\", strlen(\"$CONTROL/\"))){\n    380  \t\tgoto error_cleanup;\n    381  \t}\n    382  \trc = mosquitto_pub_topic_check(will_struct->msg.topic);\n    385  \trc = packet__read_uint16(&context->in_packet, &payloadlen);\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    394  \t\t\t}else{\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    400  \t\twill_struct->msg.payload = mosquitto__malloc((size_t)will_struct->msg.payloadlen);\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    406  \t\trc = packet__read_bytes(&context->in_packet, will_struct->msg.payload, (uint32_t)will_struct->msg.payloadlen);\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    410  \twill_struct->msg.qos = will_qos;\n    411  \twill_struct->msg.retain = will_retain;\n    416  error_cleanup:\n    417  \tif(will_struct){\n    418  \t\tmosquitto__free(will_struct->msg.topic);\n    419  \t\tmosquitto__free(will_struct->msg.payload);\n    422  \t}\n    424  }\nFunction: net__write\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:996\n    996  ssize_t net__write(struct mosquitto *mosq, const void *buf, size_t count)\n    997  {\n    999  \tint ret;\n    1001 \tassert(mosq);\n    1005 \tif(mosq->ssl){\n    1007 \t\tmosq->want_write = false;\n    1008 \t\tret = SSL_write(mosq->ssl, buf, (int)count);\n    1009 \t\tif(ret < 0){\n    1010 \t\t\tret = net__handle_ssl(mosq, ret);\n    1011 \t\t}\n    1012 \t\treturn (ssize_t )ret;\n    1013 \t}else{\n    1017 \treturn send(mosq->sock, buf, count, MSG_NOSIGNAL);\n    1020 \t}\n    1022 }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    51   \tassert(packet);\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    73   \tassert(packet);\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    157  \tassert(packet);\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    371  \t\tmux__delete(context);\n    372  \t\tcontext__disconnect(context);\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto__malloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:83\n    83   void *mosquitto__malloc(size_t size)\n    84   {\n    88   \tif(mem_limit && memcount + size > mem_limit){\n    89   \t\treturn NULL;\n    90   \t}\n    93   \tmem = malloc(size);\n    96   \tif(mem){\n    97   \t\tmemcount += malloc_usable_size(mem);\n    101  \t}\n    105  }\nFunction: mosquitto__strdup\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:144\n    144  char *mosquitto__strdup(const char *s)\n    145  {\n    148  \tif(mem_limit && memcount + strlen(s) > mem_limit){\n    149  \t\treturn NULL;\n    150  \t}\n    152  \tstr = strdup(s);\n    155  \tif(str){\n    156  \t\tmemcount += malloc_usable_size(str);\n    160  \t}\n    164  }\nFunction: mosquitto_free\nPath: /root/projects/mosquitto/src/memory_public.c:27\n    27   void mosquitto_free(void *mem)\n    29   \tmosquitto__free(mem);\n    30   }\nFunction: mosquitto_malloc\nPath: /root/projects/mosquitto/src/memory_public.c:32\n    32   void *mosquitto_malloc(size_t size)\n    34   \treturn mosquitto__malloc(size);\n    35   }\nFunction: mux__delete\nPath: /root/projects/mosquitto/src/mux.c:61\n    61   int mux__delete(struct mosquitto *context)\n    64   \treturn mux_epoll__delete(context);\n    68   }\nFunction: send__auth\nPath: /root/projects/mosquitto/src/send_auth.c:28\n    28   int send__auth(struct mosquitto *context, uint8_t reason_code, const void *auth_data, uint16_t auth_data_len)\n    29   {\n    32   \tmosquitto_property *properties = NULL;\n    35   \tif(context->auth_method == NULL) return MOSQ_ERR_INVAL;\n    36   \tif(context->protocol != mosq_p_mqtt5) return MOSQ_ERR_PROTOCOL;\n    38   \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending AUTH to %s (rc%d, %s)\", context->id, reason_code, context->auth_method);\n    42   \trc = mosquitto_property_add_string(&properties, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method);\n    43   \tif(rc){\n    45   \t\treturn rc;\n    46   \t}\n    56   \tremaining_length += property__get_remaining_length(properties);\n    58   \tif(packet__check_oversize(context, remaining_length)){\n    61   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    62   \t}\n    67   \tpacket->command = CMD_AUTH;\n    68   \tpacket->remaining_length = remaining_length;\n    70   \trc = packet__alloc(packet);\n    76   \tpacket__write_byte(packet, reason_code);\n    77   \tproperty__write_all(packet, properties, true);\n    80   \treturn packet__queue(context, packet);\n    81   }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    126  \tassert(mosq);\n    130  \tpacket->command = command;\n    131  \tif(dup){\n    132  \t\tpacket->command |= 8;\n    133  \t}\n    134  \tpacket->remaining_length = 2;\n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    137  \t\tif(reason_code != 0 || properties){\n    138  \t\t\tpacket->remaining_length += 1;\n    139  \t\t}\n    141  \t\tif(properties){\n    142  \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    143  \t\t}\n    144  \t}\n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    161  \t}\n    163  \treturn packet__queue(mosq, packet);\n    164  }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    117  \treturn send__command_with_mid(mosq, CMD_PUBREL|2, mid, false, 0, properties);\n    118  }\nFunction: send__publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:42\n    42   int send__publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    43   {\n    47   \tint i;\n    49   \tbool match;\n    51   \tchar *mapped_topic = NULL;\n    55   \tassert(mosq);\n    60   \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    63   \tif(!mosq->retain_available){\n    65   \t}\n    68   \tif(mosq->listener && mosq->listener->mount_point){\n    69   \t\tlen = strlen(mosq->listener->mount_point);\n    70   \t\tif(len < strlen(topic)){\n    71   \t\t\ttopic += len;\n    72   \t\t}else{\n    74   \t\t\treturn MOSQ_ERR_SUCCESS;\n    75   \t\t}\n    76   \t}\n    78   \tif(mosq->bridge && mosq->bridge->topics && mosq->bridge->topic_remapping){\n    79   \t\tfor(i=0; i<mosq->bridge->topic_count; i++){\n    80   \t\t\tcur_topic = &mosq->bridge->topics[i];\n    81   \t\t\tif((cur_topic->direction == bd_both || cur_topic->direction == bd_out)\n    82   \t\t\t\t\t&& (cur_topic->remote_prefix || cur_topic->local_prefix)){\n    85   \t\t\t\trc = mosquitto_topic_matches_sub(cur_topic->local_topic, topic, &match);\n    86   \t\t\t\tif(rc){\n    87   \t\t\t\t\treturn rc;\n    88   \t\t\t\t}\n    89   \t\t\t\tif(match){\n    90   \t\t\t\t\tmapped_topic = mosquitto__strdup(topic);\n    91   \t\t\t\t\tif(!mapped_topic) return MOSQ_ERR_NOMEM;\n    92   \t\t\t\t\tif(cur_topic->local_prefix){\n    94   \t\t\t\t\t\tif(!strncmp(cur_topic->local_prefix, mapped_topic, strlen(cur_topic->local_prefix))){\n    95   \t\t\t\t\t\t\ttopic_temp = mosquitto__strdup(mapped_topic+strlen(cur_topic->local_prefix));\n    96   \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    97   \t\t\t\t\t\t\tif(!topic_temp){\n    98   \t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    99   \t\t\t\t\t\t\t}\n    101  \t\t\t\t\t\t}\n    102  \t\t\t\t\t}\n    104  \t\t\t\t\tif(cur_topic->remote_prefix){\n    106  \t\t\t\t\t\tlen = strlen(mapped_topic) + strlen(cur_topic->remote_prefix)+1;\n    107  \t\t\t\t\t\ttopic_temp = mosquitto__malloc(len+1);\n    108  \t\t\t\t\t\tif(!topic_temp){\n    109  \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    110  \t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    111  \t\t\t\t\t\t}\n    112  \t\t\t\t\t\tsnprintf(topic_temp, len, \"%s%s\", cur_topic->remote_prefix, mapped_topic);\n    113  \t\t\t\t\t\ttopic_temp[len] = '\\0';\n    114  \t\t\t\t\t\tmosquitto__free(mapped_topic);\n    116  \t\t\t\t\t}\n    117  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, mapped_topic, (long)payloadlen);\n    119  \t\t\t\t\trc =  send__real_publish(mosq, mid, mapped_topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    120  \t\t\t\t\tmosquitto__free(mapped_topic);\n    121  \t\t\t\t\treturn rc;\n    122  \t\t\t\t}\n    123  \t\t\t}\n    124  \t\t}\n    125  \t}\n    127  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, topic, (long)payloadlen);\n    133  \treturn send__real_publish(mosq, mid, topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    134  }\nFunction: send__real_publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:137\n    137  int send__real_publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    138  {\n    140  \tunsigned int packetlen;\n    141  \tunsigned int proplen = 0, varbytes;\n    143  \tmosquitto_property expiry_prop;\n    145  \tassert(mosq);\n    147  \tif(topic){\n    148  \t\tpacketlen = 2+(unsigned int)strlen(topic) + payloadlen;\n    149  \t}else{\n    150  \t\tpacketlen = 2 + payloadlen;\n    151  \t}\n    152  \tif(qos > 0) packetlen += 2; /* For message id */\n    153  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tproplen += property__get_length_all(cmsg_props);\n    156  \t\tproplen += property__get_length_all(store_props);\n    157  \t\tif(expiry_interval > 0){\n    158  \t\t\texpiry_prop.next = NULL;\n    160  \t\t\texpiry_prop.identifier = MQTT_PROP_MESSAGE_EXPIRY_INTERVAL;\n    163  \t\t\tproplen += property__get_length_all(&expiry_prop);\n    164  \t\t}\n    166  \t\tvarbytes = packet__varint_bytes(proplen);\n    172  \t\t}else{\n    173  \t\t\tpacketlen += proplen + varbytes;\n    174  \t\t}\n    175  \t}\n    176  \tif(packet__check_oversize(mosq, packetlen)){\n    178  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Dropping too large outgoing PUBLISH for %s (%d bytes)\", SAFE_PRINT(mosq->id), packetlen);\n    182  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    183  \t}\n    189  \tpacket->command = (uint8_t)(CMD_PUBLISH | (uint8_t)((dup&0x1)<<3) | (uint8_t)(qos<<1) | retain);\n    190  \tpacket->remaining_length = packetlen;\n    206  \tif(mosq->protocol == mosq_p_mqtt5){\n    213  \t}\n    220  \treturn packet__queue(mosq, packet);\n    221  }\nFunction: session_expiry__cmp\nPath: /root/projects/mosquitto/src/session_expiry.c:34\n    34   static int session_expiry__cmp(struct session_expiry_list *i1, struct session_expiry_list *i2)\n    35   {\n    36   \tif(i1->context->session_expiry_time == i2->context->session_expiry_time){\n    37   \t\treturn 0;\n    38   \t}else if(i1->context->session_expiry_time > i2->context->session_expiry_time){\n    39   \t\treturn 1;\n    40   \t}else{\n    41   \t\treturn -1;\n    42   \t}\n    43   }\nFunction: session_expiry__remove\nPath: /root/projects/mosquitto/src/session_expiry.c:121\n    121  void session_expiry__remove(struct mosquitto *context)\n    122  {\n    123  \tif(context->expiry_list_item){\n    124  \t\tDL_DELETE(expiry_list, context->expiry_list_item);\n    125  \t\tmosquitto__free(context->expiry_list_item);\n    126  \t\tcontext->expiry_list_item = NULL;\n    127  \t}\n    128  }\nFunction: acl__check_single\nPath: /root/projects/mosquitto/src/security.c:602\n    602  static int acl__check_single(struct mosquitto__auth_plugin_config *auth_plugin, struct mosquitto *context, struct mosquitto_acl_msg *msg, int access)\n    603  {\n    607  \tusername = mosquitto_client_username(context);\n    608  \tif(auth_plugin->deny_special_chars == true){\n    615  \t\tif(username && strpbrk(username, \"+#\")){\n    616  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous username \\\"%s\\\"\", username);\n    617  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    618  \t\t}\n    619  \t\tif(context->id && strpbrk(context->id, \"+#\")){\n    620  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous client id \\\"%s\\\"\", context->id);\n    621  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    622  \t\t}\n    623  \t}\n    625  \tif(auth_plugin->plugin.version == 4){\n    626  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    627  \t\t\treturn MOSQ_ERR_SUCCESS;\n    628  \t\t}\n    629  \t\treturn auth_plugin->plugin.acl_check_v4(auth_plugin->plugin.user_data, access, context, msg);\n    630  \t}else if(auth_plugin->plugin.version == 3){\n    631  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    632  \t\t\treturn MOSQ_ERR_SUCCESS;\n    633  \t\t}\n    634  \t\treturn auth_plugin->plugin.acl_check_v3(auth_plugin->plugin.user_data, access, context, msg);\n    635  \t}else if(auth_plugin->plugin.version == 2){\n    636  \t\tif(access == MOSQ_ACL_SUBSCRIBE || access == MOSQ_ACL_UNSUBSCRIBE){\n    637  \t\t\treturn MOSQ_ERR_SUCCESS;\n    638  \t\t}\n    639  \t\treturn auth_plugin->plugin.acl_check_v2(auth_plugin->plugin.user_data, context->id, username, topic, access);\n    640  \t}else{\n    641  \t\treturn MOSQ_ERR_INVAL;\n    642  \t}\n    643  }\nFunction: sub__remove_shared_leaf\nPath: /root/projects/mosquitto/src/subs.c:190\n    190  static void sub__remove_shared_leaf(struct mosquitto__subhier *subhier, struct mosquitto__subshared *shared, struct mosquitto__subleaf *leaf)\n    191  {\n    192  \tDL_DELETE(shared->subs, leaf);\n    193  \tif(shared->subs == NULL){\n    194  \t\tHASH_DELETE(hh, subhier->shared, shared);\n    195  \t\tmosquitto__free(shared->name);\n    196  \t\tmosquitto__free(shared);\n    197  \t}\n    199  }\nFunction: sub__messages_queue\nPath: /root/projects/mosquitto/src/subs.c:659\n    659  int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n    660  {\n    661  \tint rc = MOSQ_ERR_SUCCESS, rc2;\n    662  \tint rc_normal = MOSQ_ERR_NO_SUBSCRIBERS, rc_shared = MOSQ_ERR_NO_SUBSCRIBERS;\n    663  \tstruct mosquitto__subhier *subhier;\n    664  \tchar **split_topics = NULL;\n    677  \tHASH_FIND(hh, db.normal_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    678  \tif(subhier){\n    679  \t\trc_normal = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    680  \t\tif(rc_normal > 0){\n    682  \t\t\tgoto end;\n    683  \t\t}\n    684  \t}\n    686  \tHASH_FIND(hh, db.shared_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    687  \tif(subhier){\n    688  \t\trc_shared = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    689  \t\tif(rc_shared > 0){\n    691  \t\t\tgoto end;\n    692  \t\t}\n    693  \t}\n    695  \tif(rc_normal == MOSQ_ERR_NO_SUBSCRIBERS && rc_shared == MOSQ_ERR_NO_SUBSCRIBERS){\n    697  \t}\n    711  }\nFunction: sub__search\nPath: /root/projects/mosquitto/src/subs.c:479\n    479  static int sub__search(struct mosquitto__subhier *subhier, char **split_topics, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    480  {\n    482  \tstruct mosquitto__subhier *branch;\n    486  \tif(split_topics && split_topics[0]){\n    488  \t\tHASH_FIND(hh, subhier->children, split_topics[0], strlen(split_topics[0]), branch);\n    490  \t\tif(branch){\n    491  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    492  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    494  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    495  \t\t\t\treturn rc;\n    496  \t\t\t}\n    497  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    498  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    499  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    501  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    502  \t\t\t\t\treturn rc;\n    503  \t\t\t\t}\n    504  \t\t\t}\n    505  \t\t}\n    508  \t\tHASH_FIND(hh, subhier->children, \"+\", 1, branch);\n    510  \t\tif(branch){\n    511  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    512  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    514  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    515  \t\t\t\treturn rc;\n    516  \t\t\t}\n    517  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    518  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    519  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    521  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    522  \t\t\t\t\treturn rc;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}\n    526  \t}\n    529  \tHASH_FIND(hh, subhier->children, \"#\", 1, branch);\n    530  \tif(branch && !branch->children){\n    535  \t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    536  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    538  \t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    539  \t\t\treturn rc;\n    540  \t\t}\n    541  \t}\n    548  }\nFunction: subs__process\nPath: /root/projects/mosquitto/src/subs.c:129\n    129  static int subs__process(struct mosquitto__subhier *hier, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    130  {\n    133  \tstruct mosquitto__subleaf *leaf;\n    135  \trc = subs__shared_process(hier, topic, qos, retain, stored);\n    137  \tleaf = hier->subs;\n    138  \twhile(source_id && leaf){\n    139  \t\tif(!leaf->context->id || (leaf->no_local && !strcmp(leaf->context->id, source_id))){\n    140  \t\t\tleaf = leaf->next;\n    142  \t\t}\n    147  \t\tleaf = leaf->next;\n    148  \t}\n    149  \tif(hier->subs || hier->shared){\n    150  \t\treturn rc;\n    151  \t}else{\n    152  \t\treturn MOSQ_ERR_NO_SUBSCRIBERS;\n    153  \t}\n    154  }\nFunction: subs__send\nPath: /root/projects/mosquitto/src/subs.c:63\n    63   static int subs__send(struct mosquitto__subleaf *leaf, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    64   {\n    65   \tbool client_retain;\n    66   \tuint16_t mid;\n    67   \tuint8_t client_qos, msg_qos;\n    68   \tmosquitto_property *properties = NULL;\n    72   \trc2 = mosquitto_acl_check(leaf->context, topic, stored->payloadlen, stored->payload, stored->qos, stored->retain, MOSQ_ACL_READ);\n    73   \tif(rc2 == MOSQ_ERR_ACL_DENIED){\n    74   \t\treturn MOSQ_ERR_SUCCESS;\n    75   \t}else if(rc2 == MOSQ_ERR_SUCCESS){\n    76   \t\tclient_qos = leaf->qos;\n    87   \t\tif(msg_qos){\n    88   \t\t\tmid = mosquitto__mid_generate(leaf->context);\n    89   \t\t}else{\n    92   \t\tif(leaf->retain_as_published){\n    93   \t\t\tclient_retain = retain;\n    94   \t\t}else{\n    97   \t\tif(leaf->identifier){\n    98   \t\t\tmosquitto_property_add_varint(&properties, MQTT_PROP_SUBSCRIPTION_IDENTIFIER, leaf->identifier);\n    99   \t\t}\n    100  \t\tif(db__message_insert(leaf->context, mid, mosq_md_out, msg_qos, client_retain, stored, properties, true) == 1){\n    101  \t\t\treturn 1;\n    102  \t\t}\n    103  \t}else{\n    104  \t\treturn 1; /* Application error */\n    105  \t}\n    107  }\nFunction: sub__clean_session\nPath: /root/projects/mosquitto/src/subs.c:746\n    746  int sub__clean_session(struct mosquitto *context)\n    747  {\n    748  \tint i;\n    749  \tstruct mosquitto__subleaf *leaf;\n    750  \tstruct mosquitto__subhier *hier;\n    752  \tfor(i=0; i<context->sub_count; i++){\n    753  \t\tif(context->subs[i] == NULL){\n    755  \t\t}\n    757  \t\thier = context->subs[i]->hier;\n    759  \t\tif(context->subs[i]->shared){\n    760  \t\t\tleaf = context->subs[i]->shared->subs;\n    761  \t\t\twhile(leaf){\n    762  \t\t\t\tif(leaf->context==context){\n    766  \t\t\t\t\tsub__remove_shared_leaf(context->subs[i]->hier, context->subs[i]->shared, leaf);\n    768  \t\t\t\t}\n    769  \t\t\t\tleaf = leaf->next;\n    770  \t\t\t}\n    771  \t\t}else{\n    772  \t\t\tleaf = hier->subs;\n    773  \t\t\twhile(leaf){\n    774  \t\t\t\tif(leaf->context==context){\n    778  \t\t\t\t\tDL_DELETE(hier->subs, leaf);\n    779  \t\t\t\t\tmosquitto__free(leaf);\n    781  \t\t\t\t}\n    782  \t\t\t\tleaf = leaf->next;\n    783  \t\t\t}\n    784  \t\t}\n    785  \t\tmosquitto__free(context->subs[i]);\n    786  \t\tcontext->subs[i] = NULL;\n    788  \t\tif(hier->subs == NULL\n    789  \t\t\t\t&& hier->children == NULL\n    790  \t\t\t\t&& hier->shared == NULL\n    791  \t\t\t\t&& hier->parent){\n    794  \t\t\t\thier = tmp_remove_subs(hier);\n    795  \t\t\t}while(hier);\n    796  \t\t}\n    797  \t}\n    798  \tmosquitto__free(context->subs);\n    799  \tcontext->subs = NULL;\n    800  \tcontext->sub_count = 0;\n    803  }\nFunction: tmp_remove_subs\nPath: /root/projects/mosquitto/src/subs.c:715\n    715  static struct mosquitto__subhier *tmp_remove_subs(struct mosquitto__subhier *sub)\n    716  {\n    719  \tif(!sub || !sub->parent){\n    720  \t\treturn NULL;\n    721  \t}\n    723  \tif(sub->children || sub->subs){\n    724  \t\treturn NULL;\n    725  \t}\n    727  \tparent = sub->parent;\n    728  \tHASH_DELETE(hh, parent->children, sub);\n    729  \tmosquitto__free(sub->topic);\n    730  \tmosquitto__free(sub);\n    732  \tif(parent->subs == NULL\n    733  \t\t\t&& parent->children == NULL\n    734  \t\t\t&& parent->shared == NULL\n    735  \t\t\t&& parent->parent){\n    737  \t\treturn parent;\n    738  \t}else{\n    739  \t\treturn NULL;\n    740  \t}\n    741  }\nFunction: util__increment_send_quota\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:222\n    222  void util__increment_send_quota(struct mosquitto *mosq)\n    223  {\n    224  \tif(mosq->msgs_out.inflight_quota < mosq->msgs_out.inflight_maximum){\n    225  \t\tmosq->msgs_out.inflight_quota++;\n    226  \t}\n    227  }\nFunction: will_delay__remove\nPath: /root/projects/mosquitto/src/will_delay.c:99\n    99   void will_delay__remove(struct mosquitto *mosq)\n    100  {\n    101  \tif(mosq->will_delay_entry != NULL){\n    102  \t\tDL_DELETE(delay_list, mosq->will_delay_entry);\n    103  \t\tmosquitto__free(mosq->will_delay_entry);\n    104  \t\tmosq->will_delay_entry = NULL;\n    105  \t}\n    106  }\nFunction: will__clear\nPath: /root/projects/mosquitto/src/../lib/will_mosq.c:111\n    111  int will__clear(struct mosquitto *mosq)\n    112  {\n    113  \tif(!mosq->will) return MOSQ_ERR_SUCCESS;\n    115  \tmosquitto__free(mosq->will->msg.topic);\n    116  \tmosq->will->msg.topic = NULL;\n    118  \tmosquitto__free(mosq->will->msg.payload);\n    119  \tmosq->will->msg.payload = NULL;\n    121  \tmosquitto_property_free_all(&mosq->will->properties);\n    123  \tmosquitto__free(mosq->will);\n    124  \tmosq->will = NULL;\n    125  \tmosq->will_delay_interval = 0;\n    128  }\n",
    "If the Will Flag is set to 0, then the Will QoS MUST be set to 0 (0x00) [MQTT-3.1.2-11].": "Function: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    150  \tpacket->pos = 0;\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    353  }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    113  \tmosquitto_property *connack_props = NULL;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    205  \t\tfound_context->clean_start = true;\n    213  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    247  \t\t} else {\n    250  \t}\n    263  \tif(!context->clean_start){\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    330  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    258  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    465  \tif(context->state != mosq_cs_new){\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    557  \t}else{\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    563  \t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid Will QoS in CONNECT from %s.\",\n    564  \t\t\t\tcontext->address);\n    565  \t\trc = MOSQ_ERR_PROTOCOL;\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    666  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    887  \tcontext->clean_start = clean_start;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    976  \tcontext->clean_start = true;\n    980  }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    410  \twill_struct->msg.qos = will_qos;\n    424  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    316  \t\tif(db.config->connection_messages == true){\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    363  \t\t\t}else{\n    370  \t\t}\n    374  }\nFunction: mosquitto__get_state\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:295\n    295  enum mosquitto_client_state mosquitto__get_state(struct mosquitto *mosq)\n    300  \tstate = mosq->state;\n    303  \treturn state;\n    304  }\nFunction: mosquitto__set_state\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:281\n    281  int mosquitto__set_state(struct mosquitto *mosq, enum mosquitto_client_state state)\n    282  {\n    285  \tif(mosq->state != mosq_cs_disused)\n    287  \t{\n    288  \t\tmosq->state = state;\n    289  \t}\n    293  }\n",
    "If the User Name Flag is set to 1, a User Name MUST be present in the Payload [MQTT-3.1.2-17].": "Function: mosquitto_client_username\nPath: /root/projects/mosquitto/src/plugin_public.c:134\n    134  const char *mosquitto_client_username(const struct mosquitto *client)\n    135  {\n    136  \tif(client){\n    138  \t\tif(client->bridge){\n    139  \t\t\treturn client->bridge->local_username;\n    140  \t\t}else\n    142  \t\t{\n    143  \t\t\treturn client->username;\n    144  \t\t}\n    145  \t}else{\n    146  \t\treturn NULL;\n    147  \t}\n    148  }\nFunction: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    209  \t\t}\n    210  \t}\n    212  }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    205  \t\tfound_context->clean_start = true;\n    213  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    247  \t\t} else {\n    250  \t}\n    263  \tif(!context->clean_start){\n    330  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    557  \t}else{\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    675  \t\t\trc = MOSQ_ERR_NOMEM;\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    679  \t\t\t\t/* Username flag given, but no username. Ignore. */\n    680  \t\t\t\tusername_flag = 0;\n    681  \t\t\t}else{\n    682  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    743  \t\t\tif(!context->username){\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    847  \t\t\t\tcontext->username = subject;\n    849  \t\t\tif(!context->username){\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    976  \tcontext->clean_start = true;\n    980  }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    410  \twill_struct->msg.qos = will_qos;\n    424  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    54   \t*byte = packet->payload[packet->pos];\n    58   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto_unpwd_check\nPath: /root/projects/mosquitto/src/security.c:755\n    755  int mosquitto_unpwd_check(struct mosquitto *context)\n    756  {\n    757  \tint rc;\n    758  \tint i;\n    759  \tstruct mosquitto__security_options *opts;\n    760  \tstruct mosquitto_evt_basic_auth event_data;\n    761  \tstruct mosquitto__callback *cb_base;\n    762  \tbool plugin_used = false;\n    766  \tif(db.config->per_listener_settings){\n    767  \t\tif(context->listener == NULL){\n    768  \t\t\treturn MOSQ_ERR_AUTH;\n    769  \t\t}\n    770  \t\topts = &context->listener->security_options;\n    771  \t}else{\n    772  \t\topts = &db.config->security_options;\n    773  \t}\n    775  \tDL_FOREACH(opts->plugin_callbacks.basic_auth, cb_base){\n    778  \t\tevent_data.username = context->username;\n    780  \t\trc = cb_base->cb(MOSQ_EVT_BASIC_AUTH, &event_data, cb_base->userdata);\n    787  \tfor(i=0; i<opts->auth_plugin_config_count; i++){\n    788  \t\tif(opts->auth_plugin_configs[i].plugin.version == 4\n    789  \t\t\t\t&& opts->auth_plugin_configs[i].plugin.unpwd_check_v4){\n    791  \t\t\trc = opts->auth_plugin_configs[i].plugin.unpwd_check_v4(\n    792  \t\t\t\t\topts->auth_plugin_configs[i].plugin.user_data,\n    794  \t\t\t\t\tcontext->username,\n    795  \t\t\t\t\tcontext->password);\n    798  \t\t}else if(opts->auth_plugin_configs[i].plugin.version == 3){\n    799  \t\t\trc = opts->auth_plugin_configs[i].plugin.unpwd_check_v3(\n    800  \t\t\t\t\topts->auth_plugin_configs[i].plugin.user_data,\n    802  \t\t\t\t\tcontext->username,\n    803  \t\t\t\t\tcontext->password);\n    806  \t\t}else if(opts->auth_plugin_configs[i].plugin.version == 2){\n    807  \t\t\trc = opts->auth_plugin_configs[i].plugin.unpwd_check_v2(\n    808  \t\t\t\t\topts->auth_plugin_configs[i].plugin.user_data,\n    809  \t\t\t\t\tcontext->username,\n    810  \t\t\t\t\tcontext->password);\n    812  \t\t}\n    813  \t}\n    817  \tif(plugin_used == false){\n    819  \t\t\t\t|| (!db.config->per_listener_settings && db.config->security_options.allow_anonymous != false)){\n    821  \t\t\treturn MOSQ_ERR_SUCCESS;\n    822  \t\t}else{\n    823  \t\t\treturn MOSQ_ERR_AUTH;\n    824  \t\t}\n    825  \t}else{\n    826  \t\tif(rc == MOSQ_ERR_PLUGIN_DEFER){\n    827  \t\t\tif(context->username == NULL &&\n    828  \t\t\t\t\t((db.config->per_listener_settings && context->listener->security_options.allow_anonymous != false)\n    829  \t\t\t\t\t|| (!db.config->per_listener_settings && db.config->security_options.allow_anonymous != false))){\n    830  \n    831  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    832  \t\t\t}else{\n    833  \t\t\t\treturn MOSQ_ERR_AUTH;\n    834  \t\t\t}\n    835  \t\t}\n    836  \t}\n    839  }\nFunction: acl__find_acls\nPath: /root/projects/mosquitto/src/security_default.c:704\n    704  int acl__find_acls(struct mosquitto *context)\n    705  {\n    706  \tstruct mosquitto__acl_user *acl_tail;\n    707  \tstruct mosquitto__security_options *security_opts;\n    710  \tif(db.config->per_listener_settings){\n    711  \t\tif(!context->listener){\n    712  \t\t\treturn MOSQ_ERR_INVAL;\n    713  \t\t}\n    714  \t\tsecurity_opts = &context->listener->security_options;\n    715  \t}else{\n    716  \t\tsecurity_opts = &db.config->security_options;\n    717  \t}\n    719  \tif(security_opts->acl_list){\n    720  \t\tacl_tail = security_opts->acl_list;\n    721  \t\twhile(acl_tail){\n    722  \t\t\tif(context->username){\n    723  \t\t\t\tif(acl_tail->username && !strcmp(context->username, acl_tail->username)){\n    724  \t\t\t\t\tcontext->acl_list = acl_tail;\n    725  \t\t\t\t\tbreak;\n    726  \t\t\t\t}\n    727  \t\t\t}else{\n    728  \t\t\t\tif(acl_tail->username == NULL){\n    729  \t\t\t\t\tcontext->acl_list = acl_tail;\n    730  \t\t\t\t\tbreak;\n    731  \t\t\t\t}\n    732  \t\t\t}\n    733  \t\t\tacl_tail = acl_tail->next;\n    734  \t\t}\n    735  \t}else{\n    740  }\nFunction: mosquitto_validate_utf8\nPath: /root/projects/mosquitto/src/../lib/utf8_mosq.c:24\n    24   int mosquitto_validate_utf8(const char *str, int len)\n    25   {\n    26   \tint i;\n    27   \tint j;\n    28   \tint codelen;\n    29   \tint codepoint;\n    32   \tif(!str) return MOSQ_ERR_INVAL;\n    35   \tfor(i=0; i<len; i++){\n    36   \t\tif(ustr[i] == 0){\n    37   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    38   \t\t}else if(ustr[i] <= 0x7f){\n    40   \t\t\tcodepoint = ustr[i];\n    41   \t\t}else if((ustr[i] & 0xE0) == 0xC0){\n    43   \t\t\tif(ustr[i] == 0xC0 || ustr[i] == 0xC1){\n    45   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    46   \t\t\t}\n    48   \t\t\tcodepoint = (ustr[i] & 0x1F);\n    49   \t\t}else if((ustr[i] & 0xF0) == 0xE0){\n    52   \t\t\tcodepoint = (ustr[i] & 0x0F);\n    53   \t\t}else if((ustr[i] & 0xF8) == 0xF0){\n    55   \t\t\tif(ustr[i] > 0xF4){\n    57   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    58   \t\t\t}\n    60   \t\t\tcodepoint = (ustr[i] & 0x07);\n    61   \t\t}else{\n    63   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    64   \t\t}\n    67   \t\tif(i == len-codelen+1){\n    69   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    70   \t\t}\n    71   \t\tfor(j=0; j<codelen-1; j++){\n    72   \t\t\tif((ustr[++i] & 0xC0) != 0x80){\n    74   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    75   \t\t\t}\n    76   \t\t\tcodepoint = (codepoint<<6) | (ustr[i] & 0x3F);\n    77   \t\t}\n    80   \t\tif(codepoint >= 0xD800 && codepoint <= 0xDFFF){\n    81   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    82   \t\t}\n    88   \t\t *\t return MOSQ_ERR_MALFORMED_UTF8;\n    91   \t\tif(codelen == 3 && codepoint < 0x0800){\n    92   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    93   \t\t}else if(codelen == 4 && (codepoint < 0x10000 || codepoint > 0x10FFFF)){\n    94   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    95   \t\t}\n    98   \t\tif(codepoint >= 0xFDD0 && codepoint <= 0xFDEF){\n    99   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    100  \t\t}\n    101  \t\tif((codepoint & 0xFFFF) == 0xFFFE || (codepoint & 0xFFFF) == 0xFFFF){\n    102  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    103  \t\t}\n    105  \t\tif(codepoint <= 0x001F || (codepoint >= 0x007F && codepoint <= 0x009F)){\n    106  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    107  \t\t}\n    108  \t}\n    110  }\n",
    "If the Will Flag is set to 1 and Will Retain is set to 0, the Server MUST publish the Will Message as a non-retained message [MQTT-3.1.2-14].": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    191  \n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    199  \n    200  \t\t\t/* Unexpected disconnect, queue the client will. */\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    97   \tpacket->remaining_length = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    150  \tpacket->pos = 0;\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    345  \t}\n    353  }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    205  \t\tfound_context->clean_start = true;\n    213  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    247  \t\t} else {\n    250  \t}\n    263  \tif(!context->clean_start){\n    330  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    557  \t}else{\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    576  \t\trc = MOSQ_ERR_NOT_SUPPORTED;\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    666  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    887  \tcontext->clean_start = clean_start;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    976  \tcontext->clean_start = true;\n    980  }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    410  \twill_struct->msg.qos = will_qos;\n    411  \twill_struct->msg.retain = will_retain;\n    424  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\n",
    "Where a Packet exceeds the Maximum Packet Size set by the Client, the Server MUST discard the Packet without sending it and then behave as if the Server had completed sending that Application Message [MQTT-3.1.2-25].": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    221  \tplugin__handle_disconnect(context, -1);\n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    226  \tif(context->bridge == NULL)\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    232  \t\t\tif(context->will_delay_interval == 0){\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__read_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:178\n    178  int packet__read_uint32(struct mosquitto__packet *packet, uint32_t *word)\n    179  {\n    180  \tuint32_t val = 0;\n    181  \tint i;\n    183  \tassert(packet);\n    184  \tif(packet->pos+4 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    186  \tfor(i=0; i<4; i++){\n    187  \t\tval = (val << 8) + packet->payload[packet->pos];\n    188  \t\tpacket->pos++;\n    189  \t}\n    191  \t*word = val;\n    194  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    147  \tassert(mosq);\n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    153  \tpacket->next = NULL;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    187  \treturn packet__write(mosq);\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    353  }\nFunction: packet__check_oversize\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:211\n    211  int packet__check_oversize(struct mosquitto *mosq, uint32_t remaining_length)\n    212  {\n    213  \tuint32_t len;\n    214  \n    215  \tif(mosq->maximum_packet_size == 0) return MOSQ_ERR_SUCCESS;\n    216  \n    217  \tlen = remaining_length + packet__varint_bytes(remaining_length);\n    218  \tif(len > mosq->maximum_packet_size){\n    219  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    220  \t}else{\n    221  \t\treturn MOSQ_ERR_SUCCESS;\n    222  \t}\n    223  }\nFunction: property__process_connect\nPath: /root/projects/mosquitto/src/property_broker.c:30\n    30   int property__process_connect(struct mosquitto *context, mosquitto_property **props)\n    31   {\n    32   \tmosquitto_property *p;\n    34   \tp = *props;\n    36   \twhile(p){\n    37   \t\tif(p->identifier == MQTT_PROP_SESSION_EXPIRY_INTERVAL){\n    38   \t\t\tcontext->session_expiry_interval = p->value.i32;\n    39   \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM){\n    40   \t\t\tif(p->value.i16 == 0){\n    41   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    42   \t\t\t}\n    44   \t\t\tcontext->msgs_out.inflight_maximum = p->value.i16;\n    45   \t\t\tcontext->msgs_out.inflight_quota = context->msgs_out.inflight_maximum;\n    46   \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    47   \t\t\tif(p->value.i32 == 0){\n    48   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    49   \t\t\t}\n    50   \t\t\tcontext->maximum_packet_size = p->value.i32;\n    51   \t\t}\n    52   \t\tp = p->next;\n    53   \t}\n    56   }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__read\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:35\n    35   static int property__read(struct mosquitto__packet *packet, uint32_t *len, mosquitto_property *property)\n    36   {\n    38   \tuint32_t property_identifier;\n    39   \tuint8_t byte;\n    40   \tuint8_t byte_count;\n    41   \tuint16_t uint16;\n    42   \tuint32_t uint32;\n    43   \tuint32_t varint;\n    44   \tchar *str1, *str2;\n    45   \tuint16_t slen1, slen2;\n    47   \tif(!property) return MOSQ_ERR_INVAL;\n    49   \trc = packet__read_varint(packet, &property_identifier, NULL);\n    50   \tif(rc){\n    51   \t\treturn rc;\n    52   \t}\n    55   \tmemset(property, 0, sizeof(mosquitto_property));\n    57   \tproperty->identifier = (int32_t)property_identifier;\n    59   \tswitch(property_identifier){\n    60   \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    61   \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    62   \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    63   \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    64   \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    65   \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    66   \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    67   \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    68   \t\t\trc = packet__read_byte(packet, &byte);\n    69   \t\t\tif(rc) return rc;\n    71   \t\t\tproperty->value.i8 = byte;\n    72   \t\t\tbreak;\n    74   \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    75   \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    76   \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    77   \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    78   \t\t\trc = packet__read_uint16(packet, &uint16);\n    79   \t\t\tif(rc) return rc;\n    81   \t\t\tproperty->value.i16 = uint16;\n    82   \t\t\tbreak;\n    84   \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    85   \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    86   \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    87   \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    88   \t\t\trc = packet__read_uint32(packet, &uint32);\n    89   \t\t\tif(rc) return rc;\n    91   \t\t\tproperty->value.i32 = uint32;\n    92   \t\t\tbreak;\n    94   \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    95   \t\t\trc = packet__read_varint(packet, &varint, &byte_count);\n    96   \t\t\tif(rc) return rc;\n    98   \t\t\tproperty->value.varint = varint;\n    99   \t\t\tbreak;\n    101  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    102  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    103  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    104  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    105  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    106  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    107  \t\tcase MQTT_PROP_REASON_STRING:\n    108  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    109  \t\t\tif(rc) return rc;\n    111  \t\t\tproperty->value.s.v = str1;\n    112  \t\t\tproperty->value.s.len = slen1;\n    113  \t\t\tbreak;\n    115  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    116  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    117  \t\t\trc = packet__read_binary(packet, (uint8_t **)&str1, &slen1);\n    118  \t\t\tif(rc) return rc;\n    120  \t\t\tproperty->value.bin.v = str1;\n    121  \t\t\tproperty->value.bin.len = slen1;\n    122  \t\t\tbreak;\n    124  \t\tcase MQTT_PROP_USER_PROPERTY:\n    125  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    126  \t\t\tif(rc) return rc;\n    129  \t\t\trc = packet__read_string(packet, &str2, &slen2);\n    130  \t\t\tif(rc){\n    131  \t\t\t\tmosquitto__free(str1);\n    132  \t\t\t\treturn rc;\n    133  \t\t\t}\n    136  \t\t\tproperty->name.v = str1;\n    137  \t\t\tproperty->name.len = slen1;\n    138  \t\t\tproperty->value.s.v = str2;\n    139  \t\t\tproperty->value.s.len = slen2;\n    140  \t\t\tbreak;\n    142  \t\tdefault:\n    144  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property_identifier);\n    146  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    147  \t}\n    150  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: property__get_length_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:335\n    335  unsigned int property__get_length_all(const mosquitto_property *property)\n    336  {\n    337  \tconst mosquitto_property *p;\n    338  \tunsigned int len = 0;\n    341  \twhile(p){\n    342  \t\tlen += property__get_length(p);\n    343  \t\tp = p->next;\n    344  \t}\n    345  \treturn len;\n    346  }\nFunction: property__write_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:429\n    429  int property__write_all(struct mosquitto__packet *packet, const mosquitto_property *properties, bool write_len)\n    430  {\n    432  \tconst mosquitto_property *p;\n    440  \twhile(p){\n    441  \t\trc = property__write(packet, p);\n    442  \t\tif(rc) return rc;\n    443  \t\tp = p->next;\n    444  \t}\n    447  }\nFunction: property__write\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:361\n    361  static int property__write(struct mosquitto__packet *packet, const mosquitto_property *property)\n    362  {\n    365  \trc = packet__write_varint(packet, (uint32_t)property->identifier);\n    366  \tif(rc) return rc;\n    368  \tswitch(property->identifier){\n    390  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    391  \t\t\tpacket__write_uint32(packet, property->value.i32);\n    394  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    395  \t\t\treturn packet__write_varint(packet, property->value.varint);\n    397  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    398  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    399  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    400  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    401  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    402  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    403  \t\tcase MQTT_PROP_REASON_STRING:\n    404  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    405  \t\t\tbreak;\n    407  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    408  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    409  \t\t\tpacket__write_uint16(packet, property->value.bin.len);\n    410  \t\t\tpacket__write_bytes(packet, property->value.bin.v, property->value.bin.len);\n    411  \t\t\tbreak;\n    413  \t\tcase MQTT_PROP_USER_PROPERTY:\n    414  \t\t\tpacket__write_string(packet, property->name.v, property->name.len);\n    415  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    416  \t\t\tbreak;\n    418  \t\tdefault:\n    420  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property->identifier);\n    422  \t\t\treturn MOSQ_ERR_INVAL;\n    423  \t}\n    426  }\nFunction: mosquitto_property_read_binary\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1106\n    1106 const mosquitto_property *mosquitto_property_read_binary(const mosquitto_property *proplist, int identifier, void **value, uint16_t *len, bool skip_first)\n    1107 {\n    1109 \tif(!proplist || (value && !len) || (!value && len)) return NULL;\n    1113 \tp = property__get_property(proplist, identifier, skip_first);\n    1114 \tif(!p) return NULL;\n    1115 \tif(p->identifier != MQTT_PROP_CORRELATION_DATA\n    1116 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_DATA){\n    1118 \t\treturn NULL;\n    1119 \t}\n    1121 \tif(value){\n    1122 \t\t*len = p->value.bin.len;\n    1123 \t\t*value = calloc(1, *len + 1U);\n    1124 \t\tif(!(*value)) return NULL;\n    1126 \t\tmemcpy(*value, p->value.bin.v, *len);\n    1127 \t}\n    1130 }\nFunction: mosquitto_property_read_string\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1133\n    1133 const mosquitto_property *mosquitto_property_read_string(const mosquitto_property *proplist, int identifier, char **value, bool skip_first)\n    1134 {\n    1136 \tif(!proplist) return NULL;\n    1138 \tp = property__get_property(proplist, identifier, skip_first);\n    1139 \tif(!p) return NULL;\n    1140 \tif(p->identifier != MQTT_PROP_CONTENT_TYPE\n    1141 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_TOPIC\n    1142 \t\t\t&& p->identifier != MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER\n    1143 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_METHOD\n    1144 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_INFORMATION\n    1145 \t\t\t&& p->identifier != MQTT_PROP_SERVER_REFERENCE\n    1146 \t\t\t&& p->identifier != MQTT_PROP_REASON_STRING){\n    1148 \t\treturn NULL;\n    1149 \t}\n    1151 \tif(value){\n    1152 \t\t*value = calloc(1, (size_t)p->value.s.len+1);\n    1153 \t\tif(!(*value)) return NULL;\n    1155 \t\tmemcpy(*value, p->value.s.v, p->value.s.len);\n    1156 \t}\n    1159 }\nFunction: db__expire_all_messages\nPath: /root/projects/mosquitto/src/database.c:1053\n    1053 void db__expire_all_messages(struct mosquitto *context)\n    1055 \tstruct mosquitto_client_msg *msg, *tmp;\n    1057 \tDL_FOREACH_SAFE(context->msgs_out.inflight, msg, tmp){\n    1058 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1059 \t\t\tif(msg->qos > 0){\n    1060 \t\t\t\tutil__increment_send_quota(context);\n    1062 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1065 \tDL_FOREACH_SAFE(context->msgs_out.queued, msg, tmp){\n    1066 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1067 \t\t\tdb__message_remove_from_queued(&context->msgs_out, msg);\n    1070 \tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n    1071 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1072 \t\t\tif(msg->qos > 0){\n    1073 \t\t\t\tutil__increment_receive_quota(context);\n    1075 \t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n    1078 \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n    1079 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1080 \t\t\tdb__message_remove_from_queued(&context->msgs_in, msg);\n    1083 }\nFunction: db__message_remove_from_queued\nPath: /root/projects/mosquitto/src/database.c:364\n    364  static void db__message_remove_from_queued(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    365  {\n    366  \tif(!msg_data || !item){\n    367  \t\treturn;\n    368  \t}\n    370  \tDL_DELETE(msg_data->queued, item);\n    377  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1183 \tstruct mosquitto_client_msg *tail, *tmp;\n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1190 \tDL_FOREACH_SAFE(context->msgs_out.inflight, tail, tmp){\n    1191 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1192 \t\tif(rc) return rc;\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    143  \t\t\t\tin_quota = context->msgs_in.inflight_quota;\n    144  \t\t\t\tout_quota = context->msgs_out.inflight_quota;\n    145  \t\t\t\tin_maximum = context->msgs_in.inflight_maximum;\n    146  \t\t\t\tout_maximum = context->msgs_out.inflight_maximum;\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    154  \t\t\t\tcontext->msgs_in.inflight_quota = in_quota;\n    155  \t\t\t\tcontext->msgs_out.inflight_quota = out_quota;\n    156  \t\t\t\tcontext->msgs_in.inflight_maximum = in_maximum;\n    157  \t\t\t\tcontext->msgs_out.inflight_maximum = out_maximum;\n    159  \t\t\t\tdb__message_reconnect_reset(context);\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    215  \trc = acl__find_acls(context);\n    216  \tif(rc){\n    218  \t\treturn rc;\n    219  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    250  \t}\n    252  \tcontext->ping_t = 0;\n    253  \tcontext->is_dropping = false;\n    255  \tconnection_check_acl(context, &context->msgs_in.inflight);\n    256  \tconnection_check_acl(context, &context->msgs_in.queued);\n    257  \tconnection_check_acl(context, &context->msgs_out.inflight);\n    258  \tconnection_check_acl(context, &context->msgs_out.queued);\n    260  \tcontext__add_to_by_id(context);\n    263  \tif(!context->clean_start){\n    267  \tcontext->max_qos = context->listener->max_qos;\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    315  \tkeepalive__add(context);\n    317  \tmosquitto__set_state(context, mosq_cs_active);\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    320  \tif(rc) return rc;\n    321  \tdb__expire_all_messages(context);\n    322  \trc = db__message_write_queued_out(context);\n    323  \tif(rc) return rc;\n    324  \trc = db__message_write_inflight_out_all(context);\n    330  }\nFunction: connection_check_acl\nPath: /root/projects/mosquitto/src/handle_connect.c:86\n    86   static void connection_check_acl(struct mosquitto *context, struct mosquitto_client_msg **head)\n    97   \t\tif(mosquitto_acl_check(context, msg_tail->store->topic,\n    99   \t\t\t\t\t\t\t   msg_tail->store->qos, msg_tail->store->retain, access) != MOSQ_ERR_SUCCESS){\n    101  \t\t\tDL_DELETE((*head), msg_tail);\n    107  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    248  \tmosquitto__set_state(context, mosq_cs_disused);\n    250  \tif(context->id){\n    251  \t\tcontext__remove_from_by_id(context);\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    256  \tcontext->for_free_next = db.ll_for_free;\n    257  \tdb.ll_for_free = context;\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    296  \t\tcontext->in_by_id = true;\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__msg_add_to_queued_stats\nPath: /root/projects/mosquitto/src/database.c:162\n    162  void db__msg_add_to_queued_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    163  {\n    164  \tmsg_data->queued_count++;\n    165  \tmsg_data->queued_bytes += msg->store->payloadlen;\n    166  \tif(msg->qos != 0){\n    167  \t\tmsg_data->queued_count12++;\n    168  \t\tmsg_data->queued_bytes12 += msg->store->payloadlen;\n    169  \t}\n    170  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    271  \tmosquitto__free(store->source_id);\n    272  \tmosquitto__free(store->source_username);\n    283  }\nFunction: db__message_remove_from_inflight\nPath: /root/projects/mosquitto/src/database.c:347\n    347  static void db__message_remove_from_inflight(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    348  {\n    349  \tif(!msg_data || !item){\n    350  \t\treturn;\n    351  \t}\n    353  \tDL_DELETE(msg_data->inflight, item);\n    354  \tif(item->store){\n    355  \t\tdb__msg_remove_from_inflight_stats(msg_data, item);\n    357  \t}\n    361  }\nFunction: db__message_write_inflight_out_latest\nPath: /root/projects/mosquitto/src/database.c:1198\n    1198 int db__message_write_inflight_out_latest(struct mosquitto *context)\n    1199 {\n    1200 \tstruct mosquitto_client_msg *tail, *next;\n    1203 \tif(context->state != mosq_cs_active\n    1204 \t\t\t|| context->sock == INVALID_SOCKET\n    1205 \t\t\t|| context->msgs_out.inflight == NULL){\n    1207 \t\treturn MOSQ_ERR_SUCCESS;\n    1208 \t}\n    1210 \tif(context->msgs_out.inflight->prev == context->msgs_out.inflight){\n    1212 \t\treturn db__message_write_inflight_out_single(context, context->msgs_out.inflight);\n    1213 \t}\n    1217 \ttail = context->msgs_out.inflight->prev;\n    1218 \twhile(tail != context->msgs_out.inflight &&\n    1219 \t\t\t(tail->state == mosq_ms_publish_qos0\n    1220 \t\t\t || tail->state == mosq_ms_publish_qos1\n    1221 \t\t\t || tail->state == mosq_ms_publish_qos2)){\n    1223 \t\ttail = tail->prev;\n    1224 \t}\n    1229 \tif(tail != context->msgs_out.inflight){\n    1230 \t\ttail = tail->next;\n    1231 \t}\n    1233 \twhile(tail){\n    1234 \t\tnext = tail->next;\n    1235 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1236 \t\tif(rc) return rc;\n    1238 \t}\n    1240 }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1097 \tuint32_t expiry_interval;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1103 \t\t\tif(msg->direction == mosq_md_out && msg->qos > 0){\n    1104 \t\t\t\tutil__increment_send_quota(context);\n    1105 \t\t\t}\n    1106 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1126 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1135 \t\t\t\tmsg->timestamp = db.now_s;\n    1136 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1137 \t\t\t\tmsg->state = mosq_ms_wait_for_puback;\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1139 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1148 \t\t\t\tmsg->timestamp = db.now_s;\n    1149 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1150 \t\t\t\tmsg->state = mosq_ms_wait_for_pubrec;\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1152 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1159 \t\t\trc = send__pubrel(context, mid, NULL);\n    1160 \t\t\tif(!rc){\n    1161 \t\t\t\tmsg->state = mosq_ms_wait_for_pubcomp;\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1176 \t}\n    1178 }\nFunction: db__msg_remove_from_inflight_stats\nPath: /root/projects/mosquitto/src/database.c:151\n    151  static void db__msg_remove_from_inflight_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    152  {\n    153  \tmsg_data->inflight_count--;\n    154  \tmsg_data->inflight_bytes -= msg->store->payloadlen;\n    155  \tif(msg->qos != 0){\n    156  \t\tmsg_data->inflight_count12--;\n    157  \t\tmsg_data->inflight_bytes12 -= msg->store->payloadlen;\n    158  \t}\n    159  }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    449  \tstruct mosquitto_msg_data *msg_data;\n    450  \tenum mosquitto_msg_state state = mosq_ms_invalid;\n    452  \tint i;\n    457  \tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n    459  \tif(dir == mosq_md_out){\n    460  \t\tmsg_data = &context->msgs_out;\n    461  \t}else{\n    462  \t\tmsg_data = &context->msgs_in;\n    463  \t}\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    484  \tif(context->sock == INVALID_SOCKET){\n    486  \t\tif(qos == 0 && !db.config->queue_qos0_messages){\n    487  \t\t\tif(!context->bridge){\n    489  \t\t\t\treturn 2;\n    490  \t\t\t}else{\n    491  \t\t\t\tif(context->bridge->start_type != bst_lazy){\n    493  \t\t\t\t\treturn 2;\n    494  \t\t\t\t}\n    495  \t\t\t}\n    496  \t\t}\n    497  \t\tif(context->bridge && context->bridge->clean_start_local == true){\n    499  \t\t\treturn 2;\n    500  \t\t}\n    501  \t}\n    503  \tif(context->sock != INVALID_SOCKET){\n    504  \t\tif(db__ready_for_flight(context, dir, qos)){\n    517  \t\t\t}else{\n    520  \t\t\t\t}else{\n    522  \t\t\t\t\treturn 1;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n    528  \t\t}else{\n    530  \t\t\tif(context->is_dropping == false){\n    531  \t\t\t\tcontext->is_dropping = true;\n    532  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    534  \t\t\t\t\t\tcontext->id);\n    535  \t\t\t}\n    538  \t\t\treturn 2;\n    539  \t\t}\n    540  \t}else{\n    541  \t\tif (db__ready_for_queue(context, qos, msg_data)){\n    543  \t\t}else{\n    545  \t\t\tif(context->is_dropping == false){\n    546  \t\t\t\tcontext->is_dropping = true;\n    547  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    549  \t\t\t\t\t\tcontext->id);\n    550  \t\t\t}\n    552  \t\t\treturn 2;\n    553  \t\t}\n    554  \t}\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    582  \tif(state == mosq_ms_queued){\n    583  \t\tDL_APPEND(msg_data->queued, msg);\n    585  \t}else{\n    586  \t\tDL_APPEND(msg_data->inflight, msg);\n    588  \t}\n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    598  \t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n    599  \t\tif(dest_ids){\n    602  \t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t}\n    609  \t}\n    611  \tif(context->bridge && context->bridge->start_type == bst_lazy\n    612  \t\t\t&& context->sock == INVALID_SOCKET\n    613  \t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n    616  \t}\n    633  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    704  \tstruct mosquitto_msg_store *stored;\n    705  \tconst char *source_id;\n    706  \tenum mosquitto_msg_origin origin;\n    710  \tstored = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    711  \tif(stored == NULL) return MOSQ_ERR_NOMEM;\n    713  \tstored->topic = mosquitto__strdup(topic);\n    714  \tif(stored->topic == NULL){\n    715  \t\tdb__msg_store_free(stored);\n    716  \t\treturn MOSQ_ERR_INVAL;\n    717  \t}\n    719  \tstored->qos = qos;\n    720  \tif(db.config->retain_available == false){\n    721  \t\tstored->retain = 0;\n    722  \t}else{\n    723  \t\tstored->retain = retain;\n    724  \t}\n    726  \tstored->payloadlen = payloadlen;\n    727  \tif(payloadlen > 0){\n    728  \t\tstored->payload = mosquitto__malloc(stored->payloadlen+1);\n    729  \t\tif(stored->payload == NULL){\n    730  \t\t\tdb__msg_store_free(stored);\n    731  \t\t\treturn MOSQ_ERR_NOMEM;\n    732  \t\t}\n    734  \t\t((uint8_t *)stored->payload)[stored->payloadlen] = 0;\n    735  \t\tmemcpy(stored->payload, payload, stored->payloadlen);\n    736  \t}\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    746  \t}\n    748  \tif(context){\n    750  \t}else{\n    753  \tif(db__message_store(context, stored, message_expiry_interval, 0, origin)) return 1;\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    763  \tif(source && source->id){\n    764  \t\tstored->source_id = mosquitto__strdup(source->id);\n    765  \t}else{\n    766  \t\tstored->source_id = mosquitto__strdup(\"\");\n    767  \t}\n    768  \tif(!stored->source_id){\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    774  \tif(source && source->username){\n    775  \t\tstored->source_username = mosquitto__strdup(source->username);\n    776  \t\tif(!stored->source_username){\n    778  \t\t\treturn MOSQ_ERR_NOMEM;\n    779  \t\t}\n    780  \t}\n    781  \tif(source){\n    782  \t\tstored->source_listener = source->listener;\n    783  \t}\n    806  }\nFunction: db__message_reconnect_reset\nPath: /root/projects/mosquitto/src/database.c:960\n    960  int db__message_reconnect_reset(struct mosquitto *context)\n    961  {\n    964  \trc = db__message_reconnect_reset_outgoing(context);\n    965  \tif(rc) return rc;\n    966  \treturn db__message_reconnect_reset_incoming(context);\n    967  }\nFunction: db__message_reconnect_reset_incoming\nPath: /root/projects/mosquitto/src/database.c:900\n    900  static int db__message_reconnect_reset_incoming(struct mosquitto *context)\n    902  \tstruct mosquitto_client_msg *msg, *tmp;\n    904  \tcontext->msgs_in.inflight_bytes = 0;\n    905  \tcontext->msgs_in.inflight_bytes12 = 0;\n    906  \tcontext->msgs_in.inflight_count = 0;\n    907  \tcontext->msgs_in.inflight_count12 = 0;\n    908  \tcontext->msgs_in.queued_bytes = 0;\n    909  \tcontext->msgs_in.queued_bytes12 = 0;\n    910  \tcontext->msgs_in.queued_count = 0;\n    911  \tcontext->msgs_in.queued_count12 = 0;\n    912  \tcontext->msgs_in.inflight_quota = context->msgs_in.inflight_maximum;\n    914  \tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n    915  \t\tdb__msg_add_to_inflight_stats(&context->msgs_in, msg);\n    916  \t\tif(msg->qos > 0){\n    917  \t\t\tutil__decrement_receive_quota(context);\n    920  \t\tif(msg->qos != 2){\n    923  \t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n    927  \t\t\tmsg->dup = 0;\n    937  \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n    938  \t\tmsg->dup = 0;\n    939  \t\tdb__msg_add_to_queued_stats(&context->msgs_in, msg);\n    940  \t\tif(db__ready_for_flight(context, mosq_md_in, msg->qos)){\n    941  \t\t\tswitch(msg->qos){\n    943  \t\t\t\t\tmsg->state = mosq_ms_publish_qos0;\n    946  \t\t\t\t\tmsg->state = mosq_ms_publish_qos1;\n    949  \t\t\t\t\tmsg->state = mosq_ms_publish_qos2;\n    952  \t\t\tdb__message_dequeue_first(context, &context->msgs_in);\n    957  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    448  \tX509 *client_cert = NULL;\n    460  \tif(!context->listener){\n    461  \t\treturn MOSQ_ERR_INVAL;\n    462  \t}\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    502  \t\tcontext->protocol = mosq_p_mqtt31;\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    504  \t\t\tcontext->is_bridge = true;\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    508  \t\t\tcontext->protocol = mosq_p_mqtt311;\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    511  \t\t\t\tcontext->is_bridge = true;\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    514  \t\t\tcontext->protocol = mosq_p_mqtt5;\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    563  \t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid Will QoS in CONNECT from %s.\",\n    564  \t\t\t\tcontext->address);\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    724  \tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    731  \t\tif(!context->ssl){\n    732  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    741  \t\tif(context->listener->psk_hint){\n    743  \t\t\tif(!context->username){\n    744  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    754  \t\t\tclient_cert = SSL_get_peer_certificate(context->ssl);\n    755  \t\t\tif(!client_cert){\n    756  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    764  \t\t\tname = X509_get_subject_name(client_cert);\n    765  \t\t\tif(!name){\n    766  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    774  \t\t\tif (context->listener->use_identity_as_username) { /* use_identity_as_username */\n    775  \t\t\t\ti = X509_NAME_get_index_by_NID(name, NID_commonName, -1);\n    776  \t\t\t\tif(i == -1){\n    777  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    785  \t\t\t\tname_entry = X509_NAME_get_entry(name, i);\n    786  \t\t\t\tif(name_entry){\n    787  \t\t\t\t\tname_asn1 = X509_NAME_ENTRY_get_data(name_entry);\n    788  \t\t\t\t\tif (name_asn1 == NULL) {\n    789  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    801  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_get0_data(name_asn1);\n    803  \t\t\t\t\tif(mosquitto_validate_utf8(new_username, (int)strlen(new_username))){\n    804  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    809  \t\t\t\t\t\tX509_free(client_cert);\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    814  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    824  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    835  \t\t\t\tX509_NAME_print_ex(subject_bio, X509_get_subject_name(client_cert), 0, XN_FLAG_RFC2253);\n    847  \t\t\t\tcontext->username = subject;\n    849  \t\t\tif(!context->username){\n    853  \t\t\tX509_free(client_cert);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    898  \t\t\tmosquitto__set_state(context, mosq_cs_authenticating);\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    905  \t\t\twill__clear(context);\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    925  \t\tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    973  \tif(client_cert) X509_free(client_cert);\n    976  \tcontext->clean_start = true;\n    977  \tcontext->session_expiry_interval = 0;\n    978  \tcontext->will_delay_interval = 0;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    55   \tint i;\n    56   \tint pos;\n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    335  \tint rc = MOSQ_ERR_SUCCESS;\n    337  \tuint16_t tlen;\n    340  \tuint16_t payloadlen;\n    341  \tmosquitto_property *properties = NULL;\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    349  \t\trc = property__read_all(CMD_WILL, &context->in_packet, &properties);\n    350  \t\tif(rc) goto error_cleanup;\n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    353  \t\tmosquitto_property_free_all(&properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    356  \trc = packet__read_string(&context->in_packet, &will_struct->msg.topic, &tlen);\n    357  \tif(rc) goto error_cleanup;\n    363  \tif(context->listener->mount_point){\n    364  \t\tslen = strlen(context->listener->mount_point) + strlen(will_struct->msg.topic) + 1;\n    365  \t\twill_topic_mount = mosquitto__malloc(slen+1);\n    366  \t\tif(!will_topic_mount){\n    368  \t\t\tgoto error_cleanup;\n    369  \t\t}\n    371  \t\tsnprintf(will_topic_mount, slen, \"%s%s\", context->listener->mount_point, will_struct->msg.topic);\n    372  \t\twill_topic_mount[slen] = '\\0';\n    374  \t\tmosquitto__free(will_struct->msg.topic);\n    375  \t\twill_struct->msg.topic = will_topic_mount;\n    376  \t}\n    378  \tif(!strncmp(will_struct->msg.topic, \"$CONTROL/\", strlen(\"$CONTROL/\"))){\n    380  \t\tgoto error_cleanup;\n    381  \t}\n    382  \trc = mosquitto_pub_topic_check(will_struct->msg.topic);\n    385  \trc = packet__read_uint16(&context->in_packet, &payloadlen);\n    386  \tif(rc) goto error_cleanup;\n    388  \twill_struct->msg.payloadlen = payloadlen;\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    391  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Client %s connected with too large Will payload\", client_id);\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    393  \t\t\t\tsend__connack(context, 0, MQTT_RC_PACKET_TOO_LARGE, NULL);\n    394  \t\t\t}else{\n    395  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    396  \t\t\t}\n    397  \t\t\trc = MOSQ_ERR_PAYLOAD_SIZE;\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    400  \t\twill_struct->msg.payload = mosquitto__malloc((size_t)will_struct->msg.payloadlen);\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    406  \t\trc = packet__read_bytes(&context->in_packet, will_struct->msg.payload, (uint32_t)will_struct->msg.payloadlen);\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    416  error_cleanup:\n    417  \tif(will_struct){\n    418  \t\tmosquitto__free(will_struct->msg.topic);\n    419  \t\tmosquitto__free(will_struct->msg.payload);\n    422  \t}\n    424  }\nFunction: net__write\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:996\n    996  ssize_t net__write(struct mosquitto *mosq, const void *buf, size_t count)\n    997  {\n    999  \tint ret;\n    1001 \tassert(mosq);\n    1005 \tif(mosq->ssl){\n    1007 \t\tmosq->want_write = false;\n    1008 \t\tret = SSL_write(mosq->ssl, buf, (int)count);\n    1009 \t\tif(ret < 0){\n    1010 \t\t\tret = net__handle_ssl(mosq, ret);\n    1011 \t\t}\n    1012 \t\treturn (ssize_t )ret;\n    1013 \t}else{\n    1017 \treturn send(mosq->sock, buf, count, MSG_NOSIGNAL);\n    1020 \t}\n    1022 }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    51   \tassert(packet);\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__write_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:61\n    61   void packet__write_byte(struct mosquitto__packet *packet, uint8_t byte)\n    64   \tassert(packet->pos+1 <= packet->packet_length);\n    66   \tpacket->payload[packet->pos] = byte;\n    67   \tpacket->pos++;\n    68   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    73   \tassert(packet);\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__write_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:83\n    83   void packet__write_bytes(struct mosquitto__packet *packet, const void *bytes, uint32_t count)\n    84   {\n    86   \tassert(packet->pos+count <= packet->packet_length);\n    88   \tif(count > 0){\n    89   \t\tmemcpy(&(packet->payload[packet->pos]), bytes, count);\n    90   \t\tpacket->pos += count;\n    91   \t}\n    92   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    157  \tassert(packet);\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: property__get_property\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:988\n    988  static const mosquitto_property *property__get_property(const mosquitto_property *proplist, int identifier, bool skip_first)\n    989  {\n    990  \tconst mosquitto_property *p;\n    995  \twhile(p){\n    996  \t\tif(p->identifier == identifier){\n    997  \t\t\tif(!is_first || !skip_first){\n    998  \t\t\t\treturn p;\n    999  \t\t\t}\n    1001 \t\t}\n    1002 \t\tp = p->next;\n    1003 \t}\n    1005 }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    371  \t\tmux__delete(context);\n    372  \t\tcontext__disconnect(context);\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto__malloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:83\n    83   void *mosquitto__malloc(size_t size)\n    84   {\n    88   \tif(mem_limit && memcount + size > mem_limit){\n    89   \t\treturn NULL;\n    90   \t}\n    93   \tmem = malloc(size);\n    96   \tif(mem){\n    97   \t\tmemcount += malloc_usable_size(mem);\n    101  \t}\n    105  }\nFunction: mosquitto__strdup\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:144\n    144  char *mosquitto__strdup(const char *s)\n    145  {\n    148  \tif(mem_limit && memcount + strlen(s) > mem_limit){\n    149  \t\treturn NULL;\n    150  \t}\n    152  \tstr = strdup(s);\n    155  \tif(str){\n    156  \t\tmemcount += malloc_usable_size(str);\n    160  \t}\n    164  }\nFunction: mosquitto_free\nPath: /root/projects/mosquitto/src/memory_public.c:27\n    27   void mosquitto_free(void *mem)\n    29   \tmosquitto__free(mem);\n    30   }\nFunction: mosquitto_malloc\nPath: /root/projects/mosquitto/src/memory_public.c:32\n    32   void *mosquitto_malloc(size_t size)\n    34   \treturn mosquitto__malloc(size);\n    35   }\nFunction: mux__delete\nPath: /root/projects/mosquitto/src/mux.c:61\n    61   int mux__delete(struct mosquitto *context)\n    64   \treturn mux_epoll__delete(context);\n    68   }\nFunction: send__auth\nPath: /root/projects/mosquitto/src/send_auth.c:28\n    28   int send__auth(struct mosquitto *context, uint8_t reason_code, const void *auth_data, uint16_t auth_data_len)\n    29   {\n    32   \tmosquitto_property *properties = NULL;\n    35   \tif(context->auth_method == NULL) return MOSQ_ERR_INVAL;\n    36   \tif(context->protocol != mosq_p_mqtt5) return MOSQ_ERR_PROTOCOL;\n    38   \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending AUTH to %s (rc%d, %s)\", context->id, reason_code, context->auth_method);\n    42   \trc = mosquitto_property_add_string(&properties, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method);\n    43   \tif(rc){\n    45   \t\treturn rc;\n    46   \t}\n    56   \tremaining_length += property__get_remaining_length(properties);\n    58   \tif(packet__check_oversize(context, remaining_length)){\n    59   \t\tmosquitto_property_free_all(&properties);\n    60   \t\tmosquitto__free(packet);\n    61   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    62   \t}\n    67   \tpacket->command = CMD_AUTH;\n    68   \tpacket->remaining_length = remaining_length;\n    70   \trc = packet__alloc(packet);\n    76   \tpacket__write_byte(packet, reason_code);\n    77   \tproperty__write_all(packet, properties, true);\n    80   \treturn packet__queue(context, packet);\n    81   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    32   \tmosquitto_property *connack_props = NULL;\n    33   \tuint32_t remaining_length;\n    35   \trc = mosquitto_property_copy_all(&connack_props, properties);\n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    43   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->address, ack, reason_code);\n    44   \t}\n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    51   \t\t\tif(rc){\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    58   \t\t\tif(rc){\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    65   \t\t\tif(rc){\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    71   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_MAXIMUM_QOS, context->listener->max_qos);\n    72   \t\t\tif(rc){\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    78   \t\tremaining_length += property__get_remaining_length(connack_props);\n    79   \t}\n    81   \tif(packet__check_oversize(context, remaining_length)){\n    82   \t\tmosquitto_property_free_all(&connack_props);\n    83   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    84   \t}\n    92   \tpacket->command = CMD_CONNACK;\n    93   \tpacket->remaining_length = remaining_length;\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    105  \t}\n    108  \treturn packet__queue(context, packet);\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    42   \tassert(mosq);\n    45   \tif(mosq->bridge){\n    46   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Bridge %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    47   \t}else\n    56   \tassert(mosq);\n    60   \tpacket->command = CMD_DISCONNECT;\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    62   \t\tpacket->remaining_length = 1;\n    63   \t\tif(properties){\n    64   \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    65   \t\t}\n    66   \t}else{\n    67   \t\tpacket->remaining_length = 0;\n    68   \t}\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    80   \t}\n    82   \treturn packet__queue(mosq, packet);\n    83   }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    126  \tassert(mosq);\n    130  \tpacket->command = command;\n    131  \tif(dup){\n    132  \t\tpacket->command |= 8;\n    133  \t}\n    134  \tpacket->remaining_length = 2;\n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    137  \t\tif(reason_code != 0 || properties){\n    138  \t\t\tpacket->remaining_length += 1;\n    139  \t\t}\n    141  \t\tif(properties){\n    142  \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    143  \t\t}\n    144  \t}\n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    161  \t}\n    163  \treturn packet__queue(mosq, packet);\n    164  }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    117  \treturn send__command_with_mid(mosq, CMD_PUBREL|2, mid, false, 0, properties);\n    118  }\nFunction: send__publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:42\n    42   int send__publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    43   {\n    47   \tint i;\n    49   \tbool match;\n    51   \tchar *mapped_topic = NULL;\n    55   \tassert(mosq);\n    60   \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    63   \tif(!mosq->retain_available){\n    65   \t}\n    68   \tif(mosq->listener && mosq->listener->mount_point){\n    69   \t\tlen = strlen(mosq->listener->mount_point);\n    70   \t\tif(len < strlen(topic)){\n    71   \t\t\ttopic += len;\n    72   \t\t}else{\n    74   \t\t\treturn MOSQ_ERR_SUCCESS;\n    75   \t\t}\n    76   \t}\n    78   \tif(mosq->bridge && mosq->bridge->topics && mosq->bridge->topic_remapping){\n    79   \t\tfor(i=0; i<mosq->bridge->topic_count; i++){\n    80   \t\t\tcur_topic = &mosq->bridge->topics[i];\n    81   \t\t\tif((cur_topic->direction == bd_both || cur_topic->direction == bd_out)\n    82   \t\t\t\t\t&& (cur_topic->remote_prefix || cur_topic->local_prefix)){\n    85   \t\t\t\trc = mosquitto_topic_matches_sub(cur_topic->local_topic, topic, &match);\n    86   \t\t\t\tif(rc){\n    87   \t\t\t\t\treturn rc;\n    88   \t\t\t\t}\n    89   \t\t\t\tif(match){\n    90   \t\t\t\t\tmapped_topic = mosquitto__strdup(topic);\n    91   \t\t\t\t\tif(!mapped_topic) return MOSQ_ERR_NOMEM;\n    92   \t\t\t\t\tif(cur_topic->local_prefix){\n    94   \t\t\t\t\t\tif(!strncmp(cur_topic->local_prefix, mapped_topic, strlen(cur_topic->local_prefix))){\n    95   \t\t\t\t\t\t\ttopic_temp = mosquitto__strdup(mapped_topic+strlen(cur_topic->local_prefix));\n    96   \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    97   \t\t\t\t\t\t\tif(!topic_temp){\n    98   \t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    99   \t\t\t\t\t\t\t}\n    101  \t\t\t\t\t\t}\n    102  \t\t\t\t\t}\n    104  \t\t\t\t\tif(cur_topic->remote_prefix){\n    106  \t\t\t\t\t\tlen = strlen(mapped_topic) + strlen(cur_topic->remote_prefix)+1;\n    107  \t\t\t\t\t\ttopic_temp = mosquitto__malloc(len+1);\n    108  \t\t\t\t\t\tif(!topic_temp){\n    109  \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    110  \t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    111  \t\t\t\t\t\t}\n    112  \t\t\t\t\t\tsnprintf(topic_temp, len, \"%s%s\", cur_topic->remote_prefix, mapped_topic);\n    113  \t\t\t\t\t\ttopic_temp[len] = '\\0';\n    114  \t\t\t\t\t\tmosquitto__free(mapped_topic);\n    116  \t\t\t\t\t}\n    117  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, mapped_topic, (long)payloadlen);\n    119  \t\t\t\t\trc =  send__real_publish(mosq, mid, mapped_topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    120  \t\t\t\t\tmosquitto__free(mapped_topic);\n    121  \t\t\t\t\treturn rc;\n    122  \t\t\t\t}\n    123  \t\t\t}\n    124  \t\t}\n    125  \t}\n    127  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, topic, (long)payloadlen);\n    133  \treturn send__real_publish(mosq, mid, topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    134  }\nFunction: send__real_publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:137\n    137  int send__real_publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    138  {\n    140  \tunsigned int packetlen;\n    141  \tunsigned int proplen = 0, varbytes;\n    143  \tmosquitto_property expiry_prop;\n    145  \tassert(mosq);\n    147  \tif(topic){\n    148  \t\tpacketlen = 2+(unsigned int)strlen(topic) + payloadlen;\n    149  \t}else{\n    150  \t\tpacketlen = 2 + payloadlen;\n    151  \t}\n    152  \tif(qos > 0) packetlen += 2; /* For message id */\n    153  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tproplen += property__get_length_all(cmsg_props);\n    156  \t\tproplen += property__get_length_all(store_props);\n    157  \t\tif(expiry_interval > 0){\n    158  \t\t\texpiry_prop.next = NULL;\n    160  \t\t\texpiry_prop.identifier = MQTT_PROP_MESSAGE_EXPIRY_INTERVAL;\n    163  \t\t\tproplen += property__get_length_all(&expiry_prop);\n    164  \t\t}\n    166  \t\tvarbytes = packet__varint_bytes(proplen);\n    172  \t\t}else{\n    173  \t\t\tpacketlen += proplen + varbytes;\n    174  \t\t}\n    175  \t}\n    176  \tif(packet__check_oversize(mosq, packetlen)){\n    177  #ifdef WITH_BROKER\n    178  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Dropping too large outgoing PUBLISH for %s (%d bytes)\", SAFE_PRINT(mosq->id), packetlen);\n    179  #else\n    180  \t\tlog__printf(mosq, MOSQ_LOG_NOTICE, \"Dropping too large outgoing PUBLISH (%d bytes)\", packetlen);\n    181  #endif\n    182  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    183  \t}\n    189  \tpacket->command = (uint8_t)(CMD_PUBLISH | (uint8_t)((dup&0x1)<<3) | (uint8_t)(qos<<1) | retain);\n    190  \tpacket->remaining_length = packetlen;\n    206  \tif(mosq->protocol == mosq_p_mqtt5){\n    213  \t}\n    220  \treturn packet__queue(mosq, packet);\n    221  }\nFunction: session_expiry__cmp\nPath: /root/projects/mosquitto/src/session_expiry.c:34\n    34   static int session_expiry__cmp(struct session_expiry_list *i1, struct session_expiry_list *i2)\n    35   {\n    36   \tif(i1->context->session_expiry_time == i2->context->session_expiry_time){\n    37   \t\treturn 0;\n    38   \t}else if(i1->context->session_expiry_time > i2->context->session_expiry_time){\n    39   \t\treturn 1;\n    40   \t}else{\n    41   \t\treturn -1;\n    42   \t}\n    43   }\nFunction: session_expiry__remove\nPath: /root/projects/mosquitto/src/session_expiry.c:121\n    121  void session_expiry__remove(struct mosquitto *context)\n    122  {\n    123  \tif(context->expiry_list_item){\n    124  \t\tDL_DELETE(expiry_list, context->expiry_list_item);\n    125  \t\tmosquitto__free(context->expiry_list_item);\n    126  \t\tcontext->expiry_list_item = NULL;\n    127  \t}\n    128  }\nFunction: acl__check_single\nPath: /root/projects/mosquitto/src/security.c:602\n    602  static int acl__check_single(struct mosquitto__auth_plugin_config *auth_plugin, struct mosquitto *context, struct mosquitto_acl_msg *msg, int access)\n    603  {\n    607  \tusername = mosquitto_client_username(context);\n    608  \tif(auth_plugin->deny_special_chars == true){\n    615  \t\tif(username && strpbrk(username, \"+#\")){\n    616  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous username \\\"%s\\\"\", username);\n    617  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    618  \t\t}\n    619  \t\tif(context->id && strpbrk(context->id, \"+#\")){\n    620  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous client id \\\"%s\\\"\", context->id);\n    621  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    622  \t\t}\n    623  \t}\n    625  \tif(auth_plugin->plugin.version == 4){\n    626  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    627  \t\t\treturn MOSQ_ERR_SUCCESS;\n    628  \t\t}\n    629  \t\treturn auth_plugin->plugin.acl_check_v4(auth_plugin->plugin.user_data, access, context, msg);\n    630  \t}else if(auth_plugin->plugin.version == 3){\n    631  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    632  \t\t\treturn MOSQ_ERR_SUCCESS;\n    633  \t\t}\n    634  \t\treturn auth_plugin->plugin.acl_check_v3(auth_plugin->plugin.user_data, access, context, msg);\n    635  \t}else if(auth_plugin->plugin.version == 2){\n    636  \t\tif(access == MOSQ_ACL_SUBSCRIBE || access == MOSQ_ACL_UNSUBSCRIBE){\n    637  \t\t\treturn MOSQ_ERR_SUCCESS;\n    638  \t\t}\n    639  \t\treturn auth_plugin->plugin.acl_check_v2(auth_plugin->plugin.user_data, context->id, username, topic, access);\n    640  \t}else{\n    641  \t\treturn MOSQ_ERR_INVAL;\n    642  \t}\n    643  }\nFunction: sub__remove_shared_leaf\nPath: /root/projects/mosquitto/src/subs.c:190\n    190  static void sub__remove_shared_leaf(struct mosquitto__subhier *subhier, struct mosquitto__subshared *shared, struct mosquitto__subleaf *leaf)\n    191  {\n    192  \tDL_DELETE(shared->subs, leaf);\n    193  \tif(shared->subs == NULL){\n    194  \t\tHASH_DELETE(hh, subhier->shared, shared);\n    195  \t\tmosquitto__free(shared->name);\n    196  \t\tmosquitto__free(shared);\n    197  \t}\n    199  }\nFunction: sub__messages_queue\nPath: /root/projects/mosquitto/src/subs.c:659\n    659  int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n    660  {\n    661  \tint rc = MOSQ_ERR_SUCCESS, rc2;\n    662  \tint rc_normal = MOSQ_ERR_NO_SUBSCRIBERS, rc_shared = MOSQ_ERR_NO_SUBSCRIBERS;\n    663  \tstruct mosquitto__subhier *subhier;\n    664  \tchar **split_topics = NULL;\n    677  \tHASH_FIND(hh, db.normal_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    678  \tif(subhier){\n    679  \t\trc_normal = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    680  \t\tif(rc_normal > 0){\n    682  \t\t\tgoto end;\n    683  \t\t}\n    684  \t}\n    686  \tHASH_FIND(hh, db.shared_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    687  \tif(subhier){\n    688  \t\trc_shared = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    689  \t\tif(rc_shared > 0){\n    691  \t\t\tgoto end;\n    692  \t\t}\n    693  \t}\n    695  \tif(rc_normal == MOSQ_ERR_NO_SUBSCRIBERS && rc_shared == MOSQ_ERR_NO_SUBSCRIBERS){\n    697  \t}\n    711  }\nFunction: sub__search\nPath: /root/projects/mosquitto/src/subs.c:479\n    479  static int sub__search(struct mosquitto__subhier *subhier, char **split_topics, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    480  {\n    482  \tstruct mosquitto__subhier *branch;\n    486  \tif(split_topics && split_topics[0]){\n    488  \t\tHASH_FIND(hh, subhier->children, split_topics[0], strlen(split_topics[0]), branch);\n    490  \t\tif(branch){\n    491  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    492  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    494  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    495  \t\t\t\treturn rc;\n    496  \t\t\t}\n    497  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    498  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    499  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    501  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    502  \t\t\t\t\treturn rc;\n    503  \t\t\t\t}\n    504  \t\t\t}\n    505  \t\t}\n    508  \t\tHASH_FIND(hh, subhier->children, \"+\", 1, branch);\n    510  \t\tif(branch){\n    511  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    512  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    514  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    515  \t\t\t\treturn rc;\n    516  \t\t\t}\n    517  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    518  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    519  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    521  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    522  \t\t\t\t\treturn rc;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}\n    526  \t}\n    529  \tHASH_FIND(hh, subhier->children, \"#\", 1, branch);\n    530  \tif(branch && !branch->children){\n    535  \t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    536  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    538  \t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    539  \t\t\treturn rc;\n    540  \t\t}\n    541  \t}\n    548  }\nFunction: subs__process\nPath: /root/projects/mosquitto/src/subs.c:129\n    129  static int subs__process(struct mosquitto__subhier *hier, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    130  {\n    133  \tstruct mosquitto__subleaf *leaf;\n    135  \trc = subs__shared_process(hier, topic, qos, retain, stored);\n    137  \tleaf = hier->subs;\n    138  \twhile(source_id && leaf){\n    139  \t\tif(!leaf->context->id || (leaf->no_local && !strcmp(leaf->context->id, source_id))){\n    140  \t\t\tleaf = leaf->next;\n    142  \t\t}\n    147  \t\tleaf = leaf->next;\n    148  \t}\n    149  \tif(hier->subs || hier->shared){\n    150  \t\treturn rc;\n    151  \t}else{\n    152  \t\treturn MOSQ_ERR_NO_SUBSCRIBERS;\n    153  \t}\n    154  }\nFunction: subs__send\nPath: /root/projects/mosquitto/src/subs.c:63\n    63   static int subs__send(struct mosquitto__subleaf *leaf, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    64   {\n    65   \tbool client_retain;\n    66   \tuint16_t mid;\n    67   \tuint8_t client_qos, msg_qos;\n    68   \tmosquitto_property *properties = NULL;\n    72   \trc2 = mosquitto_acl_check(leaf->context, topic, stored->payloadlen, stored->payload, stored->qos, stored->retain, MOSQ_ACL_READ);\n    73   \tif(rc2 == MOSQ_ERR_ACL_DENIED){\n    74   \t\treturn MOSQ_ERR_SUCCESS;\n    75   \t}else if(rc2 == MOSQ_ERR_SUCCESS){\n    76   \t\tclient_qos = leaf->qos;\n    87   \t\tif(msg_qos){\n    88   \t\t\tmid = mosquitto__mid_generate(leaf->context);\n    89   \t\t}else{\n    92   \t\tif(leaf->retain_as_published){\n    93   \t\t\tclient_retain = retain;\n    94   \t\t}else{\n    97   \t\tif(leaf->identifier){\n    98   \t\t\tmosquitto_property_add_varint(&properties, MQTT_PROP_SUBSCRIPTION_IDENTIFIER, leaf->identifier);\n    99   \t\t}\n    100  \t\tif(db__message_insert(leaf->context, mid, mosq_md_out, msg_qos, client_retain, stored, properties, true) == 1){\n    101  \t\t\treturn 1;\n    102  \t\t}\n    103  \t}else{\n    104  \t\treturn 1; /* Application error */\n    105  \t}\n    107  }\nFunction: sub__clean_session\nPath: /root/projects/mosquitto/src/subs.c:746\n    746  int sub__clean_session(struct mosquitto *context)\n    747  {\n    748  \tint i;\n    749  \tstruct mosquitto__subleaf *leaf;\n    750  \tstruct mosquitto__subhier *hier;\n    752  \tfor(i=0; i<context->sub_count; i++){\n    753  \t\tif(context->subs[i] == NULL){\n    755  \t\t}\n    757  \t\thier = context->subs[i]->hier;\n    759  \t\tif(context->subs[i]->shared){\n    760  \t\t\tleaf = context->subs[i]->shared->subs;\n    761  \t\t\twhile(leaf){\n    762  \t\t\t\tif(leaf->context==context){\n    766  \t\t\t\t\tsub__remove_shared_leaf(context->subs[i]->hier, context->subs[i]->shared, leaf);\n    768  \t\t\t\t}\n    769  \t\t\t\tleaf = leaf->next;\n    770  \t\t\t}\n    771  \t\t}else{\n    772  \t\t\tleaf = hier->subs;\n    773  \t\t\twhile(leaf){\n    774  \t\t\t\tif(leaf->context==context){\n    778  \t\t\t\t\tDL_DELETE(hier->subs, leaf);\n    779  \t\t\t\t\tmosquitto__free(leaf);\n    781  \t\t\t\t}\n    782  \t\t\t\tleaf = leaf->next;\n    783  \t\t\t}\n    784  \t\t}\n    785  \t\tmosquitto__free(context->subs[i]);\n    786  \t\tcontext->subs[i] = NULL;\n    788  \t\tif(hier->subs == NULL\n    789  \t\t\t\t&& hier->children == NULL\n    790  \t\t\t\t&& hier->shared == NULL\n    791  \t\t\t\t&& hier->parent){\n    794  \t\t\t\thier = tmp_remove_subs(hier);\n    795  \t\t\t}while(hier);\n    796  \t\t}\n    797  \t}\n    798  \tmosquitto__free(context->subs);\n    799  \tcontext->subs = NULL;\n    800  \tcontext->sub_count = 0;\n    803  }\nFunction: tmp_remove_subs\nPath: /root/projects/mosquitto/src/subs.c:715\n    715  static struct mosquitto__subhier *tmp_remove_subs(struct mosquitto__subhier *sub)\n    716  {\n    719  \tif(!sub || !sub->parent){\n    720  \t\treturn NULL;\n    721  \t}\n    723  \tif(sub->children || sub->subs){\n    724  \t\treturn NULL;\n    725  \t}\n    727  \tparent = sub->parent;\n    728  \tHASH_DELETE(hh, parent->children, sub);\n    729  \tmosquitto__free(sub->topic);\n    730  \tmosquitto__free(sub);\n    732  \tif(parent->subs == NULL\n    733  \t\t\t&& parent->children == NULL\n    734  \t\t\t&& parent->shared == NULL\n    735  \t\t\t&& parent->parent){\n    737  \t\treturn parent;\n    738  \t}else{\n    739  \t\treturn NULL;\n    740  \t}\n    741  }\nFunction: util__increment_send_quota\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:222\n    222  void util__increment_send_quota(struct mosquitto *mosq)\n    223  {\n    224  \tif(mosq->msgs_out.inflight_quota < mosq->msgs_out.inflight_maximum){\n    225  \t\tmosq->msgs_out.inflight_quota++;\n    226  \t}\n    227  }\nFunction: will_delay__remove\nPath: /root/projects/mosquitto/src/will_delay.c:99\n    99   void will_delay__remove(struct mosquitto *mosq)\n    100  {\n    101  \tif(mosq->will_delay_entry != NULL){\n    102  \t\tDL_DELETE(delay_list, mosq->will_delay_entry);\n    103  \t\tmosquitto__free(mosq->will_delay_entry);\n    104  \t\tmosq->will_delay_entry = NULL;\n    105  \t}\n    106  }\nFunction: will__clear\nPath: /root/projects/mosquitto/src/../lib/will_mosq.c:111\n    111  int will__clear(struct mosquitto *mosq)\n    112  {\n    113  \tif(!mosq->will) return MOSQ_ERR_SUCCESS;\n    115  \tmosquitto__free(mosq->will->msg.topic);\n    116  \tmosq->will->msg.topic = NULL;\n    118  \tmosquitto__free(mosq->will->msg.payload);\n    119  \tmosq->will->msg.payload = NULL;\n    121  \tmosquitto_property_free_all(&mosq->will->properties);\n    123  \tmosquitto__free(mosq->will);\n    124  \tmosq->will = NULL;\n    125  \tmosq->will_delay_interval = 0;\n    128  }\n",
    "If the Protocol Version is not 5 and the Server does not want to accept the CONNECT packet, the Server MAY send a CONNACK packet with Reason Code 0x84 (Unsupported Protocol Version) and then MUST close the Network Connection [MQTT-3.1.2-2].": "Function: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    94   \tpacket->command = 0;\n    97   \tpacket->remaining_length = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    150  \tpacket->pos = 0;\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    345  \t}\n    353  }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    205  \t\tfound_context->clean_start = true;\n    213  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    247  \t\t} else {\n    250  \t}\n    263  \tif(!context->clean_start){\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    320  \tif(rc) return rc;\n    330  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    499  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    521  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    557  \t}else{\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    976  \tcontext->clean_start = true;\n    980  }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    393  \t\t\t\tsend__connack(context, 0, MQTT_RC_PACKET_TOO_LARGE, NULL);\n    394  \t\t\t}else{\n    395  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    396  \t\t\t}\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    410  \twill_struct->msg.qos = will_qos;\n    424  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\n",
    "If the Password Flag is set to 0, a Password MUST NOT be present in the Payload [MQTT-3.1.2-18].": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    221  \tplugin__handle_disconnect(context, -1);\n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    226  \tif(context->bridge == NULL)\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    232  \t\t\tif(context->will_delay_interval == 0){\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    147  \tassert(mosq);\n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    153  \tpacket->next = NULL;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    187  \treturn packet__write(mosq);\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    353  }\nFunction: property__process_connect\nPath: /root/projects/mosquitto/src/property_broker.c:30\n    30   int property__process_connect(struct mosquitto *context, mosquitto_property **props)\n    31   {\n    32   \tmosquitto_property *p;\n    34   \tp = *props;\n    36   \twhile(p){\n    37   \t\tif(p->identifier == MQTT_PROP_SESSION_EXPIRY_INTERVAL){\n    38   \t\t\tcontext->session_expiry_interval = p->value.i32;\n    39   \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM){\n    40   \t\t\tif(p->value.i16 == 0){\n    41   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    42   \t\t\t}\n    44   \t\t\tcontext->msgs_out.inflight_maximum = p->value.i16;\n    45   \t\t\tcontext->msgs_out.inflight_quota = context->msgs_out.inflight_maximum;\n    46   \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    47   \t\t\tif(p->value.i32 == 0){\n    48   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    49   \t\t\t}\n    50   \t\t\tcontext->maximum_packet_size = p->value.i32;\n    51   \t\t}\n    52   \t\tp = p->next;\n    53   \t}\n    56   }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__read\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:35\n    35   static int property__read(struct mosquitto__packet *packet, uint32_t *len, mosquitto_property *property)\n    36   {\n    38   \tuint32_t property_identifier;\n    39   \tuint8_t byte;\n    40   \tuint8_t byte_count;\n    41   \tuint16_t uint16;\n    42   \tuint32_t uint32;\n    43   \tuint32_t varint;\n    44   \tchar *str1, *str2;\n    45   \tuint16_t slen1, slen2;\n    47   \tif(!property) return MOSQ_ERR_INVAL;\n    49   \trc = packet__read_varint(packet, &property_identifier, NULL);\n    50   \tif(rc){\n    51   \t\treturn rc;\n    52   \t}\n    55   \tmemset(property, 0, sizeof(mosquitto_property));\n    57   \tproperty->identifier = (int32_t)property_identifier;\n    59   \tswitch(property_identifier){\n    60   \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    61   \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    62   \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    63   \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    64   \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    65   \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    66   \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    67   \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    68   \t\t\trc = packet__read_byte(packet, &byte);\n    69   \t\t\tif(rc) return rc;\n    71   \t\t\tproperty->value.i8 = byte;\n    72   \t\t\tbreak;\n    74   \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    75   \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    76   \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    77   \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    78   \t\t\trc = packet__read_uint16(packet, &uint16);\n    79   \t\t\tif(rc) return rc;\n    81   \t\t\tproperty->value.i16 = uint16;\n    82   \t\t\tbreak;\n    84   \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    85   \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    86   \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    87   \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    88   \t\t\trc = packet__read_uint32(packet, &uint32);\n    89   \t\t\tif(rc) return rc;\n    91   \t\t\tproperty->value.i32 = uint32;\n    92   \t\t\tbreak;\n    94   \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    95   \t\t\trc = packet__read_varint(packet, &varint, &byte_count);\n    96   \t\t\tif(rc) return rc;\n    98   \t\t\tproperty->value.varint = varint;\n    99   \t\t\tbreak;\n    101  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    102  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    103  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    104  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    105  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    106  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    107  \t\tcase MQTT_PROP_REASON_STRING:\n    108  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    109  \t\t\tif(rc) return rc;\n    111  \t\t\tproperty->value.s.v = str1;\n    112  \t\t\tproperty->value.s.len = slen1;\n    113  \t\t\tbreak;\n    115  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    116  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    117  \t\t\trc = packet__read_binary(packet, (uint8_t **)&str1, &slen1);\n    118  \t\t\tif(rc) return rc;\n    120  \t\t\tproperty->value.bin.v = str1;\n    121  \t\t\tproperty->value.bin.len = slen1;\n    122  \t\t\tbreak;\n    124  \t\tcase MQTT_PROP_USER_PROPERTY:\n    125  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    126  \t\t\tif(rc) return rc;\n    129  \t\t\trc = packet__read_string(packet, &str2, &slen2);\n    130  \t\t\tif(rc){\n    131  \t\t\t\tmosquitto__free(str1);\n    132  \t\t\t\treturn rc;\n    133  \t\t\t}\n    136  \t\t\tproperty->name.v = str1;\n    137  \t\t\tproperty->name.len = slen1;\n    138  \t\t\tproperty->value.s.v = str2;\n    139  \t\t\tproperty->value.s.len = slen2;\n    140  \t\t\tbreak;\n    142  \t\tdefault:\n    144  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property_identifier);\n    146  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    147  \t}\n    150  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: mosquitto_property_read_string\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1133\n    1133 const mosquitto_property *mosquitto_property_read_string(const mosquitto_property *proplist, int identifier, char **value, bool skip_first)\n    1134 {\n    1136 \tif(!proplist) return NULL;\n    1138 \tp = property__get_property(proplist, identifier, skip_first);\n    1139 \tif(!p) return NULL;\n    1140 \tif(p->identifier != MQTT_PROP_CONTENT_TYPE\n    1141 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_TOPIC\n    1142 \t\t\t&& p->identifier != MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER\n    1143 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_METHOD\n    1144 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_INFORMATION\n    1145 \t\t\t&& p->identifier != MQTT_PROP_SERVER_REFERENCE\n    1146 \t\t\t&& p->identifier != MQTT_PROP_REASON_STRING){\n    1148 \t\treturn NULL;\n    1149 \t}\n    1151 \tif(value){\n    1152 \t\t*value = calloc(1, (size_t)p->value.s.len+1);\n    1153 \t\tif(!(*value)) return NULL;\n    1155 \t\tmemcpy(*value, p->value.s.v, p->value.s.len);\n    1156 \t}\n    1159 }\nFunction: db__expire_all_messages\nPath: /root/projects/mosquitto/src/database.c:1053\n    1053 void db__expire_all_messages(struct mosquitto *context)\n    1055 \tstruct mosquitto_client_msg *msg, *tmp;\n    1057 \tDL_FOREACH_SAFE(context->msgs_out.inflight, msg, tmp){\n    1058 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1059 \t\t\tif(msg->qos > 0){\n    1060 \t\t\t\tutil__increment_send_quota(context);\n    1062 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1065 \tDL_FOREACH_SAFE(context->msgs_out.queued, msg, tmp){\n    1066 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1067 \t\t\tdb__message_remove_from_queued(&context->msgs_out, msg);\n    1070 \tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n    1071 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1072 \t\t\tif(msg->qos > 0){\n    1073 \t\t\t\tutil__increment_receive_quota(context);\n    1075 \t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n    1078 \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n    1079 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1080 \t\t\tdb__message_remove_from_queued(&context->msgs_in, msg);\n    1083 }\nFunction: db__message_remove_from_queued\nPath: /root/projects/mosquitto/src/database.c:364\n    364  static void db__message_remove_from_queued(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    365  {\n    366  \tif(!msg_data || !item){\n    367  \t\treturn;\n    368  \t}\n    370  \tDL_DELETE(msg_data->queued, item);\n    377  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1183 \tstruct mosquitto_client_msg *tail, *tmp;\n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1190 \tDL_FOREACH_SAFE(context->msgs_out.inflight, tail, tmp){\n    1191 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1192 \t\tif(rc) return rc;\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    143  \t\t\t\tin_quota = context->msgs_in.inflight_quota;\n    144  \t\t\t\tout_quota = context->msgs_out.inflight_quota;\n    145  \t\t\t\tin_maximum = context->msgs_in.inflight_maximum;\n    146  \t\t\t\tout_maximum = context->msgs_out.inflight_maximum;\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    154  \t\t\t\tcontext->msgs_in.inflight_quota = in_quota;\n    155  \t\t\t\tcontext->msgs_out.inflight_quota = out_quota;\n    156  \t\t\t\tcontext->msgs_in.inflight_maximum = in_maximum;\n    157  \t\t\t\tcontext->msgs_out.inflight_maximum = out_maximum;\n    159  \t\t\t\tdb__message_reconnect_reset(context);\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    215  \trc = acl__find_acls(context);\n    216  \tif(rc){\n    218  \t\treturn rc;\n    219  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    250  \t}\n    252  \tcontext->ping_t = 0;\n    253  \tcontext->is_dropping = false;\n    255  \tconnection_check_acl(context, &context->msgs_in.inflight);\n    256  \tconnection_check_acl(context, &context->msgs_in.queued);\n    257  \tconnection_check_acl(context, &context->msgs_out.inflight);\n    258  \tconnection_check_acl(context, &context->msgs_out.queued);\n    260  \tcontext__add_to_by_id(context);\n    263  \tif(!context->clean_start){\n    267  \tcontext->max_qos = context->listener->max_qos;\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    315  \tkeepalive__add(context);\n    317  \tmosquitto__set_state(context, mosq_cs_active);\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    320  \tif(rc) return rc;\n    321  \tdb__expire_all_messages(context);\n    322  \trc = db__message_write_queued_out(context);\n    323  \tif(rc) return rc;\n    324  \trc = db__message_write_inflight_out_all(context);\n    330  }\nFunction: connection_check_acl\nPath: /root/projects/mosquitto/src/handle_connect.c:86\n    86   static void connection_check_acl(struct mosquitto *context, struct mosquitto_client_msg **head)\n    97   \t\tif(mosquitto_acl_check(context, msg_tail->store->topic,\n    99   \t\t\t\t\t\t\t   msg_tail->store->qos, msg_tail->store->retain, access) != MOSQ_ERR_SUCCESS){\n    101  \t\t\tDL_DELETE((*head), msg_tail);\n    107  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    248  \tmosquitto__set_state(context, mosq_cs_disused);\n    250  \tif(context->id){\n    251  \t\tcontext__remove_from_by_id(context);\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    256  \tcontext->for_free_next = db.ll_for_free;\n    257  \tdb.ll_for_free = context;\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    296  \t\tcontext->in_by_id = true;\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__msg_add_to_queued_stats\nPath: /root/projects/mosquitto/src/database.c:162\n    162  void db__msg_add_to_queued_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    163  {\n    164  \tmsg_data->queued_count++;\n    165  \tmsg_data->queued_bytes += msg->store->payloadlen;\n    166  \tif(msg->qos != 0){\n    167  \t\tmsg_data->queued_count12++;\n    168  \t\tmsg_data->queued_bytes12 += msg->store->payloadlen;\n    169  \t}\n    170  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    271  \tmosquitto__free(store->source_id);\n    272  \tmosquitto__free(store->source_username);\n    283  }\nFunction: db__message_remove_from_inflight\nPath: /root/projects/mosquitto/src/database.c:347\n    347  static void db__message_remove_from_inflight(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    348  {\n    349  \tif(!msg_data || !item){\n    350  \t\treturn;\n    351  \t}\n    353  \tDL_DELETE(msg_data->inflight, item);\n    354  \tif(item->store){\n    355  \t\tdb__msg_remove_from_inflight_stats(msg_data, item);\n    357  \t}\n    361  }\nFunction: db__message_write_inflight_out_latest\nPath: /root/projects/mosquitto/src/database.c:1198\n    1198 int db__message_write_inflight_out_latest(struct mosquitto *context)\n    1199 {\n    1200 \tstruct mosquitto_client_msg *tail, *next;\n    1203 \tif(context->state != mosq_cs_active\n    1204 \t\t\t|| context->sock == INVALID_SOCKET\n    1205 \t\t\t|| context->msgs_out.inflight == NULL){\n    1207 \t\treturn MOSQ_ERR_SUCCESS;\n    1208 \t}\n    1210 \tif(context->msgs_out.inflight->prev == context->msgs_out.inflight){\n    1212 \t\treturn db__message_write_inflight_out_single(context, context->msgs_out.inflight);\n    1213 \t}\n    1217 \ttail = context->msgs_out.inflight->prev;\n    1218 \twhile(tail != context->msgs_out.inflight &&\n    1219 \t\t\t(tail->state == mosq_ms_publish_qos0\n    1220 \t\t\t || tail->state == mosq_ms_publish_qos1\n    1221 \t\t\t || tail->state == mosq_ms_publish_qos2)){\n    1223 \t\ttail = tail->prev;\n    1224 \t}\n    1229 \tif(tail != context->msgs_out.inflight){\n    1230 \t\ttail = tail->next;\n    1231 \t}\n    1233 \twhile(tail){\n    1234 \t\tnext = tail->next;\n    1235 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1236 \t\tif(rc) return rc;\n    1238 \t}\n    1240 }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1097 \tuint32_t expiry_interval;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1103 \t\t\tif(msg->direction == mosq_md_out && msg->qos > 0){\n    1104 \t\t\t\tutil__increment_send_quota(context);\n    1105 \t\t\t}\n    1106 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1126 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1135 \t\t\t\tmsg->timestamp = db.now_s;\n    1136 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1137 \t\t\t\tmsg->state = mosq_ms_wait_for_puback;\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1139 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1148 \t\t\t\tmsg->timestamp = db.now_s;\n    1149 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1150 \t\t\t\tmsg->state = mosq_ms_wait_for_pubrec;\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1152 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1159 \t\t\trc = send__pubrel(context, mid, NULL);\n    1160 \t\t\tif(!rc){\n    1161 \t\t\t\tmsg->state = mosq_ms_wait_for_pubcomp;\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1176 \t}\n    1178 }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    449  \tstruct mosquitto_msg_data *msg_data;\n    450  \tenum mosquitto_msg_state state = mosq_ms_invalid;\n    452  \tint i;\n    457  \tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n    459  \tif(dir == mosq_md_out){\n    460  \t\tmsg_data = &context->msgs_out;\n    461  \t}else{\n    462  \t\tmsg_data = &context->msgs_in;\n    463  \t}\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    484  \tif(context->sock == INVALID_SOCKET){\n    486  \t\tif(qos == 0 && !db.config->queue_qos0_messages){\n    487  \t\t\tif(!context->bridge){\n    489  \t\t\t\treturn 2;\n    490  \t\t\t}else{\n    491  \t\t\t\tif(context->bridge->start_type != bst_lazy){\n    493  \t\t\t\t\treturn 2;\n    494  \t\t\t\t}\n    495  \t\t\t}\n    496  \t\t}\n    497  \t\tif(context->bridge && context->bridge->clean_start_local == true){\n    499  \t\t\treturn 2;\n    500  \t\t}\n    501  \t}\n    503  \tif(context->sock != INVALID_SOCKET){\n    504  \t\tif(db__ready_for_flight(context, dir, qos)){\n    517  \t\t\t}else{\n    520  \t\t\t\t}else{\n    522  \t\t\t\t\treturn 1;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n    528  \t\t}else{\n    530  \t\t\tif(context->is_dropping == false){\n    531  \t\t\t\tcontext->is_dropping = true;\n    532  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    534  \t\t\t\t\t\tcontext->id);\n    535  \t\t\t}\n    538  \t\t\treturn 2;\n    539  \t\t}\n    540  \t}else{\n    541  \t\tif (db__ready_for_queue(context, qos, msg_data)){\n    543  \t\t}else{\n    545  \t\t\tif(context->is_dropping == false){\n    546  \t\t\t\tcontext->is_dropping = true;\n    547  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    549  \t\t\t\t\t\tcontext->id);\n    550  \t\t\t}\n    552  \t\t\treturn 2;\n    553  \t\t}\n    554  \t}\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    582  \tif(state == mosq_ms_queued){\n    583  \t\tDL_APPEND(msg_data->queued, msg);\n    585  \t}else{\n    586  \t\tDL_APPEND(msg_data->inflight, msg);\n    588  \t}\n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    598  \t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n    599  \t\tif(dest_ids){\n    602  \t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t}\n    609  \t}\n    611  \tif(context->bridge && context->bridge->start_type == bst_lazy\n    612  \t\t\t&& context->sock == INVALID_SOCKET\n    613  \t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n    616  \t}\n    633  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    704  \tstruct mosquitto_msg_store *stored;\n    705  \tconst char *source_id;\n    706  \tenum mosquitto_msg_origin origin;\n    710  \tstored = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    711  \tif(stored == NULL) return MOSQ_ERR_NOMEM;\n    713  \tstored->topic = mosquitto__strdup(topic);\n    714  \tif(stored->topic == NULL){\n    715  \t\tdb__msg_store_free(stored);\n    716  \t\treturn MOSQ_ERR_INVAL;\n    717  \t}\n    719  \tstored->qos = qos;\n    720  \tif(db.config->retain_available == false){\n    721  \t\tstored->retain = 0;\n    722  \t}else{\n    723  \t\tstored->retain = retain;\n    724  \t}\n    726  \tstored->payloadlen = payloadlen;\n    727  \tif(payloadlen > 0){\n    728  \t\tstored->payload = mosquitto__malloc(stored->payloadlen+1);\n    729  \t\tif(stored->payload == NULL){\n    730  \t\t\tdb__msg_store_free(stored);\n    731  \t\t\treturn MOSQ_ERR_NOMEM;\n    732  \t\t}\n    734  \t\t((uint8_t *)stored->payload)[stored->payloadlen] = 0;\n    735  \t\tmemcpy(stored->payload, payload, stored->payloadlen);\n    736  \t}\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    746  \t}\n    748  \tif(context){\n    750  \t}else{\n    753  \tif(db__message_store(context, stored, message_expiry_interval, 0, origin)) return 1;\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    763  \tif(source && source->id){\n    764  \t\tstored->source_id = mosquitto__strdup(source->id);\n    765  \t}else{\n    766  \t\tstored->source_id = mosquitto__strdup(\"\");\n    767  \t}\n    768  \tif(!stored->source_id){\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    774  \tif(source && source->username){\n    775  \t\tstored->source_username = mosquitto__strdup(source->username);\n    776  \t\tif(!stored->source_username){\n    778  \t\t\treturn MOSQ_ERR_NOMEM;\n    779  \t\t}\n    780  \t}\n    781  \tif(source){\n    782  \t\tstored->source_listener = source->listener;\n    783  \t}\n    806  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    448  \tX509 *client_cert = NULL;\n    460  \tif(!context->listener){\n    461  \t\treturn MOSQ_ERR_INVAL;\n    462  \t}\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    502  \t\tcontext->protocol = mosq_p_mqtt31;\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    504  \t\t\tcontext->is_bridge = true;\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    508  \t\t\tcontext->protocol = mosq_p_mqtt311;\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    511  \t\t\t\tcontext->is_bridge = true;\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    514  \t\t\tcontext->protocol = mosq_p_mqtt5;\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    563  \t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid Will QoS in CONNECT from %s.\",\n    564  \t\t\t\tcontext->address);\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    724  \tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    731  \t\tif(!context->ssl){\n    732  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    741  \t\tif(context->listener->psk_hint){\n    743  \t\t\tif(!context->username){\n    744  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    754  \t\t\tclient_cert = SSL_get_peer_certificate(context->ssl);\n    755  \t\t\tif(!client_cert){\n    756  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    764  \t\t\tname = X509_get_subject_name(client_cert);\n    765  \t\t\tif(!name){\n    766  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    774  \t\t\tif (context->listener->use_identity_as_username) { /* use_identity_as_username */\n    775  \t\t\t\ti = X509_NAME_get_index_by_NID(name, NID_commonName, -1);\n    776  \t\t\t\tif(i == -1){\n    777  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    785  \t\t\t\tname_entry = X509_NAME_get_entry(name, i);\n    786  \t\t\t\tif(name_entry){\n    787  \t\t\t\t\tname_asn1 = X509_NAME_ENTRY_get_data(name_entry);\n    788  \t\t\t\t\tif (name_asn1 == NULL) {\n    789  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    801  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_get0_data(name_asn1);\n    803  \t\t\t\t\tif(mosquitto_validate_utf8(new_username, (int)strlen(new_username))){\n    804  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    809  \t\t\t\t\t\tX509_free(client_cert);\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    814  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    824  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    835  \t\t\t\tX509_NAME_print_ex(subject_bio, X509_get_subject_name(client_cert), 0, XN_FLAG_RFC2253);\n    847  \t\t\t\tcontext->username = subject;\n    849  \t\t\tif(!context->username){\n    853  \t\t\tX509_free(client_cert);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    898  \t\t\tmosquitto__set_state(context, mosq_cs_authenticating);\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    905  \t\t\twill__clear(context);\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    925  \t\tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    973  \tif(client_cert) X509_free(client_cert);\n    976  \tcontext->clean_start = true;\n    977  \tcontext->session_expiry_interval = 0;\n    978  \tcontext->will_delay_interval = 0;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    55   \tint i;\n    56   \tint pos;\n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    349  \t\trc = property__read_all(CMD_WILL, &context->in_packet, &properties);\n    350  \t\tif(rc) goto error_cleanup;\n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    356  \trc = packet__read_string(&context->in_packet, &will_struct->msg.topic, &tlen);\n    363  \tif(context->listener->mount_point){\n    364  \t\tslen = strlen(context->listener->mount_point) + strlen(will_struct->msg.topic) + 1;\n    366  \t\tif(!will_topic_mount){\n    368  \t\t\tgoto error_cleanup;\n    369  \t\t}\n    371  \t\tsnprintf(will_topic_mount, slen, \"%s%s\", context->listener->mount_point, will_struct->msg.topic);\n    374  \t\tmosquitto__free(will_struct->msg.topic);\n    375  \t\twill_struct->msg.topic = will_topic_mount;\n    376  \t}\n    378  \tif(!strncmp(will_struct->msg.topic, \"$CONTROL/\", strlen(\"$CONTROL/\"))){\n    380  \t\tgoto error_cleanup;\n    381  \t}\n    382  \trc = mosquitto_pub_topic_check(will_struct->msg.topic);\n    385  \trc = packet__read_uint16(&context->in_packet, &payloadlen);\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    391  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Client %s connected with too large Will payload\", client_id);\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    394  \t\t\t}else{\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    400  \t\twill_struct->msg.payload = mosquitto__malloc((size_t)will_struct->msg.payloadlen);\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    406  \t\trc = packet__read_bytes(&context->in_packet, will_struct->msg.payload, (uint32_t)will_struct->msg.payloadlen);\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    416  error_cleanup:\n    417  \tif(will_struct){\n    418  \t\tmosquitto__free(will_struct->msg.topic);\n    419  \t\tmosquitto__free(will_struct->msg.payload);\n    422  \t}\n    424  }\nFunction: net__write\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:996\n    996  ssize_t net__write(struct mosquitto *mosq, const void *buf, size_t count)\n    997  {\n    999  \tint ret;\n    1001 \tassert(mosq);\n    1005 \tif(mosq->ssl){\n    1007 \t\tmosq->want_write = false;\n    1008 \t\tret = SSL_write(mosq->ssl, buf, (int)count);\n    1009 \t\tif(ret < 0){\n    1010 \t\t\tret = net__handle_ssl(mosq, ret);\n    1011 \t\t}\n    1012 \t\treturn (ssize_t )ret;\n    1013 \t}else{\n    1017 \treturn send(mosq->sock, buf, count, MSG_NOSIGNAL);\n    1020 \t}\n    1022 }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    51   \tassert(packet);\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    73   \tassert(packet);\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    106  \t\t*length = 0;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    157  \tassert(packet);\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    371  \t\tmux__delete(context);\n    372  \t\tcontext__disconnect(context);\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto__malloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:83\n    83   void *mosquitto__malloc(size_t size)\n    84   {\n    88   \tif(mem_limit && memcount + size > mem_limit){\n    89   \t\treturn NULL;\n    90   \t}\n    93   \tmem = malloc(size);\n    96   \tif(mem){\n    97   \t\tmemcount += malloc_usable_size(mem);\n    101  \t}\n    105  }\nFunction: mosquitto__strdup\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:144\n    144  char *mosquitto__strdup(const char *s)\n    145  {\n    148  \tif(mem_limit && memcount + strlen(s) > mem_limit){\n    149  \t\treturn NULL;\n    150  \t}\n    152  \tstr = strdup(s);\n    155  \tif(str){\n    156  \t\tmemcount += malloc_usable_size(str);\n    160  \t}\n    164  }\nFunction: mosquitto_free\nPath: /root/projects/mosquitto/src/memory_public.c:27\n    27   void mosquitto_free(void *mem)\n    29   \tmosquitto__free(mem);\n    30   }\nFunction: mosquitto_malloc\nPath: /root/projects/mosquitto/src/memory_public.c:32\n    32   void *mosquitto_malloc(size_t size)\n    34   \treturn mosquitto__malloc(size);\n    35   }\nFunction: mux__delete\nPath: /root/projects/mosquitto/src/mux.c:61\n    61   int mux__delete(struct mosquitto *context)\n    64   \treturn mux_epoll__delete(context);\n    68   }\nFunction: send__auth\nPath: /root/projects/mosquitto/src/send_auth.c:28\n    28   int send__auth(struct mosquitto *context, uint8_t reason_code, const void *auth_data, uint16_t auth_data_len)\n    29   {\n    32   \tmosquitto_property *properties = NULL;\n    35   \tif(context->auth_method == NULL) return MOSQ_ERR_INVAL;\n    36   \tif(context->protocol != mosq_p_mqtt5) return MOSQ_ERR_PROTOCOL;\n    38   \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending AUTH to %s (rc%d, %s)\", context->id, reason_code, context->auth_method);\n    42   \trc = mosquitto_property_add_string(&properties, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method);\n    43   \tif(rc){\n    45   \t\treturn rc;\n    46   \t}\n    56   \tremaining_length += property__get_remaining_length(properties);\n    58   \tif(packet__check_oversize(context, remaining_length)){\n    61   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    62   \t}\n    67   \tpacket->command = CMD_AUTH;\n    68   \tpacket->remaining_length = remaining_length;\n    70   \trc = packet__alloc(packet);\n    76   \tpacket__write_byte(packet, reason_code);\n    77   \tproperty__write_all(packet, properties, true);\n    80   \treturn packet__queue(context, packet);\n    81   }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    126  \tassert(mosq);\n    130  \tpacket->command = command;\n    131  \tif(dup){\n    132  \t\tpacket->command |= 8;\n    133  \t}\n    134  \tpacket->remaining_length = 2;\n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    137  \t\tif(reason_code != 0 || properties){\n    138  \t\t\tpacket->remaining_length += 1;\n    139  \t\t}\n    141  \t\tif(properties){\n    142  \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    143  \t\t}\n    144  \t}\n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    161  \t}\n    163  \treturn packet__queue(mosq, packet);\n    164  }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    117  \treturn send__command_with_mid(mosq, CMD_PUBREL|2, mid, false, 0, properties);\n    118  }\nFunction: send__publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:42\n    42   int send__publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    43   {\n    47   \tint i;\n    49   \tbool match;\n    51   \tchar *mapped_topic = NULL;\n    55   \tassert(mosq);\n    60   \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    63   \tif(!mosq->retain_available){\n    65   \t}\n    68   \tif(mosq->listener && mosq->listener->mount_point){\n    69   \t\tlen = strlen(mosq->listener->mount_point);\n    70   \t\tif(len < strlen(topic)){\n    71   \t\t\ttopic += len;\n    72   \t\t}else{\n    74   \t\t\treturn MOSQ_ERR_SUCCESS;\n    75   \t\t}\n    76   \t}\n    78   \tif(mosq->bridge && mosq->bridge->topics && mosq->bridge->topic_remapping){\n    79   \t\tfor(i=0; i<mosq->bridge->topic_count; i++){\n    80   \t\t\tcur_topic = &mosq->bridge->topics[i];\n    81   \t\t\tif((cur_topic->direction == bd_both || cur_topic->direction == bd_out)\n    82   \t\t\t\t\t&& (cur_topic->remote_prefix || cur_topic->local_prefix)){\n    85   \t\t\t\trc = mosquitto_topic_matches_sub(cur_topic->local_topic, topic, &match);\n    86   \t\t\t\tif(rc){\n    87   \t\t\t\t\treturn rc;\n    88   \t\t\t\t}\n    89   \t\t\t\tif(match){\n    90   \t\t\t\t\tmapped_topic = mosquitto__strdup(topic);\n    91   \t\t\t\t\tif(!mapped_topic) return MOSQ_ERR_NOMEM;\n    92   \t\t\t\t\tif(cur_topic->local_prefix){\n    94   \t\t\t\t\t\tif(!strncmp(cur_topic->local_prefix, mapped_topic, strlen(cur_topic->local_prefix))){\n    95   \t\t\t\t\t\t\ttopic_temp = mosquitto__strdup(mapped_topic+strlen(cur_topic->local_prefix));\n    96   \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    97   \t\t\t\t\t\t\tif(!topic_temp){\n    98   \t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    99   \t\t\t\t\t\t\t}\n    101  \t\t\t\t\t\t}\n    102  \t\t\t\t\t}\n    104  \t\t\t\t\tif(cur_topic->remote_prefix){\n    106  \t\t\t\t\t\tlen = strlen(mapped_topic) + strlen(cur_topic->remote_prefix)+1;\n    107  \t\t\t\t\t\ttopic_temp = mosquitto__malloc(len+1);\n    108  \t\t\t\t\t\tif(!topic_temp){\n    109  \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    110  \t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    111  \t\t\t\t\t\t}\n    112  \t\t\t\t\t\tsnprintf(topic_temp, len, \"%s%s\", cur_topic->remote_prefix, mapped_topic);\n    113  \t\t\t\t\t\ttopic_temp[len] = '\\0';\n    114  \t\t\t\t\t\tmosquitto__free(mapped_topic);\n    116  \t\t\t\t\t}\n    117  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, mapped_topic, (long)payloadlen);\n    119  \t\t\t\t\trc =  send__real_publish(mosq, mid, mapped_topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    120  \t\t\t\t\tmosquitto__free(mapped_topic);\n    121  \t\t\t\t\treturn rc;\n    122  \t\t\t\t}\n    123  \t\t\t}\n    124  \t\t}\n    125  \t}\n    127  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, topic, (long)payloadlen);\n    133  \treturn send__real_publish(mosq, mid, topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    134  }\nFunction: send__real_publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:137\n    137  int send__real_publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    138  {\n    140  \tunsigned int packetlen;\n    141  \tunsigned int proplen = 0, varbytes;\n    143  \tmosquitto_property expiry_prop;\n    145  \tassert(mosq);\n    147  \tif(topic){\n    148  \t\tpacketlen = 2+(unsigned int)strlen(topic) + payloadlen;\n    149  \t}else{\n    150  \t\tpacketlen = 2 + payloadlen;\n    151  \t}\n    152  \tif(qos > 0) packetlen += 2; /* For message id */\n    153  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tproplen += property__get_length_all(cmsg_props);\n    156  \t\tproplen += property__get_length_all(store_props);\n    157  \t\tif(expiry_interval > 0){\n    158  \t\t\texpiry_prop.next = NULL;\n    160  \t\t\texpiry_prop.identifier = MQTT_PROP_MESSAGE_EXPIRY_INTERVAL;\n    163  \t\t\tproplen += property__get_length_all(&expiry_prop);\n    164  \t\t}\n    166  \t\tvarbytes = packet__varint_bytes(proplen);\n    172  \t\t}else{\n    173  \t\t\tpacketlen += proplen + varbytes;\n    174  \t\t}\n    175  \t}\n    176  \tif(packet__check_oversize(mosq, packetlen)){\n    178  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Dropping too large outgoing PUBLISH for %s (%d bytes)\", SAFE_PRINT(mosq->id), packetlen);\n    182  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    183  \t}\n    189  \tpacket->command = (uint8_t)(CMD_PUBLISH | (uint8_t)((dup&0x1)<<3) | (uint8_t)(qos<<1) | retain);\n    190  \tpacket->remaining_length = packetlen;\n    206  \tif(mosq->protocol == mosq_p_mqtt5){\n    213  \t}\n    220  \treturn packet__queue(mosq, packet);\n    221  }\nFunction: session_expiry__cmp\nPath: /root/projects/mosquitto/src/session_expiry.c:34\n    34   static int session_expiry__cmp(struct session_expiry_list *i1, struct session_expiry_list *i2)\n    35   {\n    36   \tif(i1->context->session_expiry_time == i2->context->session_expiry_time){\n    37   \t\treturn 0;\n    38   \t}else if(i1->context->session_expiry_time > i2->context->session_expiry_time){\n    39   \t\treturn 1;\n    40   \t}else{\n    41   \t\treturn -1;\n    42   \t}\n    43   }\nFunction: session_expiry__remove\nPath: /root/projects/mosquitto/src/session_expiry.c:121\n    121  void session_expiry__remove(struct mosquitto *context)\n    122  {\n    123  \tif(context->expiry_list_item){\n    124  \t\tDL_DELETE(expiry_list, context->expiry_list_item);\n    125  \t\tmosquitto__free(context->expiry_list_item);\n    126  \t\tcontext->expiry_list_item = NULL;\n    127  \t}\n    128  }\nFunction: acl__check_single\nPath: /root/projects/mosquitto/src/security.c:602\n    602  static int acl__check_single(struct mosquitto__auth_plugin_config *auth_plugin, struct mosquitto *context, struct mosquitto_acl_msg *msg, int access)\n    603  {\n    607  \tusername = mosquitto_client_username(context);\n    608  \tif(auth_plugin->deny_special_chars == true){\n    615  \t\tif(username && strpbrk(username, \"+#\")){\n    616  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous username \\\"%s\\\"\", username);\n    617  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    618  \t\t}\n    619  \t\tif(context->id && strpbrk(context->id, \"+#\")){\n    620  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous client id \\\"%s\\\"\", context->id);\n    621  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    622  \t\t}\n    623  \t}\n    625  \tif(auth_plugin->plugin.version == 4){\n    626  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    627  \t\t\treturn MOSQ_ERR_SUCCESS;\n    628  \t\t}\n    629  \t\treturn auth_plugin->plugin.acl_check_v4(auth_plugin->plugin.user_data, access, context, msg);\n    630  \t}else if(auth_plugin->plugin.version == 3){\n    631  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    632  \t\t\treturn MOSQ_ERR_SUCCESS;\n    633  \t\t}\n    634  \t\treturn auth_plugin->plugin.acl_check_v3(auth_plugin->plugin.user_data, access, context, msg);\n    635  \t}else if(auth_plugin->plugin.version == 2){\n    636  \t\tif(access == MOSQ_ACL_SUBSCRIBE || access == MOSQ_ACL_UNSUBSCRIBE){\n    637  \t\t\treturn MOSQ_ERR_SUCCESS;\n    638  \t\t}\n    639  \t\treturn auth_plugin->plugin.acl_check_v2(auth_plugin->plugin.user_data, context->id, username, topic, access);\n    640  \t}else{\n    641  \t\treturn MOSQ_ERR_INVAL;\n    642  \t}\n    643  }\nFunction: sub__remove_shared_leaf\nPath: /root/projects/mosquitto/src/subs.c:190\n    190  static void sub__remove_shared_leaf(struct mosquitto__subhier *subhier, struct mosquitto__subshared *shared, struct mosquitto__subleaf *leaf)\n    191  {\n    192  \tDL_DELETE(shared->subs, leaf);\n    193  \tif(shared->subs == NULL){\n    194  \t\tHASH_DELETE(hh, subhier->shared, shared);\n    195  \t\tmosquitto__free(shared->name);\n    196  \t\tmosquitto__free(shared);\n    197  \t}\n    199  }\nFunction: sub__messages_queue\nPath: /root/projects/mosquitto/src/subs.c:659\n    659  int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n    660  {\n    661  \tint rc = MOSQ_ERR_SUCCESS, rc2;\n    662  \tint rc_normal = MOSQ_ERR_NO_SUBSCRIBERS, rc_shared = MOSQ_ERR_NO_SUBSCRIBERS;\n    663  \tstruct mosquitto__subhier *subhier;\n    664  \tchar **split_topics = NULL;\n    677  \tHASH_FIND(hh, db.normal_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    678  \tif(subhier){\n    679  \t\trc_normal = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    680  \t\tif(rc_normal > 0){\n    682  \t\t\tgoto end;\n    683  \t\t}\n    684  \t}\n    686  \tHASH_FIND(hh, db.shared_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    687  \tif(subhier){\n    688  \t\trc_shared = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    689  \t\tif(rc_shared > 0){\n    691  \t\t\tgoto end;\n    692  \t\t}\n    693  \t}\n    695  \tif(rc_normal == MOSQ_ERR_NO_SUBSCRIBERS && rc_shared == MOSQ_ERR_NO_SUBSCRIBERS){\n    697  \t}\n    711  }\nFunction: sub__search\nPath: /root/projects/mosquitto/src/subs.c:479\n    479  static int sub__search(struct mosquitto__subhier *subhier, char **split_topics, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    480  {\n    482  \tstruct mosquitto__subhier *branch;\n    486  \tif(split_topics && split_topics[0]){\n    488  \t\tHASH_FIND(hh, subhier->children, split_topics[0], strlen(split_topics[0]), branch);\n    490  \t\tif(branch){\n    491  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    492  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    494  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    495  \t\t\t\treturn rc;\n    496  \t\t\t}\n    497  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    498  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    499  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    501  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    502  \t\t\t\t\treturn rc;\n    503  \t\t\t\t}\n    504  \t\t\t}\n    505  \t\t}\n    508  \t\tHASH_FIND(hh, subhier->children, \"+\", 1, branch);\n    510  \t\tif(branch){\n    511  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    512  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    514  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    515  \t\t\t\treturn rc;\n    516  \t\t\t}\n    517  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    518  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    519  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    521  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    522  \t\t\t\t\treturn rc;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}\n    526  \t}\n    529  \tHASH_FIND(hh, subhier->children, \"#\", 1, branch);\n    530  \tif(branch && !branch->children){\n    535  \t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    536  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    538  \t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    539  \t\t\treturn rc;\n    540  \t\t}\n    541  \t}\n    548  }\nFunction: subs__process\nPath: /root/projects/mosquitto/src/subs.c:129\n    129  static int subs__process(struct mosquitto__subhier *hier, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    130  {\n    133  \tstruct mosquitto__subleaf *leaf;\n    135  \trc = subs__shared_process(hier, topic, qos, retain, stored);\n    137  \tleaf = hier->subs;\n    138  \twhile(source_id && leaf){\n    139  \t\tif(!leaf->context->id || (leaf->no_local && !strcmp(leaf->context->id, source_id))){\n    140  \t\t\tleaf = leaf->next;\n    142  \t\t}\n    147  \t\tleaf = leaf->next;\n    148  \t}\n    149  \tif(hier->subs || hier->shared){\n    150  \t\treturn rc;\n    151  \t}else{\n    152  \t\treturn MOSQ_ERR_NO_SUBSCRIBERS;\n    153  \t}\n    154  }\nFunction: subs__send\nPath: /root/projects/mosquitto/src/subs.c:63\n    63   static int subs__send(struct mosquitto__subleaf *leaf, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    64   {\n    65   \tbool client_retain;\n    66   \tuint16_t mid;\n    67   \tuint8_t client_qos, msg_qos;\n    68   \tmosquitto_property *properties = NULL;\n    72   \trc2 = mosquitto_acl_check(leaf->context, topic, stored->payloadlen, stored->payload, stored->qos, stored->retain, MOSQ_ACL_READ);\n    73   \tif(rc2 == MOSQ_ERR_ACL_DENIED){\n    74   \t\treturn MOSQ_ERR_SUCCESS;\n    75   \t}else if(rc2 == MOSQ_ERR_SUCCESS){\n    76   \t\tclient_qos = leaf->qos;\n    87   \t\tif(msg_qos){\n    88   \t\t\tmid = mosquitto__mid_generate(leaf->context);\n    89   \t\t}else{\n    92   \t\tif(leaf->retain_as_published){\n    93   \t\t\tclient_retain = retain;\n    94   \t\t}else{\n    97   \t\tif(leaf->identifier){\n    98   \t\t\tmosquitto_property_add_varint(&properties, MQTT_PROP_SUBSCRIPTION_IDENTIFIER, leaf->identifier);\n    99   \t\t}\n    100  \t\tif(db__message_insert(leaf->context, mid, mosq_md_out, msg_qos, client_retain, stored, properties, true) == 1){\n    101  \t\t\treturn 1;\n    102  \t\t}\n    103  \t}else{\n    104  \t\treturn 1; /* Application error */\n    105  \t}\n    107  }\nFunction: sub__clean_session\nPath: /root/projects/mosquitto/src/subs.c:746\n    746  int sub__clean_session(struct mosquitto *context)\n    747  {\n    748  \tint i;\n    749  \tstruct mosquitto__subleaf *leaf;\n    750  \tstruct mosquitto__subhier *hier;\n    752  \tfor(i=0; i<context->sub_count; i++){\n    753  \t\tif(context->subs[i] == NULL){\n    755  \t\t}\n    757  \t\thier = context->subs[i]->hier;\n    759  \t\tif(context->subs[i]->shared){\n    760  \t\t\tleaf = context->subs[i]->shared->subs;\n    761  \t\t\twhile(leaf){\n    762  \t\t\t\tif(leaf->context==context){\n    766  \t\t\t\t\tsub__remove_shared_leaf(context->subs[i]->hier, context->subs[i]->shared, leaf);\n    768  \t\t\t\t}\n    769  \t\t\t\tleaf = leaf->next;\n    770  \t\t\t}\n    771  \t\t}else{\n    772  \t\t\tleaf = hier->subs;\n    773  \t\t\twhile(leaf){\n    774  \t\t\t\tif(leaf->context==context){\n    778  \t\t\t\t\tDL_DELETE(hier->subs, leaf);\n    779  \t\t\t\t\tmosquitto__free(leaf);\n    781  \t\t\t\t}\n    782  \t\t\t\tleaf = leaf->next;\n    783  \t\t\t}\n    784  \t\t}\n    785  \t\tmosquitto__free(context->subs[i]);\n    786  \t\tcontext->subs[i] = NULL;\n    788  \t\tif(hier->subs == NULL\n    789  \t\t\t\t&& hier->children == NULL\n    790  \t\t\t\t&& hier->shared == NULL\n    791  \t\t\t\t&& hier->parent){\n    794  \t\t\t\thier = tmp_remove_subs(hier);\n    795  \t\t\t}while(hier);\n    796  \t\t}\n    797  \t}\n    798  \tmosquitto__free(context->subs);\n    799  \tcontext->subs = NULL;\n    800  \tcontext->sub_count = 0;\n    803  }\nFunction: tmp_remove_subs\nPath: /root/projects/mosquitto/src/subs.c:715\n    715  static struct mosquitto__subhier *tmp_remove_subs(struct mosquitto__subhier *sub)\n    716  {\n    719  \tif(!sub || !sub->parent){\n    720  \t\treturn NULL;\n    721  \t}\n    723  \tif(sub->children || sub->subs){\n    724  \t\treturn NULL;\n    725  \t}\n    727  \tparent = sub->parent;\n    728  \tHASH_DELETE(hh, parent->children, sub);\n    729  \tmosquitto__free(sub->topic);\n    730  \tmosquitto__free(sub);\n    732  \tif(parent->subs == NULL\n    733  \t\t\t&& parent->children == NULL\n    734  \t\t\t&& parent->shared == NULL\n    735  \t\t\t&& parent->parent){\n    737  \t\treturn parent;\n    738  \t}else{\n    739  \t\treturn NULL;\n    740  \t}\n    741  }\nFunction: util__increment_send_quota\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:222\n    222  void util__increment_send_quota(struct mosquitto *mosq)\n    223  {\n    224  \tif(mosq->msgs_out.inflight_quota < mosq->msgs_out.inflight_maximum){\n    225  \t\tmosq->msgs_out.inflight_quota++;\n    226  \t}\n    227  }\nFunction: will_delay__remove\nPath: /root/projects/mosquitto/src/will_delay.c:99\n    99   void will_delay__remove(struct mosquitto *mosq)\n    100  {\n    101  \tif(mosq->will_delay_entry != NULL){\n    102  \t\tDL_DELETE(delay_list, mosq->will_delay_entry);\n    103  \t\tmosquitto__free(mosq->will_delay_entry);\n    104  \t\tmosq->will_delay_entry = NULL;\n    105  \t}\n    106  }\nFunction: will__clear\nPath: /root/projects/mosquitto/src/../lib/will_mosq.c:111\n    111  int will__clear(struct mosquitto *mosq)\n    112  {\n    113  \tif(!mosq->will) return MOSQ_ERR_SUCCESS;\n    115  \tmosquitto__free(mosq->will->msg.topic);\n    116  \tmosq->will->msg.topic = NULL;\n    118  \tmosquitto__free(mosq->will->msg.payload);\n    119  \tmosq->will->msg.payload = NULL;\n    121  \tmosquitto_property_free_all(&mosq->will->properties);\n    123  \tmosquitto__free(mosq->will);\n    124  \tmosq->will = NULL;\n    125  \tmosq->will_delay_interval = 0;\n    128  }\n",
    "If the User Name Flag is set to 0, a User Name MUST NOT be present in the Payload [MQTT-3.1.2-16].": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    209  \t\t}\n    210  \t}\n    212  }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    205  \t\tfound_context->clean_start = true;\n    213  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    247  \t\t} else {\n    250  \t}\n    263  \tif(!context->clean_start){\n    330  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    465  \tif(context->state != mosq_cs_new){\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    557  \t}else{\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    675  \t\t\trc = MOSQ_ERR_NOMEM;\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    679  \t\t\t\t/* Username flag given, but no username. Ignore. */\n    680  \t\t\t\tusername_flag = 0;\n    681  \t\t\t}else{\n    682  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    689  \t\t\t\t/* username_flag == 0 && password_flag == 1 is forbidden */\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    691  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    743  \t\t\tif(!context->username){\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    847  \t\t\t\tcontext->username = subject;\n    849  \t\t\tif(!context->username){\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    976  \tcontext->clean_start = true;\n    980  }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    410  \twill_struct->msg.qos = will_qos;\n    424  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    54   \t*byte = packet->payload[packet->pos];\n    58   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto_validate_utf8\nPath: /root/projects/mosquitto/src/../lib/utf8_mosq.c:24\n    24   int mosquitto_validate_utf8(const char *str, int len)\n    25   {\n    26   \tint i;\n    27   \tint j;\n    28   \tint codelen;\n    29   \tint codepoint;\n    32   \tif(!str) return MOSQ_ERR_INVAL;\n    35   \tfor(i=0; i<len; i++){\n    36   \t\tif(ustr[i] == 0){\n    37   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    38   \t\t}else if(ustr[i] <= 0x7f){\n    40   \t\t\tcodepoint = ustr[i];\n    41   \t\t}else if((ustr[i] & 0xE0) == 0xC0){\n    43   \t\t\tif(ustr[i] == 0xC0 || ustr[i] == 0xC1){\n    45   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    46   \t\t\t}\n    48   \t\t\tcodepoint = (ustr[i] & 0x1F);\n    49   \t\t}else if((ustr[i] & 0xF0) == 0xE0){\n    52   \t\t\tcodepoint = (ustr[i] & 0x0F);\n    53   \t\t}else if((ustr[i] & 0xF8) == 0xF0){\n    55   \t\t\tif(ustr[i] > 0xF4){\n    57   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    58   \t\t\t}\n    60   \t\t\tcodepoint = (ustr[i] & 0x07);\n    61   \t\t}else{\n    63   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    64   \t\t}\n    67   \t\tif(i == len-codelen+1){\n    69   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    70   \t\t}\n    71   \t\tfor(j=0; j<codelen-1; j++){\n    72   \t\t\tif((ustr[++i] & 0xC0) != 0x80){\n    74   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    75   \t\t\t}\n    76   \t\t\tcodepoint = (codepoint<<6) | (ustr[i] & 0x3F);\n    77   \t\t}\n    80   \t\tif(codepoint >= 0xD800 && codepoint <= 0xDFFF){\n    81   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    82   \t\t}\n    88   \t\t *\t return MOSQ_ERR_MALFORMED_UTF8;\n    91   \t\tif(codelen == 3 && codepoint < 0x0800){\n    92   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    93   \t\t}else if(codelen == 4 && (codepoint < 0x10000 || codepoint > 0x10FFFF)){\n    94   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    95   \t\t}\n    98   \t\tif(codepoint >= 0xFDD0 && codepoint <= 0xFDEF){\n    99   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    100  \t\t}\n    101  \t\tif((codepoint & 0xFFFF) == 0xFFFE || (codepoint & 0xFFFF) == 0xFFFF){\n    102  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    103  \t\t}\n    105  \t\tif(codepoint <= 0x001F || (codepoint >= 0x007F && codepoint <= 0x009F)){\n    106  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    107  \t\t}\n    108  \t}\n    110  }\n",
    "It is a Protocol Error to include the Request Response Information more than once, or to have a value other than 0 or 1.": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    221  \tplugin__handle_disconnect(context, -1);\n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    226  \tif(context->bridge == NULL)\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    232  \t\t\tif(context->will_delay_interval == 0){\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__read_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:178\n    178  int packet__read_uint32(struct mosquitto__packet *packet, uint32_t *word)\n    179  {\n    180  \tuint32_t val = 0;\n    181  \tint i;\n    183  \tassert(packet);\n    184  \tif(packet->pos+4 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    186  \tfor(i=0; i<4; i++){\n    187  \t\tval = (val << 8) + packet->payload[packet->pos];\n    188  \t\tpacket->pos++;\n    189  \t}\n    191  \t*word = val;\n    194  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    223  \t\t\t\t\t/* Catch overlong encodings */\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    235  \treturn MOSQ_ERR_MALFORMED_PACKET;\n    236  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    147  \tassert(mosq);\n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    153  \tpacket->next = NULL;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    187  \treturn packet__write(mosq);\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    353  }\nFunction: property__process_connect\nPath: /root/projects/mosquitto/src/property_broker.c:30\n    30   int property__process_connect(struct mosquitto *context, mosquitto_property **props)\n    31   {\n    32   \tmosquitto_property *p;\n    34   \tp = *props;\n    36   \twhile(p){\n    37   \t\tif(p->identifier == MQTT_PROP_SESSION_EXPIRY_INTERVAL){\n    38   \t\t\tcontext->session_expiry_interval = p->value.i32;\n    39   \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM){\n    40   \t\t\tif(p->value.i16 == 0){\n    41   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    42   \t\t\t}\n    44   \t\t\tcontext->msgs_out.inflight_maximum = p->value.i16;\n    45   \t\t\tcontext->msgs_out.inflight_quota = context->msgs_out.inflight_maximum;\n    46   \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    47   \t\t\tif(p->value.i32 == 0){\n    48   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    49   \t\t\t}\n    50   \t\t\tcontext->maximum_packet_size = p->value.i32;\n    51   \t\t}\n    52   \t\tp = p->next;\n    53   \t}\n    56   }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__read\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:35\n    35   static int property__read(struct mosquitto__packet *packet, uint32_t *len, mosquitto_property *property)\n    36   {\n    38   \tuint32_t property_identifier;\n    39   \tuint8_t byte;\n    40   \tuint8_t byte_count;\n    41   \tuint16_t uint16;\n    42   \tuint32_t uint32;\n    43   \tuint32_t varint;\n    44   \tchar *str1, *str2;\n    45   \tuint16_t slen1, slen2;\n    47   \tif(!property) return MOSQ_ERR_INVAL;\n    49   \trc = packet__read_varint(packet, &property_identifier, NULL);\n    50   \tif(rc){\n    51   \t\treturn rc;\n    52   \t}\n    55   \tmemset(property, 0, sizeof(mosquitto_property));\n    57   \tproperty->identifier = (int32_t)property_identifier;\n    59   \tswitch(property_identifier){\n    60   \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    61   \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    62   \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    63   \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    64   \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    65   \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    66   \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    67   \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    68   \t\t\trc = packet__read_byte(packet, &byte);\n    69   \t\t\tif(rc) return rc;\n    70   \t\t\t*len -= 1; /* byte */\n    71   \t\t\tproperty->value.i8 = byte;\n    72   \t\t\tbreak;\n    74   \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    75   \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    76   \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    77   \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    78   \t\t\trc = packet__read_uint16(packet, &uint16);\n    79   \t\t\tif(rc) return rc;\n    81   \t\t\tproperty->value.i16 = uint16;\n    82   \t\t\tbreak;\n    84   \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    85   \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    86   \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    87   \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    88   \t\t\trc = packet__read_uint32(packet, &uint32);\n    89   \t\t\tif(rc) return rc;\n    91   \t\t\tproperty->value.i32 = uint32;\n    92   \t\t\tbreak;\n    94   \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    95   \t\t\trc = packet__read_varint(packet, &varint, &byte_count);\n    96   \t\t\tif(rc) return rc;\n    98   \t\t\tproperty->value.varint = varint;\n    99   \t\t\tbreak;\n    101  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    102  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    103  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    104  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    105  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    106  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    107  \t\tcase MQTT_PROP_REASON_STRING:\n    108  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    109  \t\t\tif(rc) return rc;\n    111  \t\t\tproperty->value.s.v = str1;\n    112  \t\t\tproperty->value.s.len = slen1;\n    113  \t\t\tbreak;\n    115  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    116  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    117  \t\t\trc = packet__read_binary(packet, (uint8_t **)&str1, &slen1);\n    118  \t\t\tif(rc) return rc;\n    120  \t\t\tproperty->value.bin.v = str1;\n    121  \t\t\tproperty->value.bin.len = slen1;\n    122  \t\t\tbreak;\n    124  \t\tcase MQTT_PROP_USER_PROPERTY:\n    125  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    126  \t\t\tif(rc) return rc;\n    129  \t\t\trc = packet__read_string(packet, &str2, &slen2);\n    130  \t\t\tif(rc){\n    131  \t\t\t\tmosquitto__free(str1);\n    132  \t\t\t\treturn rc;\n    133  \t\t\t}\n    136  \t\t\tproperty->name.v = str1;\n    137  \t\t\tproperty->name.len = slen1;\n    138  \t\t\tproperty->value.s.v = str2;\n    139  \t\t\tproperty->value.s.len = slen2;\n    140  \t\t\tbreak;\n    142  \t\tdefault:\n    144  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property_identifier);\n    146  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    147  \t}\n    150  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: property__get_length_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:335\n    335  unsigned int property__get_length_all(const mosquitto_property *property)\n    336  {\n    337  \tconst mosquitto_property *p;\n    338  \tunsigned int len = 0;\n    341  \twhile(p){\n    342  \t\tlen += property__get_length(p);\n    343  \t\tp = p->next;\n    344  \t}\n    345  \treturn len;\n    346  }\nFunction: mosquitto_property_add_byte\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:716\n    716  int mosquitto_property_add_byte(mosquitto_property **proplist, int identifier, uint8_t value)\n    717  {\n    721  \tif(identifier != MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    722  \t\t\t&& identifier != MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    723  \t\t\t&& identifier != MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    736  \tprop->identifier = identifier;\n    737  \tprop->value.i8 = value;\n    739  \tproperty__add(proplist, prop);\n    741  }\nFunction: mosquitto_property_read_binary\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1106\n    1106 const mosquitto_property *mosquitto_property_read_binary(const mosquitto_property *proplist, int identifier, void **value, uint16_t *len, bool skip_first)\n    1107 {\n    1109 \tif(!proplist || (value && !len) || (!value && len)) return NULL;\n    1113 \tp = property__get_property(proplist, identifier, skip_first);\n    1114 \tif(!p) return NULL;\n    1115 \tif(p->identifier != MQTT_PROP_CORRELATION_DATA\n    1116 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_DATA){\n    1118 \t\treturn NULL;\n    1119 \t}\n    1121 \tif(value){\n    1122 \t\t*len = p->value.bin.len;\n    1123 \t\t*value = calloc(1, *len + 1U);\n    1124 \t\tif(!(*value)) return NULL;\n    1126 \t\tmemcpy(*value, p->value.bin.v, *len);\n    1127 \t}\n    1130 }\nFunction: mosquitto_property_read_string\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1133\n    1133 const mosquitto_property *mosquitto_property_read_string(const mosquitto_property *proplist, int identifier, char **value, bool skip_first)\n    1134 {\n    1136 \tif(!proplist) return NULL;\n    1138 \tp = property__get_property(proplist, identifier, skip_first);\n    1139 \tif(!p) return NULL;\n    1140 \tif(p->identifier != MQTT_PROP_CONTENT_TYPE\n    1141 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_TOPIC\n    1142 \t\t\t&& p->identifier != MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER\n    1143 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_METHOD\n    1144 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_INFORMATION\n    1145 \t\t\t&& p->identifier != MQTT_PROP_SERVER_REFERENCE\n    1146 \t\t\t&& p->identifier != MQTT_PROP_REASON_STRING){\n    1148 \t\treturn NULL;\n    1149 \t}\n    1151 \tif(value){\n    1152 \t\t*value = calloc(1, (size_t)p->value.s.len+1);\n    1153 \t\tif(!(*value)) return NULL;\n    1155 \t\tmemcpy(*value, p->value.s.v, p->value.s.len);\n    1156 \t}\n    1159 }\nFunction: db__expire_all_messages\nPath: /root/projects/mosquitto/src/database.c:1053\n    1053 void db__expire_all_messages(struct mosquitto *context)\n    1055 \tstruct mosquitto_client_msg *msg, *tmp;\n    1057 \tDL_FOREACH_SAFE(context->msgs_out.inflight, msg, tmp){\n    1058 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1059 \t\t\tif(msg->qos > 0){\n    1060 \t\t\t\tutil__increment_send_quota(context);\n    1062 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1065 \tDL_FOREACH_SAFE(context->msgs_out.queued, msg, tmp){\n    1066 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1067 \t\t\tdb__message_remove_from_queued(&context->msgs_out, msg);\n    1070 \tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n    1071 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1072 \t\t\tif(msg->qos > 0){\n    1073 \t\t\t\tutil__increment_receive_quota(context);\n    1075 \t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n    1078 \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n    1079 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1080 \t\t\tdb__message_remove_from_queued(&context->msgs_in, msg);\n    1083 }\nFunction: db__message_remove_from_queued\nPath: /root/projects/mosquitto/src/database.c:364\n    364  static void db__message_remove_from_queued(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    365  {\n    366  \tif(!msg_data || !item){\n    367  \t\treturn;\n    368  \t}\n    370  \tDL_DELETE(msg_data->queued, item);\n    377  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1183 \tstruct mosquitto_client_msg *tail, *tmp;\n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1190 \tDL_FOREACH_SAFE(context->msgs_out.inflight, tail, tmp){\n    1191 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1192 \t\tif(rc) return rc;\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    143  \t\t\t\tin_quota = context->msgs_in.inflight_quota;\n    144  \t\t\t\tout_quota = context->msgs_out.inflight_quota;\n    145  \t\t\t\tin_maximum = context->msgs_in.inflight_maximum;\n    146  \t\t\t\tout_maximum = context->msgs_out.inflight_maximum;\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    154  \t\t\t\tcontext->msgs_in.inflight_quota = in_quota;\n    155  \t\t\t\tcontext->msgs_out.inflight_quota = out_quota;\n    156  \t\t\t\tcontext->msgs_in.inflight_maximum = in_maximum;\n    157  \t\t\t\tcontext->msgs_out.inflight_maximum = out_maximum;\n    159  \t\t\t\tdb__message_reconnect_reset(context);\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    215  \trc = acl__find_acls(context);\n    216  \tif(rc){\n    218  \t\treturn rc;\n    219  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    250  \t}\n    252  \tcontext->ping_t = 0;\n    253  \tcontext->is_dropping = false;\n    255  \tconnection_check_acl(context, &context->msgs_in.inflight);\n    256  \tconnection_check_acl(context, &context->msgs_in.queued);\n    257  \tconnection_check_acl(context, &context->msgs_out.inflight);\n    258  \tconnection_check_acl(context, &context->msgs_out.queued);\n    260  \tcontext__add_to_by_id(context);\n    263  \tif(!context->clean_start){\n    267  \tcontext->max_qos = context->listener->max_qos;\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    315  \tkeepalive__add(context);\n    317  \tmosquitto__set_state(context, mosq_cs_active);\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    320  \tif(rc) return rc;\n    321  \tdb__expire_all_messages(context);\n    322  \trc = db__message_write_queued_out(context);\n    323  \tif(rc) return rc;\n    324  \trc = db__message_write_inflight_out_all(context);\n    330  }\nFunction: connection_check_acl\nPath: /root/projects/mosquitto/src/handle_connect.c:86\n    86   static void connection_check_acl(struct mosquitto *context, struct mosquitto_client_msg **head)\n    97   \t\tif(mosquitto_acl_check(context, msg_tail->store->topic,\n    99   \t\t\t\t\t\t\t   msg_tail->store->qos, msg_tail->store->retain, access) != MOSQ_ERR_SUCCESS){\n    101  \t\t\tDL_DELETE((*head), msg_tail);\n    107  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    248  \tmosquitto__set_state(context, mosq_cs_disused);\n    250  \tif(context->id){\n    251  \t\tcontext__remove_from_by_id(context);\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    256  \tcontext->for_free_next = db.ll_for_free;\n    257  \tdb.ll_for_free = context;\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    296  \t\tcontext->in_by_id = true;\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__msg_add_to_queued_stats\nPath: /root/projects/mosquitto/src/database.c:162\n    162  void db__msg_add_to_queued_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    163  {\n    164  \tmsg_data->queued_count++;\n    165  \tmsg_data->queued_bytes += msg->store->payloadlen;\n    166  \tif(msg->qos != 0){\n    167  \t\tmsg_data->queued_count12++;\n    168  \t\tmsg_data->queued_bytes12 += msg->store->payloadlen;\n    169  \t}\n    170  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    271  \tmosquitto__free(store->source_id);\n    272  \tmosquitto__free(store->source_username);\n    283  }\nFunction: db__message_remove_from_inflight\nPath: /root/projects/mosquitto/src/database.c:347\n    347  static void db__message_remove_from_inflight(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    348  {\n    349  \tif(!msg_data || !item){\n    350  \t\treturn;\n    351  \t}\n    353  \tDL_DELETE(msg_data->inflight, item);\n    354  \tif(item->store){\n    355  \t\tdb__msg_remove_from_inflight_stats(msg_data, item);\n    357  \t}\n    361  }\nFunction: db__message_write_inflight_out_latest\nPath: /root/projects/mosquitto/src/database.c:1198\n    1198 int db__message_write_inflight_out_latest(struct mosquitto *context)\n    1199 {\n    1200 \tstruct mosquitto_client_msg *tail, *next;\n    1203 \tif(context->state != mosq_cs_active\n    1204 \t\t\t|| context->sock == INVALID_SOCKET\n    1205 \t\t\t|| context->msgs_out.inflight == NULL){\n    1207 \t\treturn MOSQ_ERR_SUCCESS;\n    1208 \t}\n    1210 \tif(context->msgs_out.inflight->prev == context->msgs_out.inflight){\n    1212 \t\treturn db__message_write_inflight_out_single(context, context->msgs_out.inflight);\n    1213 \t}\n    1217 \ttail = context->msgs_out.inflight->prev;\n    1218 \twhile(tail != context->msgs_out.inflight &&\n    1219 \t\t\t(tail->state == mosq_ms_publish_qos0\n    1220 \t\t\t || tail->state == mosq_ms_publish_qos1\n    1221 \t\t\t || tail->state == mosq_ms_publish_qos2)){\n    1223 \t\ttail = tail->prev;\n    1224 \t}\n    1229 \tif(tail != context->msgs_out.inflight){\n    1230 \t\ttail = tail->next;\n    1231 \t}\n    1233 \twhile(tail){\n    1234 \t\tnext = tail->next;\n    1235 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1236 \t\tif(rc) return rc;\n    1238 \t}\n    1240 }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1097 \tuint32_t expiry_interval;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1103 \t\t\tif(msg->direction == mosq_md_out && msg->qos > 0){\n    1104 \t\t\t\tutil__increment_send_quota(context);\n    1105 \t\t\t}\n    1106 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1126 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1135 \t\t\t\tmsg->timestamp = db.now_s;\n    1136 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1137 \t\t\t\tmsg->state = mosq_ms_wait_for_puback;\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1139 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1148 \t\t\t\tmsg->timestamp = db.now_s;\n    1149 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1150 \t\t\t\tmsg->state = mosq_ms_wait_for_pubrec;\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1152 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1159 \t\t\trc = send__pubrel(context, mid, NULL);\n    1160 \t\t\tif(!rc){\n    1161 \t\t\t\tmsg->state = mosq_ms_wait_for_pubcomp;\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1176 \t}\n    1178 }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    449  \tstruct mosquitto_msg_data *msg_data;\n    450  \tenum mosquitto_msg_state state = mosq_ms_invalid;\n    452  \tint i;\n    457  \tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n    459  \tif(dir == mosq_md_out){\n    460  \t\tmsg_data = &context->msgs_out;\n    461  \t}else{\n    462  \t\tmsg_data = &context->msgs_in;\n    463  \t}\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    484  \tif(context->sock == INVALID_SOCKET){\n    486  \t\tif(qos == 0 && !db.config->queue_qos0_messages){\n    487  \t\t\tif(!context->bridge){\n    489  \t\t\t\treturn 2;\n    490  \t\t\t}else{\n    491  \t\t\t\tif(context->bridge->start_type != bst_lazy){\n    493  \t\t\t\t\treturn 2;\n    494  \t\t\t\t}\n    495  \t\t\t}\n    496  \t\t}\n    497  \t\tif(context->bridge && context->bridge->clean_start_local == true){\n    499  \t\t\treturn 2;\n    500  \t\t}\n    501  \t}\n    503  \tif(context->sock != INVALID_SOCKET){\n    504  \t\tif(db__ready_for_flight(context, dir, qos)){\n    517  \t\t\t}else{\n    520  \t\t\t\t}else{\n    521  \t\t\t\t\tmosquitto_property_free_all(&properties);\n    522  \t\t\t\t\treturn 1;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n    528  \t\t}else{\n    530  \t\t\tif(context->is_dropping == false){\n    531  \t\t\t\tcontext->is_dropping = true;\n    532  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    534  \t\t\t\t\t\tcontext->id);\n    535  \t\t\t}\n    538  \t\t\treturn 2;\n    539  \t\t}\n    540  \t}else{\n    541  \t\tif (db__ready_for_queue(context, qos, msg_data)){\n    543  \t\t}else{\n    545  \t\t\tif(context->is_dropping == false){\n    546  \t\t\t\tcontext->is_dropping = true;\n    547  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    549  \t\t\t\t\t\tcontext->id);\n    550  \t\t\t}\n    552  \t\t\treturn 2;\n    553  \t\t}\n    554  \t}\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    582  \tif(state == mosq_ms_queued){\n    583  \t\tDL_APPEND(msg_data->queued, msg);\n    585  \t}else{\n    586  \t\tDL_APPEND(msg_data->inflight, msg);\n    588  \t}\n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    598  \t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n    599  \t\tif(dest_ids){\n    602  \t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t}\n    609  \t}\n    611  \tif(context->bridge && context->bridge->start_type == bst_lazy\n    612  \t\t\t&& context->sock == INVALID_SOCKET\n    613  \t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n    616  \t}\n    633  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    704  \tstruct mosquitto_msg_store *stored;\n    705  \tconst char *source_id;\n    706  \tenum mosquitto_msg_origin origin;\n    710  \tstored = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    711  \tif(stored == NULL) return MOSQ_ERR_NOMEM;\n    713  \tstored->topic = mosquitto__strdup(topic);\n    714  \tif(stored->topic == NULL){\n    715  \t\tdb__msg_store_free(stored);\n    716  \t\treturn MOSQ_ERR_INVAL;\n    717  \t}\n    719  \tstored->qos = qos;\n    720  \tif(db.config->retain_available == false){\n    721  \t\tstored->retain = 0;\n    722  \t}else{\n    723  \t\tstored->retain = retain;\n    724  \t}\n    726  \tstored->payloadlen = payloadlen;\n    727  \tif(payloadlen > 0){\n    728  \t\tstored->payload = mosquitto__malloc(stored->payloadlen+1);\n    729  \t\tif(stored->payload == NULL){\n    730  \t\t\tdb__msg_store_free(stored);\n    731  \t\t\treturn MOSQ_ERR_NOMEM;\n    732  \t\t}\n    734  \t\t((uint8_t *)stored->payload)[stored->payloadlen] = 0;\n    735  \t\tmemcpy(stored->payload, payload, stored->payloadlen);\n    736  \t}\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    746  \t}\n    748  \tif(context){\n    750  \t}else{\n    753  \tif(db__message_store(context, stored, message_expiry_interval, 0, origin)) return 1;\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    763  \tif(source && source->id){\n    764  \t\tstored->source_id = mosquitto__strdup(source->id);\n    765  \t}else{\n    766  \t\tstored->source_id = mosquitto__strdup(\"\");\n    767  \t}\n    768  \tif(!stored->source_id){\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    774  \tif(source && source->username){\n    775  \t\tstored->source_username = mosquitto__strdup(source->username);\n    776  \t\tif(!stored->source_username){\n    778  \t\t\treturn MOSQ_ERR_NOMEM;\n    779  \t\t}\n    780  \t}\n    781  \tif(source){\n    782  \t\tstored->source_listener = source->listener;\n    783  \t}\n    806  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    448  \tX509 *client_cert = NULL;\n    460  \tif(!context->listener){\n    461  \t\treturn MOSQ_ERR_INVAL;\n    462  \t}\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    502  \t\tcontext->protocol = mosq_p_mqtt31;\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    504  \t\t\tcontext->is_bridge = true;\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    508  \t\t\tcontext->protocol = mosq_p_mqtt311;\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    511  \t\t\t\tcontext->is_bridge = true;\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    514  \t\t\tcontext->protocol = mosq_p_mqtt5;\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    547  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    563  \t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid Will QoS in CONNECT from %s.\",\n    564  \t\t\t\tcontext->address);\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    666  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    689  \t\t\t\t/* username_flag == 0 && password_flag == 1 is forbidden */\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    691  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    724  \tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    731  \t\tif(!context->ssl){\n    732  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    741  \t\tif(context->listener->psk_hint){\n    743  \t\t\tif(!context->username){\n    744  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    754  \t\t\tclient_cert = SSL_get_peer_certificate(context->ssl);\n    755  \t\t\tif(!client_cert){\n    756  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    764  \t\t\tname = X509_get_subject_name(client_cert);\n    765  \t\t\tif(!name){\n    766  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    774  \t\t\tif (context->listener->use_identity_as_username) { /* use_identity_as_username */\n    775  \t\t\t\ti = X509_NAME_get_index_by_NID(name, NID_commonName, -1);\n    776  \t\t\t\tif(i == -1){\n    777  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    785  \t\t\t\tname_entry = X509_NAME_get_entry(name, i);\n    786  \t\t\t\tif(name_entry){\n    787  \t\t\t\t\tname_asn1 = X509_NAME_ENTRY_get_data(name_entry);\n    788  \t\t\t\t\tif (name_asn1 == NULL) {\n    789  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    801  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_get0_data(name_asn1);\n    803  \t\t\t\t\tif(mosquitto_validate_utf8(new_username, (int)strlen(new_username))){\n    804  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    809  \t\t\t\t\t\tX509_free(client_cert);\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    814  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    824  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    835  \t\t\t\tX509_NAME_print_ex(subject_bio, X509_get_subject_name(client_cert), 0, XN_FLAG_RFC2253);\n    847  \t\t\t\tcontext->username = subject;\n    849  \t\t\tif(!context->username){\n    853  \t\t\tX509_free(client_cert);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    898  \t\t\tmosquitto__set_state(context, mosq_cs_authenticating);\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    905  \t\t\twill__clear(context);\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    925  \t\tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    973  \tif(client_cert) X509_free(client_cert);\n    976  \tcontext->clean_start = true;\n    977  \tcontext->session_expiry_interval = 0;\n    978  \tcontext->will_delay_interval = 0;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    55   \tint i;\n    56   \tint pos;\n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    335  \tint rc = MOSQ_ERR_SUCCESS;\n    337  \tuint16_t tlen;\n    340  \tuint16_t payloadlen;\n    341  \tmosquitto_property *properties = NULL;\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    349  \t\trc = property__read_all(CMD_WILL, &context->in_packet, &properties);\n    350  \t\tif(rc) goto error_cleanup;\n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    353  \t\tmosquitto_property_free_all(&properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    356  \trc = packet__read_string(&context->in_packet, &will_struct->msg.topic, &tlen);\n    357  \tif(rc) goto error_cleanup;\n    363  \tif(context->listener->mount_point){\n    364  \t\tslen = strlen(context->listener->mount_point) + strlen(will_struct->msg.topic) + 1;\n    365  \t\twill_topic_mount = mosquitto__malloc(slen+1);\n    366  \t\tif(!will_topic_mount){\n    368  \t\t\tgoto error_cleanup;\n    369  \t\t}\n    371  \t\tsnprintf(will_topic_mount, slen, \"%s%s\", context->listener->mount_point, will_struct->msg.topic);\n    372  \t\twill_topic_mount[slen] = '\\0';\n    374  \t\tmosquitto__free(will_struct->msg.topic);\n    375  \t\twill_struct->msg.topic = will_topic_mount;\n    376  \t}\n    378  \tif(!strncmp(will_struct->msg.topic, \"$CONTROL/\", strlen(\"$CONTROL/\"))){\n    380  \t\tgoto error_cleanup;\n    381  \t}\n    382  \trc = mosquitto_pub_topic_check(will_struct->msg.topic);\n    385  \trc = packet__read_uint16(&context->in_packet, &payloadlen);\n    386  \tif(rc) goto error_cleanup;\n    388  \twill_struct->msg.payloadlen = payloadlen;\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    393  \t\t\t\tsend__connack(context, 0, MQTT_RC_PACKET_TOO_LARGE, NULL);\n    394  \t\t\t}else{\n    395  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    396  \t\t\t}\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    400  \t\twill_struct->msg.payload = mosquitto__malloc((size_t)will_struct->msg.payloadlen);\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    406  \t\trc = packet__read_bytes(&context->in_packet, will_struct->msg.payload, (uint32_t)will_struct->msg.payloadlen);\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    416  error_cleanup:\n    417  \tif(will_struct){\n    418  \t\tmosquitto__free(will_struct->msg.topic);\n    419  \t\tmosquitto__free(will_struct->msg.payload);\n    422  \t}\n    424  }\nFunction: net__write\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:996\n    996  ssize_t net__write(struct mosquitto *mosq, const void *buf, size_t count)\n    997  {\n    999  \tint ret;\n    1001 \tassert(mosq);\n    1005 \tif(mosq->ssl){\n    1007 \t\tmosq->want_write = false;\n    1008 \t\tret = SSL_write(mosq->ssl, buf, (int)count);\n    1009 \t\tif(ret < 0){\n    1010 \t\t\tret = net__handle_ssl(mosq, ret);\n    1011 \t\t}\n    1012 \t\treturn (ssize_t )ret;\n    1013 \t}else{\n    1017 \treturn send(mosq->sock, buf, count, MSG_NOSIGNAL);\n    1020 \t}\n    1022 }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    51   \tassert(packet);\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    73   \tassert(packet);\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: property__get_property\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:988\n    988  static const mosquitto_property *property__get_property(const mosquitto_property *proplist, int identifier, bool skip_first)\n    989  {\n    990  \tconst mosquitto_property *p;\n    995  \twhile(p){\n    996  \t\tif(p->identifier == identifier){\n    997  \t\t\tif(!is_first || !skip_first){\n    998  \t\t\t\treturn p;\n    999  \t\t\t}\n    1001 \t\t}\n    1002 \t\tp = p->next;\n    1003 \t}\n    1005 }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    371  \t\tmux__delete(context);\n    372  \t\tcontext__disconnect(context);\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto__malloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:83\n    83   void *mosquitto__malloc(size_t size)\n    84   {\n    88   \tif(mem_limit && memcount + size > mem_limit){\n    89   \t\treturn NULL;\n    90   \t}\n    93   \tmem = malloc(size);\n    96   \tif(mem){\n    97   \t\tmemcount += malloc_usable_size(mem);\n    101  \t}\n    105  }\nFunction: mosquitto__strdup\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:144\n    144  char *mosquitto__strdup(const char *s)\n    145  {\n    148  \tif(mem_limit && memcount + strlen(s) > mem_limit){\n    149  \t\treturn NULL;\n    150  \t}\n    152  \tstr = strdup(s);\n    155  \tif(str){\n    156  \t\tmemcount += malloc_usable_size(str);\n    160  \t}\n    164  }\nFunction: mosquitto_free\nPath: /root/projects/mosquitto/src/memory_public.c:27\n    27   void mosquitto_free(void *mem)\n    29   \tmosquitto__free(mem);\n    30   }\nFunction: mosquitto_malloc\nPath: /root/projects/mosquitto/src/memory_public.c:32\n    32   void *mosquitto_malloc(size_t size)\n    34   \treturn mosquitto__malloc(size);\n    35   }\nFunction: mux__delete\nPath: /root/projects/mosquitto/src/mux.c:61\n    61   int mux__delete(struct mosquitto *context)\n    64   \treturn mux_epoll__delete(context);\n    68   }\nFunction: send__auth\nPath: /root/projects/mosquitto/src/send_auth.c:28\n    28   int send__auth(struct mosquitto *context, uint8_t reason_code, const void *auth_data, uint16_t auth_data_len)\n    29   {\n    32   \tmosquitto_property *properties = NULL;\n    35   \tif(context->auth_method == NULL) return MOSQ_ERR_INVAL;\n    36   \tif(context->protocol != mosq_p_mqtt5) return MOSQ_ERR_PROTOCOL;\n    38   \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending AUTH to %s (rc%d, %s)\", context->id, reason_code, context->auth_method);\n    42   \trc = mosquitto_property_add_string(&properties, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method);\n    43   \tif(rc){\n    45   \t\treturn rc;\n    46   \t}\n    56   \tremaining_length += property__get_remaining_length(properties);\n    58   \tif(packet__check_oversize(context, remaining_length)){\n    61   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    62   \t}\n    67   \tpacket->command = CMD_AUTH;\n    68   \tpacket->remaining_length = remaining_length;\n    70   \trc = packet__alloc(packet);\n    76   \tpacket__write_byte(packet, reason_code);\n    77   \tproperty__write_all(packet, properties, true);\n    80   \treturn packet__queue(context, packet);\n    81   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    32   \tmosquitto_property *connack_props = NULL;\n    33   \tuint32_t remaining_length;\n    35   \trc = mosquitto_property_copy_all(&connack_props, properties);\n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    43   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->address, ack, reason_code);\n    44   \t}\n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    51   \t\t\tif(rc){\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    58   \t\t\tif(rc){\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    65   \t\t\tif(rc){\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    71   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_MAXIMUM_QOS, context->listener->max_qos);\n    72   \t\t\tif(rc){\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    78   \t\tremaining_length += property__get_remaining_length(connack_props);\n    79   \t}\n    81   \tif(packet__check_oversize(context, remaining_length)){\n    83   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    84   \t}\n    92   \tpacket->command = CMD_CONNACK;\n    93   \tpacket->remaining_length = remaining_length;\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    105  \t}\n    108  \treturn packet__queue(context, packet);\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    42   \tassert(mosq);\n    45   \tif(mosq->bridge){\n    46   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Bridge %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    47   \t}else\n    56   \tassert(mosq);\n    60   \tpacket->command = CMD_DISCONNECT;\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    62   \t\tpacket->remaining_length = 1;\n    63   \t\tif(properties){\n    64   \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    65   \t\t}\n    66   \t}else{\n    67   \t\tpacket->remaining_length = 0;\n    68   \t}\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    76   \t\tpacket__write_byte(packet, reason_code);\n    77   \t\tif(properties){\n    78   \t\t\tproperty__write_all(packet, properties, true);\n    79   \t\t}\n    80   \t}\n    82   \treturn packet__queue(mosq, packet);\n    83   }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    126  \tassert(mosq);\n    130  \tpacket->command = command;\n    131  \tif(dup){\n    132  \t\tpacket->command |= 8;\n    133  \t}\n    134  \tpacket->remaining_length = 2;\n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    137  \t\tif(reason_code != 0 || properties){\n    138  \t\t\tpacket->remaining_length += 1;\n    139  \t\t}\n    141  \t\tif(properties){\n    142  \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    143  \t\t}\n    144  \t}\n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tif(reason_code != 0 || properties){\n    156  \t\t\tpacket__write_byte(packet, reason_code);\n    157  \t\t}\n    161  \t}\n    163  \treturn packet__queue(mosq, packet);\n    164  }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    117  \treturn send__command_with_mid(mosq, CMD_PUBREL|2, mid, false, 0, properties);\n    118  }\nFunction: send__publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:42\n    42   int send__publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    43   {\n    47   \tint i;\n    49   \tbool match;\n    51   \tchar *mapped_topic = NULL;\n    55   \tassert(mosq);\n    60   \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    63   \tif(!mosq->retain_available){\n    65   \t}\n    68   \tif(mosq->listener && mosq->listener->mount_point){\n    69   \t\tlen = strlen(mosq->listener->mount_point);\n    70   \t\tif(len < strlen(topic)){\n    71   \t\t\ttopic += len;\n    72   \t\t}else{\n    74   \t\t\treturn MOSQ_ERR_SUCCESS;\n    75   \t\t}\n    76   \t}\n    78   \tif(mosq->bridge && mosq->bridge->topics && mosq->bridge->topic_remapping){\n    79   \t\tfor(i=0; i<mosq->bridge->topic_count; i++){\n    80   \t\t\tcur_topic = &mosq->bridge->topics[i];\n    81   \t\t\tif((cur_topic->direction == bd_both || cur_topic->direction == bd_out)\n    82   \t\t\t\t\t&& (cur_topic->remote_prefix || cur_topic->local_prefix)){\n    85   \t\t\t\trc = mosquitto_topic_matches_sub(cur_topic->local_topic, topic, &match);\n    86   \t\t\t\tif(rc){\n    87   \t\t\t\t\treturn rc;\n    88   \t\t\t\t}\n    89   \t\t\t\tif(match){\n    90   \t\t\t\t\tmapped_topic = mosquitto__strdup(topic);\n    91   \t\t\t\t\tif(!mapped_topic) return MOSQ_ERR_NOMEM;\n    92   \t\t\t\t\tif(cur_topic->local_prefix){\n    94   \t\t\t\t\t\tif(!strncmp(cur_topic->local_prefix, mapped_topic, strlen(cur_topic->local_prefix))){\n    95   \t\t\t\t\t\t\ttopic_temp = mosquitto__strdup(mapped_topic+strlen(cur_topic->local_prefix));\n    96   \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    97   \t\t\t\t\t\t\tif(!topic_temp){\n    98   \t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    99   \t\t\t\t\t\t\t}\n    101  \t\t\t\t\t\t}\n    102  \t\t\t\t\t}\n    104  \t\t\t\t\tif(cur_topic->remote_prefix){\n    106  \t\t\t\t\t\tlen = strlen(mapped_topic) + strlen(cur_topic->remote_prefix)+1;\n    107  \t\t\t\t\t\ttopic_temp = mosquitto__malloc(len+1);\n    108  \t\t\t\t\t\tif(!topic_temp){\n    109  \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    110  \t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    111  \t\t\t\t\t\t}\n    112  \t\t\t\t\t\tsnprintf(topic_temp, len, \"%s%s\", cur_topic->remote_prefix, mapped_topic);\n    113  \t\t\t\t\t\ttopic_temp[len] = '\\0';\n    114  \t\t\t\t\t\tmosquitto__free(mapped_topic);\n    116  \t\t\t\t\t}\n    117  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, mapped_topic, (long)payloadlen);\n    119  \t\t\t\t\trc =  send__real_publish(mosq, mid, mapped_topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    120  \t\t\t\t\tmosquitto__free(mapped_topic);\n    121  \t\t\t\t\treturn rc;\n    122  \t\t\t\t}\n    123  \t\t\t}\n    124  \t\t}\n    125  \t}\n    127  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, topic, (long)payloadlen);\n    133  \treturn send__real_publish(mosq, mid, topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    134  }\nFunction: send__real_publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:137\n    137  int send__real_publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    138  {\n    140  \tunsigned int packetlen;\n    141  \tunsigned int proplen = 0, varbytes;\n    143  \tmosquitto_property expiry_prop;\n    145  \tassert(mosq);\n    147  \tif(topic){\n    148  \t\tpacketlen = 2+(unsigned int)strlen(topic) + payloadlen;\n    149  \t}else{\n    150  \t\tpacketlen = 2 + payloadlen;\n    151  \t}\n    152  \tif(qos > 0) packetlen += 2; /* For message id */\n    153  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tproplen += property__get_length_all(cmsg_props);\n    156  \t\tproplen += property__get_length_all(store_props);\n    157  \t\tif(expiry_interval > 0){\n    158  \t\t\texpiry_prop.next = NULL;\n    160  \t\t\texpiry_prop.identifier = MQTT_PROP_MESSAGE_EXPIRY_INTERVAL;\n    163  \t\t\tproplen += property__get_length_all(&expiry_prop);\n    164  \t\t}\n    166  \t\tvarbytes = packet__varint_bytes(proplen);\n    172  \t\t}else{\n    173  \t\t\tpacketlen += proplen + varbytes;\n    174  \t\t}\n    175  \t}\n    176  \tif(packet__check_oversize(mosq, packetlen)){\n    178  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Dropping too large outgoing PUBLISH for %s (%d bytes)\", SAFE_PRINT(mosq->id), packetlen);\n    182  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    183  \t}\n    189  \tpacket->command = (uint8_t)(CMD_PUBLISH | (uint8_t)((dup&0x1)<<3) | (uint8_t)(qos<<1) | retain);\n    190  \tpacket->remaining_length = packetlen;\n    206  \tif(mosq->protocol == mosq_p_mqtt5){\n    213  \t}\n    220  \treturn packet__queue(mosq, packet);\n    221  }\nFunction: session_expiry__cmp\nPath: /root/projects/mosquitto/src/session_expiry.c:34\n    34   static int session_expiry__cmp(struct session_expiry_list *i1, struct session_expiry_list *i2)\n    35   {\n    36   \tif(i1->context->session_expiry_time == i2->context->session_expiry_time){\n    37   \t\treturn 0;\n    38   \t}else if(i1->context->session_expiry_time > i2->context->session_expiry_time){\n    39   \t\treturn 1;\n    40   \t}else{\n    41   \t\treturn -1;\n    42   \t}\n    43   }\nFunction: session_expiry__remove\nPath: /root/projects/mosquitto/src/session_expiry.c:121\n    121  void session_expiry__remove(struct mosquitto *context)\n    122  {\n    123  \tif(context->expiry_list_item){\n    124  \t\tDL_DELETE(expiry_list, context->expiry_list_item);\n    125  \t\tmosquitto__free(context->expiry_list_item);\n    126  \t\tcontext->expiry_list_item = NULL;\n    127  \t}\n    128  }\nFunction: acl__check_single\nPath: /root/projects/mosquitto/src/security.c:602\n    602  static int acl__check_single(struct mosquitto__auth_plugin_config *auth_plugin, struct mosquitto *context, struct mosquitto_acl_msg *msg, int access)\n    603  {\n    607  \tusername = mosquitto_client_username(context);\n    608  \tif(auth_plugin->deny_special_chars == true){\n    615  \t\tif(username && strpbrk(username, \"+#\")){\n    616  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous username \\\"%s\\\"\", username);\n    617  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    618  \t\t}\n    619  \t\tif(context->id && strpbrk(context->id, \"+#\")){\n    620  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous client id \\\"%s\\\"\", context->id);\n    621  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    622  \t\t}\n    623  \t}\n    625  \tif(auth_plugin->plugin.version == 4){\n    626  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    627  \t\t\treturn MOSQ_ERR_SUCCESS;\n    628  \t\t}\n    629  \t\treturn auth_plugin->plugin.acl_check_v4(auth_plugin->plugin.user_data, access, context, msg);\n    630  \t}else if(auth_plugin->plugin.version == 3){\n    631  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    632  \t\t\treturn MOSQ_ERR_SUCCESS;\n    633  \t\t}\n    634  \t\treturn auth_plugin->plugin.acl_check_v3(auth_plugin->plugin.user_data, access, context, msg);\n    635  \t}else if(auth_plugin->plugin.version == 2){\n    636  \t\tif(access == MOSQ_ACL_SUBSCRIBE || access == MOSQ_ACL_UNSUBSCRIBE){\n    637  \t\t\treturn MOSQ_ERR_SUCCESS;\n    638  \t\t}\n    639  \t\treturn auth_plugin->plugin.acl_check_v2(auth_plugin->plugin.user_data, context->id, username, topic, access);\n    640  \t}else{\n    641  \t\treturn MOSQ_ERR_INVAL;\n    642  \t}\n    643  }\nFunction: sub__remove_shared_leaf\nPath: /root/projects/mosquitto/src/subs.c:190\n    190  static void sub__remove_shared_leaf(struct mosquitto__subhier *subhier, struct mosquitto__subshared *shared, struct mosquitto__subleaf *leaf)\n    191  {\n    192  \tDL_DELETE(shared->subs, leaf);\n    193  \tif(shared->subs == NULL){\n    194  \t\tHASH_DELETE(hh, subhier->shared, shared);\n    195  \t\tmosquitto__free(shared->name);\n    196  \t\tmosquitto__free(shared);\n    197  \t}\n    199  }\nFunction: sub__messages_queue\nPath: /root/projects/mosquitto/src/subs.c:659\n    659  int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n    660  {\n    661  \tint rc = MOSQ_ERR_SUCCESS, rc2;\n    662  \tint rc_normal = MOSQ_ERR_NO_SUBSCRIBERS, rc_shared = MOSQ_ERR_NO_SUBSCRIBERS;\n    663  \tstruct mosquitto__subhier *subhier;\n    664  \tchar **split_topics = NULL;\n    677  \tHASH_FIND(hh, db.normal_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    678  \tif(subhier){\n    679  \t\trc_normal = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    680  \t\tif(rc_normal > 0){\n    682  \t\t\tgoto end;\n    683  \t\t}\n    684  \t}\n    686  \tHASH_FIND(hh, db.shared_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    687  \tif(subhier){\n    688  \t\trc_shared = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    689  \t\tif(rc_shared > 0){\n    691  \t\t\tgoto end;\n    692  \t\t}\n    693  \t}\n    695  \tif(rc_normal == MOSQ_ERR_NO_SUBSCRIBERS && rc_shared == MOSQ_ERR_NO_SUBSCRIBERS){\n    697  \t}\n    711  }\nFunction: sub__search\nPath: /root/projects/mosquitto/src/subs.c:479\n    479  static int sub__search(struct mosquitto__subhier *subhier, char **split_topics, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    480  {\n    482  \tstruct mosquitto__subhier *branch;\n    486  \tif(split_topics && split_topics[0]){\n    488  \t\tHASH_FIND(hh, subhier->children, split_topics[0], strlen(split_topics[0]), branch);\n    490  \t\tif(branch){\n    491  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    492  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    494  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    495  \t\t\t\treturn rc;\n    496  \t\t\t}\n    497  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    498  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    499  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    501  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    502  \t\t\t\t\treturn rc;\n    503  \t\t\t\t}\n    504  \t\t\t}\n    505  \t\t}\n    508  \t\tHASH_FIND(hh, subhier->children, \"+\", 1, branch);\n    510  \t\tif(branch){\n    511  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    512  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    514  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    515  \t\t\t\treturn rc;\n    516  \t\t\t}\n    517  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    518  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    519  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    521  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    522  \t\t\t\t\treturn rc;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}\n    526  \t}\n    529  \tHASH_FIND(hh, subhier->children, \"#\", 1, branch);\n    530  \tif(branch && !branch->children){\n    535  \t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    536  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    538  \t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    539  \t\t\treturn rc;\n    540  \t\t}\n    541  \t}\n    548  }\nFunction: subs__process\nPath: /root/projects/mosquitto/src/subs.c:129\n    129  static int subs__process(struct mosquitto__subhier *hier, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    130  {\n    133  \tstruct mosquitto__subleaf *leaf;\n    135  \trc = subs__shared_process(hier, topic, qos, retain, stored);\n    137  \tleaf = hier->subs;\n    138  \twhile(source_id && leaf){\n    139  \t\tif(!leaf->context->id || (leaf->no_local && !strcmp(leaf->context->id, source_id))){\n    140  \t\t\tleaf = leaf->next;\n    142  \t\t}\n    147  \t\tleaf = leaf->next;\n    148  \t}\n    149  \tif(hier->subs || hier->shared){\n    150  \t\treturn rc;\n    151  \t}else{\n    152  \t\treturn MOSQ_ERR_NO_SUBSCRIBERS;\n    153  \t}\n    154  }\nFunction: subs__send\nPath: /root/projects/mosquitto/src/subs.c:63\n    63   static int subs__send(struct mosquitto__subleaf *leaf, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    64   {\n    65   \tbool client_retain;\n    66   \tuint16_t mid;\n    67   \tuint8_t client_qos, msg_qos;\n    68   \tmosquitto_property *properties = NULL;\n    72   \trc2 = mosquitto_acl_check(leaf->context, topic, stored->payloadlen, stored->payload, stored->qos, stored->retain, MOSQ_ACL_READ);\n    73   \tif(rc2 == MOSQ_ERR_ACL_DENIED){\n    74   \t\treturn MOSQ_ERR_SUCCESS;\n    75   \t}else if(rc2 == MOSQ_ERR_SUCCESS){\n    76   \t\tclient_qos = leaf->qos;\n    87   \t\tif(msg_qos){\n    88   \t\t\tmid = mosquitto__mid_generate(leaf->context);\n    89   \t\t}else{\n    92   \t\tif(leaf->retain_as_published){\n    93   \t\t\tclient_retain = retain;\n    94   \t\t}else{\n    97   \t\tif(leaf->identifier){\n    98   \t\t\tmosquitto_property_add_varint(&properties, MQTT_PROP_SUBSCRIPTION_IDENTIFIER, leaf->identifier);\n    99   \t\t}\n    100  \t\tif(db__message_insert(leaf->context, mid, mosq_md_out, msg_qos, client_retain, stored, properties, true) == 1){\n    101  \t\t\treturn 1;\n    102  \t\t}\n    103  \t}else{\n    104  \t\treturn 1; /* Application error */\n    105  \t}\n    107  }\nFunction: sub__clean_session\nPath: /root/projects/mosquitto/src/subs.c:746\n    746  int sub__clean_session(struct mosquitto *context)\n    747  {\n    748  \tint i;\n    749  \tstruct mosquitto__subleaf *leaf;\n    750  \tstruct mosquitto__subhier *hier;\n    752  \tfor(i=0; i<context->sub_count; i++){\n    753  \t\tif(context->subs[i] == NULL){\n    755  \t\t}\n    757  \t\thier = context->subs[i]->hier;\n    759  \t\tif(context->subs[i]->shared){\n    760  \t\t\tleaf = context->subs[i]->shared->subs;\n    761  \t\t\twhile(leaf){\n    762  \t\t\t\tif(leaf->context==context){\n    766  \t\t\t\t\tsub__remove_shared_leaf(context->subs[i]->hier, context->subs[i]->shared, leaf);\n    768  \t\t\t\t}\n    769  \t\t\t\tleaf = leaf->next;\n    770  \t\t\t}\n    771  \t\t}else{\n    772  \t\t\tleaf = hier->subs;\n    773  \t\t\twhile(leaf){\n    774  \t\t\t\tif(leaf->context==context){\n    778  \t\t\t\t\tDL_DELETE(hier->subs, leaf);\n    779  \t\t\t\t\tmosquitto__free(leaf);\n    781  \t\t\t\t}\n    782  \t\t\t\tleaf = leaf->next;\n    783  \t\t\t}\n    784  \t\t}\n    785  \t\tmosquitto__free(context->subs[i]);\n    786  \t\tcontext->subs[i] = NULL;\n    788  \t\tif(hier->subs == NULL\n    789  \t\t\t\t&& hier->children == NULL\n    790  \t\t\t\t&& hier->shared == NULL\n    791  \t\t\t\t&& hier->parent){\n    794  \t\t\t\thier = tmp_remove_subs(hier);\n    795  \t\t\t}while(hier);\n    796  \t\t}\n    797  \t}\n    798  \tmosquitto__free(context->subs);\n    799  \tcontext->subs = NULL;\n    800  \tcontext->sub_count = 0;\n    803  }\nFunction: tmp_remove_subs\nPath: /root/projects/mosquitto/src/subs.c:715\n    715  static struct mosquitto__subhier *tmp_remove_subs(struct mosquitto__subhier *sub)\n    716  {\n    719  \tif(!sub || !sub->parent){\n    720  \t\treturn NULL;\n    721  \t}\n    723  \tif(sub->children || sub->subs){\n    724  \t\treturn NULL;\n    725  \t}\n    727  \tparent = sub->parent;\n    728  \tHASH_DELETE(hh, parent->children, sub);\n    729  \tmosquitto__free(sub->topic);\n    730  \tmosquitto__free(sub);\n    732  \tif(parent->subs == NULL\n    733  \t\t\t&& parent->children == NULL\n    734  \t\t\t&& parent->shared == NULL\n    735  \t\t\t&& parent->parent){\n    737  \t\treturn parent;\n    738  \t}else{\n    739  \t\treturn NULL;\n    740  \t}\n    741  }\nFunction: util__increment_send_quota\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:222\n    222  void util__increment_send_quota(struct mosquitto *mosq)\n    223  {\n    224  \tif(mosq->msgs_out.inflight_quota < mosq->msgs_out.inflight_maximum){\n    225  \t\tmosq->msgs_out.inflight_quota++;\n    226  \t}\n    227  }\nFunction: will_delay__remove\nPath: /root/projects/mosquitto/src/will_delay.c:99\n    99   void will_delay__remove(struct mosquitto *mosq)\n    100  {\n    101  \tif(mosq->will_delay_entry != NULL){\n    102  \t\tDL_DELETE(delay_list, mosq->will_delay_entry);\n    103  \t\tmosquitto__free(mosq->will_delay_entry);\n    104  \t\tmosq->will_delay_entry = NULL;\n    105  \t}\n    106  }\nFunction: will__clear\nPath: /root/projects/mosquitto/src/../lib/will_mosq.c:111\n    111  int will__clear(struct mosquitto *mosq)\n    112  {\n    113  \tif(!mosq->will) return MOSQ_ERR_SUCCESS;\n    115  \tmosquitto__free(mosq->will->msg.topic);\n    116  \tmosq->will->msg.topic = NULL;\n    118  \tmosquitto__free(mosq->will->msg.payload);\n    119  \tmosq->will->msg.payload = NULL;\n    121  \tmosquitto_property_free_all(&mosq->will->properties);\n    123  \tmosquitto__free(mosq->will);\n    124  \tmosq->will = NULL;\n    125  \tmosq->will_delay_interval = 0;\n    128  }\n",
    "If the value of Request Problem Information is 0, the Server MAY return a Reason String or User Properties on a CONNACK or DISCONNECT packet, but MUST NOT send a Reason String or User Properties on any packet other than PUBLISH, CONNACK, or DISCONNECT.": "Function: plugin__handle_disconnect\nPath: /root/projects/mosquitto/src/plugin.c:106\n    106  void plugin__handle_disconnect(struct mosquitto *context, int reason)\n    107  {\n    109  \tstruct mosquitto__callback *cb_base;\n    1",
    "A Server MAY allow a Client to supply a ClientID that has a length of zero bytes, however if it does so the Server MUST treat this as a special case and assign a unique ClientID to that Client [MQTT-3.1.3-6].": "Function: context__remove_from_by_id\nPath: /root/projects/mosquitto/src/context.c:302\n    302  void context__remove_from_by_id(struct mosquitto *context)\n    303  {\n    304  \tstruct mosquitto *context_found;\n    306  \tif(context->in_by_id == true && context->id){\n    307  \t\tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), context_found);\n    308  \t\tif(context_found){\n    309  \t\t\tHASH_DELETE(hh_id, db.contexts_by_id, context_found);\n    310  \t\t}\n    312  \t}\n    313  }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    94   \tpacket->command = 0;\n    97   \tpacket->remaining_length = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    150  \tpacket->pos = 0;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    345  \t}\n    353  }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    250  \t}\n    263  \tif(!context->clean_start){\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    294  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    330  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    250  \tif(context->id){\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    705  \tconst char *source_id;\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    557  \t}else{\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    613  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    618  \n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    630  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    639  \t\t\t\t\trc = MOSQ_ERR_NOMEM;\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    976  \tcontext->clean_start = true;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    53   \tchar *client_id;\n    54   \tuint8_t rnd[16];\n    55   \tint i;\n    56   \tint pos;\n    57   \n    58   \tif(util__random_bytes(rnd, 16)) return NULL;\n    59   \n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    61   \n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    69   \n    70   \tpos = 0;\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    80   \n    81   \treturn client_id;\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    391  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Client %s connected with too large Will payload\", client_id);\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    424  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    106  \t\t*length = 0;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: send__auth\nPath: /root/projects/mosquitto/src/send_auth.c:28\n    28   int send__auth(struct mosquitto *context, uint8_t reason_code, const void *auth_data, uint16_t auth_data_len)\n    29   {\n    38   \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending AUTH to %s (rc%d, %s)\", context->id, reason_code, context->auth_method);\n    81   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    109  }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    118  }\nFunction: send__publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:42\n    42   int send__publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    43   {\n    47   \tint i;\n    49   \tbool match;\n    51   \tchar *mapped_topic = NULL;\n    78   \tif(mosq->bridge && mosq->bridge->topics && mosq->bridge->topic_remapping){\n    79   \t\tfor(i=0; i<mosq->bridge->topic_count; i++){\n    80   \t\t\tcur_topic = &mosq->bridge->topics[i];\n    81   \t\t\tif((cur_topic->direction == bd_both || cur_topic->direction == bd_out)\n    82   \t\t\t\t\t&& (cur_topic->remote_prefix || cur_topic->local_prefix)){\n    85   \t\t\t\trc = mosquitto_topic_matches_sub(cur_topic->local_topic, topic, &match);\n    86   \t\t\t\tif(rc){\n    87   \t\t\t\t\treturn rc;\n    88   \t\t\t\t}\n    89   \t\t\t\tif(match){\n    90   \t\t\t\t\tmapped_topic = mosquitto__strdup(topic);\n    91   \t\t\t\t\tif(!mapped_topic) return MOSQ_ERR_NOMEM;\n    92   \t\t\t\t\tif(cur_topic->local_prefix){\n    94   \t\t\t\t\t\tif(!strncmp(cur_topic->local_prefix, mapped_topic, strlen(cur_topic->local_prefix))){\n    95   \t\t\t\t\t\t\ttopic_temp = mosquitto__strdup(mapped_topic+strlen(cur_topic->local_prefix));\n    97   \t\t\t\t\t\t\tif(!topic_temp){\n    98   \t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    99   \t\t\t\t\t\t\t}\n    101  \t\t\t\t\t\t}\n    102  \t\t\t\t\t}\n    104  \t\t\t\t\tif(cur_topic->remote_prefix){\n    106  \t\t\t\t\t\tlen = strlen(mapped_topic) + strlen(cur_topic->remote_prefix)+1;\n    107  \t\t\t\t\t\ttopic_temp = mosquitto__malloc(len+1);\n    108  \t\t\t\t\t\tif(!topic_temp){\n    109  \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    110  \t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    111  \t\t\t\t\t\t}\n    112  \t\t\t\t\t\tsnprintf(topic_temp, len, \"%s%s\", cur_topic->remote_prefix, mapped_topic);\n    113  \t\t\t\t\t\ttopic_temp[len] = '\\0';\n    114  \t\t\t\t\t\tmosquitto__free(mapped_topic);\n    116  \t\t\t\t\t}\n    117  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, mapped_topic, (long)payloadlen);\n    119  \t\t\t\t\trc =  send__real_publish(mosq, mid, mapped_topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    120  \t\t\t\t\tmosquitto__free(mapped_topic);\n    121  \t\t\t\t\treturn rc;\n    122  \t\t\t\t}\n    123  \t\t\t}\n    124  \t\t}\n    125  \t}\n    127  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, topic, (long)payloadlen);\n    134  }\nFunction: send__real_publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:137\n    137  int send__real_publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    138  {\n    140  \tunsigned int packetlen;\n    141  \tunsigned int proplen = 0, varbytes;\n    143  \tmosquitto_property expiry_prop;\n    147  \tif(topic){\n    148  \t\tpacketlen = 2+(unsigned int)strlen(topic) + payloadlen;\n    149  \t}else{\n    150  \t\tpacketlen = 2 + payloadlen;\n    151  \t}\n    152  \tif(qos > 0) packetlen += 2; /* For message id */\n    153  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tproplen += property__get_length_all(cmsg_props);\n    156  \t\tproplen += property__get_length_all(store_props);\n    157  \t\tif(expiry_interval > 0){\n    163  \t\t\tproplen += property__get_length_all(&expiry_prop);\n    164  \t\t}\n    166  \t\tvarbytes = packet__varint_bytes(proplen);\n    172  \t\t}else{\n    173  \t\t\tpacketlen += proplen + varbytes;\n    174  \t\t}\n    175  \t}\n    176  \tif(packet__check_oversize(mosq, packetlen)){\n    178  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Dropping too large outgoing PUBLISH for %s (%d bytes)\", SAFE_PRINT(mosq->id), packetlen);\n    182  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    183  \t}\n    221  }\nFunction: mosquitto_validate_utf8\nPath: /root/projects/mosquitto/src/../lib/utf8_mosq.c:24\n    24   int mosquitto_validate_utf8(const char *str, int len)\n    25   {\n    26   \tint i;\n    27   \tint j;\n    28   \tint codelen;\n    29   \tint codepoint;\n    32   \tif(!str) return MOSQ_ERR_INVAL;\n    35   \tfor(i=0; i<len; i++){\n    36   \t\tif(ustr[i] == 0){\n    37   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    38   \t\t}else if(ustr[i] <= 0x7f){\n    40   \t\t\tcodepoint = ustr[i];\n    41   \t\t}else if((ustr[i] & 0xE0) == 0xC0){\n    43   \t\t\tif(ustr[i] == 0xC0 || ustr[i] == 0xC1){\n    45   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    46   \t\t\t}\n    48   \t\t\tcodepoint = (ustr[i] & 0x1F);\n    49   \t\t}else if((ustr[i] & 0xF0) == 0xE0){\n    52   \t\t\tcodepoint = (ustr[i] & 0x0F);\n    53   \t\t}else if((ustr[i] & 0xF8) == 0xF0){\n    55   \t\t\tif(ustr[i] > 0xF4){\n    57   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    58   \t\t\t}\n    60   \t\t\tcodepoint = (ustr[i] & 0x07);\n    61   \t\t}else{\n    63   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    64   \t\t}\n    67   \t\tif(i == len-codelen+1){\n    69   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    70   \t\t}\n    71   \t\tfor(j=0; j<codelen-1; j++){\n    72   \t\t\tif((ustr[++i] & 0xC0) != 0x80){\n    74   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    75   \t\t\t}\n    76   \t\t\tcodepoint = (codepoint<<6) | (ustr[i] & 0x3F);\n    77   \t\t}\n    80   \t\tif(codepoint >= 0xD800 && codepoint <= 0xDFFF){\n    81   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    82   \t\t}\n    88   \t\t *\t return MOSQ_ERR_MALFORMED_UTF8;\n    91   \t\tif(codelen == 3 && codepoint < 0x0800){\n    92   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    93   \t\t}else if(codelen == 4 && (codepoint < 0x10000 || codepoint > 0x10FFFF)){\n    94   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    95   \t\t}\n    98   \t\tif(codepoint >= 0xFDD0 && codepoint <= 0xFDEF){\n    99   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    100  \t\t}\n    101  \t\tif((codepoint & 0xFFFF) == 0xFFFE || (codepoint & 0xFFFF) == 0xFFFF){\n    102  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    103  \t\t}\n    105  \t\tif(codepoint <= 0x001F || (codepoint >= 0x007F && codepoint <= 0x009F)){\n    106  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    107  \t\t}\n    108  \t}\n    110  }\n",
    "A value of 0 indicates that the Server MUST NOT return Response Information [MQTT-3.1.2-28].": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    221  \tplugin__handle_disconnect(context, -1);\n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    226  \tif(context->bridge == NULL)\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    231  \t\t\t/* Client session is due to be expired now */\n    232  \t\t\tif(context->will_delay_interval == 0){\n    233  \t\t\t\t/* This will be done later, after the will is published for delay>0. */\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__read_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:178\n    178  int packet__read_uint32(struct mosquitto__packet *packet, uint32_t *word)\n    179  {\n    180  \tuint32_t val = 0;\n    181  \tint i;\n    183  \tassert(packet);\n    184  \tif(packet->pos+4 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    186  \tfor(i=0; i<4; i++){\n    187  \t\tval = (val << 8) + packet->payload[packet->pos];\n    188  \t\tpacket->pos++;\n    189  \t}\n    191  \t*word = val;\n    194  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    223  \t\t\t\t\t/* Catch overlong encodings */\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    147  \tassert(mosq);\n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    153  \tpacket->next = NULL;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    187  \treturn packet__write(mosq);\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    353  }\nFunction: property__process_connect\nPath: /root/projects/mosquitto/src/property_broker.c:30\n    30   int property__process_connect(struct mosquitto *context, mosquitto_property **props)\n    31   {\n    32   \tmosquitto_property *p;\n    34   \tp = *props;\n    36   \twhile(p){\n    37   \t\tif(p->identifier == MQTT_PROP_SESSION_EXPIRY_INTERVAL){\n    38   \t\t\tcontext->session_expiry_interval = p->value.i32;\n    39   \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM){\n    40   \t\t\tif(p->value.i16 == 0){\n    41   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    42   \t\t\t}\n    44   \t\t\tcontext->msgs_out.inflight_maximum = p->value.i16;\n    45   \t\t\tcontext->msgs_out.inflight_quota = context->msgs_out.inflight_maximum;\n    46   \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    47   \t\t\tif(p->value.i32 == 0){\n    48   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    49   \t\t\t}\n    50   \t\t\tcontext->maximum_packet_size = p->value.i32;\n    51   \t\t}\n    52   \t\tp = p->next;\n    53   \t}\n    56   }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__read\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:35\n    35   static int property__read(struct mosquitto__packet *packet, uint32_t *len, mosquitto_property *property)\n    36   {\n    38   \tuint32_t property_identifier;\n    39   \tuint8_t byte;\n    40   \tuint8_t byte_count;\n    41   \tuint16_t uint16;\n    42   \tuint32_t uint32;\n    43   \tuint32_t varint;\n    44   \tchar *str1, *str2;\n    45   \tuint16_t slen1, slen2;\n    47   \tif(!property) return MOSQ_ERR_INVAL;\n    49   \trc = packet__read_varint(packet, &property_identifier, NULL);\n    50   \tif(rc){\n    51   \t\treturn rc;\n    52   \t}\n    55   \tmemset(property, 0, sizeof(mosquitto_property));\n    57   \tproperty->identifier = (int32_t)property_identifier;\n    59   \tswitch(property_identifier){\n    60   \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    61   \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    62   \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    63   \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    64   \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    65   \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    66   \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    67   \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    68   \t\t\trc = packet__read_byte(packet, &byte);\n    69   \t\t\tif(rc) return rc;\n    71   \t\t\tproperty->value.i8 = byte;\n    72   \t\t\tbreak;\n    74   \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    75   \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    76   \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    77   \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    78   \t\t\trc = packet__read_uint16(packet, &uint16);\n    79   \t\t\tif(rc) return rc;\n    81   \t\t\tproperty->value.i16 = uint16;\n    82   \t\t\tbreak;\n    84   \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    85   \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    86   \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    87   \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    88   \t\t\trc = packet__read_uint32(packet, &uint32);\n    89   \t\t\tif(rc) return rc;\n    91   \t\t\tproperty->value.i32 = uint32;\n    92   \t\t\tbreak;\n    94   \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    95   \t\t\trc = packet__read_varint(packet, &varint, &byte_count);\n    96   \t\t\tif(rc) return rc;\n    98   \t\t\tproperty->value.varint = varint;\n    99   \t\t\tbreak;\n    101  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    102  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    103  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    104  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    105  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    106  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    107  \t\tcase MQTT_PROP_REASON_STRING:\n    108  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    109  \t\t\tif(rc) return rc;\n    111  \t\t\tproperty->value.s.v = str1;\n    112  \t\t\tproperty->value.s.len = slen1;\n    113  \t\t\tbreak;\n    115  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    116  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    117  \t\t\trc = packet__read_binary(packet, (uint8_t **)&str1, &slen1);\n    118  \t\t\tif(rc) return rc;\n    120  \t\t\tproperty->value.bin.v = str1;\n    121  \t\t\tproperty->value.bin.len = slen1;\n    122  \t\t\tbreak;\n    124  \t\tcase MQTT_PROP_USER_PROPERTY:\n    125  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    126  \t\t\tif(rc) return rc;\n    129  \t\t\trc = packet__read_string(packet, &str2, &slen2);\n    130  \t\t\tif(rc){\n    131  \t\t\t\tmosquitto__free(str1);\n    132  \t\t\t\treturn rc;\n    133  \t\t\t}\n    136  \t\t\tproperty->name.v = str1;\n    137  \t\t\tproperty->name.len = slen1;\n    138  \t\t\tproperty->value.s.v = str2;\n    139  \t\t\tproperty->value.s.len = slen2;\n    140  \t\t\tbreak;\n    142  \t\tdefault:\n    144  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property_identifier);\n    146  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    147  \t}\n    150  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    230  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: property__get_length_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:335\n    335  unsigned int property__get_length_all(const mosquitto_property *property)\n    336  {\n    337  \tconst mosquitto_property *p;\n    338  \tunsigned int len = 0;\n    341  \twhile(p){\n    342  \t\tlen += property__get_length(p);\n    343  \t\tp = p->next;\n    344  \t}\n    345  \treturn len;\n    346  }\nFunction: property__write_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:429\n    429  int property__write_all(struct mosquitto__packet *packet, const mosquitto_property *properties, bool write_len)\n    430  {\n    432  \tconst mosquitto_property *p;\n    440  \twhile(p){\n    441  \t\trc = property__write(packet, p);\n    442  \t\tif(rc) return rc;\n    443  \t\tp = p->next;\n    444  \t}\n    447  }\nFunction: property__write\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:361\n    361  static int property__write(struct mosquitto__packet *packet, const mosquitto_property *property)\n    362  {\n    365  \trc = packet__write_varint(packet, (uint32_t)property->identifier);\n    366  \tif(rc) return rc;\n    368  \tswitch(property->identifier){\n    371  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    394  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    395  \t\t\treturn packet__write_varint(packet, property->value.varint);\n    397  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    398  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    399  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    400  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    401  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    402  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    403  \t\tcase MQTT_PROP_REASON_STRING:\n    404  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    405  \t\t\tbreak;\n    407  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    408  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    409  \t\t\tpacket__write_uint16(packet, property->value.bin.len);\n    410  \t\t\tpacket__write_bytes(packet, property->value.bin.v, property->value.bin.len);\n    411  \t\t\tbreak;\n    413  \t\tcase MQTT_PROP_USER_PROPERTY:\n    414  \t\t\tpacket__write_string(packet, property->name.v, property->name.len);\n    415  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    416  \t\t\tbreak;\n    418  \t\tdefault:\n    420  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property->identifier);\n    422  \t\t\treturn MOSQ_ERR_INVAL;\n    423  \t}\n    426  }\nFunction: mosquitto_property_read_binary\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1106\n    1106 const mosquitto_property *mosquitto_property_read_binary(const mosquitto_property *proplist, int identifier, void **value, uint16_t *len, bool skip_first)\n    1107 {\n    1109 \tif(!proplist || (value && !len) || (!value && len)) return NULL;\n    1113 \tp = property__get_property(proplist, identifier, skip_first);\n    1114 \tif(!p) return NULL;\n    1115 \tif(p->identifier != MQTT_PROP_CORRELATION_DATA\n    1116 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_DATA){\n    1118 \t\treturn NULL;\n    1119 \t}\n    1121 \tif(value){\n    1122 \t\t*len = p->value.bin.len;\n    1123 \t\t*value = calloc(1, *len + 1U);\n    1124 \t\tif(!(*value)) return NULL;\n    1126 \t\tmemcpy(*value, p->value.bin.v, *len);\n    1127 \t}\n    1130 }\nFunction: mosquitto_property_read_string\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1133\n    1133 const mosquitto_property *mosquitto_property_read_string(const mosquitto_property *proplist, int identifier, char **value, bool skip_first)\n    1134 {\n    1136 \tif(!proplist) return NULL;\n    1138 \tp = property__get_property(proplist, identifier, skip_first);\n    1139 \tif(!p) return NULL;\n    1140 \tif(p->identifier != MQTT_PROP_CONTENT_TYPE\n    1141 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_TOPIC\n    1142 \t\t\t&& p->identifier != MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER\n    1143 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_METHOD\n    1144 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_INFORMATION\n    1145 \t\t\t&& p->identifier != MQTT_PROP_SERVER_REFERENCE\n    1146 \t\t\t&& p->identifier != MQTT_PROP_REASON_STRING){\n    1148 \t\treturn NULL;\n    1149 \t}\n    1151 \tif(value){\n    1152 \t\t*value = calloc(1, (size_t)p->value.s.len+1);\n    1153 \t\tif(!(*value)) return NULL;\n    1155 \t\tmemcpy(*value, p->value.s.v, p->value.s.len);\n    1156 \t}\n    1159 }\nFunction: db__expire_all_messages\nPath: /root/projects/mosquitto/src/database.c:1053\n    1053 void db__expire_all_messages(struct mosquitto *context)\n    1055 \tstruct mosquitto_client_msg *msg, *tmp;\n    1057 \tDL_FOREACH_SAFE(context->msgs_out.inflight, msg, tmp){\n    1058 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1059 \t\t\tif(msg->qos > 0){\n    1060 \t\t\t\tutil__increment_send_quota(context);\n    1062 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1065 \tDL_FOREACH_SAFE(context->msgs_out.queued, msg, tmp){\n    1066 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1067 \t\t\tdb__message_remove_from_queued(&context->msgs_out, msg);\n    1070 \tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n    1071 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1072 \t\t\tif(msg->qos > 0){\n    1073 \t\t\t\tutil__increment_receive_quota(context);\n    1075 \t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n    1078 \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n    1079 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1080 \t\t\tdb__message_remove_from_queued(&context->msgs_in, msg);\n    1083 }\nFunction: db__message_remove_from_queued\nPath: /root/projects/mosquitto/src/database.c:364\n    364  static void db__message_remove_from_queued(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    365  {\n    366  \tif(!msg_data || !item){\n    367  \t\treturn;\n    368  \t}\n    370  \tDL_DELETE(msg_data->queued, item);\n    377  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1183 \tstruct mosquitto_client_msg *tail, *tmp;\n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1190 \tDL_FOREACH_SAFE(context->msgs_out.inflight, tail, tmp){\n    1191 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1192 \t\tif(rc) return rc;\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    143  \t\t\t\tin_quota = context->msgs_in.inflight_quota;\n    144  \t\t\t\tout_quota = context->msgs_out.inflight_quota;\n    145  \t\t\t\tin_maximum = context->msgs_in.inflight_maximum;\n    146  \t\t\t\tout_maximum = context->msgs_out.inflight_maximum;\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    154  \t\t\t\tcontext->msgs_in.inflight_quota = in_quota;\n    155  \t\t\t\tcontext->msgs_out.inflight_quota = out_quota;\n    156  \t\t\t\tcontext->msgs_in.inflight_maximum = in_maximum;\n    157  \t\t\t\tcontext->msgs_out.inflight_maximum = out_maximum;\n    159  \t\t\t\tdb__message_reconnect_reset(context);\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    215  \trc = acl__find_acls(context);\n    216  \tif(rc){\n    218  \t\treturn rc;\n    219  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    250  \t}\n    252  \tcontext->ping_t = 0;\n    253  \tcontext->is_dropping = false;\n    255  \tconnection_check_acl(context, &context->msgs_in.inflight);\n    256  \tconnection_check_acl(context, &context->msgs_in.queued);\n    257  \tconnection_check_acl(context, &context->msgs_out.inflight);\n    258  \tconnection_check_acl(context, &context->msgs_out.queued);\n    260  \tcontext__add_to_by_id(context);\n    263  \tif(!context->clean_start){\n    267  \tcontext->max_qos = context->listener->max_qos;\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    315  \tkeepalive__add(context);\n    317  \tmosquitto__set_state(context, mosq_cs_active);\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    320  \tif(rc) return rc;\n    321  \tdb__expire_all_messages(context);\n    322  \trc = db__message_write_queued_out(context);\n    323  \tif(rc) return rc;\n    324  \trc = db__message_write_inflight_out_all(context);\n    330  }\nFunction: connection_check_acl\nPath: /root/projects/mosquitto/src/handle_connect.c:86\n    86   static void connection_check_acl(struct mosquitto *context, struct mosquitto_client_msg **head)\n    97   \t\tif(mosquitto_acl_check(context, msg_tail->store->topic,\n    99   \t\t\t\t\t\t\t   msg_tail->store->qos, msg_tail->store->retain, access) != MOSQ_ERR_SUCCESS){\n    101  \t\t\tDL_DELETE((*head), msg_tail);\n    107  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    248  \tmosquitto__set_state(context, mosq_cs_disused);\n    250  \tif(context->id){\n    251  \t\tcontext__remove_from_by_id(context);\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    256  \tcontext->for_free_next = db.ll_for_free;\n    257  \tdb.ll_for_free = context;\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    296  \t\tcontext->in_by_id = true;\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__msg_add_to_queued_stats\nPath: /root/projects/mosquitto/src/database.c:162\n    162  void db__msg_add_to_queued_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    163  {\n    164  \tmsg_data->queued_count++;\n    165  \tmsg_data->queued_bytes += msg->store->payloadlen;\n    166  \tif(msg->qos != 0){\n    167  \t\tmsg_data->queued_count12++;\n    168  \t\tmsg_data->queued_bytes12 += msg->store->payloadlen;\n    169  \t}\n    170  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    271  \tmosquitto__free(store->source_id);\n    272  \tmosquitto__free(store->source_username);\n    283  }\nFunction: db__message_remove_from_inflight\nPath: /root/projects/mosquitto/src/database.c:347\n    347  static void db__message_remove_from_inflight(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    348  {\n    349  \tif(!msg_data || !item){\n    350  \t\treturn;\n    351  \t}\n    353  \tDL_DELETE(msg_data->inflight, item);\n    354  \tif(item->store){\n    355  \t\tdb__msg_remove_from_inflight_stats(msg_data, item);\n    357  \t}\n    361  }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1097 \tuint32_t expiry_interval;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1102 \t\t\t/* Message is expired, must not send. */\n    1103 \t\t\tif(msg->direction == mosq_md_out && msg->qos > 0){\n    1104 \t\t\t\tutil__increment_send_quota(context);\n    1105 \t\t\t}\n    1106 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1126 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1135 \t\t\t\tmsg->timestamp = db.now_s;\n    1136 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1137 \t\t\t\tmsg->state = mosq_ms_wait_for_puback;\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1139 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1148 \t\t\t\tmsg->timestamp = db.now_s;\n    1149 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1150 \t\t\t\tmsg->state = mosq_ms_wait_for_pubrec;\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1152 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1159 \t\t\trc = send__pubrel(context, mid, NULL);\n    1160 \t\t\tif(!rc){\n    1161 \t\t\t\tmsg->state = mosq_ms_wait_for_pubcomp;\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1176 \t}\n    1178 }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    449  \tstruct mosquitto_msg_data *msg_data;\n    450  \tenum mosquitto_msg_state state = mosq_ms_invalid;\n    452  \tint i;\n    457  \tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n    459  \tif(dir == mosq_md_out){\n    460  \t\tmsg_data = &context->msgs_out;\n    461  \t}else{\n    462  \t\tmsg_data = &context->msgs_in;\n    463  \t}\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    484  \tif(context->sock == INVALID_SOCKET){\n    486  \t\tif(qos == 0 && !db.config->queue_qos0_messages){\n    487  \t\t\tif(!context->bridge){\n    488  \t\t\t\tmosquitto_property_free_all(&properties);\n    489  \t\t\t\treturn 2;\n    490  \t\t\t}else{\n    491  \t\t\t\tif(context->bridge->start_type != bst_lazy){\n    492  \t\t\t\t\tmosquitto_property_free_all(&properties);\n    493  \t\t\t\t\treturn 2;\n    494  \t\t\t\t}\n    495  \t\t\t}\n    496  \t\t}\n    497  \t\tif(context->bridge && context->bridge->clean_start_local == true){\n    498  \t\t\tmosquitto_property_free_all(&properties);\n    499  \t\t\treturn 2;\n    500  \t\t}\n    501  \t}\n    503  \tif(context->sock != INVALID_SOCKET){\n    504  \t\tif(db__ready_for_flight(context, dir, qos)){\n    517  \t\t\t}else{\n    520  \t\t\t\t}else{\n    521  \t\t\t\t\tmosquitto_property_free_all(&properties);\n    522  \t\t\t\t\treturn 1;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n    528  \t\t}else{\n    530  \t\t\tif(context->is_dropping == false){\n    531  \t\t\t\tcontext->is_dropping = true;\n    532  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    534  \t\t\t\t\t\tcontext->id);\n    535  \t\t\t}\n    537  \t\t\tmosquitto_property_free_all(&properties);\n    538  \t\t\treturn 2;\n    539  \t\t}\n    540  \t}else{\n    541  \t\tif (db__ready_for_queue(context, qos, msg_data)){\n    543  \t\t}else{\n    545  \t\t\tif(context->is_dropping == false){\n    546  \t\t\t\tcontext->is_dropping = true;\n    547  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    549  \t\t\t\t\t\tcontext->id);\n    550  \t\t\t}\n    551  \t\t\tmosquitto_property_free_all(&properties);\n    552  \t\t\treturn 2;\n    553  \t\t}\n    554  \t}\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    582  \tif(state == mosq_ms_queued){\n    583  \t\tDL_APPEND(msg_data->queued, msg);\n    585  \t}else{\n    586  \t\tDL_APPEND(msg_data->inflight, msg);\n    588  \t}\n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    598  \t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n    599  \t\tif(dest_ids){\n    602  \t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t}\n    609  \t}\n    611  \tif(context->bridge && context->bridge->start_type == bst_lazy\n    612  \t\t\t&& context->sock == INVALID_SOCKET\n    613  \t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n    616  \t}\n    633  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    704  \tstruct mosquitto_msg_store *stored;\n    705  \tconst char *source_id;\n    706  \tenum mosquitto_msg_origin origin;\n    710  \tstored = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    711  \tif(stored == NULL) return MOSQ_ERR_NOMEM;\n    713  \tstored->topic = mosquitto__strdup(topic);\n    714  \tif(stored->topic == NULL){\n    715  \t\tdb__msg_store_free(stored);\n    716  \t\treturn MOSQ_ERR_INVAL;\n    717  \t}\n    719  \tstored->qos = qos;\n    720  \tif(db.config->retain_available == false){\n    721  \t\tstored->retain = 0;\n    722  \t}else{\n    723  \t\tstored->retain = retain;\n    724  \t}\n    726  \tstored->payloadlen = payloadlen;\n    727  \tif(payloadlen > 0){\n    728  \t\tstored->payload = mosquitto__malloc(stored->payloadlen+1);\n    729  \t\tif(stored->payload == NULL){\n    730  \t\t\tdb__msg_store_free(stored);\n    731  \t\t\treturn MOSQ_ERR_NOMEM;\n    732  \t\t}\n    734  \t\t((uint8_t *)stored->payload)[stored->payloadlen] = 0;\n    735  \t\tmemcpy(stored->payload, payload, stored->payloadlen);\n    736  \t}\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    746  \t}\n    748  \tif(context){\n    750  \t}else{\n    753  \tif(db__message_store(context, stored, message_expiry_interval, 0, origin)) return 1;\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    763  \tif(source && source->id){\n    764  \t\tstored->source_id = mosquitto__strdup(source->id);\n    765  \t}else{\n    766  \t\tstored->source_id = mosquitto__strdup(\"\");\n    767  \t}\n    768  \tif(!stored->source_id){\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    774  \tif(source && source->username){\n    775  \t\tstored->source_username = mosquitto__strdup(source->username);\n    776  \t\tif(!stored->source_username){\n    778  \t\t\treturn MOSQ_ERR_NOMEM;\n    779  \t\t}\n    780  \t}\n    781  \tif(source){\n    782  \t\tstored->source_listener = source->listener;\n    783  \t}\n    806  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    448  \tX509 *client_cert = NULL;\n    460  \tif(!context->listener){\n    461  \t\treturn MOSQ_ERR_INVAL;\n    462  \t}\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    502  \t\tcontext->protocol = mosq_p_mqtt31;\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    504  \t\t\tcontext->is_bridge = true;\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    508  \t\t\tcontext->protocol = mosq_p_mqtt311;\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    511  \t\t\t\tcontext->is_bridge = true;\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    514  \t\t\tcontext->protocol = mosq_p_mqtt5;\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    534  \t\trc = MOSQ_ERR_PROTOCOL;\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    563  \t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid Will QoS in CONNECT from %s.\",\n    564  \t\t\t\tcontext->address);\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    724  \tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    731  \t\tif(!context->ssl){\n    732  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    741  \t\tif(context->listener->psk_hint){\n    743  \t\t\tif(!context->username){\n    744  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    754  \t\t\tclient_cert = SSL_get_peer_certificate(context->ssl);\n    755  \t\t\tif(!client_cert){\n    756  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    764  \t\t\tname = X509_get_subject_name(client_cert);\n    765  \t\t\tif(!name){\n    766  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    768  \t\t\t\t}else{\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    770  \t\t\t\t}\n    774  \t\t\tif (context->listener->use_identity_as_username) { /* use_identity_as_username */\n    775  \t\t\t\ti = X509_NAME_get_index_by_NID(name, NID_commonName, -1);\n    776  \t\t\t\tif(i == -1){\n    777  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    785  \t\t\t\tname_entry = X509_NAME_get_entry(name, i);\n    786  \t\t\t\tif(name_entry){\n    787  \t\t\t\t\tname_asn1 = X509_NAME_ENTRY_get_data(name_entry);\n    788  \t\t\t\t\tif (name_asn1 == NULL) {\n    789  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    801  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_get0_data(name_asn1);\n    803  \t\t\t\t\tif(mosquitto_validate_utf8(new_username, (int)strlen(new_username))){\n    804  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    809  \t\t\t\t\t\tX509_free(client_cert);\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    814  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    824  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    835  \t\t\t\tX509_NAME_print_ex(subject_bio, X509_get_subject_name(client_cert), 0, XN_FLAG_RFC2253);\n    847  \t\t\t\tcontext->username = subject;\n    849  \t\t\tif(!context->username){\n    853  \t\t\tX509_free(client_cert);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    898  \t\t\tmosquitto__set_state(context, mosq_cs_authenticating);\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    905  \t\t\twill__clear(context);\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    925  \t\tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    973  \tif(client_cert) X509_free(client_cert);\n    976  \tcontext->clean_start = true;\n    977  \tcontext->session_expiry_interval = 0;\n    978  \tcontext->will_delay_interval = 0;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    55   \tint i;\n    56   \tint pos;\n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    335  \tint rc = MOSQ_ERR_SUCCESS;\n    337  \tuint16_t tlen;\n    340  \tuint16_t payloadlen;\n    341  \tmosquitto_property *properties = NULL;\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    349  \t\trc = property__read_all(CMD_WILL, &context->in_packet, &properties);\n    350  \t\tif(rc) goto error_cleanup;\n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    353  \t\tmosquitto_property_free_all(&properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    356  \trc = packet__read_string(&context->in_packet, &will_struct->msg.topic, &tlen);\n    357  \tif(rc) goto error_cleanup;\n    363  \tif(context->listener->mount_point){\n    364  \t\tslen = strlen(context->listener->mount_point) + strlen(will_struct->msg.topic) + 1;\n    365  \t\twill_topic_mount = mosquitto__malloc(slen+1);\n    366  \t\tif(!will_topic_mount){\n    368  \t\t\tgoto error_cleanup;\n    369  \t\t}\n    371  \t\tsnprintf(will_topic_mount, slen, \"%s%s\", context->listener->mount_point, will_struct->msg.topic);\n    372  \t\twill_topic_mount[slen] = '\\0';\n    374  \t\tmosquitto__free(will_struct->msg.topic);\n    375  \t\twill_struct->msg.topic = will_topic_mount;\n    376  \t}\n    378  \tif(!strncmp(will_struct->msg.topic, \"$CONTROL/\", strlen(\"$CONTROL/\"))){\n    380  \t\tgoto error_cleanup;\n    381  \t}\n    382  \trc = mosquitto_pub_topic_check(will_struct->msg.topic);\n    385  \trc = packet__read_uint16(&context->in_packet, &payloadlen);\n    386  \tif(rc) goto error_cleanup;\n    388  \twill_struct->msg.payloadlen = payloadlen;\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    393  \t\t\t\tsend__connack(context, 0, MQTT_RC_PACKET_TOO_LARGE, NULL);\n    394  \t\t\t}else{\n    395  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    396  \t\t\t}\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    400  \t\twill_struct->msg.payload = mosquitto__malloc((size_t)will_struct->msg.payloadlen);\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    406  \t\trc = packet__read_bytes(&context->in_packet, will_struct->msg.payload, (uint32_t)will_struct->msg.payloadlen);\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    416  error_cleanup:\n    417  \tif(will_struct){\n    418  \t\tmosquitto__free(will_struct->msg.topic);\n    419  \t\tmosquitto__free(will_struct->msg.payload);\n    422  \t}\n    424  }\nFunction: net__write\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:996\n    996  ssize_t net__write(struct mosquitto *mosq, const void *buf, size_t count)\n    997  {\n    999  \tint ret;\n    1001 \tassert(mosq);\n    1005 \tif(mosq->ssl){\n    1007 \t\tmosq->want_write = false;\n    1008 \t\tret = SSL_write(mosq->ssl, buf, (int)count);\n    1009 \t\tif(ret < 0){\n    1010 \t\t\tret = net__handle_ssl(mosq, ret);\n    1011 \t\t}\n    1012 \t\treturn (ssize_t )ret;\n    1013 \t}else{\n    1017 \treturn send(mosq->sock, buf, count, MSG_NOSIGNAL);\n    1020 \t}\n    1022 }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    51   \tassert(packet);\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__write_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:83\n    83   void packet__write_bytes(struct mosquitto__packet *packet, const void *bytes, uint32_t count)\n    84   {\n    86   \tassert(packet->pos+count <= packet->packet_length);\n    88   \tif(count > 0){\n    89   \t\tmemcpy(&(packet->payload[packet->pos]), bytes, count);\n    90   \t\tpacket->pos += count;\n    91   \t}\n    92   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    106  \t\t*length = 0;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: mosquitto_property_add_string\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:845\n    845  int mosquitto_property_add_string(mosquitto_property **proplist, int identifier, const char *value)\n    846  {\n    848  \tsize_t slen = 0;\n    851  \tif(value){\n    852  \t\tslen = strlen(value);\n    853  \t\tif(mosquitto_validate_utf8(value, (int)slen)) return MOSQ_ERR_MALFORMED_UTF8;\n    854  \t}\n    860  \t\t\t&& identifier != MQTT_PROP_RESPONSE_INFORMATION\n    867  \tprop = mosquitto__calloc(1, sizeof(mosquitto_property));\n    871  \tprop->identifier = identifier;\n    872  \tif(value && slen > 0){\n    873  \t\tprop->value.s.v = mosquitto__strdup(value);\n    874  \t\tif(!prop->value.s.v){\n    876  \t\t\treturn MOSQ_ERR_NOMEM;\n    877  \t\t}\n    878  \t\tprop->value.s.len = (uint16_t)slen;\n    879  \t}\n    883  }\nFunction: property__get_property\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:988\n    988  static const mosquitto_property *property__get_property(const mosquitto_property *proplist, int identifier, bool skip_first)\n    989  {\n    990  \tconst mosquitto_property *p;\n    995  \twhile(p){\n    996  \t\tif(p->identifier == identifier){\n    997  \t\t\tif(!is_first || !skip_first){\n    998  \t\t\t\treturn p;\n    999  \t\t\t}\n    1001 \t\t}\n    1002 \t\tp = p->next;\n    1003 \t}\n    1005 }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    324  \t\t\t\t\tcase MOSQ_ERR_SUCCESS:\n    325  \t\t\t\t\t\tbreak;\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    371  \t\tmux__delete(context);\n    372  \t\tcontext__disconnect(context);\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto__malloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:83\n    83   void *mosquitto__malloc(size_t size)\n    84   {\n    88   \tif(mem_limit && memcount + size > mem_limit){\n    89   \t\treturn NULL;\n    90   \t}\n    93   \tmem = malloc(size);\n    96   \tif(mem){\n    97   \t\tmemcount += malloc_usable_size(mem);\n    101  \t}\n    105  }\nFunction: mosquitto__strdup\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:144\n    144  char *mosquitto__strdup(const char *s)\n    145  {\n    148  \tif(mem_limit && memcount + strlen(s) > mem_limit){\n    149  \t\treturn NULL;\n    150  \t}\n    152  \tstr = strdup(s);\n    155  \tif(str){\n    156  \t\tmemcount += malloc_usable_size(str);\n    160  \t}\n    164  }\nFunction: mosquitto_free\nPath: /root/projects/mosquitto/src/memory_public.c:27\n    27   void mosquitto_free(void *mem)\n    29   \tmosquitto__free(mem);\n    30   }\nFunction: mosquitto_malloc\nPath: /root/projects/mosquitto/src/memory_public.c:32\n    32   void *mosquitto_malloc(size_t size)\n    34   \treturn mosquitto__malloc(size);\n    35   }\nFunction: mux_epoll__add_out\nPath: /root/projects/mosquitto/src/mux_epoll.c:108\n    108  int mux_epoll__add_out(struct mosquitto *context)\n    109  {\n    110  \tstruct epoll_event ev;\n    112  \tif(!(context->events & EPOLLOUT)) {\n    114  \t\tev.data.ptr = context;\n    116  \t\tif(epoll_ctl(db.epollfd, EPOLL_CTL_ADD, context->sock, &ev) == -1) {\n    117  \t\t\tif((errno != EEXIST)||(epoll_ctl(db.epollfd, EPOLL_CTL_MOD, context->sock, &ev) == -1)) {\n    119  \t\t\t}\n    120  \t\t}\n    121  \t\tcontext->events = EPOLLIN | EPOLLOUT;\n    122  \t}\n    124  }\nFunction: send__auth\nPath: /root/projects/mosquitto/src/send_auth.c:28\n    28   int send__auth(struct mosquitto *context, uint8_t reason_code, const void *auth_data, uint16_t auth_data_len)\n    29   {\n    32   \tmosquitto_property *properties = NULL;\n    35   \tif(context->auth_method == NULL) return MOSQ_ERR_INVAL;\n    36   \tif(context->protocol != mosq_p_mqtt5) return MOSQ_ERR_PROTOCOL;\n    38   \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending AUTH to %s (rc%d, %s)\", context->id, reason_code, context->auth_method);\n    42   \trc = mosquitto_property_add_string(&properties, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method);\n    43   \tif(rc){\n    45   \t\treturn rc;\n    46   \t}\n    56   \tremaining_length += property__get_remaining_length(properties);\n    58   \tif(packet__check_oversize(context, remaining_length)){\n    61   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    62   \t}\n    67   \tpacket->command = CMD_AUTH;\n    68   \tpacket->remaining_length = remaining_length;\n    70   \trc = packet__alloc(packet);\n    76   \tpacket__write_byte(packet, reason_code);\n    77   \tproperty__write_all(packet, properties, true);\n    80   \treturn packet__queue(context, packet);\n    81   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    32   \tmosquitto_property *connack_props = NULL;\n    33   \tuint32_t remaining_length;\n    35   \trc = mosquitto_property_copy_all(&connack_props, properties);\n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    43   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->address, ack, reason_code);\n    44   \t}\n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    51   \t\t\tif(rc){\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    58   \t\t\tif(rc){\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    65   \t\t\tif(rc){\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    71   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_MAXIMUM_QOS, context->listener->max_qos);\n    72   \t\t\tif(rc){\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    78   \t\tremaining_length += property__get_remaining_length(connack_props);\n    79   \t}\n    81   \tif(packet__check_oversize(context, remaining_length)){\n    83   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    84   \t}\n    92   \tpacket->command = CMD_CONNACK;\n    93   \tpacket->remaining_length = remaining_length;\n    102  \tpacket__write_byte(packet, reason_code);\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    105  \t}\n    108  \treturn packet__queue(context, packet);\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    42   \tassert(mosq);\n    45   \tif(mosq->bridge){\n    46   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Bridge %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    47   \t}else\n    56   \tassert(mosq);\n    60   \tpacket->command = CMD_DISCONNECT;\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    62   \t\tpacket->remaining_length = 1;\n    63   \t\tif(properties){\n    64   \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    65   \t\t}\n    66   \t}else{\n    67   \t\tpacket->remaining_length = 0;\n    68   \t}\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    76   \t\tpacket__write_byte(packet, reason_code);\n    77   \t\tif(properties){\n    78   \t\t\tproperty__write_all(packet, properties, true);\n    79   \t\t}\n    80   \t}\n    82   \treturn packet__queue(mosq, packet);\n    83   }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    126  \tassert(mosq);\n    130  \tpacket->command = command;\n    131  \tif(dup){\n    132  \t\tpacket->command |= 8;\n    133  \t}\n    134  \tpacket->remaining_length = 2;\n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    137  \t\tif(reason_code != 0 || properties){\n    138  \t\t\tpacket->remaining_length += 1;\n    139  \t\t}\n    141  \t\tif(properties){\n    142  \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    143  \t\t}\n    144  \t}\n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tif(reason_code != 0 || properties){\n    156  \t\t\tpacket__write_byte(packet, reason_code);\n    157  \t\t}\n    161  \t}\n    163  \treturn packet__queue(mosq, packet);\n    164  }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    117  \treturn send__command_with_mid(mosq, CMD_PUBREL|2, mid, false, 0, properties);\n    118  }\nFunction: send__publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:42\n    42   int send__publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    43   {\n    47   \tint i;\n    49   \tbool match;\n    51   \tchar *mapped_topic = NULL;\n    55   \tassert(mosq);\n    60   \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    63   \tif(!mosq->retain_available){\n    65   \t}\n    68   \tif(mosq->listener && mosq->listener->mount_point){\n    69   \t\tlen = strlen(mosq->listener->mount_point);\n    70   \t\tif(len < strlen(topic)){\n    71   \t\t\ttopic += len;\n    72   \t\t}else{\n    74   \t\t\treturn MOSQ_ERR_SUCCESS;\n    75   \t\t}\n    76   \t}\n    78   \tif(mosq->bridge && mosq->bridge->topics && mosq->bridge->topic_remapping){\n    79   \t\tfor(i=0; i<mosq->bridge->topic_count; i++){\n    80   \t\t\tcur_topic = &mosq->bridge->topics[i];\n    81   \t\t\tif((cur_topic->direction == bd_both || cur_topic->direction == bd_out)\n    82   \t\t\t\t\t&& (cur_topic->remote_prefix || cur_topic->local_prefix)){\n    85   \t\t\t\trc = mosquitto_topic_matches_sub(cur_topic->local_topic, topic, &match);\n    86   \t\t\t\tif(rc){\n    87   \t\t\t\t\treturn rc;\n    88   \t\t\t\t}\n    89   \t\t\t\tif(match){\n    90   \t\t\t\t\tmapped_topic = mosquitto__strdup(topic);\n    91   \t\t\t\t\tif(!mapped_topic) return MOSQ_ERR_NOMEM;\n    92   \t\t\t\t\tif(cur_topic->local_prefix){\n    94   \t\t\t\t\t\tif(!strncmp(cur_topic->local_prefix, mapped_topic, strlen(cur_topic->local_prefix))){\n    95   \t\t\t\t\t\t\ttopic_temp = mosquitto__strdup(mapped_topic+strlen(cur_topic->local_prefix));\n    96   \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    97   \t\t\t\t\t\t\tif(!topic_temp){\n    98   \t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    99   \t\t\t\t\t\t\t}\n    101  \t\t\t\t\t\t}\n    102  \t\t\t\t\t}\n    104  \t\t\t\t\tif(cur_topic->remote_prefix){\n    106  \t\t\t\t\t\tlen = strlen(mapped_topic) + strlen(cur_topic->remote_prefix)+1;\n    107  \t\t\t\t\t\ttopic_temp = mosquitto__malloc(len+1);\n    108  \t\t\t\t\t\tif(!topic_temp){\n    109  \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    110  \t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    111  \t\t\t\t\t\t}\n    112  \t\t\t\t\t\tsnprintf(topic_temp, len, \"%s%s\", cur_topic->remote_prefix, mapped_topic);\n    113  \t\t\t\t\t\ttopic_temp[len] = '\\0';\n    114  \t\t\t\t\t\tmosquitto__free(mapped_topic);\n    116  \t\t\t\t\t}\n    117  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, mapped_topic, (long)payloadlen);\n    119  \t\t\t\t\trc =  send__real_publish(mosq, mid, mapped_topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    120  \t\t\t\t\tmosquitto__free(mapped_topic);\n    121  \t\t\t\t\treturn rc;\n    122  \t\t\t\t}\n    123  \t\t\t}\n    124  \t\t}\n    125  \t}\n    127  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, topic, (long)payloadlen);\n    133  \treturn send__real_publish(mosq, mid, topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    134  }\nFunction: send__real_publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:137\n    137  int send__real_publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    138  {\n    140  \tunsigned int packetlen;\n    141  \tunsigned int proplen = 0, varbytes;\n    143  \tmosquitto_property expiry_prop;\n    145  \tassert(mosq);\n    147  \tif(topic){\n    148  \t\tpacketlen = 2+(unsigned int)strlen(topic) + payloadlen;\n    149  \t}else{\n    150  \t\tpacketlen = 2 + payloadlen;\n    151  \t}\n    152  \tif(qos > 0) packetlen += 2; /* For message id */\n    153  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tproplen += property__get_length_all(cmsg_props);\n    156  \t\tproplen += property__get_length_all(store_props);\n    157  \t\tif(expiry_interval > 0){\n    158  \t\t\texpiry_prop.next = NULL;\n    160  \t\t\texpiry_prop.identifier = MQTT_PROP_MESSAGE_EXPIRY_INTERVAL;\n    163  \t\t\tproplen += property__get_length_all(&expiry_prop);\n    164  \t\t}\n    166  \t\tvarbytes = packet__varint_bytes(proplen);\n    172  \t\t}else{\n    173  \t\t\tpacketlen += proplen + varbytes;\n    174  \t\t}\n    175  \t}\n    176  \tif(packet__check_oversize(mosq, packetlen)){\n    178  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Dropping too large outgoing PUBLISH for %s (%d bytes)\", SAFE_PRINT(mosq->id), packetlen);\n    182  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    183  \t}\n    189  \tpacket->command = (uint8_t)(CMD_PUBLISH | (uint8_t)((dup&0x1)<<3) | (uint8_t)(qos<<1) | retain);\n    190  \tpacket->remaining_length = packetlen;\n    200  \t\tpacket__write_uint16(packet, 0);\n    206  \tif(mosq->protocol == mosq_p_mqtt5){\n    213  \t}\n    220  \treturn packet__queue(mosq, packet);\n    221  }\nFunction: session_expiry__cmp\nPath: /root/projects/mosquitto/src/session_expiry.c:34\n    34   static int session_expiry__cmp(struct session_expiry_list *i1, struct session_expiry_list *i2)\n    35   {\n    36   \tif(i1->context->session_expiry_time == i2->context->session_expiry_time){\n    37   \t\treturn 0;\n    38   \t}else if(i1->context->session_expiry_time > i2->context->session_expiry_time){\n    39   \t\treturn 1;\n    40   \t}else{\n    41   \t\treturn -1;\n    42   \t}\n    43   }\nFunction: session_expiry__remove\nPath: /root/projects/mosquitto/src/session_expiry.c:121\n    121  void session_expiry__remove(struct mosquitto *context)\n    122  {\n    123  \tif(context->expiry_list_item){\n    124  \t\tDL_DELETE(expiry_list, context->expiry_list_item);\n    125  \t\tmosquitto__free(context->expiry_list_item);\n    126  \t\tcontext->expiry_list_item = NULL;\n    127  \t}\n    128  }\nFunction: acl__check_single\nPath: /root/projects/mosquitto/src/security.c:602\n    602  static int acl__check_single(struct mosquitto__auth_plugin_config *auth_plugin, struct mosquitto *context, struct mosquitto_acl_msg *msg, int access)\n    603  {\n    607  \tusername = mosquitto_client_username(context);\n    608  \tif(auth_plugin->deny_special_chars == true){\n    615  \t\tif(username && strpbrk(username, \"+#\")){\n    616  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous username \\\"%s\\\"\", username);\n    617  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    618  \t\t}\n    619  \t\tif(context->id && strpbrk(context->id, \"+#\")){\n    620  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous client id \\\"%s\\\"\", context->id);\n    621  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    622  \t\t}\n    623  \t}\n    625  \tif(auth_plugin->plugin.version == 4){\n    626  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    627  \t\t\treturn MOSQ_ERR_SUCCESS;\n    628  \t\t}\n    629  \t\treturn auth_plugin->plugin.acl_check_v4(auth_plugin->plugin.user_data, access, context, msg);\n    630  \t}else if(auth_plugin->plugin.version == 3){\n    631  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    632  \t\t\treturn MOSQ_ERR_SUCCESS;\n    633  \t\t}\n    634  \t\treturn auth_plugin->plugin.acl_check_v3(auth_plugin->plugin.user_data, access, context, msg);\n    635  \t}else if(auth_plugin->plugin.version == 2){\n    636  \t\tif(access == MOSQ_ACL_SUBSCRIBE || access == MOSQ_ACL_UNSUBSCRIBE){\n    637  \t\t\treturn MOSQ_ERR_SUCCESS;\n    638  \t\t}\n    639  \t\treturn auth_plugin->plugin.acl_check_v2(auth_plugin->plugin.user_data, context->id, username, topic, access);\n    640  \t}else{\n    641  \t\treturn MOSQ_ERR_INVAL;\n    642  \t}\n    643  }\nFunction: sub__remove_shared_leaf\nPath: /root/projects/mosquitto/src/subs.c:190\n    190  static void sub__remove_shared_leaf(struct mosquitto__subhier *subhier, struct mosquitto__subshared *shared, struct mosquitto__subleaf *leaf)\n    191  {\n    192  \tDL_DELETE(shared->subs, leaf);\n    193  \tif(shared->subs == NULL){\n    194  \t\tHASH_DELETE(hh, subhier->shared, shared);\n    195  \t\tmosquitto__free(shared->name);\n    196  \t\tmosquitto__free(shared);\n    197  \t}\n    199  }\nFunction: sub__messages_queue\nPath: /root/projects/mosquitto/src/subs.c:659\n    659  int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n    660  {\n    661  \tint rc = MOSQ_ERR_SUCCESS, rc2;\n    662  \tint rc_normal = MOSQ_ERR_NO_SUBSCRIBERS, rc_shared = MOSQ_ERR_NO_SUBSCRIBERS;\n    663  \tstruct mosquitto__subhier *subhier;\n    664  \tchar **split_topics = NULL;\n    677  \tHASH_FIND(hh, db.normal_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    678  \tif(subhier){\n    679  \t\trc_normal = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    680  \t\tif(rc_normal > 0){\n    682  \t\t\tgoto end;\n    683  \t\t}\n    684  \t}\n    686  \tHASH_FIND(hh, db.shared_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    687  \tif(subhier){\n    688  \t\trc_shared = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    689  \t\tif(rc_shared > 0){\n    691  \t\t\tgoto end;\n    692  \t\t}\n    693  \t}\n    695  \tif(rc_normal == MOSQ_ERR_NO_SUBSCRIBERS && rc_shared == MOSQ_ERR_NO_SUBSCRIBERS){\n    697  \t}\n    711  }\nFunction: sub__search\nPath: /root/projects/mosquitto/src/subs.c:479\n    479  static int sub__search(struct mosquitto__subhier *subhier, char **split_topics, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    480  {\n    482  \tstruct mosquitto__subhier *branch;\n    486  \tif(split_topics && split_topics[0]){\n    488  \t\tHASH_FIND(hh, subhier->children, split_topics[0], strlen(split_topics[0]), branch);\n    490  \t\tif(branch){\n    491  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    492  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    494  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    495  \t\t\t\treturn rc;\n    496  \t\t\t}\n    497  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    498  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    499  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    501  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    502  \t\t\t\t\treturn rc;\n    503  \t\t\t\t}\n    504  \t\t\t}\n    505  \t\t}\n    508  \t\tHASH_FIND(hh, subhier->children, \"+\", 1, branch);\n    510  \t\tif(branch){\n    511  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    512  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    514  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    515  \t\t\t\treturn rc;\n    516  \t\t\t}\n    517  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    518  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    519  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    521  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    522  \t\t\t\t\treturn rc;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}\n    526  \t}\n    529  \tHASH_FIND(hh, subhier->children, \"#\", 1, branch);\n    530  \tif(branch && !branch->children){\n    531  \t\t/* The topic matches due to a # wildcard - process the\n    532  \t\t * subscriptions but *don't* return. Although this branch has ended\n    533  \t\t * there may still be other subscriptions to deal with.\n    534  \t\t */\n    535  \t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    536  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    537  \t\t\thave_subscribers = true;\n    538  \t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    539  \t\t\treturn rc;\n    540  \t\t}\n    541  \t}\n    548  }\nFunction: subs__process\nPath: /root/projects/mosquitto/src/subs.c:129\n    129  static int subs__process(struct mosquitto__subhier *hier, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    130  {\n    133  \tstruct mosquitto__subleaf *leaf;\n    135  \trc = subs__shared_process(hier, topic, qos, retain, stored);\n    137  \tleaf = hier->subs;\n    138  \twhile(source_id && leaf){\n    139  \t\tif(!leaf->context->id || (leaf->no_local && !strcmp(leaf->context->id, source_id))){\n    140  \t\t\tleaf = leaf->next;\n    142  \t\t}\n    147  \t\tleaf = leaf->next;\n    148  \t}\n    149  \tif(hier->subs || hier->shared){\n    150  \t\treturn rc;\n    151  \t}else{\n    152  \t\treturn MOSQ_ERR_NO_SUBSCRIBERS;\n    153  \t}\n    154  }\nFunction: subs__send\nPath: /root/projects/mosquitto/src/subs.c:63\n    63   static int subs__send(struct mosquitto__subleaf *leaf, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    64   {\n    65   \tbool client_retain;\n    66   \tuint16_t mid;\n    67   \tuint8_t client_qos, msg_qos;\n    68   \tmosquitto_property *properties = NULL;\n    72   \trc2 = mosquitto_acl_check(leaf->context, topic, stored->payloadlen, stored->payload, stored->qos, stored->retain, MOSQ_ACL_READ);\n    73   \tif(rc2 == MOSQ_ERR_ACL_DENIED){\n    74   \t\treturn MOSQ_ERR_SUCCESS;\n    75   \t}else if(rc2 == MOSQ_ERR_SUCCESS){\n    76   \t\tclient_qos = leaf->qos;\n    87   \t\tif(msg_qos){\n    88   \t\t\tmid = mosquitto__mid_generate(leaf->context);\n    89   \t\t}else{\n    90   \t\t\tmid = 0;\n    92   \t\tif(leaf->retain_as_published){\n    93   \t\t\tclient_retain = retain;\n    94   \t\t}else{\n    97   \t\tif(leaf->identifier){\n    98   \t\t\tmosquitto_property_add_varint(&properties, MQTT_PROP_SUBSCRIPTION_IDENTIFIER, leaf->identifier);\n    99   \t\t}\n    100  \t\tif(db__message_insert(leaf->context, mid, mosq_md_out, msg_qos, client_retain, stored, properties, true) == 1){\n    101  \t\t\treturn 1;\n    102  \t\t}\n    103  \t}else{\n    104  \t\treturn 1; /* Application error */\n    105  \t}\n    107  }\nFunction: sub__clean_session\nPath: /root/projects/mosquitto/src/subs.c:746\n    746  int sub__clean_session(struct mosquitto *context)\n    747  {\n    748  \tint i;\n    749  \tstruct mosquitto__subleaf *leaf;\n    750  \tstruct mosquitto__subhier *hier;\n    752  \tfor(i=0; i<context->sub_count; i++){\n    753  \t\tif(context->subs[i] == NULL){\n    755  \t\t}\n    757  \t\thier = context->subs[i]->hier;\n    759  \t\tif(context->subs[i]->shared){\n    760  \t\t\tleaf = context->subs[i]->shared->subs;\n    761  \t\t\twhile(leaf){\n    762  \t\t\t\tif(leaf->context==context){\n    766  \t\t\t\t\tsub__remove_shared_leaf(context->subs[i]->hier, context->subs[i]->shared, leaf);\n    768  \t\t\t\t}\n    769  \t\t\t\tleaf = leaf->next;\n    770  \t\t\t}\n    771  \t\t}else{\n    772  \t\t\tleaf = hier->subs;\n    773  \t\t\twhile(leaf){\n    774  \t\t\t\tif(leaf->context==context){\n    778  \t\t\t\t\tDL_DELETE(hier->subs, leaf);\n    779  \t\t\t\t\tmosquitto__free(leaf);\n    781  \t\t\t\t}\n    782  \t\t\t\tleaf = leaf->next;\n    783  \t\t\t}\n    784  \t\t}\n    785  \t\tmosquitto__free(context->subs[i]);\n    786  \t\tcontext->subs[i] = NULL;\n    788  \t\tif(hier->subs == NULL\n    789  \t\t\t\t&& hier->children == NULL\n    790  \t\t\t\t&& hier->shared == NULL\n    791  \t\t\t\t&& hier->parent){\n    794  \t\t\t\thier = tmp_remove_subs(hier);\n    795  \t\t\t}while(hier);\n    796  \t\t}\n    797  \t}\n    798  \tmosquitto__free(context->subs);\n    799  \tcontext->subs = NULL;\n    800  \tcontext->sub_count = 0;\n    803  }\nFunction: tmp_remove_subs\nPath: /root/projects/mosquitto/src/subs.c:715\n    715  static struct mosquitto__subhier *tmp_remove_subs(struct mosquitto__subhier *sub)\n    716  {\n    719  \tif(!sub || !sub->parent){\n    720  \t\treturn NULL;\n    721  \t}\n    723  \tif(sub->children || sub->subs){\n    724  \t\treturn NULL;\n    725  \t}\n    727  \tparent = sub->parent;\n    728  \tHASH_DELETE(hh, parent->children, sub);\n    729  \tmosquitto__free(sub->topic);\n    730  \tmosquitto__free(sub);\n    732  \tif(parent->subs == NULL\n    733  \t\t\t&& parent->children == NULL\n    734  \t\t\t&& parent->shared == NULL\n    735  \t\t\t&& parent->parent){\n    737  \t\treturn parent;\n    738  \t}else{\n    739  \t\treturn NULL;\n    740  \t}\n    741  }\nFunction: mosquitto_validate_utf8\nPath: /root/projects/mosquitto/src/../lib/utf8_mosq.c:24\n    24   int mosquitto_validate_utf8(const char *str, int len)\n    25   {\n    26   \tint i;\n    27   \tint j;\n    28   \tint codelen;\n    29   \tint codepoint;\n    32   \tif(!str) return MOSQ_ERR_INVAL;\n    35   \tfor(i=0; i<len; i++){\n    36   \t\tif(ustr[i] == 0){\n    37   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    38   \t\t}else if(ustr[i] <= 0x7f){\n    40   \t\t\tcodepoint = ustr[i];\n    41   \t\t}else if((ustr[i] & 0xE0) == 0xC0){\n    43   \t\t\tif(ustr[i] == 0xC0 || ustr[i] == 0xC1){\n    45   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    46   \t\t\t}\n    48   \t\t\tcodepoint = (ustr[i] & 0x1F);\n    49   \t\t}else if((ustr[i] & 0xF0) == 0xE0){\n    52   \t\t\tcodepoint = (ustr[i] & 0x0F);\n    53   \t\t}else if((ustr[i] & 0xF8) == 0xF0){\n    55   \t\t\tif(ustr[i] > 0xF4){\n    57   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    58   \t\t\t}\n    60   \t\t\tcodepoint = (ustr[i] & 0x07);\n    61   \t\t}else{\n    63   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    64   \t\t}\n    67   \t\tif(i == len-codelen+1){\n    69   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    70   \t\t}\n    71   \t\tfor(j=0; j<codelen-1; j++){\n    72   \t\t\tif((ustr[++i] & 0xC0) != 0x80){\n    74   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    75   \t\t\t}\n    76   \t\t\tcodepoint = (codepoint<<6) | (ustr[i] & 0x3F);\n    77   \t\t}\n    80   \t\tif(codepoint >= 0xD800 && codepoint <= 0xDFFF){\n    81   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    82   \t\t}\n    88   \t\t *\t return MOSQ_ERR_MALFORMED_UTF8;\n    91   \t\tif(codelen == 3 && codepoint < 0x0800){\n    92   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    93   \t\t}else if(codelen == 4 && (codepoint < 0x10000 || codepoint > 0x10FFFF)){\n    94   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    95   \t\t}\n    98   \t\tif(codepoint >= 0xFDD0 && codepoint <= 0xFDEF){\n    99   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    100  \t\t}\n    101  \t\tif((codepoint & 0xFFFF) == 0xFFFE || (codepoint & 0xFFFF) == 0xFFFF){\n    102  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    103  \t\t}\n    105  \t\tif(codepoint <= 0x001F || (codepoint >= 0x007F && codepoint <= 0x009F)){\n    106  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    107  \t\t}\n    108  \t}\n    110  }\nFunction: util__increment_send_quota\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:222\n    222  void util__increment_send_quota(struct mosquitto *mosq)\n    223  {\n    224  \tif(mosq->msgs_out.inflight_quota < mosq->msgs_out.inflight_maximum){\n    225  \t\tmosq->msgs_out.inflight_quota++;\n    226  \t}\n    227  }\nFunction: will_delay__remove\nPath: /root/projects/mosquitto/src/will_delay.c:99\n    99   void will_delay__remove(struct mosquitto *mosq)\n    100  {\n    101  \tif(mosq->will_delay_entry != NULL){\n    102  \t\tDL_DELETE(delay_list, mosq->will_delay_entry);\n    103  \t\tmosquitto__free(mosq->will_delay_entry);\n    104  \t\tmosq->will_delay_entry = NULL;\n    105  \t}\n    106  }\nFunction: will__clear\nPath: /root/projects/mosquitto/src/../lib/will_mosq.c:111\n    111  int will__clear(struct mosquitto *mosq)\n    112  {\n    113  \tif(!mosq->will) return MOSQ_ERR_SUCCESS;\n    115  \tmosquitto__free(mosq->will->msg.topic);\n    116  \tmosq->will->msg.topic = NULL;\n    118  \tmosquitto__free(mosq->will->msg.payload);\n    119  \tmosq->will->msg.payload = NULL;\n    121  \tmosquitto_property_free_all(&mosq->will->properties);\n    123  \tmosquitto__free(mosq->will);\n    124  \tmosq->will = NULL;\n    125  \tmosq->will_delay_interval = 0;\n    128  }\n",
    "If the Server assigns a unique ClientID to the Client, it MUST process the CONNECT packet as if the Client had provided that unique ClientID and MUST return the Assigned Client Identifier in the CONNACK packet.": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    212  }\nFunction: context__remove_from_by_id\nPath: /root/projects/mosquitto/src/context.c:302\n    302  void context__remove_from_by_id(struct mosquitto *context)\n    303  {\n    304  \tstruct mosquitto *context_found;\n    306  \tif(context->in_by_id == true && context->id){\n    307  \t\tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), context_found);\n    308  \t\tif(context_found){\n    309  \t\t\tHASH_DELETE(hh_id, db.contexts_by_id, context_found);\n    310  \t\t}\n    312  \t}\n    313  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    208  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    250  \t}\n    263  \tif(!context->clean_start){\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    294  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    319  \tmosquitto_property_free_all(&connack_props);\n    320  \tif(rc) return rc;\n    326  error:\n    328  \tmosquitto_property_free_all(&connack_props);\n    330  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    250  \tif(context->id){\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    705  \tconst char *source_id;\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    745  \t\t*properties = NULL;\n    746  \t}\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    557  \t}else{\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    613  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    618  \n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    630  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    639  \t\t\t\t\trc = MOSQ_ERR_NOMEM;\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    976  \tcontext->clean_start = true;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    53   \tchar *client_id;\n    54   \tuint8_t rnd[16];\n    55   \tint i;\n    56   \tint pos;\n    57   \n    58   \tif(util__random_bytes(rnd, 16)) return NULL;\n    59   \n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    61   \n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    69   \n    70   \tpos = 0;\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    80   \n    81   \treturn client_id;\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    335  \tint rc = MOSQ_ERR_SUCCESS;\n    341  \tmosquitto_property *properties = NULL;\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    349  \t\trc = property__read_all(CMD_WILL, &context->in_packet, &properties);\n    350  \t\tif(rc) goto error_cleanup;\n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    353  \t\tmosquitto_property_free_all(&properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    391  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Client %s connected with too large Will payload\", client_id);\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    393  \t\t\t\tsend__connack(context, 0, MQTT_RC_PACKET_TOO_LARGE, NULL);\n    394  \t\t\t}else{\n    395  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    396  \t\t\t}\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    413  \t*will = will_struct;\n    424  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    54   \t*byte = packet->payload[packet->pos];\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    106  \t\t*length = 0;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    32   \tmosquitto_property *connack_props = NULL;\n    33   \tuint32_t remaining_length;\n    35   \trc = mosquitto_property_copy_all(&connack_props, properties);\n    36   \tif(rc){\n    37   \t\treturn rc;\n    38   \t}\n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    50   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_RETAIN_AVAILABLE, 0);\n    51   \t\t\tif(rc){\n    52   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    57   \t\t\trc = mosquitto_property_add_int32(&connack_props, MQTT_PROP_MAXIMUM_PACKET_SIZE, db.config->max_packet_size);\n    58   \t\t\tif(rc){\n    59   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    64   \t\t\trc = mosquitto_property_add_int16(&connack_props, MQTT_PROP_RECEIVE_MAXIMUM, db.config->max_inflight_messages);\n    65   \t\t\tif(rc){\n    66   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    71   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_MAXIMUM_QOS, context->listener->max_qos);\n    72   \t\t\tif(rc){\n    73   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    78   \t\tremaining_length += property__get_remaining_length(connack_props);\n    79   \t}\n    81   \tif(packet__check_oversize(context, remaining_length)){\n    82   \t\tmosquitto_property_free_all(&connack_props);\n    83   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    84   \t}\n    87   \tif(!packet){\n    88   \t\tmosquitto_property_free_all(&connack_props);\n    89   \t\treturn MOSQ_ERR_NOMEM;\n    90   \t}\n    93   \tpacket->remaining_length = remaining_length;\n    96   \tif(rc){\n    97   \t\tmosquitto_property_free_all(&connack_props);\n    99   \t\treturn rc;\n    100  \t}\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    104  \t\tproperty__write_all(packet, connack_props, true);\n    105  \t}\n    106  \tmosquitto_property_free_all(&connack_props);\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    45   \tif(mosq->bridge){\n    46   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Bridge %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    47   \t}else\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    63   \t\tif(properties){\n    64   \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    65   \t\t}\n    66   \t}else{\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    77   \t\tif(properties){\n    78   \t\t\tproperty__write_all(packet, properties, true);\n    79   \t\t}\n    80   \t}\n    83   }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    118  }\nFunction: send__real_publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:137\n    137  int send__real_publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    138  {\n    140  \tunsigned int packetlen;\n    141  \tunsigned int proplen = 0, varbytes;\n    143  \tmosquitto_property expiry_prop;\n    147  \tif(topic){\n    148  \t\tpacketlen = 2+(unsigned int)strlen(topic) + payloadlen;\n    149  \t}else{\n    150  \t\tpacketlen = 2 + payloadlen;\n    151  \t}\n    152  \tif(qos > 0) packetlen += 2; /* For message id */\n    153  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tproplen += property__get_length_all(cmsg_props);\n    156  \t\tproplen += property__get_length_all(store_props);\n    157  \t\tif(expiry_interval > 0){\n    163  \t\t\tproplen += property__get_length_all(&expiry_prop);\n    164  \t\t}\n    166  \t\tvarbytes = packet__varint_bytes(proplen);\n    172  \t\t}else{\n    173  \t\t\tpacketlen += proplen + varbytes;\n    174  \t\t}\n    175  \t}\n    176  \tif(packet__check_oversize(mosq, packetlen)){\n    178  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Dropping too large outgoing PUBLISH for %s (%d bytes)\", SAFE_PRINT(mosq->id), packetlen);\n    182  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    183  \t}\n    221  }\nFunction: mosquitto_validate_utf8\nPath: /root/projects/mosquitto/src/../lib/utf8_mosq.c:24\n    24   int mosquitto_validate_utf8(const char *str, int len)\n    25   {\n    26   \tint i;\n    27   \tint j;\n    28   \tint codelen;\n    29   \tint codepoint;\n    32   \tif(!str) return MOSQ_ERR_INVAL;\n    35   \tfor(i=0; i<len; i++){\n    36   \t\tif(ustr[i] == 0){\n    37   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    38   \t\t}else if(ustr[i] <= 0x7f){\n    40   \t\t\tcodepoint = ustr[i];\n    41   \t\t}else if((ustr[i] & 0xE0) == 0xC0){\n    43   \t\t\tif(ustr[i] == 0xC0 || ustr[i] == 0xC1){\n    45   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    46   \t\t\t}\n    48   \t\t\tcodepoint = (ustr[i] & 0x1F);\n    49   \t\t}else if((ustr[i] & 0xF0) == 0xE0){\n    52   \t\t\tcodepoint = (ustr[i] & 0x0F);\n    53   \t\t}else if((ustr[i] & 0xF8) == 0xF0){\n    55   \t\t\tif(ustr[i] > 0xF4){\n    57   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    58   \t\t\t}\n    60   \t\t\tcodepoint = (ustr[i] & 0x07);\n    61   \t\t}else{\n    63   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    64   \t\t}\n    67   \t\tif(i == len-codelen+1){\n    69   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    70   \t\t}\n    71   \t\tfor(j=0; j<codelen-1; j++){\n    72   \t\t\tif((ustr[++i] & 0xC0) != 0x80){\n    74   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    75   \t\t\t}\n    76   \t\t\tcodepoint = (codepoint<<6) | (ustr[i] & 0x3F);\n    77   \t\t}\n    80   \t\tif(codepoint >= 0xD800 && codepoint <= 0xDFFF){\n    81   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    82   \t\t}\n    88   \t\t *\t return MOSQ_ERR_MALFORMED_UTF8;\n    91   \t\tif(codelen == 3 && codepoint < 0x0800){\n    92   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    93   \t\t}else if(codelen == 4 && (codepoint < 0x10000 || codepoint > 0x10FFFF)){\n    94   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    95   \t\t}\n    98   \t\tif(codepoint >= 0xFDD0 && codepoint <= 0xFDEF){\n    99   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    100  \t\t}\n    101  \t\tif((codepoint & 0xFFFF) == 0xFFFE || (codepoint & 0xFFFF) == 0xFFFF){\n    102  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    103  \t\t}\n    105  \t\tif(codepoint <= 0x001F || (codepoint >= 0x007F && codepoint <= 0x009F)){\n    106  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    107  \t\t}\n    108  \t}\n    110  }\nFunction: will__clear\nPath: /root/projects/mosquitto/src/../lib/will_mosq.c:111\n    111  int will__clear(struct mosquitto *mosq)\n    112  {\n    113  \tif(!mosq->will) return MOSQ_ERR_SUCCESS;\n    115  \tmosquitto__free(mosq->will->msg.topic);\n    116  \tmosq->will->msg.topic = NULL;\n    118  \tmosquitto__free(mosq->will->msg.payload);\n    119  \tmosq->will->msg.payload = NULL;\n    121  \tmosquitto_property_free_all(&mosq->will->properties);\n    123  \tmosquitto__free(mosq->will);\n    124  \tmosq->will = NULL;\n    128  }\n",
    "It is a Protocol Error to include the Payload Format Indicator more than once.": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    221  \tplugin__handle_disconnect(context, -1);\n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    226  \tif(context->bridge == NULL)\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    232  \t\t\tif(context->will_delay_interval == 0){\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__read_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:178\n    178  int packet__read_uint32(struct mosquitto__packet *packet, uint32_t *word)\n    179  {\n    180  \tuint32_t val = 0;\n    181  \tint i;\n    183  \tassert(packet);\n    184  \tif(packet->pos+4 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    186  \tfor(i=0; i<4; i++){\n    187  \t\tval = (val << 8) + packet->payload[packet->pos];\n    188  \t\tpacket->pos++;\n    189  \t}\n    191  \t*word = val;\n    194  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    147  \tassert(mosq);\n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    153  \tpacket->next = NULL;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    187  \treturn packet__write(mosq);\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    353  }\nFunction: property__process_connect\nPath: /root/projects/mosquitto/src/property_broker.c:30\n    30   int property__process_connect(struct mosquitto *context, mosquitto_property **props)\n    31   {\n    32   \tmosquitto_property *p;\n    34   \tp = *props;\n    36   \twhile(p){\n    37   \t\tif(p->identifier == MQTT_PROP_SESSION_EXPIRY_INTERVAL){\n    38   \t\t\tcontext->session_expiry_interval = p->value.i32;\n    39   \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM){\n    40   \t\t\tif(p->value.i16 == 0){\n    41   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    42   \t\t\t}\n    44   \t\t\tcontext->msgs_out.inflight_maximum = p->value.i16;\n    45   \t\t\tcontext->msgs_out.inflight_quota = context->msgs_out.inflight_maximum;\n    46   \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    47   \t\t\tif(p->value.i32 == 0){\n    48   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    49   \t\t\t}\n    50   \t\t\tcontext->maximum_packet_size = p->value.i32;\n    51   \t\t}\n    52   \t\tp = p->next;\n    53   \t}\n    56   }\nFunction: property__process_will\nPath: /root/projects/mosquitto/src/property_broker.c:59\n    59   int property__process_will(struct mosquitto *context, struct mosquitto_message_all *msg, mosquitto_property **props)\n    60   {\n    61   \tmosquitto_property *p, *p_prev;\n    62   \tmosquitto_property *msg_properties, *msg_properties_last;\n    64   \tp = *props;\n    66   \tmsg_properties = NULL;\n    68   \twhile(p){\n    69   \t\tswitch(p->identifier){\n    70   \t\t\tcase MQTT_PROP_CONTENT_TYPE:\n    71   \t\t\tcase MQTT_PROP_CORRELATION_DATA:\n    72   \t\t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    73   \t\t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    74   \t\t\tcase MQTT_PROP_USER_PROPERTY:\n    75   \t\t\t\tif(msg_properties){\n    76   \t\t\t\t\tmsg_properties_last->next = p;\n    78   \t\t\t\t}else{\n    82   \t\t\t\tif(p_prev){\n    83   \t\t\t\t\tp_prev->next = p->next;\n    84   \t\t\t\t\tp = p_prev->next;\n    85   \t\t\t\t}else{\n    86   \t\t\t\t\t*props = p->next;\n    87   \t\t\t\t\tp = *props;\n    88   \t\t\t\t}\n    89   \t\t\t\tmsg_properties_last->next = NULL;\n    90   \t\t\t\tbreak;\n    92   \t\t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    93   \t\t\t\tcontext->will_delay_interval = p->value.i32;\n    95   \t\t\t\tp = p->next;\n    96   \t\t\t\tbreak;\n    98   \t\t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    101  \t\t\t\tp = p->next;\n    102  \t\t\t\tbreak;\n    104  \t\t\tdefault:\n    106  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    107  \t\t\t\tbreak;\n    108  \t\t}\n    109  \t}\n    113  }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__read\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:35\n    35   static int property__read(struct mosquitto__packet *packet, uint32_t *len, mosquitto_property *property)\n    36   {\n    38   \tuint32_t property_identifier;\n    39   \tuint8_t byte;\n    40   \tuint8_t byte_count;\n    41   \tuint16_t uint16;\n    42   \tuint32_t uint32;\n    43   \tuint32_t varint;\n    44   \tchar *str1, *str2;\n    45   \tuint16_t slen1, slen2;\n    47   \tif(!property) return MOSQ_ERR_INVAL;\n    49   \trc = packet__read_varint(packet, &property_identifier, NULL);\n    50   \tif(rc){\n    51   \t\treturn rc;\n    52   \t}\n    55   \tmemset(property, 0, sizeof(mosquitto_property));\n    57   \tproperty->identifier = (int32_t)property_identifier;\n    59   \tswitch(property_identifier){\n    60   \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    61   \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    62   \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    63   \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    64   \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    65   \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    66   \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    67   \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    68   \t\t\trc = packet__read_byte(packet, &byte);\n    69   \t\t\tif(rc) return rc;\n    71   \t\t\tproperty->value.i8 = byte;\n    72   \t\t\tbreak;\n    74   \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    75   \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    76   \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    77   \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    78   \t\t\trc = packet__read_uint16(packet, &uint16);\n    79   \t\t\tif(rc) return rc;\n    81   \t\t\tproperty->value.i16 = uint16;\n    82   \t\t\tbreak;\n    84   \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    85   \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    86   \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    87   \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    88   \t\t\trc = packet__read_uint32(packet, &uint32);\n    89   \t\t\tif(rc) return rc;\n    91   \t\t\tproperty->value.i32 = uint32;\n    92   \t\t\tbreak;\n    94   \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    95   \t\t\trc = packet__read_varint(packet, &varint, &byte_count);\n    96   \t\t\tif(rc) return rc;\n    98   \t\t\tproperty->value.varint = varint;\n    99   \t\t\tbreak;\n    101  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    102  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    103  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    104  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    105  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    106  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    107  \t\tcase MQTT_PROP_REASON_STRING:\n    108  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    109  \t\t\tif(rc) return rc;\n    111  \t\t\tproperty->value.s.v = str1;\n    112  \t\t\tproperty->value.s.len = slen1;\n    113  \t\t\tbreak;\n    115  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    116  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    117  \t\t\trc = packet__read_binary(packet, (uint8_t **)&str1, &slen1);\n    118  \t\t\tif(rc) return rc;\n    120  \t\t\tproperty->value.bin.v = str1;\n    121  \t\t\tproperty->value.bin.len = slen1;\n    122  \t\t\tbreak;\n    124  \t\tcase MQTT_PROP_USER_PROPERTY:\n    125  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    126  \t\t\tif(rc) return rc;\n    129  \t\t\trc = packet__read_string(packet, &str2, &slen2);\n    130  \t\t\tif(rc){\n    131  \t\t\t\tmosquitto__free(str1);\n    132  \t\t\t\treturn rc;\n    133  \t\t\t}\n    136  \t\t\tproperty->name.v = str1;\n    137  \t\t\tproperty->name.len = slen1;\n    138  \t\t\tproperty->value.s.v = str2;\n    139  \t\t\tproperty->value.s.len = slen2;\n    140  \t\t\tbreak;\n    142  \t\tdefault:\n    144  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property_identifier);\n    146  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    147  \t}\n    150  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: property__get_length_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:335\n    335  unsigned int property__get_length_all(const mosquitto_property *property)\n    336  {\n    337  \tconst mosquitto_property *p;\n    338  \tunsigned int len = 0;\n    341  \twhile(p){\n    342  \t\tlen += property__get_length(p);\n    343  \t\tp = p->next;\n    344  \t}\n    345  \treturn len;\n    346  }\nFunction: property__write_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:429\n    429  int property__write_all(struct mosquitto__packet *packet, const mosquitto_property *properties, bool write_len)\n    430  {\n    432  \tconst mosquitto_property *p;\n    440  \twhile(p){\n    441  \t\trc = property__write(packet, p);\n    442  \t\tif(rc) return rc;\n    443  \t\tp = p->next;\n    444  \t}\n    447  }\nFunction: property__write\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:361\n    361  static int property__write(struct mosquitto__packet *packet, const mosquitto_property *property)\n    362  {\n    365  \trc = packet__write_varint(packet, (uint32_t)property->identifier);\n    366  \tif(rc) return rc;\n    368  \tswitch(property->identifier){\n    369  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    377  \t\t\tpacket__write_byte(packet, property->value.i8);\n    394  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    395  \t\t\treturn packet__write_varint(packet, property->value.varint);\n    397  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    398  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    399  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    400  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    401  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    402  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    403  \t\tcase MQTT_PROP_REASON_STRING:\n    404  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    405  \t\t\tbreak;\n    407  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    408  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    409  \t\t\tpacket__write_uint16(packet, property->value.bin.len);\n    410  \t\t\tpacket__write_bytes(packet, property->value.bin.v, property->value.bin.len);\n    411  \t\t\tbreak;\n    413  \t\tcase MQTT_PROP_USER_PROPERTY:\n    414  \t\t\tpacket__write_string(packet, property->name.v, property->name.len);\n    415  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    416  \t\t\tbreak;\n    418  \t\tdefault:\n    420  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property->identifier);\n    422  \t\t\treturn MOSQ_ERR_INVAL;\n    423  \t}\n    426  }\nFunction: mosquitto_property_add_byte\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:716\n    716  int mosquitto_property_add_byte(mosquitto_property **proplist, int identifier, uint8_t value)\n    717  {\n    721  \tif(identifier != MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    722  \t\t\t&& identifier != MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    723  \t\t\t&& identifier != MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    724  \t\t\t&& identifier != MQTT_PROP_MAXIMUM_QOS\n    725  \t\t\t&& identifier != MQTT_PROP_RETAIN_AVAILABLE\n    726  \t\t\t&& identifier != MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    727  \t\t\t&& identifier != MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    728  \t\t\t&& identifier != MQTT_PROP_SHARED_SUB_AVAILABLE){\n    736  \tprop->identifier = identifier;\n    737  \tprop->value.i8 = value;\n    739  \tproperty__add(proplist, prop);\n    741  }\nFunction: mosquitto_property_read_binary\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1106\n    1106 const mosquitto_property *mosquitto_property_read_binary(const mosquitto_property *proplist, int identifier, void **value, uint16_t *len, bool skip_first)\n    1107 {\n    1109 \tif(!proplist || (value && !len) || (!value && len)) return NULL;\n    1113 \tp = property__get_property(proplist, identifier, skip_first);\n    1114 \tif(!p) return NULL;\n    1115 \tif(p->identifier != MQTT_PROP_CORRELATION_DATA\n    1116 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_DATA){\n    1118 \t\treturn NULL;\n    1119 \t}\n    1121 \tif(value){\n    1122 \t\t*len = p->value.bin.len;\n    1123 \t\t*value = calloc(1, *len + 1U);\n    1124 \t\tif(!(*value)) return NULL;\n    1126 \t\tmemcpy(*value, p->value.bin.v, *len);\n    1127 \t}\n    1130 }\nFunction: mosquitto_property_read_string\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1133\n    1133 const mosquitto_property *mosquitto_property_read_string(const mosquitto_property *proplist, int identifier, char **value, bool skip_first)\n    1134 {\n    1136 \tif(!proplist) return NULL;\n    1138 \tp = property__get_property(proplist, identifier, skip_first);\n    1139 \tif(!p) return NULL;\n    1140 \tif(p->identifier != MQTT_PROP_CONTENT_TYPE\n    1141 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_TOPIC\n    1142 \t\t\t&& p->identifier != MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER\n    1143 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_METHOD\n    1144 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_INFORMATION\n    1145 \t\t\t&& p->identifier != MQTT_PROP_SERVER_REFERENCE\n    1146 \t\t\t&& p->identifier != MQTT_PROP_REASON_STRING){\n    1148 \t\treturn NULL;\n    1149 \t}\n    1151 \tif(value){\n    1152 \t\t*value = calloc(1, (size_t)p->value.s.len+1);\n    1153 \t\tif(!(*value)) return NULL;\n    1155 \t\tmemcpy(*value, p->value.s.v, p->value.s.len);\n    1156 \t}\n    1159 }\nFunction: db__expire_all_messages\nPath: /root/projects/mosquitto/src/database.c:1053\n    1053 void db__expire_all_messages(struct mosquitto *context)\n    1055 \tstruct mosquitto_client_msg *msg, *tmp;\n    1057 \tDL_FOREACH_SAFE(context->msgs_out.inflight, msg, tmp){\n    1058 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1059 \t\t\tif(msg->qos > 0){\n    1060 \t\t\t\tutil__increment_send_quota(context);\n    1062 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1065 \tDL_FOREACH_SAFE(context->msgs_out.queued, msg, tmp){\n    1066 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1067 \t\t\tdb__message_remove_from_queued(&context->msgs_out, msg);\n    1070 \tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n    1071 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1072 \t\t\tif(msg->qos > 0){\n    1073 \t\t\t\tutil__increment_receive_quota(context);\n    1075 \t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n    1078 \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n    1079 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1080 \t\t\tdb__message_remove_from_queued(&context->msgs_in, msg);\n    1083 }\nFunction: db__message_remove_from_queued\nPath: /root/projects/mosquitto/src/database.c:364\n    364  static void db__message_remove_from_queued(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    365  {\n    366  \tif(!msg_data || !item){\n    367  \t\treturn;\n    368  \t}\n    370  \tDL_DELETE(msg_data->queued, item);\n    377  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1183 \tstruct mosquitto_client_msg *tail, *tmp;\n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1190 \tDL_FOREACH_SAFE(context->msgs_out.inflight, tail, tmp){\n    1191 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1192 \t\tif(rc) return rc;\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    143  \t\t\t\tin_quota = context->msgs_in.inflight_quota;\n    144  \t\t\t\tout_quota = context->msgs_out.inflight_quota;\n    145  \t\t\t\tin_maximum = context->msgs_in.inflight_maximum;\n    146  \t\t\t\tout_maximum = context->msgs_out.inflight_maximum;\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    154  \t\t\t\tcontext->msgs_in.inflight_quota = in_quota;\n    155  \t\t\t\tcontext->msgs_out.inflight_quota = out_quota;\n    156  \t\t\t\tcontext->msgs_in.inflight_maximum = in_maximum;\n    157  \t\t\t\tcontext->msgs_out.inflight_maximum = out_maximum;\n    159  \t\t\t\tdb__message_reconnect_reset(context);\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    215  \trc = acl__find_acls(context);\n    216  \tif(rc){\n    218  \t\treturn rc;\n    219  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    250  \t}\n    252  \tcontext->ping_t = 0;\n    253  \tcontext->is_dropping = false;\n    255  \tconnection_check_acl(context, &context->msgs_in.inflight);\n    256  \tconnection_check_acl(context, &context->msgs_in.queued);\n    257  \tconnection_check_acl(context, &context->msgs_out.inflight);\n    258  \tconnection_check_acl(context, &context->msgs_out.queued);\n    260  \tcontext__add_to_by_id(context);\n    263  \tif(!context->clean_start){\n    267  \tcontext->max_qos = context->listener->max_qos;\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    315  \tkeepalive__add(context);\n    317  \tmosquitto__set_state(context, mosq_cs_active);\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    320  \tif(rc) return rc;\n    321  \tdb__expire_all_messages(context);\n    322  \trc = db__message_write_queued_out(context);\n    323  \tif(rc) return rc;\n    324  \trc = db__message_write_inflight_out_all(context);\n    330  }\nFunction: connection_check_acl\nPath: /root/projects/mosquitto/src/handle_connect.c:86\n    86   static void connection_check_acl(struct mosquitto *context, struct mosquitto_client_msg **head)\n    97   \t\tif(mosquitto_acl_check(context, msg_tail->store->topic,\n    99   \t\t\t\t\t\t\t   msg_tail->store->qos, msg_tail->store->retain, access) != MOSQ_ERR_SUCCESS){\n    101  \t\t\tDL_DELETE((*head), msg_tail);\n    107  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    248  \tmosquitto__set_state(context, mosq_cs_disused);\n    250  \tif(context->id){\n    251  \t\tcontext__remove_from_by_id(context);\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    256  \tcontext->for_free_next = db.ll_for_free;\n    257  \tdb.ll_for_free = context;\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    296  \t\tcontext->in_by_id = true;\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__msg_add_to_queued_stats\nPath: /root/projects/mosquitto/src/database.c:162\n    162  void db__msg_add_to_queued_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    163  {\n    164  \tmsg_data->queued_count++;\n    165  \tmsg_data->queued_bytes += msg->store->payloadlen;\n    166  \tif(msg->qos != 0){\n    167  \t\tmsg_data->queued_count12++;\n    168  \t\tmsg_data->queued_bytes12 += msg->store->payloadlen;\n    169  \t}\n    170  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    271  \tmosquitto__free(store->source_id);\n    272  \tmosquitto__free(store->source_username);\n    283  }\nFunction: db__message_remove_from_inflight\nPath: /root/projects/mosquitto/src/database.c:347\n    347  static void db__message_remove_from_inflight(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    348  {\n    349  \tif(!msg_data || !item){\n    350  \t\treturn;\n    351  \t}\n    353  \tDL_DELETE(msg_data->inflight, item);\n    354  \tif(item->store){\n    355  \t\tdb__msg_remove_from_inflight_stats(msg_data, item);\n    357  \t}\n    361  }\nFunction: db__message_write_inflight_out_latest\nPath: /root/projects/mosquitto/src/database.c:1198\n    1198 int db__message_write_inflight_out_latest(struct mosquitto *context)\n    1199 {\n    1200 \tstruct mosquitto_client_msg *tail, *next;\n    1203 \tif(context->state != mosq_cs_active\n    1204 \t\t\t|| context->sock == INVALID_SOCKET\n    1205 \t\t\t|| context->msgs_out.inflight == NULL){\n    1207 \t\treturn MOSQ_ERR_SUCCESS;\n    1208 \t}\n    1210 \tif(context->msgs_out.inflight->prev == context->msgs_out.inflight){\n    1212 \t\treturn db__message_write_inflight_out_single(context, context->msgs_out.inflight);\n    1213 \t}\n    1217 \ttail = context->msgs_out.inflight->prev;\n    1218 \twhile(tail != context->msgs_out.inflight &&\n    1219 \t\t\t(tail->state == mosq_ms_publish_qos0\n    1220 \t\t\t || tail->state == mosq_ms_publish_qos1\n    1221 \t\t\t || tail->state == mosq_ms_publish_qos2)){\n    1223 \t\ttail = tail->prev;\n    1224 \t}\n    1229 \tif(tail != context->msgs_out.inflight){\n    1230 \t\ttail = tail->next;\n    1231 \t}\n    1233 \twhile(tail){\n    1234 \t\tnext = tail->next;\n    1235 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1236 \t\tif(rc) return rc;\n    1238 \t}\n    1240 }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1097 \tuint32_t expiry_interval;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1103 \t\t\tif(msg->direction == mosq_md_out && msg->qos > 0){\n    1104 \t\t\t\tutil__increment_send_quota(context);\n    1105 \t\t\t}\n    1106 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1126 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1135 \t\t\t\tmsg->timestamp = db.now_s;\n    1136 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1137 \t\t\t\tmsg->state = mosq_ms_wait_for_puback;\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1139 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1148 \t\t\t\tmsg->timestamp = db.now_s;\n    1149 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1150 \t\t\t\tmsg->state = mosq_ms_wait_for_pubrec;\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1152 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1159 \t\t\trc = send__pubrel(context, mid, NULL);\n    1160 \t\t\tif(!rc){\n    1161 \t\t\t\tmsg->state = mosq_ms_wait_for_pubcomp;\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1176 \t}\n    1178 }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    449  \tstruct mosquitto_msg_data *msg_data;\n    450  \tenum mosquitto_msg_state state = mosq_ms_invalid;\n    452  \tint i;\n    457  \tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n    459  \tif(dir == mosq_md_out){\n    460  \t\tmsg_data = &context->msgs_out;\n    461  \t}else{\n    462  \t\tmsg_data = &context->msgs_in;\n    463  \t}\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    484  \tif(context->sock == INVALID_SOCKET){\n    486  \t\tif(qos == 0 && !db.config->queue_qos0_messages){\n    487  \t\t\tif(!context->bridge){\n    489  \t\t\t\treturn 2;\n    490  \t\t\t}else{\n    491  \t\t\t\tif(context->bridge->start_type != bst_lazy){\n    493  \t\t\t\t\treturn 2;\n    494  \t\t\t\t}\n    495  \t\t\t}\n    496  \t\t}\n    497  \t\tif(context->bridge && context->bridge->clean_start_local == true){\n    499  \t\t\treturn 2;\n    500  \t\t}\n    501  \t}\n    503  \tif(context->sock != INVALID_SOCKET){\n    504  \t\tif(db__ready_for_flight(context, dir, qos)){\n    517  \t\t\t}else{\n    520  \t\t\t\t}else{\n    522  \t\t\t\t\treturn 1;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n    528  \t\t}else{\n    530  \t\t\tif(context->is_dropping == false){\n    531  \t\t\t\tcontext->is_dropping = true;\n    532  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    534  \t\t\t\t\t\tcontext->id);\n    535  \t\t\t}\n    538  \t\t\treturn 2;\n    539  \t\t}\n    540  \t}else{\n    541  \t\tif (db__ready_for_queue(context, qos, msg_data)){\n    543  \t\t}else{\n    545  \t\t\tif(context->is_dropping == false){\n    546  \t\t\t\tcontext->is_dropping = true;\n    547  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    549  \t\t\t\t\t\tcontext->id);\n    550  \t\t\t}\n    552  \t\t\treturn 2;\n    553  \t\t}\n    554  \t}\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    582  \tif(state == mosq_ms_queued){\n    583  \t\tDL_APPEND(msg_data->queued, msg);\n    585  \t}else{\n    586  \t\tDL_APPEND(msg_data->inflight, msg);\n    588  \t}\n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    598  \t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n    599  \t\tif(dest_ids){\n    602  \t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t}\n    609  \t}\n    611  \tif(context->bridge && context->bridge->start_type == bst_lazy\n    612  \t\t\t&& context->sock == INVALID_SOCKET\n    613  \t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n    616  \t}\n    633  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    704  \tstruct mosquitto_msg_store *stored;\n    705  \tconst char *source_id;\n    706  \tenum mosquitto_msg_origin origin;\n    710  \tstored = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    711  \tif(stored == NULL) return MOSQ_ERR_NOMEM;\n    713  \tstored->topic = mosquitto__strdup(topic);\n    714  \tif(stored->topic == NULL){\n    715  \t\tdb__msg_store_free(stored);\n    716  \t\treturn MOSQ_ERR_INVAL;\n    717  \t}\n    719  \tstored->qos = qos;\n    720  \tif(db.config->retain_available == false){\n    721  \t\tstored->retain = 0;\n    722  \t}else{\n    723  \t\tstored->retain = retain;\n    724  \t}\n    726  \tstored->payloadlen = payloadlen;\n    727  \tif(payloadlen > 0){\n    728  \t\tstored->payload = mosquitto__malloc(stored->payloadlen+1);\n    729  \t\tif(stored->payload == NULL){\n    730  \t\t\tdb__msg_store_free(stored);\n    731  \t\t\treturn MOSQ_ERR_NOMEM;\n    732  \t\t}\n    734  \t\t((uint8_t *)stored->payload)[stored->payloadlen] = 0;\n    735  \t\tmemcpy(stored->payload, payload, stored->payloadlen);\n    736  \t}\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    746  \t}\n    748  \tif(context){\n    750  \t}else{\n    753  \tif(db__message_store(context, stored, message_expiry_interval, 0, origin)) return 1;\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    763  \tif(source && source->id){\n    764  \t\tstored->source_id = mosquitto__strdup(source->id);\n    765  \t}else{\n    766  \t\tstored->source_id = mosquitto__strdup(\"\");\n    767  \t}\n    768  \tif(!stored->source_id){\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    774  \tif(source && source->username){\n    775  \t\tstored->source_username = mosquitto__strdup(source->username);\n    776  \t\tif(!stored->source_username){\n    778  \t\t\treturn MOSQ_ERR_NOMEM;\n    779  \t\t}\n    780  \t}\n    781  \tif(source){\n    782  \t\tstored->source_listener = source->listener;\n    783  \t}\n    806  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    448  \tX509 *client_cert = NULL;\n    460  \tif(!context->listener){\n    461  \t\treturn MOSQ_ERR_INVAL;\n    462  \t}\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    502  \t\tcontext->protocol = mosq_p_mqtt31;\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    504  \t\t\tcontext->is_bridge = true;\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    508  \t\t\tcontext->protocol = mosq_p_mqtt311;\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    511  \t\t\t\tcontext->is_bridge = true;\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    514  \t\t\tcontext->protocol = mosq_p_mqtt5;\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    563  \t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid Will QoS in CONNECT from %s.\",\n    564  \t\t\t\tcontext->address);\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    724  \tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    731  \t\tif(!context->ssl){\n    732  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    741  \t\tif(context->listener->psk_hint){\n    743  \t\t\tif(!context->username){\n    744  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    754  \t\t\tclient_cert = SSL_get_peer_certificate(context->ssl);\n    755  \t\t\tif(!client_cert){\n    756  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    764  \t\t\tname = X509_get_subject_name(client_cert);\n    765  \t\t\tif(!name){\n    766  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    774  \t\t\tif (context->listener->use_identity_as_username) { /* use_identity_as_username */\n    775  \t\t\t\ti = X509_NAME_get_index_by_NID(name, NID_commonName, -1);\n    776  \t\t\t\tif(i == -1){\n    777  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    785  \t\t\t\tname_entry = X509_NAME_get_entry(name, i);\n    786  \t\t\t\tif(name_entry){\n    787  \t\t\t\t\tname_asn1 = X509_NAME_ENTRY_get_data(name_entry);\n    788  \t\t\t\t\tif (name_asn1 == NULL) {\n    789  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    801  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_get0_data(name_asn1);\n    803  \t\t\t\t\tif(mosquitto_validate_utf8(new_username, (int)strlen(new_username))){\n    804  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    809  \t\t\t\t\t\tX509_free(client_cert);\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    814  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    824  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    835  \t\t\t\tX509_NAME_print_ex(subject_bio, X509_get_subject_name(client_cert), 0, XN_FLAG_RFC2253);\n    847  \t\t\t\tcontext->username = subject;\n    849  \t\t\tif(!context->username){\n    853  \t\t\tX509_free(client_cert);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    898  \t\t\tmosquitto__set_state(context, mosq_cs_authenticating);\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    905  \t\t\twill__clear(context);\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    925  \t\tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    973  \tif(client_cert) X509_free(client_cert);\n    976  \tcontext->clean_start = true;\n    977  \tcontext->session_expiry_interval = 0;\n    978  \tcontext->will_delay_interval = 0;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    55   \tint i;\n    56   \tint pos;\n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    335  \tint rc = MOSQ_ERR_SUCCESS;\n    337  \tuint16_t tlen;\n    340  \tuint16_t payloadlen;\n    341  \tmosquitto_property *properties = NULL;\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    349  \t\trc = property__read_all(CMD_WILL, &context->in_packet, &properties);\n    350  \t\tif(rc) goto error_cleanup;\n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    353  \t\tmosquitto_property_free_all(&properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    356  \trc = packet__read_string(&context->in_packet, &will_struct->msg.topic, &tlen);\n    357  \tif(rc) goto error_cleanup;\n    363  \tif(context->listener->mount_point){\n    364  \t\tslen = strlen(context->listener->mount_point) + strlen(will_struct->msg.topic) + 1;\n    365  \t\twill_topic_mount = mosquitto__malloc(slen+1);\n    366  \t\tif(!will_topic_mount){\n    368  \t\t\tgoto error_cleanup;\n    369  \t\t}\n    371  \t\tsnprintf(will_topic_mount, slen, \"%s%s\", context->listener->mount_point, will_struct->msg.topic);\n    372  \t\twill_topic_mount[slen] = '\\0';\n    374  \t\tmosquitto__free(will_struct->msg.topic);\n    375  \t\twill_struct->msg.topic = will_topic_mount;\n    376  \t}\n    378  \tif(!strncmp(will_struct->msg.topic, \"$CONTROL/\", strlen(\"$CONTROL/\"))){\n    380  \t\tgoto error_cleanup;\n    381  \t}\n    382  \trc = mosquitto_pub_topic_check(will_struct->msg.topic);\n    385  \trc = packet__read_uint16(&context->in_packet, &payloadlen);\n    386  \tif(rc) goto error_cleanup;\n    388  \twill_struct->msg.payloadlen = payloadlen;\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    393  \t\t\t\tsend__connack(context, 0, MQTT_RC_PACKET_TOO_LARGE, NULL);\n    394  \t\t\t}else{\n    395  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    396  \t\t\t}\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    400  \t\twill_struct->msg.payload = mosquitto__malloc((size_t)will_struct->msg.payloadlen);\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    406  \t\trc = packet__read_bytes(&context->in_packet, will_struct->msg.payload, (uint32_t)will_struct->msg.payloadlen);\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    416  error_cleanup:\n    417  \tif(will_struct){\n    418  \t\tmosquitto__free(will_struct->msg.topic);\n    419  \t\tmosquitto__free(will_struct->msg.payload);\n    422  \t}\n    424  }\nFunction: net__write\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:996\n    996  ssize_t net__write(struct mosquitto *mosq, const void *buf, size_t count)\n    997  {\n    999  \tint ret;\n    1001 \tassert(mosq);\n    1005 \tif(mosq->ssl){\n    1007 \t\tmosq->want_write = false;\n    1008 \t\tret = SSL_write(mosq->ssl, buf, (int)count);\n    1009 \t\tif(ret < 0){\n    1010 \t\t\tret = net__handle_ssl(mosq, ret);\n    1011 \t\t}\n    1012 \t\treturn (ssize_t )ret;\n    1013 \t}else{\n    1017 \treturn send(mosq->sock, buf, count, MSG_NOSIGNAL);\n    1020 \t}\n    1022 }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    51   \tassert(packet);\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    73   \tassert(packet);\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    157  \tassert(packet);\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: property__get_property\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:988\n    988  static const mosquitto_property *property__get_property(const mosquitto_property *proplist, int identifier, bool skip_first)\n    989  {\n    990  \tconst mosquitto_property *p;\n    995  \twhile(p){\n    996  \t\tif(p->identifier == identifier){\n    997  \t\t\tif(!is_first || !skip_first){\n    998  \t\t\t\treturn p;\n    999  \t\t\t}\n    1001 \t\t}\n    1002 \t\tp = p->next;\n    1003 \t}\n    1005 }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    371  \t\tmux__delete(context);\n    372  \t\tcontext__disconnect(context);\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto__malloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:83\n    83   void *mosquitto__malloc(size_t size)\n    84   {\n    88   \tif(mem_limit && memcount + size > mem_limit){\n    89   \t\treturn NULL;\n    90   \t}\n    93   \tmem = malloc(size);\n    96   \tif(mem){\n    97   \t\tmemcount += malloc_usable_size(mem);\n    101  \t}\n    105  }\nFunction: mosquitto__strdup\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:144\n    144  char *mosquitto__strdup(const char *s)\n    145  {\n    148  \tif(mem_limit && memcount + strlen(s) > mem_limit){\n    149  \t\treturn NULL;\n    150  \t}\n    152  \tstr = strdup(s);\n    155  \tif(str){\n    156  \t\tmemcount += malloc_usable_size(str);\n    160  \t}\n    164  }\nFunction: mosquitto_free\nPath: /root/projects/mosquitto/src/memory_public.c:27\n    27   void mosquitto_free(void *mem)\n    29   \tmosquitto__free(mem);\n    30   }\nFunction: mosquitto_malloc\nPath: /root/projects/mosquitto/src/memory_public.c:32\n    32   void *mosquitto_malloc(size_t size)\n    34   \treturn mosquitto__malloc(size);\n    35   }\nFunction: mux__delete\nPath: /root/projects/mosquitto/src/mux.c:61\n    61   int mux__delete(struct mosquitto *context)\n    64   \treturn mux_epoll__delete(context);\n    68   }\nFunction: send__auth\nPath: /root/projects/mosquitto/src/send_auth.c:28\n    28   int send__auth(struct mosquitto *context, uint8_t reason_code, const void *auth_data, uint16_t auth_data_len)\n    29   {\n    32   \tmosquitto_property *properties = NULL;\n    35   \tif(context->auth_method == NULL) return MOSQ_ERR_INVAL;\n    36   \tif(context->protocol != mosq_p_mqtt5) return MOSQ_ERR_PROTOCOL;\n    38   \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending AUTH to %s (rc%d, %s)\", context->id, reason_code, context->auth_method);\n    42   \trc = mosquitto_property_add_string(&properties, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method);\n    43   \tif(rc){\n    45   \t\treturn rc;\n    46   \t}\n    56   \tremaining_length += property__get_remaining_length(properties);\n    58   \tif(packet__check_oversize(context, remaining_length)){\n    61   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    62   \t}\n    67   \tpacket->command = CMD_AUTH;\n    68   \tpacket->remaining_length = remaining_length;\n    70   \trc = packet__alloc(packet);\n    76   \tpacket__write_byte(packet, reason_code);\n    77   \tproperty__write_all(packet, properties, true);\n    80   \treturn packet__queue(context, packet);\n    81   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    32   \tmosquitto_property *connack_props = NULL;\n    33   \tuint32_t remaining_length;\n    35   \trc = mosquitto_property_copy_all(&connack_props, properties);\n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    43   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->address, ack, reason_code);\n    44   \t}\n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    51   \t\t\tif(rc){\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    58   \t\t\tif(rc){\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    65   \t\t\tif(rc){\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    71   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_MAXIMUM_QOS, context->listener->max_qos);\n    72   \t\t\tif(rc){\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    78   \t\tremaining_length += property__get_remaining_length(connack_props);\n    79   \t}\n    81   \tif(packet__check_oversize(context, remaining_length)){\n    83   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    84   \t}\n    92   \tpacket->command = CMD_CONNACK;\n    93   \tpacket->remaining_length = remaining_length;\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    105  \t}\n    108  \treturn packet__queue(context, packet);\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    42   \tassert(mosq);\n    45   \tif(mosq->bridge){\n    46   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Bridge %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    47   \t}else\n    56   \tassert(mosq);\n    60   \tpacket->command = CMD_DISCONNECT;\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    62   \t\tpacket->remaining_length = 1;\n    63   \t\tif(properties){\n    64   \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    65   \t\t}\n    66   \t}else{\n    67   \t\tpacket->remaining_length = 0;\n    68   \t}\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    80   \t}\n    82   \treturn packet__queue(mosq, packet);\n    83   }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    126  \tassert(mosq);\n    130  \tpacket->command = command;\n    131  \tif(dup){\n    132  \t\tpacket->command |= 8;\n    133  \t}\n    134  \tpacket->remaining_length = 2;\n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    137  \t\tif(reason_code != 0 || properties){\n    138  \t\t\tpacket->remaining_length += 1;\n    139  \t\t}\n    141  \t\tif(properties){\n    142  \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    143  \t\t}\n    144  \t}\n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    161  \t}\n    163  \treturn packet__queue(mosq, packet);\n    164  }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    117  \treturn send__command_with_mid(mosq, CMD_PUBREL|2, mid, false, 0, properties);\n    118  }\nFunction: send__publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:42\n    42   int send__publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    43   {\n    47   \tint i;\n    49   \tbool match;\n    51   \tchar *mapped_topic = NULL;\n    55   \tassert(mosq);\n    60   \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    63   \tif(!mosq->retain_available){\n    65   \t}\n    68   \tif(mosq->listener && mosq->listener->mount_point){\n    69   \t\tlen = strlen(mosq->listener->mount_point);\n    70   \t\tif(len < strlen(topic)){\n    71   \t\t\ttopic += len;\n    72   \t\t}else{\n    74   \t\t\treturn MOSQ_ERR_SUCCESS;\n    75   \t\t}\n    76   \t}\n    78   \tif(mosq->bridge && mosq->bridge->topics && mosq->bridge->topic_remapping){\n    79   \t\tfor(i=0; i<mosq->bridge->topic_count; i++){\n    80   \t\t\tcur_topic = &mosq->bridge->topics[i];\n    81   \t\t\tif((cur_topic->direction == bd_both || cur_topic->direction == bd_out)\n    82   \t\t\t\t\t&& (cur_topic->remote_prefix || cur_topic->local_prefix)){\n    85   \t\t\t\trc = mosquitto_topic_matches_sub(cur_topic->local_topic, topic, &match);\n    86   \t\t\t\tif(rc){\n    87   \t\t\t\t\treturn rc;\n    88   \t\t\t\t}\n    89   \t\t\t\tif(match){\n    90   \t\t\t\t\tmapped_topic = mosquitto__strdup(topic);\n    91   \t\t\t\t\tif(!mapped_topic) return MOSQ_ERR_NOMEM;\n    92   \t\t\t\t\tif(cur_topic->local_prefix){\n    94   \t\t\t\t\t\tif(!strncmp(cur_topic->local_prefix, mapped_topic, strlen(cur_topic->local_prefix))){\n    95   \t\t\t\t\t\t\ttopic_temp = mosquitto__strdup(mapped_topic+strlen(cur_topic->local_prefix));\n    96   \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    97   \t\t\t\t\t\t\tif(!topic_temp){\n    98   \t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    99   \t\t\t\t\t\t\t}\n    101  \t\t\t\t\t\t}\n    102  \t\t\t\t\t}\n    104  \t\t\t\t\tif(cur_topic->remote_prefix){\n    106  \t\t\t\t\t\tlen = strlen(mapped_topic) + strlen(cur_topic->remote_prefix)+1;\n    107  \t\t\t\t\t\ttopic_temp = mosquitto__malloc(len+1);\n    108  \t\t\t\t\t\tif(!topic_temp){\n    109  \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    110  \t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    111  \t\t\t\t\t\t}\n    112  \t\t\t\t\t\tsnprintf(topic_temp, len, \"%s%s\", cur_topic->remote_prefix, mapped_topic);\n    113  \t\t\t\t\t\ttopic_temp[len] = '\\0';\n    114  \t\t\t\t\t\tmosquitto__free(mapped_topic);\n    116  \t\t\t\t\t}\n    117  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, mapped_topic, (long)payloadlen);\n    119  \t\t\t\t\trc =  send__real_publish(mosq, mid, mapped_topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    120  \t\t\t\t\tmosquitto__free(mapped_topic);\n    121  \t\t\t\t\treturn rc;\n    122  \t\t\t\t}\n    123  \t\t\t}\n    124  \t\t}\n    125  \t}\n    127  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, topic, (long)payloadlen);\n    133  \treturn send__real_publish(mosq, mid, topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    134  }\nFunction: send__real_publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:137\n    137  int send__real_publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    138  {\n    140  \tunsigned int packetlen;\n    141  \tunsigned int proplen = 0, varbytes;\n    143  \tmosquitto_property expiry_prop;\n    145  \tassert(mosq);\n    147  \tif(topic){\n    148  \t\tpacketlen = 2+(unsigned int)strlen(topic) + payloadlen;\n    149  \t}else{\n    150  \t\tpacketlen = 2 + payloadlen;\n    151  \t}\n    152  \tif(qos > 0) packetlen += 2; /* For message id */\n    153  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tproplen += property__get_length_all(cmsg_props);\n    156  \t\tproplen += property__get_length_all(store_props);\n    157  \t\tif(expiry_interval > 0){\n    158  \t\t\texpiry_prop.next = NULL;\n    160  \t\t\texpiry_prop.identifier = MQTT_PROP_MESSAGE_EXPIRY_INTERVAL;\n    163  \t\t\tproplen += property__get_length_all(&expiry_prop);\n    164  \t\t}\n    166  \t\tvarbytes = packet__varint_bytes(proplen);\n    172  \t\t}else{\n    173  \t\t\tpacketlen += proplen + varbytes;\n    174  \t\t}\n    175  \t}\n    176  \tif(packet__check_oversize(mosq, packetlen)){\n    178  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Dropping too large outgoing PUBLISH for %s (%d bytes)\", SAFE_PRINT(mosq->id), packetlen);\n    182  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    183  \t}\n    189  \tpacket->command = (uint8_t)(CMD_PUBLISH | (uint8_t)((dup&0x1)<<3) | (uint8_t)(qos<<1) | retain);\n    190  \tpacket->remaining_length = packetlen;\n    206  \tif(mosq->protocol == mosq_p_mqtt5){\n    213  \t}\n    220  \treturn packet__queue(mosq, packet);\n    221  }\nFunction: session_expiry__cmp\nPath: /root/projects/mosquitto/src/session_expiry.c:34\n    34   static int session_expiry__cmp(struct session_expiry_list *i1, struct session_expiry_list *i2)\n    35   {\n    36   \tif(i1->context->session_expiry_time == i2->context->session_expiry_time){\n    37   \t\treturn 0;\n    38   \t}else if(i1->context->session_expiry_time > i2->context->session_expiry_time){\n    39   \t\treturn 1;\n    40   \t}else{\n    41   \t\treturn -1;\n    42   \t}\n    43   }\nFunction: session_expiry__remove\nPath: /root/projects/mosquitto/src/session_expiry.c:121\n    121  void session_expiry__remove(struct mosquitto *context)\n    122  {\n    123  \tif(context->expiry_list_item){\n    124  \t\tDL_DELETE(expiry_list, context->expiry_list_item);\n    125  \t\tmosquitto__free(context->expiry_list_item);\n    126  \t\tcontext->expiry_list_item = NULL;\n    127  \t}\n    128  }\nFunction: acl__check_single\nPath: /root/projects/mosquitto/src/security.c:602\n    602  static int acl__check_single(struct mosquitto__auth_plugin_config *auth_plugin, struct mosquitto *context, struct mosquitto_acl_msg *msg, int access)\n    603  {\n    607  \tusername = mosquitto_client_username(context);\n    608  \tif(auth_plugin->deny_special_chars == true){\n    615  \t\tif(username && strpbrk(username, \"+#\")){\n    616  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous username \\\"%s\\\"\", username);\n    617  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    618  \t\t}\n    619  \t\tif(context->id && strpbrk(context->id, \"+#\")){\n    620  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous client id \\\"%s\\\"\", context->id);\n    621  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    622  \t\t}\n    623  \t}\n    625  \tif(auth_plugin->plugin.version == 4){\n    626  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    627  \t\t\treturn MOSQ_ERR_SUCCESS;\n    628  \t\t}\n    629  \t\treturn auth_plugin->plugin.acl_check_v4(auth_plugin->plugin.user_data, access, context, msg);\n    630  \t}else if(auth_plugin->plugin.version == 3){\n    631  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    632  \t\t\treturn MOSQ_ERR_SUCCESS;\n    633  \t\t}\n    634  \t\treturn auth_plugin->plugin.acl_check_v3(auth_plugin->plugin.user_data, access, context, msg);\n    635  \t}else if(auth_plugin->plugin.version == 2){\n    636  \t\tif(access == MOSQ_ACL_SUBSCRIBE || access == MOSQ_ACL_UNSUBSCRIBE){\n    637  \t\t\treturn MOSQ_ERR_SUCCESS;\n    638  \t\t}\n    639  \t\treturn auth_plugin->plugin.acl_check_v2(auth_plugin->plugin.user_data, context->id, username, topic, access);\n    640  \t}else{\n    641  \t\treturn MOSQ_ERR_INVAL;\n    642  \t}\n    643  }\nFunction: sub__remove_shared_leaf\nPath: /root/projects/mosquitto/src/subs.c:190\n    190  static void sub__remove_shared_leaf(struct mosquitto__subhier *subhier, struct mosquitto__subshared *shared, struct mosquitto__subleaf *leaf)\n    191  {\n    192  \tDL_DELETE(shared->subs, leaf);\n    193  \tif(shared->subs == NULL){\n    194  \t\tHASH_DELETE(hh, subhier->shared, shared);\n    195  \t\tmosquitto__free(shared->name);\n    196  \t\tmosquitto__free(shared);\n    197  \t}\n    199  }\nFunction: sub__messages_queue\nPath: /root/projects/mosquitto/src/subs.c:659\n    659  int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n    660  {\n    661  \tint rc = MOSQ_ERR_SUCCESS, rc2;\n    662  \tint rc_normal = MOSQ_ERR_NO_SUBSCRIBERS, rc_shared = MOSQ_ERR_NO_SUBSCRIBERS;\n    663  \tstruct mosquitto__subhier *subhier;\n    664  \tchar **split_topics = NULL;\n    677  \tHASH_FIND(hh, db.normal_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    678  \tif(subhier){\n    679  \t\trc_normal = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    680  \t\tif(rc_normal > 0){\n    682  \t\t\tgoto end;\n    683  \t\t}\n    684  \t}\n    686  \tHASH_FIND(hh, db.shared_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    687  \tif(subhier){\n    688  \t\trc_shared = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    689  \t\tif(rc_shared > 0){\n    691  \t\t\tgoto end;\n    692  \t\t}\n    693  \t}\n    695  \tif(rc_normal == MOSQ_ERR_NO_SUBSCRIBERS && rc_shared == MOSQ_ERR_NO_SUBSCRIBERS){\n    697  \t}\n    711  }\nFunction: sub__search\nPath: /root/projects/mosquitto/src/subs.c:479\n    479  static int sub__search(struct mosquitto__subhier *subhier, char **split_topics, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    480  {\n    482  \tstruct mosquitto__subhier *branch;\n    486  \tif(split_topics && split_topics[0]){\n    488  \t\tHASH_FIND(hh, subhier->children, split_topics[0], strlen(split_topics[0]), branch);\n    490  \t\tif(branch){\n    491  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    492  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    494  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    495  \t\t\t\treturn rc;\n    496  \t\t\t}\n    497  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    498  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    499  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    501  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    502  \t\t\t\t\treturn rc;\n    503  \t\t\t\t}\n    504  \t\t\t}\n    505  \t\t}\n    508  \t\tHASH_FIND(hh, subhier->children, \"+\", 1, branch);\n    510  \t\tif(branch){\n    511  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    512  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    514  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    515  \t\t\t\treturn rc;\n    516  \t\t\t}\n    517  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    518  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    519  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    521  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    522  \t\t\t\t\treturn rc;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}\n    526  \t}\n    529  \tHASH_FIND(hh, subhier->children, \"#\", 1, branch);\n    530  \tif(branch && !branch->children){\n    535  \t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    536  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    538  \t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    539  \t\t\treturn rc;\n    540  \t\t}\n    541  \t}\n    548  }\nFunction: subs__process\nPath: /root/projects/mosquitto/src/subs.c:129\n    129  static int subs__process(struct mosquitto__subhier *hier, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    130  {\n    133  \tstruct mosquitto__subleaf *leaf;\n    135  \trc = subs__shared_process(hier, topic, qos, retain, stored);\n    137  \tleaf = hier->subs;\n    138  \twhile(source_id && leaf){\n    139  \t\tif(!leaf->context->id || (leaf->no_local && !strcmp(leaf->context->id, source_id))){\n    140  \t\t\tleaf = leaf->next;\n    142  \t\t}\n    147  \t\tleaf = leaf->next;\n    148  \t}\n    149  \tif(hier->subs || hier->shared){\n    150  \t\treturn rc;\n    151  \t}else{\n    152  \t\treturn MOSQ_ERR_NO_SUBSCRIBERS;\n    153  \t}\n    154  }\nFunction: subs__send\nPath: /root/projects/mosquitto/src/subs.c:63\n    63   static int subs__send(struct mosquitto__subleaf *leaf, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    64   {\n    65   \tbool client_retain;\n    66   \tuint16_t mid;\n    67   \tuint8_t client_qos, msg_qos;\n    68   \tmosquitto_property *properties = NULL;\n    72   \trc2 = mosquitto_acl_check(leaf->context, topic, stored->payloadlen, stored->payload, stored->qos, stored->retain, MOSQ_ACL_READ);\n    73   \tif(rc2 == MOSQ_ERR_ACL_DENIED){\n    74   \t\treturn MOSQ_ERR_SUCCESS;\n    75   \t}else if(rc2 == MOSQ_ERR_SUCCESS){\n    76   \t\tclient_qos = leaf->qos;\n    87   \t\tif(msg_qos){\n    88   \t\t\tmid = mosquitto__mid_generate(leaf->context);\n    89   \t\t}else{\n    92   \t\tif(leaf->retain_as_published){\n    93   \t\t\tclient_retain = retain;\n    94   \t\t}else{\n    97   \t\tif(leaf->identifier){\n    98   \t\t\tmosquitto_property_add_varint(&properties, MQTT_PROP_SUBSCRIPTION_IDENTIFIER, leaf->identifier);\n    99   \t\t}\n    100  \t\tif(db__message_insert(leaf->context, mid, mosq_md_out, msg_qos, client_retain, stored, properties, true) == 1){\n    101  \t\t\treturn 1;\n    102  \t\t}\n    103  \t}else{\n    104  \t\treturn 1; /* Application error */\n    105  \t}\n    107  }\nFunction: sub__clean_session\nPath: /root/projects/mosquitto/src/subs.c:746\n    746  int sub__clean_session(struct mosquitto *context)\n    747  {\n    748  \tint i;\n    749  \tstruct mosquitto__subleaf *leaf;\n    750  \tstruct mosquitto__subhier *hier;\n    752  \tfor(i=0; i<context->sub_count; i++){\n    753  \t\tif(context->subs[i] == NULL){\n    755  \t\t}\n    757  \t\thier = context->subs[i]->hier;\n    759  \t\tif(context->subs[i]->shared){\n    760  \t\t\tleaf = context->subs[i]->shared->subs;\n    761  \t\t\twhile(leaf){\n    762  \t\t\t\tif(leaf->context==context){\n    766  \t\t\t\t\tsub__remove_shared_leaf(context->subs[i]->hier, context->subs[i]->shared, leaf);\n    768  \t\t\t\t}\n    769  \t\t\t\tleaf = leaf->next;\n    770  \t\t\t}\n    771  \t\t}else{\n    772  \t\t\tleaf = hier->subs;\n    773  \t\t\twhile(leaf){\n    774  \t\t\t\tif(leaf->context==context){\n    778  \t\t\t\t\tDL_DELETE(hier->subs, leaf);\n    779  \t\t\t\t\tmosquitto__free(leaf);\n    781  \t\t\t\t}\n    782  \t\t\t\tleaf = leaf->next;\n    783  \t\t\t}\n    784  \t\t}\n    785  \t\tmosquitto__free(context->subs[i]);\n    786  \t\tcontext->subs[i] = NULL;\n    788  \t\tif(hier->subs == NULL\n    789  \t\t\t\t&& hier->children == NULL\n    790  \t\t\t\t&& hier->shared == NULL\n    791  \t\t\t\t&& hier->parent){\n    794  \t\t\t\thier = tmp_remove_subs(hier);\n    795  \t\t\t}while(hier);\n    796  \t\t}\n    797  \t}\n    798  \tmosquitto__free(context->subs);\n    799  \tcontext->subs = NULL;\n    800  \tcontext->sub_count = 0;\n    803  }\nFunction: tmp_remove_subs\nPath: /root/projects/mosquitto/src/subs.c:715\n    715  static struct mosquitto__subhier *tmp_remove_subs(struct mosquitto__subhier *sub)\n    716  {\n    719  \tif(!sub || !sub->parent){\n    720  \t\treturn NULL;\n    721  \t}\n    723  \tif(sub->children || sub->subs){\n    724  \t\treturn NULL;\n    725  \t}\n    727  \tparent = sub->parent;\n    728  \tHASH_DELETE(hh, parent->children, sub);\n    729  \tmosquitto__free(sub->topic);\n    730  \tmosquitto__free(sub);\n    732  \tif(parent->subs == NULL\n    733  \t\t\t&& parent->children == NULL\n    734  \t\t\t&& parent->shared == NULL\n    735  \t\t\t&& parent->parent){\n    737  \t\treturn parent;\n    738  \t}else{\n    739  \t\treturn NULL;\n    740  \t}\n    741  }\nFunction: util__increment_send_quota\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:222\n    222  void util__increment_send_quota(struct mosquitto *mosq)\n    223  {\n    224  \tif(mosq->msgs_out.inflight_quota < mosq->msgs_out.inflight_maximum){\n    225  \t\tmosq->msgs_out.inflight_quota++;\n    226  \t}\n    227  }\nFunction: will_delay__remove\nPath: /root/projects/mosquitto/src/will_delay.c:99\n    99   void will_delay__remove(struct mosquitto *mosq)\n    100  {\n    101  \tif(mosq->will_delay_entry != NULL){\n    102  \t\tDL_DELETE(delay_list, mosq->will_delay_entry);\n    103  \t\tmosquitto__free(mosq->will_delay_entry);\n    104  \t\tmosq->will_delay_entry = NULL;\n    105  \t}\n    106  }\nFunction: will__clear\nPath: /root/projects/mosquitto/src/../lib/will_mosq.c:111\n    111  int will__clear(struct mosquitto *mosq)\n    112  {\n    113  \tif(!mosq->will) return MOSQ_ERR_SUCCESS;\n    115  \tmosquitto__free(mosq->will->msg.topic);\n    116  \tmosq->will->msg.topic = NULL;\n    118  \tmosquitto__free(mosq->will->msg.payload);\n    119  \tmosq->will->msg.payload = NULL;\n    121  \tmosquitto_property_free_all(&mosq->will->properties);\n    123  \tmosquitto__free(mosq->will);\n    124  \tmosq->will = NULL;\n    125  \tmosq->will_delay_interval = 0;\n    128  }\n",
    "Including the Will Delay Interval more than once is a Protocol Error.": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    221  \tplugin__handle_disconnect(context, -1);\n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    226  \tif(context->bridge == NULL)\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    232  \t\t\tif(context->will_delay_interval == 0){\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    147  \tassert(mosq);\n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    153  \tpacket->next = NULL;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    187  \treturn packet__write(mosq);\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    353  }\nFunction: property__process_connect\nPath: /root/projects/mosquitto/src/property_broker.c:30\n    30   int property__process_connect(struct mosquitto *context, mosquitto_property **props)\n    31   {\n    32   \tmosquitto_property *p;\n    34   \tp = *props;\n    36   \twhile(p){\n    37   \t\tif(p->identifier == MQTT_PROP_SESSION_EXPIRY_INTERVAL){\n    38   \t\t\tcontext->session_expiry_interval = p->value.i32;\n    39   \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM){\n    40   \t\t\tif(p->value.i16 == 0){\n    41   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    42   \t\t\t}\n    44   \t\t\tcontext->msgs_out.inflight_maximum = p->value.i16;\n    45   \t\t\tcontext->msgs_out.inflight_quota = context->msgs_out.inflight_maximum;\n    46   \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    47   \t\t\tif(p->value.i32 == 0){\n    48   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    49   \t\t\t}\n    50   \t\t\tcontext->maximum_packet_size = p->value.i32;\n    51   \t\t}\n    52   \t\tp = p->next;\n    53   \t}\n    56   }\nFunction: property__process_will\nPath: /root/projects/mosquitto/src/property_broker.c:59\n    59   int property__process_will(struct mosquitto *context, struct mosquitto_message_all *msg, mosquitto_property **props)\n    60   {\n    61   \tmosquitto_property *p, *p_prev;\n    64   \tp = *props;\n    68   \twhile(p){\n    69   \t\tswitch(p->identifier){\n    70   \t\t\tcase MQTT_PROP_CONTENT_TYPE:\n    71   \t\t\tcase MQTT_PROP_CORRELATION_DATA:\n    72   \t\t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    73   \t\t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    74   \t\t\tcase MQTT_PROP_USER_PROPERTY:\n    82   \t\t\t\tif(p_prev){\n    84   \t\t\t\t\tp = p_prev->next;\n    85   \t\t\t\t}else{\n    87   \t\t\t\t\tp = *props;\n    88   \t\t\t\t}\n    90   \t\t\t\tbreak;\n    92   \t\t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    93   \t\t\t\tcontext->will_delay_interval = p->value.i32;\n    94   \t\t\t\tp_prev = p;\n    95   \t\t\t\tp = p->next;\n    96   \t\t\t\tbreak;\n    98   \t\t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    101  \t\t\t\tp = p->next;\n    102  \t\t\t\tbreak;\n    104  \t\t\tdefault:\n    106  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    107  \t\t\t\tbreak;\n    108  \t\t}\n    109  \t}\n    113  }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    227  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    228  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    229  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: mosquitto_property_add_int16\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:744\n    744  int mosquitto_property_add_int16(mosquitto_property **proplist, int identifier, uint16_t value)\n    745  {\n    761  \tprop->value.i16 = value;\n    765  }\nFunction: mosquitto_property_read_binary\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1106\n    1106 const mosquitto_property *mosquitto_property_read_binary(const mosquitto_property *proplist, int identifier, void **value, uint16_t *len, bool skip_first)\n    1107 {\n    1109 \tif(!proplist || (value && !len) || (!value && len)) return NULL;\n    1113 \tp = property__get_property(proplist, identifier, skip_first);\n    1114 \tif(!p) return NULL;\n    1115 \tif(p->identifier != MQTT_PROP_CORRELATION_DATA\n    1116 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_DATA){\n    1118 \t\treturn NULL;\n    1119 \t}\n    1121 \tif(value){\n    1122 \t\t*len = p->value.bin.len;\n    1123 \t\t*value = calloc(1, *len + 1U);\n    1124 \t\tif(!(*value)) return NULL;\n    1126 \t\tmemcpy(*value, p->value.bin.v, *len);\n    1127 \t}\n    1130 }\nFunction: mosquitto_property_read_string\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1133\n    1133 const mosquitto_property *mosquitto_property_read_string(const mosquitto_property *proplist, int identifier, char **value, bool skip_first)\n    1134 {\n    1136 \tif(!proplist) return NULL;\n    1138 \tp = property__get_property(proplist, identifier, skip_first);\n    1139 \tif(!p) return NULL;\n    1140 \tif(p->identifier != MQTT_PROP_CONTENT_TYPE\n    1141 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_TOPIC\n    1142 \t\t\t&& p->identifier != MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER\n    1143 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_METHOD\n    1144 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_INFORMATION\n    1145 \t\t\t&& p->identifier != MQTT_PROP_SERVER_REFERENCE\n    1146 \t\t\t&& p->identifier != MQTT_PROP_REASON_STRING){\n    1148 \t\treturn NULL;\n    1149 \t}\n    1151 \tif(value){\n    1152 \t\t*value = calloc(1, (size_t)p->value.s.len+1);\n    1153 \t\tif(!(*value)) return NULL;\n    1155 \t\tmemcpy(*value, p->value.s.v, p->value.s.len);\n    1156 \t}\n    1159 }\nFunction: db__expire_all_messages\nPath: /root/projects/mosquitto/src/database.c:1053\n    1053 void db__expire_all_messages(struct mosquitto *context)\n    1055 \tstruct mosquitto_client_msg *msg, *tmp;\n    1057 \tDL_FOREACH_SAFE(context->msgs_out.inflight, msg, tmp){\n    1058 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1059 \t\t\tif(msg->qos > 0){\n    1060 \t\t\t\tutil__increment_send_quota(context);\n    1062 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1065 \tDL_FOREACH_SAFE(context->msgs_out.queued, msg, tmp){\n    1066 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1067 \t\t\tdb__message_remove_from_queued(&context->msgs_out, msg);\n    1070 \tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n    1071 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1072 \t\t\tif(msg->qos > 0){\n    1073 \t\t\t\tutil__increment_receive_quota(context);\n    1075 \t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n    1078 \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n    1079 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1080 \t\t\tdb__message_remove_from_queued(&context->msgs_in, msg);\n    1083 }\nFunction: db__message_remove_from_queued\nPath: /root/projects/mosquitto/src/database.c:364\n    364  static void db__message_remove_from_queued(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    365  {\n    366  \tif(!msg_data || !item){\n    367  \t\treturn;\n    368  \t}\n    370  \tDL_DELETE(msg_data->queued, item);\n    377  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1183 \tstruct mosquitto_client_msg *tail, *tmp;\n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1190 \tDL_FOREACH_SAFE(context->msgs_out.inflight, tail, tmp){\n    1191 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1192 \t\tif(rc) return rc;\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    143  \t\t\t\tin_quota = context->msgs_in.inflight_quota;\n    144  \t\t\t\tout_quota = context->msgs_out.inflight_quota;\n    145  \t\t\t\tin_maximum = context->msgs_in.inflight_maximum;\n    146  \t\t\t\tout_maximum = context->msgs_out.inflight_maximum;\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    154  \t\t\t\tcontext->msgs_in.inflight_quota = in_quota;\n    155  \t\t\t\tcontext->msgs_out.inflight_quota = out_quota;\n    156  \t\t\t\tcontext->msgs_in.inflight_maximum = in_maximum;\n    157  \t\t\t\tcontext->msgs_out.inflight_maximum = out_maximum;\n    159  \t\t\t\tdb__message_reconnect_reset(context);\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    215  \trc = acl__find_acls(context);\n    216  \tif(rc){\n    218  \t\treturn rc;\n    219  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    250  \t}\n    252  \tcontext->ping_t = 0;\n    253  \tcontext->is_dropping = false;\n    255  \tconnection_check_acl(context, &context->msgs_in.inflight);\n    256  \tconnection_check_acl(context, &context->msgs_in.queued);\n    257  \tconnection_check_acl(context, &context->msgs_out.inflight);\n    258  \tconnection_check_acl(context, &context->msgs_out.queued);\n    260  \tcontext__add_to_by_id(context);\n    263  \tif(!context->clean_start){\n    267  \tcontext->max_qos = context->listener->max_qos;\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    315  \tkeepalive__add(context);\n    317  \tmosquitto__set_state(context, mosq_cs_active);\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    320  \tif(rc) return rc;\n    321  \tdb__expire_all_messages(context);\n    322  \trc = db__message_write_queued_out(context);\n    323  \tif(rc) return rc;\n    324  \trc = db__message_write_inflight_out_all(context);\n    330  }\nFunction: connection_check_acl\nPath: /root/projects/mosquitto/src/handle_connect.c:86\n    86   static void connection_check_acl(struct mosquitto *context, struct mosquitto_client_msg **head)\n    97   \t\tif(mosquitto_acl_check(context, msg_tail->store->topic,\n    99   \t\t\t\t\t\t\t   msg_tail->store->qos, msg_tail->store->retain, access) != MOSQ_ERR_SUCCESS){\n    101  \t\t\tDL_DELETE((*head), msg_tail);\n    107  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    248  \tmosquitto__set_state(context, mosq_cs_disused);\n    250  \tif(context->id){\n    251  \t\tcontext__remove_from_by_id(context);\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    256  \tcontext->for_free_next = db.ll_for_free;\n    257  \tdb.ll_for_free = context;\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    296  \t\tcontext->in_by_id = true;\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__msg_add_to_inflight_stats\nPath: /root/projects/mosquitto/src/database.c:141\n    141  void db__msg_add_to_inflight_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    142  {\n    143  \tmsg_data->inflight_count++;\n    144  \tmsg_data->inflight_bytes += msg->store->payloadlen;\n    145  \tif(msg->qos != 0){\n    146  \t\tmsg_data->inflight_count12++;\n    147  \t\tmsg_data->inflight_bytes12 += msg->store->payloadlen;\n    148  \t}\n    149  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    271  \tmosquitto__free(store->source_id);\n    272  \tmosquitto__free(store->source_username);\n    283  }\nFunction: db__msg_remove_from_queued_stats\nPath: /root/projects/mosquitto/src/database.c:172\n    172  static void db__msg_remove_from_queued_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    173  {\n    174  \tmsg_data->queued_count--;\n    175  \tmsg_data->queued_bytes -= msg->store->payloadlen;\n    176  \tif(msg->qos != 0){\n    177  \t\tmsg_data->queued_count12--;\n    178  \t\tmsg_data->queued_bytes12 -= msg->store->payloadlen;\n    179  \t}\n    180  }\nFunction: db__message_remove_from_inflight\nPath: /root/projects/mosquitto/src/database.c:347\n    347  static void db__message_remove_from_inflight(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    348  {\n    349  \tif(!msg_data || !item){\n    350  \t\treturn;\n    351  \t}\n    353  \tDL_DELETE(msg_data->inflight, item);\n    354  \tif(item->store){\n    355  \t\tdb__msg_remove_from_inflight_stats(msg_data, item);\n    357  \t}\n    361  }\nFunction: db__message_write_inflight_out_latest\nPath: /root/projects/mosquitto/src/database.c:1198\n    1198 int db__message_write_inflight_out_latest(struct mosquitto *context)\n    1199 {\n    1200 \tstruct mosquitto_client_msg *tail, *next;\n    1203 \tif(context->state != mosq_cs_active\n    1204 \t\t\t|| context->sock == INVALID_SOCKET\n    1205 \t\t\t|| context->msgs_out.inflight == NULL){\n    1207 \t\treturn MOSQ_ERR_SUCCESS;\n    1208 \t}\n    1210 \tif(context->msgs_out.inflight->prev == context->msgs_out.inflight){\n    1212 \t\treturn db__message_write_inflight_out_single(context, context->msgs_out.inflight);\n    1213 \t}\n    1217 \ttail = context->msgs_out.inflight->prev;\n    1218 \twhile(tail != context->msgs_out.inflight &&\n    1219 \t\t\t(tail->state == mosq_ms_publish_qos0\n    1220 \t\t\t || tail->state == mosq_ms_publish_qos1\n    1221 \t\t\t || tail->state == mosq_ms_publish_qos2)){\n    1223 \t\ttail = tail->prev;\n    1224 \t}\n    1229 \tif(tail != context->msgs_out.inflight){\n    1230 \t\ttail = tail->next;\n    1231 \t}\n    1233 \twhile(tail){\n    1234 \t\tnext = tail->next;\n    1235 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1236 \t\tif(rc) return rc;\n    1238 \t}\n    1240 }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1097 \tuint32_t expiry_interval;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1103 \t\t\tif(msg->direction == mosq_md_out && msg->qos > 0){\n    1104 \t\t\t\tutil__increment_send_quota(context);\n    1105 \t\t\t}\n    1106 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1126 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1135 \t\t\t\tmsg->timestamp = db.now_s;\n    1136 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1137 \t\t\t\tmsg->state = mosq_ms_wait_for_puback;\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1139 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1148 \t\t\t\tmsg->timestamp = db.now_s;\n    1149 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1150 \t\t\t\tmsg->state = mosq_ms_wait_for_pubrec;\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1152 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1159 \t\t\trc = send__pubrel(context, mid, NULL);\n    1160 \t\t\tif(!rc){\n    1161 \t\t\t\tmsg->state = mosq_ms_wait_for_pubcomp;\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1176 \t}\n    1178 }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    449  \tstruct mosquitto_msg_data *msg_data;\n    450  \tenum mosquitto_msg_state state = mosq_ms_invalid;\n    452  \tint i;\n    457  \tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n    459  \tif(dir == mosq_md_out){\n    460  \t\tmsg_data = &context->msgs_out;\n    461  \t}else{\n    462  \t\tmsg_data = &context->msgs_in;\n    463  \t}\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    484  \tif(context->sock == INVALID_SOCKET){\n    486  \t\tif(qos == 0 && !db.config->queue_qos0_messages){\n    487  \t\t\tif(!context->bridge){\n    489  \t\t\t\treturn 2;\n    490  \t\t\t}else{\n    491  \t\t\t\tif(context->bridge->start_type != bst_lazy){\n    493  \t\t\t\t\treturn 2;\n    494  \t\t\t\t}\n    495  \t\t\t}\n    496  \t\t}\n    497  \t\tif(context->bridge && context->bridge->clean_start_local == true){\n    499  \t\t\treturn 2;\n    500  \t\t}\n    501  \t}\n    503  \tif(context->sock != INVALID_SOCKET){\n    504  \t\tif(db__ready_for_flight(context, dir, qos)){\n    517  \t\t\t}else{\n    520  \t\t\t\t}else{\n    522  \t\t\t\t\treturn 1;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n    528  \t\t}else{\n    530  \t\t\tif(context->is_dropping == false){\n    531  \t\t\t\tcontext->is_dropping = true;\n    532  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    534  \t\t\t\t\t\tcontext->id);\n    535  \t\t\t}\n    538  \t\t\treturn 2;\n    539  \t\t}\n    540  \t}else{\n    541  \t\tif (db__ready_for_queue(context, qos, msg_data)){\n    543  \t\t}else{\n    545  \t\t\tif(context->is_dropping == false){\n    546  \t\t\t\tcontext->is_dropping = true;\n    547  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    549  \t\t\t\t\t\tcontext->id);\n    550  \t\t\t}\n    552  \t\t\treturn 2;\n    553  \t\t}\n    554  \t}\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    582  \tif(state == mosq_ms_queued){\n    583  \t\tDL_APPEND(msg_data->queued, msg);\n    585  \t}else{\n    586  \t\tDL_APPEND(msg_data->inflight, msg);\n    588  \t}\n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    598  \t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n    599  \t\tif(dest_ids){\n    602  \t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t}\n    609  \t}\n    611  \tif(context->bridge && context->bridge->start_type == bst_lazy\n    612  \t\t\t&& context->sock == INVALID_SOCKET\n    613  \t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n    616  \t}\n    633  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    704  \tstruct mosquitto_msg_store *stored;\n    705  \tconst char *source_id;\n    706  \tenum mosquitto_msg_origin origin;\n    710  \tstored = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    711  \tif(stored == NULL) return MOSQ_ERR_NOMEM;\n    713  \tstored->topic = mosquitto__strdup(topic);\n    714  \tif(stored->topic == NULL){\n    715  \t\tdb__msg_store_free(stored);\n    716  \t\treturn MOSQ_ERR_INVAL;\n    717  \t}\n    719  \tstored->qos = qos;\n    720  \tif(db.config->retain_available == false){\n    721  \t\tstored->retain = 0;\n    722  \t}else{\n    723  \t\tstored->retain = retain;\n    724  \t}\n    726  \tstored->payloadlen = payloadlen;\n    727  \tif(payloadlen > 0){\n    728  \t\tstored->payload = mosquitto__malloc(stored->payloadlen+1);\n    729  \t\tif(stored->payload == NULL){\n    730  \t\t\tdb__msg_store_free(stored);\n    731  \t\t\treturn MOSQ_ERR_NOMEM;\n    732  \t\t}\n    734  \t\t((uint8_t *)stored->payload)[stored->payloadlen] = 0;\n    735  \t\tmemcpy(stored->payload, payload, stored->payloadlen);\n    736  \t}\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    746  \t}\n    748  \tif(context){\n    750  \t}else{\n    753  \tif(db__message_store(context, stored, message_expiry_interval, 0, origin)) return 1;\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    763  \tif(source && source->id){\n    764  \t\tstored->source_id = mosquitto__strdup(source->id);\n    765  \t}else{\n    766  \t\tstored->source_id = mosquitto__strdup(\"\");\n    767  \t}\n    768  \tif(!stored->source_id){\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    774  \tif(source && source->username){\n    775  \t\tstored->source_username = mosquitto__strdup(source->username);\n    776  \t\tif(!stored->source_username){\n    778  \t\t\treturn MOSQ_ERR_NOMEM;\n    779  \t\t}\n    780  \t}\n    781  \tif(source){\n    782  \t\tstored->source_listener = source->listener;\n    783  \t}\n    806  }\nFunction: net__socket_close\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:205\n    205  int net__socket_close(struct mosquitto *mosq)\n    206  {\n    207  \tint rc = 0;\n    209  \tstruct mosquitto *mosq_found;\n    212  \tassert(mosq);\n    218  \t\tif(mosq->ssl){\n    219  \t\t\tif(!SSL_in_init(mosq->ssl)){\n    220  \t\t\t\tSSL_shutdown(mosq->ssl);\n    221  \t\t\t}\n    222  \t\t\tSSL_free(mosq->ssl);\n    223  \t\t\tmosq->ssl = NULL;\n    224  \t\t}\n    238  \t\tif(mosq->sock != INVALID_SOCKET){\n    240  \t\t\tHASH_FIND(hh_sock, db.contexts_by_sock, &mosq->sock, sizeof(mosq->sock), mosq_found);\n    241  \t\t\tif(mosq_found){\n    242  \t\t\t\tHASH_DELETE(hh_sock, db.contexts_by_sock, mosq_found);\n    243  \t\t\t}\n    245  \t\t\trc = COMPAT_CLOSE(mosq->sock);\n    246  \t\t\tmosq->sock = INVALID_SOCKET;\n    247  \t\t}\n    251  \tif(mosq->listener){\n    252  \t\tmosq->listener->client_count--;\n    253  \t\tmosq->listener = NULL;\n    254  \t}\n    257  \treturn rc;\n    258  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    448  \tX509 *client_cert = NULL;\n    460  \tif(!context->listener){\n    461  \t\treturn MOSQ_ERR_INVAL;\n    462  \t}\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    502  \t\tcontext->protocol = mosq_p_mqtt31;\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    504  \t\t\tcontext->is_bridge = true;\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    508  \t\t\tcontext->protocol = mosq_p_mqtt311;\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    511  \t\t\t\tcontext->is_bridge = true;\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    514  \t\t\tcontext->protocol = mosq_p_mqtt5;\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    563  \t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid Will QoS in CONNECT from %s.\",\n    564  \t\t\t\tcontext->address);\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    724  \tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    731  \t\tif(!context->ssl){\n    732  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    741  \t\tif(context->listener->psk_hint){\n    743  \t\t\tif(!context->username){\n    744  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    754  \t\t\tclient_cert = SSL_get_peer_certificate(context->ssl);\n    755  \t\t\tif(!client_cert){\n    756  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    764  \t\t\tname = X509_get_subject_name(client_cert);\n    765  \t\t\tif(!name){\n    766  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    774  \t\t\tif (context->listener->use_identity_as_username) { /* use_identity_as_username */\n    775  \t\t\t\ti = X509_NAME_get_index_by_NID(name, NID_commonName, -1);\n    776  \t\t\t\tif(i == -1){\n    777  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    785  \t\t\t\tname_entry = X509_NAME_get_entry(name, i);\n    786  \t\t\t\tif(name_entry){\n    787  \t\t\t\t\tname_asn1 = X509_NAME_ENTRY_get_data(name_entry);\n    788  \t\t\t\t\tif (name_asn1 == NULL) {\n    789  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    801  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_get0_data(name_asn1);\n    803  \t\t\t\t\tif(mosquitto_validate_utf8(new_username, (int)strlen(new_username))){\n    804  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    809  \t\t\t\t\t\tX509_free(client_cert);\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    814  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    824  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    835  \t\t\t\tX509_NAME_print_ex(subject_bio, X509_get_subject_name(client_cert), 0, XN_FLAG_RFC2253);\n    847  \t\t\t\tcontext->username = subject;\n    849  \t\t\tif(!context->username){\n    853  \t\t\tX509_free(client_cert);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    898  \t\t\tmosquitto__set_state(context, mosq_cs_authenticating);\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    905  \t\t\twill__clear(context);\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    925  \t\tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    973  \tif(client_cert) X509_free(client_cert);\n    976  \tcontext->clean_start = true;\n    977  \tcontext->session_expiry_interval = 0;\n    978  \tcontext->will_delay_interval = 0;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    55   \tint i;\n    56   \tint pos;\n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    350  \t\tif(rc) goto error_cleanup;\n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    356  \trc = packet__read_string(&context->in_packet, &will_struct->msg.topic, &tlen);\n    363  \tif(context->listener->mount_point){\n    364  \t\tslen = strlen(context->listener->mount_point) + strlen(will_struct->msg.topic) + 1;\n    366  \t\tif(!will_topic_mount){\n    368  \t\t\tgoto error_cleanup;\n    369  \t\t}\n    371  \t\tsnprintf(will_topic_mount, slen, \"%s%s\", context->listener->mount_point, will_struct->msg.topic);\n    374  \t\tmosquitto__free(will_struct->msg.topic);\n    375  \t\twill_struct->msg.topic = will_topic_mount;\n    376  \t}\n    378  \tif(!strncmp(will_struct->msg.topic, \"$CONTROL/\", strlen(\"$CONTROL/\"))){\n    380  \t\tgoto error_cleanup;\n    381  \t}\n    382  \trc = mosquitto_pub_topic_check(will_struct->msg.topic);\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    394  \t\t\t}else{\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    400  \t\twill_struct->msg.payload = mosquitto__malloc((size_t)will_struct->msg.payloadlen);\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    406  \t\trc = packet__read_bytes(&context->in_packet, will_struct->msg.payload, (uint32_t)will_struct->msg.payloadlen);\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    413  \t*will = will_struct;\n    416  error_cleanup:\n    417  \tif(will_struct){\n    418  \t\tmosquitto__free(will_struct->msg.topic);\n    419  \t\tmosquitto__free(will_struct->msg.payload);\n    422  \t}\n    424  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    51   \tassert(packet);\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    73   \tassert(packet);\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    157  \tassert(packet);\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: property__get_property\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:988\n    988  static const mosquitto_property *property__get_property(const mosquitto_property *proplist, int identifier, bool skip_first)\n    989  {\n    990  \tconst mosquitto_property *p;\n    995  \twhile(p){\n    996  \t\tif(p->identifier == identifier){\n    997  \t\t\tif(!is_first || !skip_first){\n    998  \t\t\t\treturn p;\n    999  \t\t\t}\n    1001 \t\t}\n    1002 \t\tp = p->next;\n    1003 \t}\n    1005 }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    371  \t\tmux__delete(context);\n    372  \t\tcontext__disconnect(context);\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto__malloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:83\n    83   void *mosquitto__malloc(size_t size)\n    84   {\n    88   \tif(mem_limit && memcount + size > mem_limit){\n    89   \t\treturn NULL;\n    90   \t}\n    93   \tmem = malloc(size);\n    96   \tif(mem){\n    97   \t\tmemcount += malloc_usable_size(mem);\n    101  \t}\n    105  }\nFunction: mosquitto__strdup\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:144\n    144  char *mosquitto__strdup(const char *s)\n    145  {\n    148  \tif(mem_limit && memcount + strlen(s) > mem_limit){\n    149  \t\treturn NULL;\n    150  \t}\n    152  \tstr = strdup(s);\n    155  \tif(str){\n    156  \t\tmemcount += malloc_usable_size(str);\n    160  \t}\n    164  }\nFunction: mosquitto_free\nPath: /root/projects/mosquitto/src/memory_public.c:27\n    27   void mosquitto_free(void *mem)\n    29   \tmosquitto__free(mem);\n    30   }\nFunction: mosquitto_malloc\nPath: /root/projects/mosquitto/src/memory_public.c:32\n    32   void *mosquitto_malloc(size_t size)\n    34   \treturn mosquitto__malloc(size);\n    35   }\nFunction: mux__delete\nPath: /root/projects/mosquitto/src/mux.c:61\n    61   int mux__delete(struct mosquitto *context)\n    64   \treturn mux_epoll__delete(context);\n    68   }\nFunction: send__auth\nPath: /root/projects/mosquitto/src/send_auth.c:28\n    28   int send__auth(struct mosquitto *context, uint8_t reason_code, const void *auth_data, uint16_t auth_data_len)\n    29   {\n    32   \tmosquitto_property *properties = NULL;\n    35   \tif(context->auth_method == NULL) return MOSQ_ERR_INVAL;\n    36   \tif(context->protocol != mosq_p_mqtt5) return MOSQ_ERR_PROTOCOL;\n    38   \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending AUTH to %s (rc%d, %s)\", context->id, reason_code, context->auth_method);\n    42   \trc = mosquitto_property_add_string(&properties, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method);\n    43   \tif(rc){\n    45   \t\treturn rc;\n    46   \t}\n    56   \tremaining_length += property__get_remaining_length(properties);\n    58   \tif(packet__check_oversize(context, remaining_length)){\n    61   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    62   \t}\n    67   \tpacket->command = CMD_AUTH;\n    68   \tpacket->remaining_length = remaining_length;\n    70   \trc = packet__alloc(packet);\n    76   \tpacket__write_byte(packet, reason_code);\n    77   \tproperty__write_all(packet, properties, true);\n    80   \treturn packet__queue(context, packet);\n    81   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    32   \tmosquitto_property *connack_props = NULL;\n    33   \tuint32_t remaining_length;\n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    43   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->address, ack, reason_code);\n    44   \t}\n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    51   \t\t\tif(rc){\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    58   \t\t\tif(rc){\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    65   \t\t\tif(rc){\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    71   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_MAXIMUM_QOS, context->listener->max_qos);\n    72   \t\t\tif(rc){\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    78   \t\tremaining_length += property__get_remaining_length(connack_props);\n    79   \t}\n    81   \tif(packet__check_oversize(context, remaining_length)){\n    83   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    84   \t}\n    92   \tpacket->command = CMD_CONNACK;\n    93   \tpacket->remaining_length = remaining_length;\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    105  \t}\n    108  \treturn packet__queue(context, packet);\n    109  }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    126  \tassert(mosq);\n    130  \tpacket->command = command;\n    131  \tif(dup){\n    132  \t\tpacket->command |= 8;\n    133  \t}\n    134  \tpacket->remaining_length = 2;\n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    137  \t\tif(reason_code != 0 || properties){\n    138  \t\t\tpacket->remaining_length += 1;\n    139  \t\t}\n    141  \t\tif(properties){\n    142  \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    143  \t\t}\n    144  \t}\n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    161  \t}\n    163  \treturn packet__queue(mosq, packet);\n    164  }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    117  \treturn send__command_with_mid(mosq, CMD_PUBREL|2, mid, false, 0, properties);\n    118  }\nFunction: send__publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:42\n    42   int send__publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    43   {\n    47   \tint i;\n    49   \tbool match;\n    51   \tchar *mapped_topic = NULL;\n    55   \tassert(mosq);\n    60   \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    63   \tif(!mosq->retain_available){\n    65   \t}\n    68   \tif(mosq->listener && mosq->listener->mount_point){\n    69   \t\tlen = strlen(mosq->listener->mount_point);\n    70   \t\tif(len < strlen(topic)){\n    71   \t\t\ttopic += len;\n    72   \t\t}else{\n    74   \t\t\treturn MOSQ_ERR_SUCCESS;\n    75   \t\t}\n    76   \t}\n    78   \tif(mosq->bridge && mosq->bridge->topics && mosq->bridge->topic_remapping){\n    79   \t\tfor(i=0; i<mosq->bridge->topic_count; i++){\n    80   \t\t\tcur_topic = &mosq->bridge->topics[i];\n    81   \t\t\tif((cur_topic->direction == bd_both || cur_topic->direction == bd_out)\n    82   \t\t\t\t\t&& (cur_topic->remote_prefix || cur_topic->local_prefix)){\n    85   \t\t\t\trc = mosquitto_topic_matches_sub(cur_topic->local_topic, topic, &match);\n    86   \t\t\t\tif(rc){\n    87   \t\t\t\t\treturn rc;\n    88   \t\t\t\t}\n    89   \t\t\t\tif(match){\n    90   \t\t\t\t\tmapped_topic = mosquitto__strdup(topic);\n    91   \t\t\t\t\tif(!mapped_topic) return MOSQ_ERR_NOMEM;\n    92   \t\t\t\t\tif(cur_topic->local_prefix){\n    94   \t\t\t\t\t\tif(!strncmp(cur_topic->local_prefix, mapped_topic, strlen(cur_topic->local_prefix))){\n    95   \t\t\t\t\t\t\ttopic_temp = mosquitto__strdup(mapped_topic+strlen(cur_topic->local_prefix));\n    96   \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    97   \t\t\t\t\t\t\tif(!topic_temp){\n    98   \t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    99   \t\t\t\t\t\t\t}\n    101  \t\t\t\t\t\t}\n    102  \t\t\t\t\t}\n    104  \t\t\t\t\tif(cur_topic->remote_prefix){\n    106  \t\t\t\t\t\tlen = strlen(mapped_topic) + strlen(cur_topic->remote_prefix)+1;\n    107  \t\t\t\t\t\ttopic_temp = mosquitto__malloc(len+1);\n    108  \t\t\t\t\t\tif(!topic_temp){\n    109  \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    110  \t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    111  \t\t\t\t\t\t}\n    112  \t\t\t\t\t\tsnprintf(topic_temp, len, \"%s%s\", cur_topic->remote_prefix, mapped_topic);\n    113  \t\t\t\t\t\ttopic_temp[len] = '\\0';\n    114  \t\t\t\t\t\tmosquitto__free(mapped_topic);\n    116  \t\t\t\t\t}\n    117  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, mapped_topic, (long)payloadlen);\n    119  \t\t\t\t\trc =  send__real_publish(mosq, mid, mapped_topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    120  \t\t\t\t\tmosquitto__free(mapped_topic);\n    121  \t\t\t\t\treturn rc;\n    122  \t\t\t\t}\n    123  \t\t\t}\n    124  \t\t}\n    125  \t}\n    127  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, topic, (long)payloadlen);\n    133  \treturn send__real_publish(mosq, mid, topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    134  }\nFunction: send__real_publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:137\n    137  int send__real_publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    138  {\n    140  \tunsigned int packetlen;\n    141  \tunsigned int proplen = 0, varbytes;\n    143  \tmosquitto_property expiry_prop;\n    145  \tassert(mosq);\n    147  \tif(topic){\n    148  \t\tpacketlen = 2+(unsigned int)strlen(topic) + payloadlen;\n    149  \t}else{\n    150  \t\tpacketlen = 2 + payloadlen;\n    151  \t}\n    152  \tif(qos > 0) packetlen += 2; /* For message id */\n    153  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tproplen += property__get_length_all(cmsg_props);\n    156  \t\tproplen += property__get_length_all(store_props);\n    157  \t\tif(expiry_interval > 0){\n    163  \t\t\tproplen += property__get_length_all(&expiry_prop);\n    164  \t\t}\n    166  \t\tvarbytes = packet__varint_bytes(proplen);\n    172  \t\t}else{\n    173  \t\t\tpacketlen += proplen + varbytes;\n    174  \t\t}\n    175  \t}\n    176  \tif(packet__check_oversize(mosq, packetlen)){\n    178  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Dropping too large outgoing PUBLISH for %s (%d bytes)\", SAFE_PRINT(mosq->id), packetlen);\n    182  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    183  \t}\n    189  \tpacket->command = (uint8_t)(CMD_PUBLISH | (uint8_t)((dup&0x1)<<3) | (uint8_t)(qos<<1) | retain);\n    190  \tpacket->remaining_length = packetlen;\n    206  \tif(mosq->protocol == mosq_p_mqtt5){\n    213  \t}\n    220  \treturn packet__queue(mosq, packet);\n    221  }\nFunction: set_session_expiry_time\nPath: /root/projects/mosquitto/src/session_expiry.c:46\n    46   static void set_session_expiry_time(struct mosquitto *context)\n    47   {\n    50   \tif(db.config->persistent_client_expiration == 0){\n    52   \t\tcontext->session_expiry_time += context->session_expiry_interval;\n    53   \t}else{\n    55   \t\tif(db.config->persistent_client_expiration < context->session_expiry_interval){\n    58   \t\t}else{\n    60   \t\t\tcontext->session_expiry_time += context->session_expiry_interval;\n    61   \t\t}\n    62   \t}\n    63   }\nFunction: session_expiry__remove\nPath: /root/projects/mosquitto/src/session_expiry.c:121\n    121  void session_expiry__remove(struct mosquitto *context)\n    122  {\n    123  \tif(context->expiry_list_item){\n    124  \t\tDL_DELETE(expiry_list, context->expiry_list_item);\n    125  \t\tmosquitto__free(context->expiry_list_item);\n    126  \t\tcontext->expiry_list_item = NULL;\n    127  \t}\n    128  }\nFunction: mosquitto_acl_check\nPath: /root/projects/mosquitto/src/security.c:679\n    679  int mosquitto_acl_check(struct mosquitto *context, const char *topic, uint32_t payloadlen, void* payload, uint8_t qos, bool retain, int access)\n    680  {\n    681  \tint rc;\n    682  \tint i;\n    683  \tstruct mosquitto__security_options *opts;\n    684  \tstruct mosquitto_acl_msg msg;\n    685  \tstruct mosquitto__callback *cb_base;\n    686  \tstruct mosquitto_evt_acl_check event_data;\n    688  \tif(!context->id){\n    689  \t\treturn MOSQ_ERR_ACL_DENIED;\n    690  \t}\n    691  \tif(context->bridge){\n    692  \t\treturn MOSQ_ERR_SUCCESS;\n    693  \t}\n    703  \tif(db.config->per_listener_settings){\n    704  \t\tif(context->listener){\n    705  \t\t\topts = &context->listener->security_options;\n    706  \t\t}else{\n    707  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    708  \t\t}\n    709  \t}else{\n    710  \t\topts = &db.config->security_options;\n    711  \t}\n    720  \tDL_FOREACH(opts->plugin_callbacks.acl_check, cb_base){\n    724  \t\tevent_data.client = context;\n    732  \t\trc = cb_base->cb(MOSQ_EVT_ACL_CHECK, &event_data, cb_base->userdata);\n    733  \t\tif(rc != MOSQ_ERR_PLUGIN_DEFER){\n    738  \tfor(i=0; i<opts->auth_plugin_config_count; i++){\n    739  \t\tif(opts->auth_plugin_configs[i].plugin.version < 5){\n    740  \t\t\trc = acl__check_single(&opts->auth_plugin_configs[i], context, &msg, access);\n    741  \t\t\tif(rc != MOSQ_ERR_PLUGIN_DEFER){\n    742  \t\t\t\treturn rc;\n    743  \t\t\t}\n    744  \t\t}\n    745  \t}\n    749  \tif(rc == MOSQ_ERR_PLUGIN_DEFER){\n    751  \t}\n    753  }\nFunction: sub__remove_shared_leaf\nPath: /root/projects/mosquitto/src/subs.c:190\n    190  static void sub__remove_shared_leaf(struct mosquitto__subhier *subhier, struct mosquitto__subshared *shared, struct mosquitto__subleaf *leaf)\n    191  {\n    192  \tDL_DELETE(shared->subs, leaf);\n    193  \tif(shared->subs == NULL){\n    194  \t\tHASH_DELETE(hh, subhier->shared, shared);\n    195  \t\tmosquitto__free(shared->name);\n    196  \t\tmosquitto__free(shared);\n    197  \t}\n    199  }\nFunction: sub__messages_queue\nPath: /root/projects/mosquitto/src/subs.c:659\n    659  int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n    660  {\n    661  \tint rc = MOSQ_ERR_SUCCESS, rc2;\n    662  \tint rc_normal = MOSQ_ERR_NO_SUBSCRIBERS, rc_shared = MOSQ_ERR_NO_SUBSCRIBERS;\n    663  \tstruct mosquitto__subhier *subhier;\n    664  \tchar **split_topics = NULL;\n    677  \tHASH_FIND(hh, db.normal_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    678  \tif(subhier){\n    679  \t\trc_normal = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    680  \t\tif(rc_normal > 0){\n    682  \t\t\tgoto end;\n    683  \t\t}\n    684  \t}\n    686  \tHASH_FIND(hh, db.shared_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    687  \tif(subhier){\n    688  \t\trc_shared = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    689  \t\tif(rc_shared > 0){\n    691  \t\t\tgoto end;\n    692  \t\t}\n    693  \t}\n    695  \tif(rc_normal == MOSQ_ERR_NO_SUBSCRIBERS && rc_shared == MOSQ_ERR_NO_SUBSCRIBERS){\n    697  \t}\n    711  }\nFunction: sub__search\nPath: /root/projects/mosquitto/src/subs.c:479\n    479  static int sub__search(struct mosquitto__subhier *subhier, char **split_topics, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    480  {\n    482  \tstruct mosquitto__subhier *branch;\n    486  \tif(split_topics && split_topics[0]){\n    488  \t\tHASH_FIND(hh, subhier->children, split_topics[0], strlen(split_topics[0]), branch);\n    490  \t\tif(branch){\n    491  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    492  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    494  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    495  \t\t\t\treturn rc;\n    496  \t\t\t}\n    497  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    498  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    499  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    501  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    502  \t\t\t\t\treturn rc;\n    503  \t\t\t\t}\n    504  \t\t\t}\n    505  \t\t}\n    508  \t\tHASH_FIND(hh, subhier->children, \"+\", 1, branch);\n    510  \t\tif(branch){\n    511  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    512  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    514  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    515  \t\t\t\treturn rc;\n    516  \t\t\t}\n    517  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    518  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    519  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    521  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    522  \t\t\t\t\treturn rc;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}\n    526  \t}\n    529  \tHASH_FIND(hh, subhier->children, \"#\", 1, branch);\n    530  \tif(branch && !branch->children){\n    535  \t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    536  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    538  \t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    539  \t\t\treturn rc;\n    540  \t\t}\n    541  \t}\n    548  }\nFunction: subs__process\nPath: /root/projects/mosquitto/src/subs.c:129\n    129  static int subs__process(struct mosquitto__subhier *hier, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    130  {\n    133  \tstruct mosquitto__subleaf *leaf;\n    135  \trc = subs__shared_process(hier, topic, qos, retain, stored);\n    137  \tleaf = hier->subs;\n    138  \twhile(source_id && leaf){\n    139  \t\tif(!leaf->context->id || (leaf->no_local && !strcmp(leaf->context->id, source_id))){\n    140  \t\t\tleaf = leaf->next;\n    142  \t\t}\n    147  \t\tleaf = leaf->next;\n    148  \t}\n    149  \tif(hier->subs || hier->shared){\n    150  \t\treturn rc;\n    151  \t}else{\n    152  \t\treturn MOSQ_ERR_NO_SUBSCRIBERS;\n    153  \t}\n    154  }\nFunction: subs__send\nPath: /root/projects/mosquitto/src/subs.c:63\n    63   static int subs__send(struct mosquitto__subleaf *leaf, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    64   {\n    65   \tbool client_retain;\n    66   \tuint16_t mid;\n    67   \tuint8_t client_qos, msg_qos;\n    68   \tmosquitto_property *properties = NULL;\n    72   \trc2 = mosquitto_acl_check(leaf->context, topic, stored->payloadlen, stored->payload, stored->qos, stored->retain, MOSQ_ACL_READ);\n    73   \tif(rc2 == MOSQ_ERR_ACL_DENIED){\n    74   \t\treturn MOSQ_ERR_SUCCESS;\n    75   \t}else if(rc2 == MOSQ_ERR_SUCCESS){\n    76   \t\tclient_qos = leaf->qos;\n    87   \t\tif(msg_qos){\n    88   \t\t\tmid = mosquitto__mid_generate(leaf->context);\n    89   \t\t}else{\n    92   \t\tif(leaf->retain_as_published){\n    93   \t\t\tclient_retain = retain;\n    94   \t\t}else{\n    97   \t\tif(leaf->identifier){\n    98   \t\t\tmosquitto_property_add_varint(&properties, MQTT_PROP_SUBSCRIPTION_IDENTIFIER, leaf->identifier);\n    99   \t\t}\n    100  \t\tif(db__message_insert(leaf->context, mid, mosq_md_out, msg_qos, client_retain, stored, properties, true) == 1){\n    101  \t\t\treturn 1;\n    102  \t\t}\n    103  \t}else{\n    104  \t\treturn 1; /* Application error */\n    105  \t}\n    107  }\nFunction: sub__clean_session\nPath: /root/projects/mosquitto/src/subs.c:746\n    746  int sub__clean_session(struct mosquitto *context)\n    747  {\n    748  \tint i;\n    749  \tstruct mosquitto__subleaf *leaf;\n    750  \tstruct mosquitto__subhier *hier;\n    752  \tfor(i=0; i<context->sub_count; i++){\n    753  \t\tif(context->subs[i] == NULL){\n    755  \t\t}\n    757  \t\thier = context->subs[i]->hier;\n    759  \t\tif(context->subs[i]->shared){\n    760  \t\t\tleaf = context->subs[i]->shared->subs;\n    761  \t\t\twhile(leaf){\n    762  \t\t\t\tif(leaf->context==context){\n    766  \t\t\t\t\tsub__remove_shared_leaf(context->subs[i]->hier, context->subs[i]->shared, leaf);\n    768  \t\t\t\t}\n    769  \t\t\t\tleaf = leaf->next;\n    770  \t\t\t}\n    771  \t\t}else{\n    772  \t\t\tleaf = hier->subs;\n    773  \t\t\twhile(leaf){\n    774  \t\t\t\tif(leaf->context==context){\n    778  \t\t\t\t\tDL_DELETE(hier->subs, leaf);\n    779  \t\t\t\t\tmosquitto__free(leaf);\n    781  \t\t\t\t}\n    782  \t\t\t\tleaf = leaf->next;\n    783  \t\t\t}\n    784  \t\t}\n    785  \t\tmosquitto__free(context->subs[i]);\n    786  \t\tcontext->subs[i] = NULL;\n    788  \t\tif(hier->subs == NULL\n    789  \t\t\t\t&& hier->children == NULL\n    790  \t\t\t\t&& hier->shared == NULL\n    791  \t\t\t\t&& hier->parent){\n    794  \t\t\t\thier = tmp_remove_subs(hier);\n    795  \t\t\t}while(hier);\n    796  \t\t}\n    797  \t}\n    798  \tmosquitto__free(context->subs);\n    799  \tcontext->subs = NULL;\n    800  \tcontext->sub_count = 0;\n    803  }\nFunction: tmp_remove_subs\nPath: /root/projects/mosquitto/src/subs.c:715\n    715  static struct mosquitto__subhier *tmp_remove_subs(struct mosquitto__subhier *sub)\n    716  {\n    719  \tif(!sub || !sub->parent){\n    720  \t\treturn NULL;\n    721  \t}\n    723  \tif(sub->children || sub->subs){\n    724  \t\treturn NULL;\n    725  \t}\n    727  \tparent = sub->parent;\n    728  \tHASH_DELETE(hh, parent->children, sub);\n    729  \tmosquitto__free(sub->topic);\n    730  \tmosquitto__free(sub);\n    732  \tif(parent->subs == NULL\n    733  \t\t\t&& parent->children == NULL\n    734  \t\t\t&& parent->shared == NULL\n    735  \t\t\t&& parent->parent){\n    737  \t\treturn parent;\n    738  \t}else{\n    739  \t\treturn NULL;\n    740  \t}\n    741  }\nFunction: util__increment_receive_quota\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:215\n    215  void util__increment_receive_quota(struct mosquitto *mosq)\n    216  {\n    217  \tif(mosq->msgs_in.inflight_quota < mosq->msgs_in.inflight_maximum){\n    218  \t\tmosq->msgs_in.inflight_quota++;\n    219  \t}\n    220  }\nFunction: will_delay__remove\nPath: /root/projects/mosquitto/src/will_delay.c:99\n    99   void will_delay__remove(struct mosquitto *mosq)\n    100  {\n    101  \tif(mosq->will_delay_entry != NULL){\n    102  \t\tDL_DELETE(delay_list, mosq->will_delay_entry);\n    103  \t\tmosquitto__free(mosq->will_delay_entry);\n    104  \t\tmosq->will_delay_entry = NULL;\n    105  \t}\n    106  }\nFunction: will__clear\nPath: /root/projects/mosquitto/src/../lib/will_mosq.c:111\n    111  int will__clear(struct mosquitto *mosq)\n    112  {\n    113  \tif(!mosq->will) return MOSQ_ERR_SUCCESS;\n    115  \tmosquitto__free(mosq->will->msg.topic);\n    116  \tmosq->will->msg.topic = NULL;\n    118  \tmosquitto__free(mosq->will->msg.payload);\n    119  \tmosq->will->msg.payload = NULL;\n    121  \tmosquitto_property_free_all(&mosq->will->properties);\n    123  \tmosquitto__free(mosq->will);\n    124  \tmosq->will = NULL;\n    125  \tmosq->will_delay_interval = 0;\n    128  }\n",
    "Including the Response Topic more than once is a Protocol Error.": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    221  \tplugin__handle_disconnect(context, -1);\n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    226  \tif(context->bridge == NULL)\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    232  \t\t\tif(context->will_delay_interval == 0){\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    235  \treturn MOSQ_ERR_MALFORMED_PACKET;\n    236  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    147  \tassert(mosq);\n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    153  \tpacket->next = NULL;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    187  \treturn packet__write(mosq);\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    353  }\nFunction: property__process_connect\nPath: /root/projects/mosquitto/src/property_broker.c:30\n    30   int property__process_connect(struct mosquitto *context, mosquitto_property **props)\n    31   {\n    32   \tmosquitto_property *p;\n    34   \tp = *props;\n    36   \twhile(p){\n    37   \t\tif(p->identifier == MQTT_PROP_SESSION_EXPIRY_INTERVAL){\n    38   \t\t\tcontext->session_expiry_interval = p->value.i32;\n    39   \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM){\n    40   \t\t\tif(p->value.i16 == 0){\n    41   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    42   \t\t\t}\n    44   \t\t\tcontext->msgs_out.inflight_maximum = p->value.i16;\n    45   \t\t\tcontext->msgs_out.inflight_quota = context->msgs_out.inflight_maximum;\n    46   \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    47   \t\t\tif(p->value.i32 == 0){\n    48   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    49   \t\t\t}\n    50   \t\t\tcontext->maximum_packet_size = p->value.i32;\n    51   \t\t}\n    52   \t\tp = p->next;\n    53   \t}\n    56   }\nFunction: property__process_will\nPath: /root/projects/mosquitto/src/property_broker.c:59\n    59   int property__process_will(struct mosquitto *context, struct mosquitto_message_all *msg, mosquitto_property **props)\n    60   {\n    61   \tmosquitto_property *p, *p_prev;\n    64   \tp = *props;\n    68   \twhile(p){\n    69   \t\tswitch(p->identifier){\n    70   \t\t\tcase MQTT_PROP_CONTENT_TYPE:\n    71   \t\t\tcase MQTT_PROP_CORRELATION_DATA:\n    72   \t\t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    73   \t\t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    74   \t\t\tcase MQTT_PROP_USER_PROPERTY:\n    82   \t\t\t\tif(p_prev){\n    84   \t\t\t\t\tp = p_prev->next;\n    85   \t\t\t\t}else{\n    87   \t\t\t\t\tp = *props;\n    88   \t\t\t\t}\n    90   \t\t\t\tbreak;\n    92   \t\t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    93   \t\t\t\tcontext->will_delay_interval = p->value.i32;\n    95   \t\t\t\tp = p->next;\n    96   \t\t\t\tbreak;\n    98   \t\t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    101  \t\t\t\tp = p->next;\n    102  \t\t\t\tbreak;\n    104  \t\t\tdefault:\n    106  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    107  \t\t\t\tbreak;\n    108  \t\t}\n    109  \t}\n    113  }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: mosquitto_property_add_int16\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:744\n    744  int mosquitto_property_add_int16(mosquitto_property **proplist, int identifier, uint16_t value)\n    745  {\n    761  \tprop->value.i16 = value;\n    765  }\nFunction: mosquitto_property_read_binary\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1106\n    1106 const mosquitto_property *mosquitto_property_read_binary(const mosquitto_property *proplist, int identifier, void **value, uint16_t *len, bool skip_first)\n    1107 {\n    1109 \tif(!proplist || (value && !len) || (!value && len)) return NULL;\n    1113 \tp = property__get_property(proplist, identifier, skip_first);\n    1114 \tif(!p) return NULL;\n    1115 \tif(p->identifier != MQTT_PROP_CORRELATION_DATA\n    1116 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_DATA){\n    1118 \t\treturn NULL;\n    1119 \t}\n    1121 \tif(value){\n    1122 \t\t*len = p->value.bin.len;\n    1123 \t\t*value = calloc(1, *len + 1U);\n    1124 \t\tif(!(*value)) return NULL;\n    1126 \t\tmemcpy(*value, p->value.bin.v, *len);\n    1127 \t}\n    1130 }\nFunction: mosquitto_property_read_string\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1133\n    1133 const mosquitto_property *mosquitto_property_read_string(const mosquitto_property *proplist, int identifier, char **value, bool skip_first)\n    1134 {\n    1136 \tif(!proplist) return NULL;\n    1138 \tp = property__get_property(proplist, identifier, skip_first);\n    1139 \tif(!p) return NULL;\n    1140 \tif(p->identifier != MQTT_PROP_CONTENT_TYPE\n    1141 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_TOPIC\n    1142 \t\t\t&& p->identifier != MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER\n    1143 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_METHOD\n    1144 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_INFORMATION\n    1145 \t\t\t&& p->identifier != MQTT_PROP_SERVER_REFERENCE\n    1146 \t\t\t&& p->identifier != MQTT_PROP_REASON_STRING){\n    1147 \n    1148 \t\treturn NULL;\n    1149 \t}\n    1151 \tif(value){\n    1152 \t\t*value = calloc(1, (size_t)p->value.s.len+1);\n    1153 \t\tif(!(*value)) return NULL;\n    1155 \t\tmemcpy(*value, p->value.s.v, p->value.s.len);\n    1156 \t}\n    1159 }\nFunction: db__expire_all_messages\nPath: /root/projects/mosquitto/src/database.c:1053\n    1053 void db__expire_all_messages(struct mosquitto *context)\n    1055 \tstruct mosquitto_client_msg *msg, *tmp;\n    1057 \tDL_FOREACH_SAFE(context->msgs_out.inflight, msg, tmp){\n    1058 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1059 \t\t\tif(msg->qos > 0){\n    1060 \t\t\t\tutil__increment_send_quota(context);\n    1062 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1065 \tDL_FOREACH_SAFE(context->msgs_out.queued, msg, tmp){\n    1066 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1067 \t\t\tdb__message_remove_from_queued(&context->msgs_out, msg);\n    1070 \tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n    1071 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1072 \t\t\tif(msg->qos > 0){\n    1073 \t\t\t\tutil__increment_receive_quota(context);\n    1075 \t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n    1078 \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n    1079 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1080 \t\t\tdb__message_remove_from_queued(&context->msgs_in, msg);\n    1083 }\nFunction: db__message_remove_from_queued\nPath: /root/projects/mosquitto/src/database.c:364\n    364  static void db__message_remove_from_queued(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    365  {\n    366  \tif(!msg_data || !item){\n    367  \t\treturn;\n    368  \t}\n    370  \tDL_DELETE(msg_data->queued, item);\n    377  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1183 \tstruct mosquitto_client_msg *tail, *tmp;\n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1190 \tDL_FOREACH_SAFE(context->msgs_out.inflight, tail, tmp){\n    1191 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1192 \t\tif(rc) return rc;\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    143  \t\t\t\tin_quota = context->msgs_in.inflight_quota;\n    144  \t\t\t\tout_quota = context->msgs_out.inflight_quota;\n    145  \t\t\t\tin_maximum = context->msgs_in.inflight_maximum;\n    146  \t\t\t\tout_maximum = context->msgs_out.inflight_maximum;\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    154  \t\t\t\tcontext->msgs_in.inflight_quota = in_quota;\n    155  \t\t\t\tcontext->msgs_out.inflight_quota = out_quota;\n    156  \t\t\t\tcontext->msgs_in.inflight_maximum = in_maximum;\n    157  \t\t\t\tcontext->msgs_out.inflight_maximum = out_maximum;\n    159  \t\t\t\tdb__message_reconnect_reset(context);\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    215  \trc = acl__find_acls(context);\n    216  \tif(rc){\n    218  \t\treturn rc;\n    219  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    250  \t}\n    252  \tcontext->ping_t = 0;\n    253  \tcontext->is_dropping = false;\n    255  \tconnection_check_acl(context, &context->msgs_in.inflight);\n    256  \tconnection_check_acl(context, &context->msgs_in.queued);\n    257  \tconnection_check_acl(context, &context->msgs_out.inflight);\n    258  \tconnection_check_acl(context, &context->msgs_out.queued);\n    260  \tcontext__add_to_by_id(context);\n    263  \tif(!context->clean_start){\n    267  \tcontext->max_qos = context->listener->max_qos;\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    315  \tkeepalive__add(context);\n    317  \tmosquitto__set_state(context, mosq_cs_active);\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    320  \tif(rc) return rc;\n    321  \tdb__expire_all_messages(context);\n    322  \trc = db__message_write_queued_out(context);\n    323  \tif(rc) return rc;\n    324  \trc = db__message_write_inflight_out_all(context);\n    330  }\nFunction: connection_check_acl\nPath: /root/projects/mosquitto/src/handle_connect.c:86\n    86   static void connection_check_acl(struct mosquitto *context, struct mosquitto_client_msg **head)\n    97   \t\tif(mosquitto_acl_check(context, msg_tail->store->topic,\n    99   \t\t\t\t\t\t\t   msg_tail->store->qos, msg_tail->store->retain, access) != MOSQ_ERR_SUCCESS){\n    101  \t\t\tDL_DELETE((*head), msg_tail);\n    107  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    248  \tmosquitto__set_state(context, mosq_cs_disused);\n    250  \tif(context->id){\n    251  \t\tcontext__remove_from_by_id(context);\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    256  \tcontext->for_free_next = db.ll_for_free;\n    257  \tdb.ll_for_free = context;\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    296  \t\tcontext->in_by_id = true;\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__msg_add_to_inflight_stats\nPath: /root/projects/mosquitto/src/database.c:141\n    141  void db__msg_add_to_inflight_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    142  {\n    143  \tmsg_data->inflight_count++;\n    144  \tmsg_data->inflight_bytes += msg->store->payloadlen;\n    145  \tif(msg->qos != 0){\n    146  \t\tmsg_data->inflight_count12++;\n    147  \t\tmsg_data->inflight_bytes12 += msg->store->payloadlen;\n    148  \t}\n    149  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    271  \tmosquitto__free(store->source_id);\n    272  \tmosquitto__free(store->source_username);\n    283  }\nFunction: db__msg_remove_from_queued_stats\nPath: /root/projects/mosquitto/src/database.c:172\n    172  static void db__msg_remove_from_queued_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    173  {\n    174  \tmsg_data->queued_count--;\n    175  \tmsg_data->queued_bytes -= msg->store->payloadlen;\n    176  \tif(msg->qos != 0){\n    177  \t\tmsg_data->queued_count12--;\n    178  \t\tmsg_data->queued_bytes12 -= msg->store->payloadlen;\n    179  \t}\n    180  }\nFunction: db__message_remove_from_inflight\nPath: /root/projects/mosquitto/src/database.c:347\n    347  static void db__message_remove_from_inflight(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    348  {\n    349  \tif(!msg_data || !item){\n    350  \t\treturn;\n    351  \t}\n    353  \tDL_DELETE(msg_data->inflight, item);\n    354  \tif(item->store){\n    355  \t\tdb__msg_remove_from_inflight_stats(msg_data, item);\n    357  \t}\n    361  }\nFunction: db__message_write_inflight_out_latest\nPath: /root/projects/mosquitto/src/database.c:1198\n    1198 int db__message_write_inflight_out_latest(struct mosquitto *context)\n    1199 {\n    1200 \tstruct mosquitto_client_msg *tail, *next;\n    1203 \tif(context->state != mosq_cs_active\n    1204 \t\t\t|| context->sock == INVALID_SOCKET\n    1205 \t\t\t|| context->msgs_out.inflight == NULL){\n    1207 \t\treturn MOSQ_ERR_SUCCESS;\n    1208 \t}\n    1210 \tif(context->msgs_out.inflight->prev == context->msgs_out.inflight){\n    1212 \t\treturn db__message_write_inflight_out_single(context, context->msgs_out.inflight);\n    1213 \t}\n    1217 \ttail = context->msgs_out.inflight->prev;\n    1218 \twhile(tail != context->msgs_out.inflight &&\n    1219 \t\t\t(tail->state == mosq_ms_publish_qos0\n    1220 \t\t\t || tail->state == mosq_ms_publish_qos1\n    1221 \t\t\t || tail->state == mosq_ms_publish_qos2)){\n    1223 \t\ttail = tail->prev;\n    1224 \t}\n    1229 \tif(tail != context->msgs_out.inflight){\n    1230 \t\ttail = tail->next;\n    1231 \t}\n    1233 \twhile(tail){\n    1234 \t\tnext = tail->next;\n    1235 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1236 \t\tif(rc) return rc;\n    1238 \t}\n    1240 }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1097 \tuint32_t expiry_interval;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1103 \t\t\tif(msg->direction == mosq_md_out && msg->qos > 0){\n    1104 \t\t\t\tutil__increment_send_quota(context);\n    1105 \t\t\t}\n    1106 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1126 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1135 \t\t\t\tmsg->timestamp = db.now_s;\n    1136 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1137 \t\t\t\tmsg->state = mosq_ms_wait_for_puback;\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1139 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1148 \t\t\t\tmsg->timestamp = db.now_s;\n    1149 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1150 \t\t\t\tmsg->state = mosq_ms_wait_for_pubrec;\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1152 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1159 \t\t\trc = send__pubrel(context, mid, NULL);\n    1160 \t\t\tif(!rc){\n    1161 \t\t\t\tmsg->state = mosq_ms_wait_for_pubcomp;\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1176 \t}\n    1178 }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    449  \tstruct mosquitto_msg_data *msg_data;\n    450  \tenum mosquitto_msg_state state = mosq_ms_invalid;\n    452  \tint i;\n    457  \tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n    459  \tif(dir == mosq_md_out){\n    460  \t\tmsg_data = &context->msgs_out;\n    461  \t}else{\n    462  \t\tmsg_data = &context->msgs_in;\n    463  \t}\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    484  \tif(context->sock == INVALID_SOCKET){\n    486  \t\tif(qos == 0 && !db.config->queue_qos0_messages){\n    487  \t\t\tif(!context->bridge){\n    489  \t\t\t\treturn 2;\n    490  \t\t\t}else{\n    491  \t\t\t\tif(context->bridge->start_type != bst_lazy){\n    493  \t\t\t\t\treturn 2;\n    494  \t\t\t\t}\n    495  \t\t\t}\n    496  \t\t}\n    497  \t\tif(context->bridge && context->bridge->clean_start_local == true){\n    499  \t\t\treturn 2;\n    500  \t\t}\n    501  \t}\n    503  \tif(context->sock != INVALID_SOCKET){\n    504  \t\tif(db__ready_for_flight(context, dir, qos)){\n    517  \t\t\t}else{\n    520  \t\t\t\t}else{\n    522  \t\t\t\t\treturn 1;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n    528  \t\t}else{\n    530  \t\t\tif(context->is_dropping == false){\n    531  \t\t\t\tcontext->is_dropping = true;\n    532  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    534  \t\t\t\t\t\tcontext->id);\n    535  \t\t\t}\n    538  \t\t\treturn 2;\n    539  \t\t}\n    540  \t}else{\n    541  \t\tif (db__ready_for_queue(context, qos, msg_data)){\n    543  \t\t}else{\n    545  \t\t\tif(context->is_dropping == false){\n    546  \t\t\t\tcontext->is_dropping = true;\n    547  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    549  \t\t\t\t\t\tcontext->id);\n    550  \t\t\t}\n    552  \t\t\treturn 2;\n    553  \t\t}\n    554  \t}\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    582  \tif(state == mosq_ms_queued){\n    583  \t\tDL_APPEND(msg_data->queued, msg);\n    585  \t}else{\n    586  \t\tDL_APPEND(msg_data->inflight, msg);\n    588  \t}\n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    598  \t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n    599  \t\tif(dest_ids){\n    602  \t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t}\n    609  \t}\n    611  \tif(context->bridge && context->bridge->start_type == bst_lazy\n    612  \t\t\t&& context->sock == INVALID_SOCKET\n    613  \t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n    616  \t}\n    633  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    704  \tstruct mosquitto_msg_store *stored;\n    705  \tconst char *source_id;\n    706  \tenum mosquitto_msg_origin origin;\n    710  \tstored = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    711  \tif(stored == NULL) return MOSQ_ERR_NOMEM;\n    713  \tstored->topic = mosquitto__strdup(topic);\n    714  \tif(stored->topic == NULL){\n    715  \t\tdb__msg_store_free(stored);\n    716  \t\treturn MOSQ_ERR_INVAL;\n    717  \t}\n    719  \tstored->qos = qos;\n    720  \tif(db.config->retain_available == false){\n    721  \t\tstored->retain = 0;\n    722  \t}else{\n    723  \t\tstored->retain = retain;\n    724  \t}\n    726  \tstored->payloadlen = payloadlen;\n    727  \tif(payloadlen > 0){\n    728  \t\tstored->payload = mosquitto__malloc(stored->payloadlen+1);\n    729  \t\tif(stored->payload == NULL){\n    730  \t\t\tdb__msg_store_free(stored);\n    731  \t\t\treturn MOSQ_ERR_NOMEM;\n    732  \t\t}\n    734  \t\t((uint8_t *)stored->payload)[stored->payloadlen] = 0;\n    735  \t\tmemcpy(stored->payload, payload, stored->payloadlen);\n    736  \t}\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    746  \t}\n    748  \tif(context){\n    750  \t}else{\n    753  \tif(db__message_store(context, stored, message_expiry_interval, 0, origin)) return 1;\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    763  \tif(source && source->id){\n    764  \t\tstored->source_id = mosquitto__strdup(source->id);\n    765  \t}else{\n    766  \t\tstored->source_id = mosquitto__strdup(\"\");\n    767  \t}\n    768  \tif(!stored->source_id){\n    769  \t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n    770  \t\tdb__msg_store_free(stored);\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    774  \tif(source && source->username){\n    775  \t\tstored->source_username = mosquitto__strdup(source->username);\n    776  \t\tif(!stored->source_username){\n    777  \t\t\tdb__msg_store_free(stored);\n    778  \t\t\treturn MOSQ_ERR_NOMEM;\n    779  \t\t}\n    780  \t}\n    781  \tif(source){\n    782  \t\tstored->source_listener = source->listener;\n    783  \t}\n    806  }\nFunction: net__socket_close\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:205\n    205  int net__socket_close(struct mosquitto *mosq)\n    206  {\n    207  \tint rc = 0;\n    209  \tstruct mosquitto *mosq_found;\n    212  \tassert(mosq);\n    218  \t\tif(mosq->ssl){\n    219  \t\t\tif(!SSL_in_init(mosq->ssl)){\n    220  \t\t\t\tSSL_shutdown(mosq->ssl);\n    221  \t\t\t}\n    222  \t\t\tSSL_free(mosq->ssl);\n    223  \t\t\tmosq->ssl = NULL;\n    224  \t\t}\n    238  \t\tif(mosq->sock != INVALID_SOCKET){\n    240  \t\t\tHASH_FIND(hh_sock, db.contexts_by_sock, &mosq->sock, sizeof(mosq->sock), mosq_found);\n    241  \t\t\tif(mosq_found){\n    242  \t\t\t\tHASH_DELETE(hh_sock, db.contexts_by_sock, mosq_found);\n    243  \t\t\t}\n    245  \t\t\trc = COMPAT_CLOSE(mosq->sock);\n    246  \t\t\tmosq->sock = INVALID_SOCKET;\n    247  \t\t}\n    251  \tif(mosq->listener){\n    252  \t\tmosq->listener->client_count--;\n    253  \t\tmosq->listener = NULL;\n    254  \t}\n    257  \treturn rc;\n    258  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    448  \tX509 *client_cert = NULL;\n    460  \tif(!context->listener){\n    461  \t\treturn MOSQ_ERR_INVAL;\n    462  \t}\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    467  \t\trc = MOSQ_ERR_PROTOCOL;\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    502  \t\tcontext->protocol = mosq_p_mqtt31;\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    504  \t\t\tcontext->is_bridge = true;\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    508  \t\t\tcontext->protocol = mosq_p_mqtt311;\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    511  \t\t\t\tcontext->is_bridge = true;\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    514  \t\t\tcontext->protocol = mosq_p_mqtt5;\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    563  \t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid Will QoS in CONNECT from %s.\",\n    564  \t\t\t\tcontext->address);\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    724  \tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    731  \t\tif(!context->ssl){\n    732  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    741  \t\tif(context->listener->psk_hint){\n    743  \t\t\tif(!context->username){\n    744  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    754  \t\t\tclient_cert = SSL_get_peer_certificate(context->ssl);\n    755  \t\t\tif(!client_cert){\n    756  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    764  \t\t\tname = X509_get_subject_name(client_cert);\n    765  \t\t\tif(!name){\n    766  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    774  \t\t\tif (context->listener->use_identity_as_username) { /* use_identity_as_username */\n    775  \t\t\t\ti = X509_NAME_get_index_by_NID(name, NID_commonName, -1);\n    776  \t\t\t\tif(i == -1){\n    777  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    785  \t\t\t\tname_entry = X509_NAME_get_entry(name, i);\n    786  \t\t\t\tif(name_entry){\n    787  \t\t\t\t\tname_asn1 = X509_NAME_ENTRY_get_data(name_entry);\n    788  \t\t\t\t\tif (name_asn1 == NULL) {\n    789  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    801  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_get0_data(name_asn1);\n    803  \t\t\t\t\tif(mosquitto_validate_utf8(new_username, (int)strlen(new_username))){\n    804  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    809  \t\t\t\t\t\tX509_free(client_cert);\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    814  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    824  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    835  \t\t\t\tX509_NAME_print_ex(subject_bio, X509_get_subject_name(client_cert), 0, XN_FLAG_RFC2253);\n    847  \t\t\t\tcontext->username = subject;\n    849  \t\t\tif(!context->username){\n    853  \t\t\tX509_free(client_cert);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    898  \t\t\tmosquitto__set_state(context, mosq_cs_authenticating);\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    905  \t\t\twill__clear(context);\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    925  \t\tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    973  \tif(client_cert) X509_free(client_cert);\n    976  \tcontext->clean_start = true;\n    977  \tcontext->session_expiry_interval = 0;\n    978  \tcontext->will_delay_interval = 0;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    55   \tint i;\n    56   \tint pos;\n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    350  \t\tif(rc) goto error_cleanup;\n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    356  \trc = packet__read_string(&context->in_packet, &will_struct->msg.topic, &tlen);\n    358  \tif(!tlen){\n    359  \t\trc = MOSQ_ERR_PROTOCOL;\n    360  \t\tgoto error_cleanup;\n    361  \t}\n    363  \tif(context->listener->mount_point){\n    364  \t\tslen = strlen(context->listener->mount_point) + strlen(will_struct->msg.topic) + 1;\n    366  \t\tif(!will_topic_mount){\n    368  \t\t\tgoto error_cleanup;\n    369  \t\t}\n    371  \t\tsnprintf(will_topic_mount, slen, \"%s%s\", context->listener->mount_point, will_struct->msg.topic);\n    374  \t\tmosquitto__free(will_struct->msg.topic);\n    375  \t\twill_struct->msg.topic = will_topic_mount;\n    376  \t}\n    378  \tif(!strncmp(will_struct->msg.topic, \"$CONTROL/\", strlen(\"$CONTROL/\"))){\n    380  \t\tgoto error_cleanup;\n    381  \t}\n    382  \trc = mosquitto_pub_topic_check(will_struct->msg.topic);\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    394  \t\t\t}else{\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    400  \t\twill_struct->msg.payload = mosquitto__malloc((size_t)will_struct->msg.payloadlen);\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    406  \t\trc = packet__read_bytes(&context->in_packet, will_struct->msg.payload, (uint32_t)will_struct->msg.payloadlen);\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    413  \t*will = will_struct;\n    416  error_cleanup:\n    417  \tif(will_struct){\n    418  \t\tmosquitto__free(will_struct->msg.topic);\n    419  \t\tmosquitto__free(will_struct->msg.payload);\n    422  \t}\n    424  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    106  \t\t*length = 0;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    157  \tassert(packet);\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    167  \treturn MOSQ_ERR_SUCCESS;\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: mosquitto_property_add_string\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:845\n    845  int mosquitto_property_add_string(mosquitto_property **proplist, int identifier, const char *value)\n    846  {\n    848  \tsize_t slen = 0;\n    851  \tif(value){\n    852  \t\tslen = strlen(value);\n    853  \t\tif(mosquitto_validate_utf8(value, (int)slen)) return MOSQ_ERR_MALFORMED_UTF8;\n    854  \t}\n    856  \tif(identifier != MQTT_PROP_CONTENT_TYPE\n    857  \t\t\t&& identifier != MQTT_PROP_RESPONSE_TOPIC\n    858  \t\t\t&& identifier != MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER\n    859  \t\t\t&& identifier != MQTT_PROP_AUTHENTICATION_METHOD\n    860  \t\t\t&& identifier != MQTT_PROP_RESPONSE_INFORMATION\n    861  \t\t\t&& identifier != MQTT_PROP_SERVER_REFERENCE\n    862  \t\t\t&& identifier != MQTT_PROP_REASON_STRING){\n    863  \n    864  \t\treturn MOSQ_ERR_INVAL;\n    867  \tprop = mosquitto__calloc(1, sizeof(mosquitto_property));\n    872  \tif(value && slen > 0){\n    873  \t\tprop->value.s.v = mosquitto__strdup(value);\n    874  \t\tif(!prop->value.s.v){\n    876  \t\t\treturn MOSQ_ERR_NOMEM;\n    877  \t\t}\n    878  \t\tprop->value.s.len = (uint16_t)slen;\n    879  \t}\n    883  }\nFunction: property__get_property\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:988\n    988  static const mosquitto_property *property__get_property(const mosquitto_property *proplist, int identifier, bool skip_first)\n    989  {\n    990  \tconst mosquitto_property *p;\n    995  \twhile(p){\n    996  \t\tif(p->identifier == identifier){\n    997  \t\t\tif(!is_first || !skip_first){\n    998  \t\t\t\treturn p;\n    999  \t\t\t}\n    1001 \t\t}\n    1002 \t\tp = p->next;\n    1003 \t}\n    1005 }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    371  \t\tmux__delete(context);\n    372  \t\tcontext__disconnect(context);\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto__malloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:83\n    83   void *mosquitto__malloc(size_t size)\n    84   {\n    88   \tif(mem_limit && memcount + size > mem_limit){\n    89   \t\treturn NULL;\n    90   \t}\n    93   \tmem = malloc(size);\n    96   \tif(mem){\n    97   \t\tmemcount += malloc_usable_size(mem);\n    101  \t}\n    105  }\nFunction: mosquitto__strdup\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:144\n    144  char *mosquitto__strdup(const char *s)\n    145  {\n    148  \tif(mem_limit && memcount + strlen(s) > mem_limit){\n    149  \t\treturn NULL;\n    150  \t}\n    152  \tstr = strdup(s);\n    155  \tif(str){\n    156  \t\tmemcount += malloc_usable_size(str);\n    160  \t}\n    164  }\nFunction: mosquitto_free\nPath: /root/projects/mosquitto/src/memory_public.c:27\n    27   void mosquitto_free(void *mem)\n    29   \tmosquitto__free(mem);\n    30   }\nFunction: mosquitto_malloc\nPath: /root/projects/mosquitto/src/memory_public.c:32\n    32   void *mosquitto_malloc(size_t size)\n    34   \treturn mosquitto__malloc(size);\n    35   }\nFunction: mux__delete\nPath: /root/projects/mosquitto/src/mux.c:61\n    61   int mux__delete(struct mosquitto *context)\n    64   \treturn mux_epoll__delete(context);\n    68   }\nFunction: mux_epoll__delete\nPath: /root/projects/mosquitto/src/mux_epoll.c:163\n    163  int mux_epoll__delete(struct mosquitto *context)\n    164  {\n    165  \tstruct epoll_event ev;\n    168  \tif(context->sock != INVALID_SOCKET){\n    169  \t\tif(epoll_ctl(db.epollfd, EPOLL_CTL_DEL, context->sock, &ev) == -1){\n    170  \t\t\treturn 1;\n    171  \t\t}\n    172  \t}\n    174  }\nFunction: send__auth\nPath: /root/projects/mosquitto/src/send_auth.c:28\n    28   int send__auth(struct mosquitto *context, uint8_t reason_code, const void *auth_data, uint16_t auth_data_len)\n    29   {\n    32   \tmosquitto_property *properties = NULL;\n    35   \tif(context->auth_method == NULL) return MOSQ_ERR_INVAL;\n    36   \tif(context->protocol != mosq_p_mqtt5) return MOSQ_ERR_PROTOCOL;\n    38   \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending AUTH to %s (rc%d, %s)\", context->id, reason_code, context->auth_method);\n    42   \trc = mosquitto_property_add_string(&properties, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method);\n    43   \tif(rc){\n    45   \t\treturn rc;\n    46   \t}\n    56   \tremaining_length += property__get_remaining_length(properties);\n    58   \tif(packet__check_oversize(context, remaining_length)){\n    61   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    62   \t}\n    67   \tpacket->command = CMD_AUTH;\n    68   \tpacket->remaining_length = remaining_length;\n    70   \trc = packet__alloc(packet);\n    76   \tpacket__write_byte(packet, reason_code);\n    77   \tproperty__write_all(packet, properties, true);\n    80   \treturn packet__queue(context, packet);\n    81   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    32   \tmosquitto_property *connack_props = NULL;\n    33   \tuint32_t remaining_length;\n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    43   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->address, ack, reason_code);\n    44   \t}\n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    51   \t\t\tif(rc){\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    58   \t\t\tif(rc){\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    65   \t\t\tif(rc){\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    71   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_MAXIMUM_QOS, context->listener->max_qos);\n    72   \t\t\tif(rc){\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    78   \t\tremaining_length += property__get_remaining_length(connack_props);\n    79   \t}\n    81   \tif(packet__check_oversize(context, remaining_length)){\n    83   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    84   \t}\n    92   \tpacket->command = CMD_CONNACK;\n    93   \tpacket->remaining_length = remaining_length;\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    105  \t}\n    108  \treturn packet__queue(context, packet);\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    42   \tassert(mosq);\n    45   \tif(mosq->bridge){\n    46   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Bridge %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    47   \t}else\n    56   \tassert(mosq);\n    60   \tpacket->command = CMD_DISCONNECT;\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    62   \t\tpacket->remaining_length = 1;\n    63   \t\tif(properties){\n    64   \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    65   \t\t}\n    66   \t}else{\n    67   \t\tpacket->remaining_length = 0;\n    68   \t}\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    80   \t}\n    82   \treturn packet__queue(mosq, packet);\n    83   }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    126  \tassert(mosq);\n    130  \tpacket->command = command;\n    131  \tif(dup){\n    132  \t\tpacket->command |= 8;\n    133  \t}\n    134  \tpacket->remaining_length = 2;\n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    137  \t\tif(reason_code != 0 || properties){\n    138  \t\t\tpacket->remaining_length += 1;\n    139  \t\t}\n    141  \t\tif(properties){\n    142  \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    143  \t\t}\n    144  \t}\n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    161  \t}\n    163  \treturn packet__queue(mosq, packet);\n    164  }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    117  \treturn send__command_with_mid(mosq, CMD_PUBREL|2, mid, false, 0, properties);\n    118  }\nFunction: send__publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:42\n    42   int send__publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    43   {\n    47   \tint i;\n    49   \tbool match;\n    51   \tchar *mapped_topic = NULL;\n    55   \tassert(mosq);\n    60   \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    63   \tif(!mosq->retain_available){\n    65   \t}\n    68   \tif(mosq->listener && mosq->listener->mount_point){\n    69   \t\tlen = strlen(mosq->listener->mount_point);\n    70   \t\tif(len < strlen(topic)){\n    71   \t\t\ttopic += len;\n    72   \t\t}else{\n    74   \t\t\treturn MOSQ_ERR_SUCCESS;\n    75   \t\t}\n    76   \t}\n    78   \tif(mosq->bridge && mosq->bridge->topics && mosq->bridge->topic_remapping){\n    79   \t\tfor(i=0; i<mosq->bridge->topic_count; i++){\n    80   \t\t\tcur_topic = &mosq->bridge->topics[i];\n    81   \t\t\tif((cur_topic->direction == bd_both || cur_topic->direction == bd_out)\n    82   \t\t\t\t\t&& (cur_topic->remote_prefix || cur_topic->local_prefix)){\n    85   \t\t\t\trc = mosquitto_topic_matches_sub(cur_topic->local_topic, topic, &match);\n    86   \t\t\t\tif(rc){\n    87   \t\t\t\t\treturn rc;\n    88   \t\t\t\t}\n    89   \t\t\t\tif(match){\n    90   \t\t\t\t\tmapped_topic = mosquitto__strdup(topic);\n    91   \t\t\t\t\tif(!mapped_topic) return MOSQ_ERR_NOMEM;\n    92   \t\t\t\t\tif(cur_topic->local_prefix){\n    94   \t\t\t\t\t\tif(!strncmp(cur_topic->local_prefix, mapped_topic, strlen(cur_topic->local_prefix))){\n    95   \t\t\t\t\t\t\ttopic_temp = mosquitto__strdup(mapped_topic+strlen(cur_topic->local_prefix));\n    96   \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    97   \t\t\t\t\t\t\tif(!topic_temp){\n    98   \t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    99   \t\t\t\t\t\t\t}\n    101  \t\t\t\t\t\t}\n    102  \t\t\t\t\t}\n    104  \t\t\t\t\tif(cur_topic->remote_prefix){\n    106  \t\t\t\t\t\tlen = strlen(mapped_topic) + strlen(cur_topic->remote_prefix)+1;\n    107  \t\t\t\t\t\ttopic_temp = mosquitto__malloc(len+1);\n    108  \t\t\t\t\t\tif(!topic_temp){\n    109  \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    110  \t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    111  \t\t\t\t\t\t}\n    112  \t\t\t\t\t\tsnprintf(topic_temp, len, \"%s%s\", cur_topic->remote_prefix, mapped_topic);\n    113  \t\t\t\t\t\ttopic_temp[len] = '\\0';\n    114  \t\t\t\t\t\tmosquitto__free(mapped_topic);\n    116  \t\t\t\t\t}\n    117  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, mapped_topic, (long)payloadlen);\n    119  \t\t\t\t\trc =  send__real_publish(mosq, mid, mapped_topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    120  \t\t\t\t\tmosquitto__free(mapped_topic);\n    121  \t\t\t\t\treturn rc;\n    122  \t\t\t\t}\n    123  \t\t\t}\n    124  \t\t}\n    125  \t}\n    127  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, topic, (long)payloadlen);\n    133  \treturn send__real_publish(mosq, mid, topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    134  }\nFunction: send__real_publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:137\n    137  int send__real_publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    138  {\n    140  \tunsigned int packetlen;\n    141  \tunsigned int proplen = 0, varbytes;\n    143  \tmosquitto_property expiry_prop;\n    145  \tassert(mosq);\n    147  \tif(topic){\n    148  \t\tpacketlen = 2+(unsigned int)strlen(topic) + payloadlen;\n    149  \t}else{\n    150  \t\tpacketlen = 2 + payloadlen;\n    151  \t}\n    152  \tif(qos > 0) packetlen += 2; /* For message id */\n    153  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tproplen += property__get_length_all(cmsg_props);\n    156  \t\tproplen += property__get_length_all(store_props);\n    157  \t\tif(expiry_interval > 0){\n    163  \t\t\tproplen += property__get_length_all(&expiry_prop);\n    164  \t\t}\n    166  \t\tvarbytes = packet__varint_bytes(proplen);\n    172  \t\t}else{\n    173  \t\t\tpacketlen += proplen + varbytes;\n    174  \t\t}\n    175  \t}\n    176  \tif(packet__check_oversize(mosq, packetlen)){\n    178  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Dropping too large outgoing PUBLISH for %s (%d bytes)\", SAFE_PRINT(mosq->id), packetlen);\n    182  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    183  \t}\n    189  \tpacket->command = (uint8_t)(CMD_PUBLISH | (uint8_t)((dup&0x1)<<3) | (uint8_t)(qos<<1) | retain);\n    190  \tpacket->remaining_length = packetlen;\n    206  \tif(mosq->protocol == mosq_p_mqtt5){\n    213  \t}\n    220  \treturn packet__queue(mosq, packet);\n    221  }\nFunction: set_session_expiry_time\nPath: /root/projects/mosquitto/src/session_expiry.c:46\n    46   static void set_session_expiry_time(struct mosquitto *context)\n    47   {\n    50   \tif(db.config->persistent_client_expiration == 0){\n    52   \t\tcontext->session_expiry_time += context->session_expiry_interval;\n    53   \t}else{\n    55   \t\tif(db.config->persistent_client_expiration < context->session_expiry_interval){\n    58   \t\t}else{\n    60   \t\t\tcontext->session_expiry_time += context->session_expiry_interval;\n    61   \t\t}\n    62   \t}\n    63   }\nFunction: session_expiry__remove\nPath: /root/projects/mosquitto/src/session_expiry.c:121\n    121  void session_expiry__remove(struct mosquitto *context)\n    122  {\n    123  \tif(context->expiry_list_item){\n    124  \t\tDL_DELETE(expiry_list, context->expiry_list_item);\n    125  \t\tmosquitto__free(context->expiry_list_item);\n    126  \t\tcontext->expiry_list_item = NULL;\n    127  \t}\n    128  }\nFunction: mosquitto_acl_check\nPath: /root/projects/mosquitto/src/security.c:679\n    679  int mosquitto_acl_check(struct mosquitto *context, const char *topic, uint32_t payloadlen, void* payload, uint8_t qos, bool retain, int access)\n    680  {\n    681  \tint rc;\n    682  \tint i;\n    683  \tstruct mosquitto__security_options *opts;\n    684  \tstruct mosquitto_acl_msg msg;\n    685  \tstruct mosquitto__callback *cb_base;\n    686  \tstruct mosquitto_evt_acl_check event_data;\n    688  \tif(!context->id){\n    689  \t\treturn MOSQ_ERR_ACL_DENIED;\n    690  \t}\n    691  \tif(context->bridge){\n    692  \t\treturn MOSQ_ERR_SUCCESS;\n    693  \t}\n    703  \tif(db.config->per_listener_settings){\n    704  \t\tif(context->listener){\n    705  \t\t\topts = &context->listener->security_options;\n    706  \t\t}else{\n    707  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    708  \t\t}\n    709  \t}else{\n    710  \t\topts = &db.config->security_options;\n    711  \t}\n    720  \tDL_FOREACH(opts->plugin_callbacks.acl_check, cb_base){\n    724  \t\tevent_data.client = context;\n    732  \t\trc = cb_base->cb(MOSQ_EVT_ACL_CHECK, &event_data, cb_base->userdata);\n    733  \t\tif(rc != MOSQ_ERR_PLUGIN_DEFER){\n    738  \tfor(i=0; i<opts->auth_plugin_config_count; i++){\n    739  \t\tif(opts->auth_plugin_configs[i].plugin.version < 5){\n    740  \t\t\trc = acl__check_single(&opts->auth_plugin_configs[i], context, &msg, access);\n    741  \t\t\tif(rc != MOSQ_ERR_PLUGIN_DEFER){\n    742  \t\t\t\treturn rc;\n    743  \t\t\t}\n    744  \t\t}\n    745  \t}\n    749  \tif(rc == MOSQ_ERR_PLUGIN_DEFER){\n    751  \t}\n    753  }\nFunction: sub__remove_shared_leaf\nPath: /root/projects/mosquitto/src/subs.c:190\n    190  static void sub__remove_shared_leaf(struct mosquitto__subhier *subhier, struct mosquitto__subshared *shared, struct mosquitto__subleaf *leaf)\n    191  {\n    192  \tDL_DELETE(shared->subs, leaf);\n    193  \tif(shared->subs == NULL){\n    194  \t\tHASH_DELETE(hh, subhier->shared, shared);\n    195  \t\tmosquitto__free(shared->name);\n    196  \t\tmosquitto__free(shared);\n    197  \t}\n    199  }\nFunction: sub__messages_queue\nPath: /root/projects/mosquitto/src/subs.c:659\n    659  int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n    660  {\n    661  \tint rc = MOSQ_ERR_SUCCESS, rc2;\n    662  \tint rc_normal = MOSQ_ERR_NO_SUBSCRIBERS, rc_shared = MOSQ_ERR_NO_SUBSCRIBERS;\n    663  \tstruct mosquitto__subhier *subhier;\n    664  \tchar **split_topics = NULL;\n    677  \tHASH_FIND(hh, db.normal_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    678  \tif(subhier){\n    679  \t\trc_normal = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    680  \t\tif(rc_normal > 0){\n    682  \t\t\tgoto end;\n    683  \t\t}\n    684  \t}\n    686  \tHASH_FIND(hh, db.shared_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    687  \tif(subhier){\n    688  \t\trc_shared = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    689  \t\tif(rc_shared > 0){\n    691  \t\t\tgoto end;\n    692  \t\t}\n    693  \t}\n    695  \tif(rc_normal == MOSQ_ERR_NO_SUBSCRIBERS && rc_shared == MOSQ_ERR_NO_SUBSCRIBERS){\n    697  \t}\n    711  }\nFunction: sub__search\nPath: /root/projects/mosquitto/src/subs.c:479\n    479  static int sub__search(struct mosquitto__subhier *subhier, char **split_topics, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    480  {\n    482  \tstruct mosquitto__subhier *branch;\n    486  \tif(split_topics && split_topics[0]){\n    488  \t\tHASH_FIND(hh, subhier->children, split_topics[0], strlen(split_topics[0]), branch);\n    490  \t\tif(branch){\n    491  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    492  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    494  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    495  \t\t\t\treturn rc;\n    496  \t\t\t}\n    497  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    498  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    499  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    501  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    502  \t\t\t\t\treturn rc;\n    503  \t\t\t\t}\n    504  \t\t\t}\n    505  \t\t}\n    508  \t\tHASH_FIND(hh, subhier->children, \"+\", 1, branch);\n    510  \t\tif(branch){\n    511  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    512  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    514  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    515  \t\t\t\treturn rc;\n    516  \t\t\t}\n    517  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    518  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    519  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    521  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    522  \t\t\t\t\treturn rc;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}\n    526  \t}\n    529  \tHASH_FIND(hh, subhier->children, \"#\", 1, branch);\n    530  \tif(branch && !branch->children){\n    531  \t\t/* The topic matches due to a # wildcard - process the\n    532  \t\t * subscriptions but *don't* return. Although this branch has ended\n    533  \t\t * there may still be other subscriptions to deal with.\n    534  \t\t */\n    535  \t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    536  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    537  \t\t\thave_subscribers = true;\n    538  \t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    539  \t\t\treturn rc;\n    540  \t\t}\n    541  \t}\n    548  }\nFunction: subs__process\nPath: /root/projects/mosquitto/src/subs.c:129\n    129  static int subs__process(struct mosquitto__subhier *hier, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    130  {\n    133  \tstruct mosquitto__subleaf *leaf;\n    135  \trc = subs__shared_process(hier, topic, qos, retain, stored);\n    137  \tleaf = hier->subs;\n    138  \twhile(source_id && leaf){\n    139  \t\tif(!leaf->context->id || (leaf->no_local && !strcmp(leaf->context->id, source_id))){\n    140  \t\t\tleaf = leaf->next;\n    142  \t\t}\n    147  \t\tleaf = leaf->next;\n    148  \t}\n    149  \tif(hier->subs || hier->shared){\n    150  \t\treturn rc;\n    151  \t}else{\n    152  \t\treturn MOSQ_ERR_NO_SUBSCRIBERS;\n    153  \t}\n    154  }\nFunction: subs__send\nPath: /root/projects/mosquitto/src/subs.c:63\n    63   static int subs__send(struct mosquitto__subleaf *leaf, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    64   {\n    65   \tbool client_retain;\n    66   \tuint16_t mid;\n    67   \tuint8_t client_qos, msg_qos;\n    68   \tmosquitto_property *properties = NULL;\n    72   \trc2 = mosquitto_acl_check(leaf->context, topic, stored->payloadlen, stored->payload, stored->qos, stored->retain, MOSQ_ACL_READ);\n    73   \tif(rc2 == MOSQ_ERR_ACL_DENIED){\n    74   \t\treturn MOSQ_ERR_SUCCESS;\n    75   \t}else if(rc2 == MOSQ_ERR_SUCCESS){\n    76   \t\tclient_qos = leaf->qos;\n    87   \t\tif(msg_qos){\n    88   \t\t\tmid = mosquitto__mid_generate(leaf->context);\n    89   \t\t}else{\n    92   \t\tif(leaf->retain_as_published){\n    93   \t\t\tclient_retain = retain;\n    94   \t\t}else{\n    97   \t\tif(leaf->identifier){\n    98   \t\t\tmosquitto_property_add_varint(&properties, MQTT_PROP_SUBSCRIPTION_IDENTIFIER, leaf->identifier);\n    99   \t\t}\n    100  \t\tif(db__message_insert(leaf->context, mid, mosq_md_out, msg_qos, client_retain, stored, properties, true) == 1){\n    101  \t\t\treturn 1;\n    102  \t\t}\n    103  \t}else{\n    104  \t\treturn 1; /* Application error */\n    105  \t}\n    107  }\nFunction: sub__clean_session\nPath: /root/projects/mosquitto/src/subs.c:746\n    746  int sub__clean_session(struct mosquitto *context)\n    747  {\n    748  \tint i;\n    749  \tstruct mosquitto__subleaf *leaf;\n    750  \tstruct mosquitto__subhier *hier;\n    752  \tfor(i=0; i<context->sub_count; i++){\n    753  \t\tif(context->subs[i] == NULL){\n    755  \t\t}\n    757  \t\thier = context->subs[i]->hier;\n    759  \t\tif(context->subs[i]->shared){\n    760  \t\t\tleaf = context->subs[i]->shared->subs;\n    761  \t\t\twhile(leaf){\n    762  \t\t\t\tif(leaf->context==context){\n    766  \t\t\t\t\tsub__remove_shared_leaf(context->subs[i]->hier, context->subs[i]->shared, leaf);\n    768  \t\t\t\t}\n    769  \t\t\t\tleaf = leaf->next;\n    770  \t\t\t}\n    771  \t\t}else{\n    772  \t\t\tleaf = hier->subs;\n    773  \t\t\twhile(leaf){\n    774  \t\t\t\tif(leaf->context==context){\n    778  \t\t\t\t\tDL_DELETE(hier->subs, leaf);\n    779  \t\t\t\t\tmosquitto__free(leaf);\n    781  \t\t\t\t}\n    782  \t\t\t\tleaf = leaf->next;\n    783  \t\t\t}\n    784  \t\t}\n    785  \t\tmosquitto__free(context->subs[i]);\n    786  \t\tcontext->subs[i] = NULL;\n    788  \t\tif(hier->subs == NULL\n    789  \t\t\t\t&& hier->children == NULL\n    790  \t\t\t\t&& hier->shared == NULL\n    791  \t\t\t\t&& hier->parent){\n    794  \t\t\t\thier = tmp_remove_subs(hier);\n    795  \t\t\t}while(hier);\n    796  \t\t}\n    797  \t}\n    798  \tmosquitto__free(context->subs);\n    799  \tcontext->subs = NULL;\n    800  \tcontext->sub_count = 0;\n    803  }\nFunction: tmp_remove_subs\nPath: /root/projects/mosquitto/src/subs.c:715\n    715  static struct mosquitto__subhier *tmp_remove_subs(struct mosquitto__subhier *sub)\n    716  {\n    719  \tif(!sub || !sub->parent){\n    720  \t\treturn NULL;\n    721  \t}\n    723  \tif(sub->children || sub->subs){\n    724  \t\treturn NULL;\n    725  \t}\n    727  \tparent = sub->parent;\n    728  \tHASH_DELETE(hh, parent->children, sub);\n    729  \tmosquitto__free(sub->topic);\n    730  \tmosquitto__free(sub);\n    732  \tif(parent->subs == NULL\n    733  \t\t\t&& parent->children == NULL\n    734  \t\t\t&& parent->shared == NULL\n    735  \t\t\t&& parent->parent){\n    737  \t\treturn parent;\n    738  \t}else{\n    739  \t\treturn NULL;\n    740  \t}\n    741  }\nFunction: mosquitto_validate_utf8\nPath: /root/projects/mosquitto/src/../lib/utf8_mosq.c:24\n    24   int mosquitto_validate_utf8(const char *str, int len)\n    25   {\n    26   \tint i;\n    27   \tint j;\n    28   \tint codelen;\n    29   \tint codepoint;\n    32   \tif(!str) return MOSQ_ERR_INVAL;\n    33   \tif(len < 0 || len > 65536) return MOSQ_ERR_INVAL;\n    35   \tfor(i=0; i<len; i++){\n    36   \t\tif(ustr[i] == 0){\n    37   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    38   \t\t}else if(ustr[i] <= 0x7f){\n    40   \t\t\tcodepoint = ustr[i];\n    41   \t\t}else if((ustr[i] & 0xE0) == 0xC0){\n    43   \t\t\tif(ustr[i] == 0xC0 || ustr[i] == 0xC1){\n    45   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    46   \t\t\t}\n    48   \t\t\tcodepoint = (ustr[i] & 0x1F);\n    49   \t\t}else if((ustr[i] & 0xF0) == 0xE0){\n    52   \t\t\tcodepoint = (ustr[i] & 0x0F);\n    53   \t\t}else if((ustr[i] & 0xF8) == 0xF0){\n    55   \t\t\tif(ustr[i] > 0xF4){\n    57   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    58   \t\t\t}\n    60   \t\t\tcodepoint = (ustr[i] & 0x07);\n    61   \t\t}else{\n    63   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    64   \t\t}\n    67   \t\tif(i == len-codelen+1){\n    69   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    70   \t\t}\n    71   \t\tfor(j=0; j<codelen-1; j++){\n    72   \t\t\tif((ustr[++i] & 0xC0) != 0x80){\n    74   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    75   \t\t\t}\n    76   \t\t\tcodepoint = (codepoint<<6) | (ustr[i] & 0x3F);\n    77   \t\t}\n    80   \t\tif(codepoint >= 0xD800 && codepoint <= 0xDFFF){\n    81   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    82   \t\t}\n    88   \t\t *\t return MOSQ_ERR_MALFORMED_UTF8;\n    91   \t\tif(codelen == 3 && codepoint < 0x0800){\n    92   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    93   \t\t}else if(codelen == 4 && (codepoint < 0x10000 || codepoint > 0x10FFFF)){\n    94   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    95   \t\t}\n    98   \t\tif(codepoint >= 0xFDD0 && codepoint <= 0xFDEF){\n    99   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    100  \t\t}\n    101  \t\tif((codepoint & 0xFFFF) == 0xFFFE || (codepoint & 0xFFFF) == 0xFFFF){\n    102  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    103  \t\t}\n    105  \t\tif(codepoint <= 0x001F || (codepoint >= 0x007F && codepoint <= 0x009F)){\n    106  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    107  \t\t}\n    108  \t}\n    110  }\nFunction: util__increment_receive_quota\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:215\n    215  void util__increment_receive_quota(struct mosquitto *mosq)\n    216  {\n    217  \tif(mosq->msgs_in.inflight_quota < mosq->msgs_in.inflight_maximum){\n    218  \t\tmosq->msgs_in.inflight_quota++;\n    219  \t}\n    220  }\nFunction: mosquitto_pub_topic_check\nPath: /root/projects/mosquitto/src/../lib/util_topic.c:50\n    50   int mosquitto_pub_topic_check(const char *str)\n    51   {\n    57   \tif(str == NULL){\n    58   \t\treturn MOSQ_ERR_INVAL;\n    59   \t}\n    61   \twhile(str && str[0]){\n    62   \t\tif(str[0] == '+' || str[0] == '#'){\n    63   \t\t\treturn MOSQ_ERR_INVAL;\n    64   \t\t}\n    66   \t\telse if(str[0] == '/'){\n    68   \t\t}\n    71   \t\tstr = &str[1];\n    72   \t}\n    73   \tif(len > 65535) return MOSQ_ERR_INVAL;\n    75   \tif(hier_count > TOPIC_HIERARCHY_LIMIT) return MOSQ_ERR_INVAL;\n    79   }\nFunction: will_delay__cmp\nPath: /root/projects/mosquitto/src/will_delay.c:33\n    33   static int will_delay__cmp(struct will_delay_list *i1, struct will_delay_list *i2)\n    35   \treturn (int)(i1->context->will_delay_interval - i2->context->will_delay_interval);\n    36   }\nFunction: will_delay__remove\nPath: /root/projects/mosquitto/src/will_delay.c:99\n    99   void will_delay__remove(struct mosquitto *mosq)\n    100  {\n    101  \tif(mosq->will_delay_entry != NULL){\n    102  \t\tDL_DELETE(delay_list, mosq->will_delay_entry);\n    103  \t\tmosquitto__free(mosq->will_delay_entry);\n    104  \t\tmosq->will_delay_entry = NULL;\n    105  \t}\n    106  }\nFunction: will__clear\nPath: /root/projects/mosquitto/src/../lib/will_mosq.c:111\n    111  int will__clear(struct mosquitto *mosq)\n    112  {\n    113  \tif(!mosq->will) return MOSQ_ERR_SUCCESS;\n    115  \tmosquitto__free(mosq->will->msg.topic);\n    116  \tmosq->will->msg.topic = NULL;\n    118  \tmosquitto__free(mosq->will->msg.payload);\n    119  \tmosq->will->msg.payload = NULL;\n    121  \tmosquitto_property_free_all(&mosq->will->properties);\n    123  \tmosquitto__free(mosq->will);\n    124  \tmosq->will = NULL;\n    125  \tmosq->will_delay_interval = 0;\n    128  }\n",
    "If the Server rejects the ClientID it MAY respond to the CONNECT packet with a CONNACK using Reason Code 0x85 (Client Identifier not valid) as described in section 4.13 Handling errors, and then it MUST close the Network Connection [MQTT-3.1.3-8].": "Function: context__remove_from_by_id\nPath: /root/projects/mosquitto/src/context.c:302\n    302  void context__remove_from_by_id(struct mosquitto *context)\n    303  {\n    304  \tstruct mosquitto *context_found;\n    306  \tif(context->in_by_id == true && context->id){\n    307  \t\tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), context_found);\n    308  \t\tif(context_found){\n    309  \t\t\tHASH_DELETE(hh_id, db.contexts_by_id, context_found);\n    310  \t\t}\n    312  \t}\n    313  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    208  }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    250  \t}\n    263  \tif(!context->clean_start){\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    320  \tif(rc) return rc;\n    330  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    250  \tif(context->id){\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    258  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    705  \tconst char *source_id;\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    557  \t}else{\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    613  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    630  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    976  \tcontext->clean_start = true;\n    980  }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    391  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Client %s connected with too large Will payload\", client_id);\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    393  \t\t\t\tsend__connack(context, 0, MQTT_RC_PACKET_TOO_LARGE, NULL);\n    394  \t\t\t}else{\n    395  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    396  \t\t\t}\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    424  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    54   \t*byte = packet->payload[packet->pos];\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    374  }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    43   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->address, ack, reason_code);\n    44   \t}\n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    51   \t\t\tif(rc){\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    58   \t\t\tif(rc){\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    65   \t\t\tif(rc){\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    72   \t\t\tif(rc){\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    79   \t}\n    102  \tpacket__write_byte(packet, reason_code);\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    45   \tif(mosq->bridge){\n    46   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Bridge %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    47   \t}else\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    66   \t}else{\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    76   \t\tpacket__write_byte(packet, reason_code);\n    80   \t}\n    83   }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    118  }\nFunction: send__real_publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:137\n    137  int send__real_publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    138  {\n    140  \tunsigned int packetlen;\n    141  \tunsigned int proplen = 0, varbytes;\n    143  \tmosquitto_property expiry_prop;\n    147  \tif(topic){\n    148  \t\tpacketlen = 2+(unsigned int)strlen(topic) + payloadlen;\n    149  \t}else{\n    150  \t\tpacketlen = 2 + payloadlen;\n    151  \t}\n    152  \tif(qos > 0) packetlen += 2; /* For message id */\n    153  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tproplen += property__get_length_all(cmsg_props);\n    156  \t\tproplen += property__get_length_all(store_props);\n    157  \t\tif(expiry_interval > 0){\n    163  \t\t\tproplen += property__get_length_all(&expiry_prop);\n    164  \t\t}\n    166  \t\tvarbytes = packet__varint_bytes(proplen);\n    172  \t\t}else{\n    173  \t\t\tpacketlen += proplen + varbytes;\n    174  \t\t}\n    175  \t}\n    176  \tif(packet__check_oversize(mosq, packetlen)){\n    178  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Dropping too large outgoing PUBLISH for %s (%d bytes)\", SAFE_PRINT(mosq->id), packetlen);\n    182  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    183  \t}\n    221  }\nFunction: mosquitto_validate_utf8\nPath: /root/projects/mosquitto/src/../lib/utf8_mosq.c:24\n    24   int mosquitto_validate_utf8(const char *str, int len)\n    25   {\n    26   \tint i;\n    27   \tint j;\n    28   \tint codelen;\n    29   \tint codepoint;\n    32   \tif(!str) return MOSQ_ERR_INVAL;\n    35   \tfor(i=0; i<len; i++){\n    36   \t\tif(ustr[i] == 0){\n    37   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    38   \t\t}else if(ustr[i] <= 0x7f){\n    40   \t\t\tcodepoint = ustr[i];\n    41   \t\t}else if((ustr[i] & 0xE0) == 0xC0){\n    43   \t\t\tif(ustr[i] == 0xC0 || ustr[i] == 0xC1){\n    45   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    46   \t\t\t}\n    48   \t\t\tcodepoint = (ustr[i] & 0x1F);\n    49   \t\t}else if((ustr[i] & 0xF0) == 0xE0){\n    52   \t\t\tcodepoint = (ustr[i] & 0x0F);\n    53   \t\t}else if((ustr[i] & 0xF8) == 0xF0){\n    55   \t\t\tif(ustr[i] > 0xF4){\n    57   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    58   \t\t\t}\n    60   \t\t\tcodepoint = (ustr[i] & 0x07);\n    61   \t\t}else{\n    63   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    64   \t\t}\n    67   \t\tif(i == len-codelen+1){\n    69   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    70   \t\t}\n    71   \t\tfor(j=0; j<codelen-1; j++){\n    72   \t\t\tif((ustr[++i] & 0xC0) != 0x80){\n    74   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    75   \t\t\t}\n    76   \t\t\tcodepoint = (codepoint<<6) | (ustr[i] & 0x3F);\n    77   \t\t}\n    80   \t\tif(codepoint >= 0xD800 && codepoint <= 0xDFFF){\n    81   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    82   \t\t}\n    88   \t\t *\t return MOSQ_ERR_MALFORMED_UTF8;\n    91   \t\tif(codelen == 3 && codepoint < 0x0800){\n    92   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    93   \t\t}else if(codelen == 4 && (codepoint < 0x10000 || codepoint > 0x10FFFF)){\n    94   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    95   \t\t}\n    98   \t\tif(codepoint >= 0xFDD0 && codepoint <= 0xFDEF){\n    99   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    100  \t\t}\n    101  \t\tif((codepoint & 0xFFFF) == 0xFFFE || (codepoint & 0xFFFF) == 0xFFFF){\n    102  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    103  \t\t}\n    105  \t\tif(codepoint <= 0x001F || (codepoint >= 0x007F && codepoint <= 0x009F)){\n    106  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    107  \t\t}\n    108  \t}\n    110  }\n",
    "The Server MUST maintain the order of User Properties when publishing the Will Message [MQTT-3.1.3-10].": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    200  \t\t\t/* Unexpected disconnect, queue the client will. */\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    221  \tplugin__handle_disconnect(context, -1);\n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    226  \tif(context->bridge == NULL)\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    232  \t\t\tif(context->will_delay_interval == 0){\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    147  \tassert(mosq);\n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    153  \tpacket->next = NULL;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    187  \treturn packet__write(mosq);\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    353  }\nFunction: property__process_connect\nPath: /root/projects/mosquitto/src/property_broker.c:30\n    30   int property__process_connect(struct mosquitto *context, mosquitto_property **props)\n    31   {\n    32   \tmosquitto_property *p;\n    34   \tp = *props;\n    36   \twhile(p){\n    37   \t\tif(p->identifier == MQTT_PROP_SESSION_EXPIRY_INTERVAL){\n    38   \t\t\tcontext->session_expiry_interval = p->value.i32;\n    39   \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM){\n    40   \t\t\tif(p->value.i16 == 0){\n    41   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    42   \t\t\t}\n    44   \t\t\tcontext->msgs_out.inflight_maximum = p->value.i16;\n    45   \t\t\tcontext->msgs_out.inflight_quota = context->msgs_out.inflight_maximum;\n    46   \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    47   \t\t\tif(p->value.i32 == 0){\n    48   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    49   \t\t\t}\n    50   \t\t\tcontext->maximum_packet_size = p->value.i32;\n    51   \t\t}\n    52   \t\tp = p->next;\n    53   \t}\n    56   }\nFunction: property__process_will\nPath: /root/projects/mosquitto/src/property_broker.c:59\n    59   int property__process_will(struct mosquitto *context, struct mosquitto_message_all *msg, mosquitto_property **props)\n    60   {\n    61   \tmosquitto_property *p, *p_prev;\n    62   \tmosquitto_property *msg_properties, *msg_properties_last;\n    63   \n    64   \tp = *props;\n    65   \tp_prev = NULL;\n    66   \tmsg_properties = NULL;\n    67   \tmsg_properties_last = NULL;\n    68   \twhile(p){\n    69   \t\tswitch(p->identifier){\n    70   \t\t\tcase MQTT_PROP_CONTENT_TYPE:\n    71   \t\t\tcase MQTT_PROP_CORRELATION_DATA:\n    72   \t\t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    73   \t\t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    74   \t\t\tcase MQTT_PROP_USER_PROPERTY:\n    75   \t\t\t\tif(msg_properties){\n    76   \t\t\t\t\tmsg_properties_last->next = p;\n    77   \t\t\t\t\tmsg_properties_last = p;\n    78   \t\t\t\t}else{\n    79   \t\t\t\t\tmsg_properties = p;\n    80   \t\t\t\t\tmsg_properties_last = p;\n    81   \t\t\t\t}\n    82   \t\t\t\tif(p_prev){\n    83   \t\t\t\t\tp_prev->next = p->next;\n    84   \t\t\t\t\tp = p_prev->next;\n    85   \t\t\t\t}else{\n    86   \t\t\t\t\t*props = p->next;\n    87   \t\t\t\t\tp = *props;\n    88   \t\t\t\t}\n    89   \t\t\t\tmsg_properties_last->next = NULL;\n    90   \t\t\t\tbreak;\n    91   \n    92   \t\t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    93   \t\t\t\tcontext->will_delay_interval = p->value.i32;\n    94   \t\t\t\tp_prev = p;\n    95   \t\t\t\tp = p->next;\n    96   \t\t\t\tbreak;\n    97   \n    98   \t\t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    99   \t\t\t\tmsg->expiry_interval = p->value.i32;\n    100  \t\t\t\tp_prev = p;\n    101  \t\t\t\tp = p->next;\n    102  \t\t\t\tbreak;\n    103  \n    104  \t\t\tdefault:\n    105  \t\t\t\tmsg->properties = msg_properties;\n    106  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    107  \t\t\t\tbreak;\n    108  \t\t}\n    109  \t}\n    110  \n    111  \tmsg->properties = msg_properties;\n    112  \treturn MOSQ_ERR_SUCCESS;\n    113  }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    164  \t/* The order of properties must be preserved for some types, so keep the\n    165  \t * same order for all */\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    534  \t\tcase MQTT_PROP_USER_PROPERTY:\n    535  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: db__expire_all_messages\nPath: /root/projects/mosquitto/src/database.c:1053\n    1053 void db__expire_all_messages(struct mosquitto *context)\n    1055 \tstruct mosquitto_client_msg *msg, *tmp;\n    1057 \tDL_FOREACH_SAFE(context->msgs_out.inflight, msg, tmp){\n    1058 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1059 \t\t\tif(msg->qos > 0){\n    1060 \t\t\t\tutil__increment_send_quota(context);\n    1062 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1065 \tDL_FOREACH_SAFE(context->msgs_out.queued, msg, tmp){\n    1066 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1067 \t\t\tdb__message_remove_from_queued(&context->msgs_out, msg);\n    1070 \tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n    1071 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1072 \t\t\tif(msg->qos > 0){\n    1073 \t\t\t\tutil__increment_receive_quota(context);\n    1075 \t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n    1078 \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n    1079 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1080 \t\t\tdb__message_remove_from_queued(&context->msgs_in, msg);\n    1083 }\nFunction: db__message_remove_from_queued\nPath: /root/projects/mosquitto/src/database.c:364\n    364  static void db__message_remove_from_queued(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    365  {\n    366  \tif(!msg_data || !item){\n    367  \t\treturn;\n    368  \t}\n    370  \tDL_DELETE(msg_data->queued, item);\n    377  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1183 \tstruct mosquitto_client_msg *tail, *tmp;\n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1190 \tDL_FOREACH_SAFE(context->msgs_out.inflight, tail, tmp){\n    1191 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1192 \t\tif(rc) return rc;\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    143  \t\t\t\tin_quota = context->msgs_in.inflight_quota;\n    144  \t\t\t\tout_quota = context->msgs_out.inflight_quota;\n    145  \t\t\t\tin_maximum = context->msgs_in.inflight_maximum;\n    146  \t\t\t\tout_maximum = context->msgs_out.inflight_maximum;\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    154  \t\t\t\tcontext->msgs_in.inflight_quota = in_quota;\n    155  \t\t\t\tcontext->msgs_out.inflight_quota = out_quota;\n    156  \t\t\t\tcontext->msgs_in.inflight_maximum = in_maximum;\n    157  \t\t\t\tcontext->msgs_out.inflight_maximum = out_maximum;\n    159  \t\t\t\tdb__message_reconnect_reset(context);\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    215  \trc = acl__find_acls(context);\n    216  \tif(rc){\n    218  \t\treturn rc;\n    219  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    250  \t}\n    252  \tcontext->ping_t = 0;\n    253  \tcontext->is_dropping = false;\n    255  \tconnection_check_acl(context, &context->msgs_in.inflight);\n    256  \tconnection_check_acl(context, &context->msgs_in.queued);\n    257  \tconnection_check_acl(context, &context->msgs_out.inflight);\n    258  \tconnection_check_acl(context, &context->msgs_out.queued);\n    260  \tcontext__add_to_by_id(context);\n    263  \tif(!context->clean_start){\n    267  \tcontext->max_qos = context->listener->max_qos;\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    315  \tkeepalive__add(context);\n    317  \tmosquitto__set_state(context, mosq_cs_active);\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    320  \tif(rc) return rc;\n    321  \tdb__expire_all_messages(context);\n    322  \trc = db__message_write_queued_out(context);\n    323  \tif(rc) return rc;\n    324  \trc = db__message_write_inflight_out_all(context);\n    330  }\nFunction: connection_check_acl\nPath: /root/projects/mosquitto/src/handle_connect.c:86\n    86   static void connection_check_acl(struct mosquitto *context, struct mosquitto_client_msg **head)\n    97   \t\tif(mosquitto_acl_check(context, msg_tail->store->topic,\n    99   \t\t\t\t\t\t\t   msg_tail->store->qos, msg_tail->store->retain, access) != MOSQ_ERR_SUCCESS){\n    101  \t\t\tDL_DELETE((*head), msg_tail);\n    107  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    248  \tmosquitto__set_state(context, mosq_cs_disused);\n    250  \tif(context->id){\n    251  \t\tcontext__remove_from_by_id(context);\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    256  \tcontext->for_free_next = db.ll_for_free;\n    257  \tdb.ll_for_free = context;\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    296  \t\tcontext->in_by_id = true;\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__msg_add_to_inflight_stats\nPath: /root/projects/mosquitto/src/database.c:141\n    141  void db__msg_add_to_inflight_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    142  {\n    143  \tmsg_data->inflight_count++;\n    144  \tmsg_data->inflight_bytes += msg->store->payloadlen;\n    145  \tif(msg->qos != 0){\n    146  \t\tmsg_data->inflight_count12++;\n    147  \t\tmsg_data->inflight_bytes12 += msg->store->payloadlen;\n    148  \t}\n    149  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    271  \tmosquitto__free(store->source_id);\n    272  \tmosquitto__free(store->source_username);\n    283  }\nFunction: db__msg_remove_from_queued_stats\nPath: /root/projects/mosquitto/src/database.c:172\n    172  static void db__msg_remove_from_queued_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    173  {\n    174  \tmsg_data->queued_count--;\n    175  \tmsg_data->queued_bytes -= msg->store->payloadlen;\n    176  \tif(msg->qos != 0){\n    177  \t\tmsg_data->queued_count12--;\n    178  \t\tmsg_data->queued_bytes12 -= msg->store->payloadlen;\n    179  \t}\n    180  }\nFunction: db__message_remove_from_inflight\nPath: /root/projects/mosquitto/src/database.c:347\n    347  static void db__message_remove_from_inflight(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    348  {\n    349  \tif(!msg_data || !item){\n    350  \t\treturn;\n    351  \t}\n    353  \tDL_DELETE(msg_data->inflight, item);\n    354  \tif(item->store){\n    355  \t\tdb__msg_remove_from_inflight_stats(msg_data, item);\n    357  \t}\n    361  }\nFunction: db__message_write_inflight_out_latest\nPath: /root/projects/mosquitto/src/database.c:1198\n    1198 int db__message_write_inflight_out_latest(struct mosquitto *context)\n    1199 {\n    1200 \tstruct mosquitto_client_msg *tail, *next;\n    1203 \tif(context->state != mosq_cs_active\n    1204 \t\t\t|| context->sock == INVALID_SOCKET\n    1205 \t\t\t|| context->msgs_out.inflight == NULL){\n    1207 \t\treturn MOSQ_ERR_SUCCESS;\n    1208 \t}\n    1210 \tif(context->msgs_out.inflight->prev == context->msgs_out.inflight){\n    1212 \t\treturn db__message_write_inflight_out_single(context, context->msgs_out.inflight);\n    1213 \t}\n    1217 \ttail = context->msgs_out.inflight->prev;\n    1218 \twhile(tail != context->msgs_out.inflight &&\n    1219 \t\t\t(tail->state == mosq_ms_publish_qos0\n    1220 \t\t\t || tail->state == mosq_ms_publish_qos1\n    1221 \t\t\t || tail->state == mosq_ms_publish_qos2)){\n    1223 \t\ttail = tail->prev;\n    1224 \t}\n    1229 \tif(tail != context->msgs_out.inflight){\n    1230 \t\ttail = tail->next;\n    1231 \t}\n    1233 \twhile(tail){\n    1234 \t\tnext = tail->next;\n    1235 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1236 \t\tif(rc) return rc;\n    1238 \t}\n    1240 }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1097 \tuint32_t expiry_interval;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1103 \t\t\tif(msg->direction == mosq_md_out && msg->qos > 0){\n    1104 \t\t\t\tutil__increment_send_quota(context);\n    1105 \t\t\t}\n    1106 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1126 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1135 \t\t\t\tmsg->timestamp = db.now_s;\n    1136 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1137 \t\t\t\tmsg->state = mosq_ms_wait_for_puback;\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1139 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1148 \t\t\t\tmsg->timestamp = db.now_s;\n    1149 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1150 \t\t\t\tmsg->state = mosq_ms_wait_for_pubrec;\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1152 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1159 \t\t\trc = send__pubrel(context, mid, NULL);\n    1160 \t\t\tif(!rc){\n    1161 \t\t\t\tmsg->state = mosq_ms_wait_for_pubcomp;\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1176 \t}\n    1178 }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    449  \tstruct mosquitto_msg_data *msg_data;\n    450  \tenum mosquitto_msg_state state = mosq_ms_invalid;\n    452  \tint i;\n    457  \tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n    459  \tif(dir == mosq_md_out){\n    460  \t\tmsg_data = &context->msgs_out;\n    461  \t}else{\n    462  \t\tmsg_data = &context->msgs_in;\n    463  \t}\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    484  \tif(context->sock == INVALID_SOCKET){\n    486  \t\tif(qos == 0 && !db.config->queue_qos0_messages){\n    487  \t\t\tif(!context->bridge){\n    489  \t\t\t\treturn 2;\n    490  \t\t\t}else{\n    491  \t\t\t\tif(context->bridge->start_type != bst_lazy){\n    493  \t\t\t\t\treturn 2;\n    494  \t\t\t\t}\n    495  \t\t\t}\n    496  \t\t}\n    497  \t\tif(context->bridge && context->bridge->clean_start_local == true){\n    499  \t\t\treturn 2;\n    500  \t\t}\n    501  \t}\n    503  \tif(context->sock != INVALID_SOCKET){\n    504  \t\tif(db__ready_for_flight(context, dir, qos)){\n    517  \t\t\t}else{\n    520  \t\t\t\t}else{\n    522  \t\t\t\t\treturn 1;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n    528  \t\t}else{\n    530  \t\t\tif(context->is_dropping == false){\n    531  \t\t\t\tcontext->is_dropping = true;\n    532  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    534  \t\t\t\t\t\tcontext->id);\n    535  \t\t\t}\n    538  \t\t\treturn 2;\n    539  \t\t}\n    540  \t}else{\n    541  \t\tif (db__ready_for_queue(context, qos, msg_data)){\n    543  \t\t}else{\n    545  \t\t\tif(context->is_dropping == false){\n    546  \t\t\t\tcontext->is_dropping = true;\n    547  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    549  \t\t\t\t\t\tcontext->id);\n    550  \t\t\t}\n    552  \t\t\treturn 2;\n    553  \t\t}\n    554  \t}\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    582  \tif(state == mosq_ms_queued){\n    583  \t\tDL_APPEND(msg_data->queued, msg);\n    585  \t}else{\n    586  \t\tDL_APPEND(msg_data->inflight, msg);\n    588  \t}\n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    598  \t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n    599  \t\tif(dest_ids){\n    602  \t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t}\n    609  \t}\n    611  \tif(context->bridge && context->bridge->start_type == bst_lazy\n    612  \t\t\t&& context->sock == INVALID_SOCKET\n    613  \t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n    616  \t}\n    633  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    704  \tstruct mosquitto_msg_store *stored;\n    705  \tconst char *source_id;\n    706  \tenum mosquitto_msg_origin origin;\n    710  \tstored = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    711  \tif(stored == NULL) return MOSQ_ERR_NOMEM;\n    713  \tstored->topic = mosquitto__strdup(topic);\n    714  \tif(stored->topic == NULL){\n    715  \t\tdb__msg_store_free(stored);\n    716  \t\treturn MOSQ_ERR_INVAL;\n    717  \t}\n    719  \tstored->qos = qos;\n    720  \tif(db.config->retain_available == false){\n    721  \t\tstored->retain = 0;\n    722  \t}else{\n    723  \t\tstored->retain = retain;\n    724  \t}\n    726  \tstored->payloadlen = payloadlen;\n    727  \tif(payloadlen > 0){\n    728  \t\tstored->payload = mosquitto__malloc(stored->payloadlen+1);\n    729  \t\tif(stored->payload == NULL){\n    730  \t\t\tdb__msg_store_free(stored);\n    731  \t\t\treturn MOSQ_ERR_NOMEM;\n    732  \t\t}\n    734  \t\t((uint8_t *)stored->payload)[stored->payloadlen] = 0;\n    735  \t\tmemcpy(stored->payload, payload, stored->payloadlen);\n    736  \t}\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    746  \t}\n    748  \tif(context){\n    750  \t}else{\n    753  \tif(db__message_store(context, stored, message_expiry_interval, 0, origin)) return 1;\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    763  \tif(source && source->id){\n    764  \t\tstored->source_id = mosquitto__strdup(source->id);\n    765  \t}else{\n    766  \t\tstored->source_id = mosquitto__strdup(\"\");\n    767  \t}\n    768  \tif(!stored->source_id){\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    774  \tif(source && source->username){\n    775  \t\tstored->source_username = mosquitto__strdup(source->username);\n    776  \t\tif(!stored->source_username){\n    778  \t\t\treturn MOSQ_ERR_NOMEM;\n    779  \t\t}\n    780  \t}\n    781  \tif(source){\n    782  \t\tstored->source_listener = source->listener;\n    783  \t}\n    806  }\nFunction: net__socket_close\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:205\n    205  int net__socket_close(struct mosquitto *mosq)\n    206  {\n    207  \tint rc = 0;\n    209  \tstruct mosquitto *mosq_found;\n    212  \tassert(mosq);\n    218  \t\tif(mosq->ssl){\n    219  \t\t\tif(!SSL_in_init(mosq->ssl)){\n    220  \t\t\t\tSSL_shutdown(mosq->ssl);\n    221  \t\t\t}\n    222  \t\t\tSSL_free(mosq->ssl);\n    223  \t\t\tmosq->ssl = NULL;\n    224  \t\t}\n    238  \t\tif(mosq->sock != INVALID_SOCKET){\n    240  \t\t\tHASH_FIND(hh_sock, db.contexts_by_sock, &mosq->sock, sizeof(mosq->sock), mosq_found);\n    241  \t\t\tif(mosq_found){\n    242  \t\t\t\tHASH_DELETE(hh_sock, db.contexts_by_sock, mosq_found);\n    243  \t\t\t}\n    245  \t\t\trc = COMPAT_CLOSE(mosq->sock);\n    246  \t\t\tmosq->sock = INVALID_SOCKET;\n    247  \t\t}\n    251  \tif(mosq->listener){\n    252  \t\tmosq->listener->client_count--;\n    253  \t\tmosq->listener = NULL;\n    254  \t}\n    257  \treturn rc;\n    258  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    448  \tX509 *client_cert = NULL;\n    460  \tif(!context->listener){\n    461  \t\treturn MOSQ_ERR_INVAL;\n    462  \t}\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    502  \t\tcontext->protocol = mosq_p_mqtt31;\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    504  \t\t\tcontext->is_bridge = true;\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    508  \t\t\tcontext->protocol = mosq_p_mqtt311;\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    511  \t\t\t\tcontext->is_bridge = true;\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    514  \t\t\tcontext->protocol = mosq_p_mqtt5;\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    563  \t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid Will QoS in CONNECT from %s.\",\n    564  \t\t\t\tcontext->address);\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    724  \tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    731  \t\tif(!context->ssl){\n    732  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    741  \t\tif(context->listener->psk_hint){\n    743  \t\t\tif(!context->username){\n    744  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    754  \t\t\tclient_cert = SSL_get_peer_certificate(context->ssl);\n    755  \t\t\tif(!client_cert){\n    756  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    764  \t\t\tname = X509_get_subject_name(client_cert);\n    765  \t\t\tif(!name){\n    766  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    774  \t\t\tif (context->listener->use_identity_as_username) { /* use_identity_as_username */\n    775  \t\t\t\ti = X509_NAME_get_index_by_NID(name, NID_commonName, -1);\n    776  \t\t\t\tif(i == -1){\n    777  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    785  \t\t\t\tname_entry = X509_NAME_get_entry(name, i);\n    786  \t\t\t\tif(name_entry){\n    787  \t\t\t\t\tname_asn1 = X509_NAME_ENTRY_get_data(name_entry);\n    788  \t\t\t\t\tif (name_asn1 == NULL) {\n    789  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    801  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_get0_data(name_asn1);\n    803  \t\t\t\t\tif(mosquitto_validate_utf8(new_username, (int)strlen(new_username))){\n    804  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    809  \t\t\t\t\t\tX509_free(client_cert);\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    814  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    824  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    835  \t\t\t\tX509_NAME_print_ex(subject_bio, X509_get_subject_name(client_cert), 0, XN_FLAG_RFC2253);\n    847  \t\t\t\tcontext->username = subject;\n    849  \t\t\tif(!context->username){\n    853  \t\t\tX509_free(client_cert);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    898  \t\t\tmosquitto__set_state(context, mosq_cs_authenticating);\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    905  \t\t\twill__clear(context);\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    925  \t\tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    973  \tif(client_cert) X509_free(client_cert);\n    976  \tcontext->clean_start = true;\n    977  \tcontext->session_expiry_interval = 0;\n    978  \tcontext->will_delay_interval = 0;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    55   \tint i;\n    56   \tint pos;\n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    349  \t\trc = property__read_all(CMD_WILL, &context->in_packet, &properties);\n    350  \t\tif(rc) goto error_cleanup;\n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    353  \t\tmosquitto_property_free_all(&properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    356  \trc = packet__read_string(&context->in_packet, &will_struct->msg.topic, &tlen);\n    363  \tif(context->listener->mount_point){\n    364  \t\tslen = strlen(context->listener->mount_point) + strlen(will_struct->msg.topic) + 1;\n    366  \t\tif(!will_topic_mount){\n    368  \t\t\tgoto error_cleanup;\n    369  \t\t}\n    371  \t\tsnprintf(will_topic_mount, slen, \"%s%s\", context->listener->mount_point, will_struct->msg.topic);\n    374  \t\tmosquitto__free(will_struct->msg.topic);\n    375  \t\twill_struct->msg.topic = will_topic_mount;\n    376  \t}\n    378  \tif(!strncmp(will_struct->msg.topic, \"$CONTROL/\", strlen(\"$CONTROL/\"))){\n    380  \t\tgoto error_cleanup;\n    381  \t}\n    382  \trc = mosquitto_pub_topic_check(will_struct->msg.topic);\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    394  \t\t\t}else{\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    400  \t\twill_struct->msg.payload = mosquitto__malloc((size_t)will_struct->msg.payloadlen);\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    406  \t\trc = packet__read_bytes(&context->in_packet, will_struct->msg.payload, (uint32_t)will_struct->msg.payloadlen);\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    413  \t*will = will_struct;\n    416  error_cleanup:\n    417  \tif(will_struct){\n    418  \t\tmosquitto__free(will_struct->msg.topic);\n    419  \t\tmosquitto__free(will_struct->msg.payload);\n    422  \t}\n    424  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    73   \tassert(packet);\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    157  \tassert(packet);\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    371  \t\tmux__delete(context);\n    372  \t\tcontext__disconnect(context);\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto__malloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:83\n    83   void *mosquitto__malloc(size_t size)\n    84   {\n    88   \tif(mem_limit && memcount + size > mem_limit){\n    89   \t\treturn NULL;\n    90   \t}\n    93   \tmem = malloc(size);\n    96   \tif(mem){\n    97   \t\tmemcount += malloc_usable_size(mem);\n    101  \t}\n    105  }\nFunction: mosquitto__strdup\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:144\n    144  char *mosquitto__strdup(const char *s)\n    145  {\n    148  \tif(mem_limit && memcount + strlen(s) > mem_limit){\n    149  \t\treturn NULL;\n    150  \t}\n    152  \tstr = strdup(s);\n    155  \tif(str){\n    156  \t\tmemcount += malloc_usable_size(str);\n    160  \t}\n    164  }\nFunction: mosquitto_free\nPath: /root/projects/mosquitto/src/memory_public.c:27\n    27   void mosquitto_free(void *mem)\n    29   \tmosquitto__free(mem);\n    30   }\nFunction: mosquitto_malloc\nPath: /root/projects/mosquitto/src/memory_public.c:32\n    32   void *mosquitto_malloc(size_t size)\n    34   \treturn mosquitto__malloc(size);\n    35   }\nFunction: mux__delete\nPath: /root/projects/mosquitto/src/mux.c:61\n    61   int mux__delete(struct mosquitto *context)\n    64   \treturn mux_epoll__delete(context);\n    68   }\nFunction: send__auth\nPath: /root/projects/mosquitto/src/send_auth.c:28\n    28   int send__auth(struct mosquitto *context, uint8_t reason_code, const void *auth_data, uint16_t auth_data_len)\n    29   {\n    32   \tmosquitto_property *properties = NULL;\n    35   \tif(context->auth_method == NULL) return MOSQ_ERR_INVAL;\n    36   \tif(context->protocol != mosq_p_mqtt5) return MOSQ_ERR_PROTOCOL;\n    38   \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending AUTH to %s (rc%d, %s)\", context->id, reason_code, context->auth_method);\n    42   \trc = mosquitto_property_add_string(&properties, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method);\n    43   \tif(rc){\n    45   \t\treturn rc;\n    46   \t}\n    56   \tremaining_length += property__get_remaining_length(properties);\n    58   \tif(packet__check_oversize(context, remaining_length)){\n    61   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    62   \t}\n    67   \tpacket->command = CMD_AUTH;\n    68   \tpacket->remaining_length = remaining_length;\n    70   \trc = packet__alloc(packet);\n    76   \tpacket__write_byte(packet, reason_code);\n    77   \tproperty__write_all(packet, properties, true);\n    80   \treturn packet__queue(context, packet);\n    81   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    32   \tmosquitto_property *connack_props = NULL;\n    33   \tuint32_t remaining_length;\n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    43   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->address, ack, reason_code);\n    44   \t}\n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    51   \t\t\tif(rc){\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    58   \t\t\tif(rc){\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    65   \t\t\tif(rc){\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    71   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_MAXIMUM_QOS, context->listener->max_qos);\n    72   \t\t\tif(rc){\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    78   \t\tremaining_length += property__get_remaining_length(connack_props);\n    79   \t}\n    81   \tif(packet__check_oversize(context, remaining_length)){\n    83   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    84   \t}\n    92   \tpacket->command = CMD_CONNACK;\n    93   \tpacket->remaining_length = remaining_length;\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    105  \t}\n    108  \treturn packet__queue(context, packet);\n    109  }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    126  \tassert(mosq);\n    130  \tpacket->command = command;\n    131  \tif(dup){\n    132  \t\tpacket->command |= 8;\n    133  \t}\n    134  \tpacket->remaining_length = 2;\n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    137  \t\tif(reason_code != 0 || properties){\n    138  \t\t\tpacket->remaining_length += 1;\n    139  \t\t}\n    141  \t\tif(properties){\n    142  \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    143  \t\t}\n    144  \t}\n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    161  \t}\n    163  \treturn packet__queue(mosq, packet);\n    164  }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    117  \treturn send__command_with_mid(mosq, CMD_PUBREL|2, mid, false, 0, properties);\n    118  }\nFunction: send__publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:42\n    42   int send__publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    43   {\n    47   \tint i;\n    49   \tbool match;\n    51   \tchar *mapped_topic = NULL;\n    55   \tassert(mosq);\n    60   \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    63   \tif(!mosq->retain_available){\n    65   \t}\n    68   \tif(mosq->listener && mosq->listener->mount_point){\n    69   \t\tlen = strlen(mosq->listener->mount_point);\n    70   \t\tif(len < strlen(topic)){\n    71   \t\t\ttopic += len;\n    72   \t\t}else{\n    74   \t\t\treturn MOSQ_ERR_SUCCESS;\n    75   \t\t}\n    76   \t}\n    78   \tif(mosq->bridge && mosq->bridge->topics && mosq->bridge->topic_remapping){\n    79   \t\tfor(i=0; i<mosq->bridge->topic_count; i++){\n    80   \t\t\tcur_topic = &mosq->bridge->topics[i];\n    81   \t\t\tif((cur_topic->direction == bd_both || cur_topic->direction == bd_out)\n    82   \t\t\t\t\t&& (cur_topic->remote_prefix || cur_topic->local_prefix)){\n    85   \t\t\t\trc = mosquitto_topic_matches_sub(cur_topic->local_topic, topic, &match);\n    86   \t\t\t\tif(rc){\n    87   \t\t\t\t\treturn rc;\n    88   \t\t\t\t}\n    89   \t\t\t\tif(match){\n    90   \t\t\t\t\tmapped_topic = mosquitto__strdup(topic);\n    91   \t\t\t\t\tif(!mapped_topic) return MOSQ_ERR_NOMEM;\n    92   \t\t\t\t\tif(cur_topic->local_prefix){\n    94   \t\t\t\t\t\tif(!strncmp(cur_topic->local_prefix, mapped_topic, strlen(cur_topic->local_prefix))){\n    95   \t\t\t\t\t\t\ttopic_temp = mosquitto__strdup(mapped_topic+strlen(cur_topic->local_prefix));\n    96   \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    97   \t\t\t\t\t\t\tif(!topic_temp){\n    98   \t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    99   \t\t\t\t\t\t\t}\n    101  \t\t\t\t\t\t}\n    102  \t\t\t\t\t}\n    104  \t\t\t\t\tif(cur_topic->remote_prefix){\n    106  \t\t\t\t\t\tlen = strlen(mapped_topic) + strlen(cur_topic->remote_prefix)+1;\n    107  \t\t\t\t\t\ttopic_temp = mosquitto__malloc(len+1);\n    108  \t\t\t\t\t\tif(!topic_temp){\n    109  \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    110  \t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    111  \t\t\t\t\t\t}\n    112  \t\t\t\t\t\tsnprintf(topic_temp, len, \"%s%s\", cur_topic->remote_prefix, mapped_topic);\n    113  \t\t\t\t\t\ttopic_temp[len] = '\\0';\n    114  \t\t\t\t\t\tmosquitto__free(mapped_topic);\n    116  \t\t\t\t\t}\n    117  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, mapped_topic, (long)payloadlen);\n    119  \t\t\t\t\trc =  send__real_publish(mosq, mid, mapped_topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    120  \t\t\t\t\tmosquitto__free(mapped_topic);\n    121  \t\t\t\t\treturn rc;\n    122  \t\t\t\t}\n    123  \t\t\t}\n    124  \t\t}\n    125  \t}\n    127  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, topic, (long)payloadlen);\n    133  \treturn send__real_publish(mosq, mid, topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    134  }\nFunction: send__real_publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:137\n    137  int send__real_publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    138  {\n    140  \tunsigned int packetlen;\n    141  \tunsigned int proplen = 0, varbytes;\n    143  \tmosquitto_property expiry_prop;\n    145  \tassert(mosq);\n    147  \tif(topic){\n    148  \t\tpacketlen = 2+(unsigned int)strlen(topic) + payloadlen;\n    149  \t}else{\n    150  \t\tpacketlen = 2 + payloadlen;\n    151  \t}\n    152  \tif(qos > 0) packetlen += 2; /* For message id */\n    153  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tproplen += property__get_length_all(cmsg_props);\n    156  \t\tproplen += property__get_length_all(store_props);\n    157  \t\tif(expiry_interval > 0){\n    163  \t\t\tproplen += property__get_length_all(&expiry_prop);\n    164  \t\t}\n    166  \t\tvarbytes = packet__varint_bytes(proplen);\n    172  \t\t}else{\n    173  \t\t\tpacketlen += proplen + varbytes;\n    174  \t\t}\n    175  \t}\n    176  \tif(packet__check_oversize(mosq, packetlen)){\n    178  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Dropping too large outgoing PUBLISH for %s (%d bytes)\", SAFE_PRINT(mosq->id), packetlen);\n    182  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    183  \t}\n    189  \tpacket->command = (uint8_t)(CMD_PUBLISH | (uint8_t)((dup&0x1)<<3) | (uint8_t)(qos<<1) | retain);\n    190  \tpacket->remaining_length = packetlen;\n    206  \tif(mosq->protocol == mosq_p_mqtt5){\n    213  \t}\n    220  \treturn packet__queue(mosq, packet);\n    221  }\nFunction: set_session_expiry_time\nPath: /root/projects/mosquitto/src/session_expiry.c:46\n    46   static void set_session_expiry_time(struct mosquitto *context)\n    47   {\n    50   \tif(db.config->persistent_client_expiration == 0){\n    52   \t\tcontext->session_expiry_time += context->session_expiry_interval;\n    53   \t}else{\n    55   \t\tif(db.config->persistent_client_expiration < context->session_expiry_interval){\n    58   \t\t}else{\n    60   \t\t\tcontext->session_expiry_time += context->session_expiry_interval;\n    61   \t\t}\n    62   \t}\n    63   }\nFunction: session_expiry__remove\nPath: /root/projects/mosquitto/src/session_expiry.c:121\n    121  void session_expiry__remove(struct mosquitto *context)\n    122  {\n    123  \tif(context->expiry_list_item){\n    124  \t\tDL_DELETE(expiry_list, context->expiry_list_item);\n    125  \t\tmosquitto__free(context->expiry_list_item);\n    126  \t\tcontext->expiry_list_item = NULL;\n    127  \t}\n    128  }\nFunction: mosquitto_acl_check\nPath: /root/projects/mosquitto/src/security.c:679\n    679  int mosquitto_acl_check(struct mosquitto *context, const char *topic, uint32_t payloadlen, void* payload, uint8_t qos, bool retain, int access)\n    680  {\n    681  \tint rc;\n    682  \tint i;\n    683  \tstruct mosquitto__security_options *opts;\n    684  \tstruct mosquitto_acl_msg msg;\n    685  \tstruct mosquitto__callback *cb_base;\n    686  \tstruct mosquitto_evt_acl_check event_data;\n    688  \tif(!context->id){\n    689  \t\treturn MOSQ_ERR_ACL_DENIED;\n    690  \t}\n    691  \tif(context->bridge){\n    692  \t\treturn MOSQ_ERR_SUCCESS;\n    693  \t}\n    703  \tif(db.config->per_listener_settings){\n    704  \t\tif(context->listener){\n    705  \t\t\topts = &context->listener->security_options;\n    706  \t\t}else{\n    707  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    708  \t\t}\n    709  \t}else{\n    710  \t\topts = &db.config->security_options;\n    711  \t}\n    720  \tDL_FOREACH(opts->plugin_callbacks.acl_check, cb_base){\n    724  \t\tevent_data.client = context;\n    732  \t\trc = cb_base->cb(MOSQ_EVT_ACL_CHECK, &event_data, cb_base->userdata);\n    733  \t\tif(rc != MOSQ_ERR_PLUGIN_DEFER){\n    738  \tfor(i=0; i<opts->auth_plugin_config_count; i++){\n    739  \t\tif(opts->auth_plugin_configs[i].plugin.version < 5){\n    740  \t\t\trc = acl__check_single(&opts->auth_plugin_configs[i], context, &msg, access);\n    741  \t\t\tif(rc != MOSQ_ERR_PLUGIN_DEFER){\n    742  \t\t\t\treturn rc;\n    743  \t\t\t}\n    744  \t\t}\n    745  \t}\n    749  \tif(rc == MOSQ_ERR_PLUGIN_DEFER){\n    751  \t}\n    753  }\nFunction: sub__remove_shared_leaf\nPath: /root/projects/mosquitto/src/subs.c:190\n    190  static void sub__remove_shared_leaf(struct mosquitto__subhier *subhier, struct mosquitto__subshared *shared, struct mosquitto__subleaf *leaf)\n    191  {\n    192  \tDL_DELETE(shared->subs, leaf);\n    193  \tif(shared->subs == NULL){\n    194  \t\tHASH_DELETE(hh, subhier->shared, shared);\n    195  \t\tmosquitto__free(shared->name);\n    196  \t\tmosquitto__free(shared);\n    197  \t}\n    199  }\nFunction: sub__messages_queue\nPath: /root/projects/mosquitto/src/subs.c:659\n    659  int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n    660  {\n    661  \tint rc = MOSQ_ERR_SUCCESS, rc2;\n    662  \tint rc_normal = MOSQ_ERR_NO_SUBSCRIBERS, rc_shared = MOSQ_ERR_NO_SUBSCRIBERS;\n    663  \tstruct mosquitto__subhier *subhier;\n    664  \tchar **split_topics = NULL;\n    677  \tHASH_FIND(hh, db.normal_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    678  \tif(subhier){\n    679  \t\trc_normal = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    680  \t\tif(rc_normal > 0){\n    682  \t\t\tgoto end;\n    683  \t\t}\n    684  \t}\n    686  \tHASH_FIND(hh, db.shared_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    687  \tif(subhier){\n    688  \t\trc_shared = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    689  \t\tif(rc_shared > 0){\n    691  \t\t\tgoto end;\n    692  \t\t}\n    693  \t}\n    695  \tif(rc_normal == MOSQ_ERR_NO_SUBSCRIBERS && rc_shared == MOSQ_ERR_NO_SUBSCRIBERS){\n    697  \t}\n    711  }\nFunction: sub__search\nPath: /root/projects/mosquitto/src/subs.c:479\n    479  static int sub__search(struct mosquitto__subhier *subhier, char **split_topics, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    480  {\n    482  \tstruct mosquitto__subhier *branch;\n    486  \tif(split_topics && split_topics[0]){\n    488  \t\tHASH_FIND(hh, subhier->children, split_topics[0], strlen(split_topics[0]), branch);\n    490  \t\tif(branch){\n    491  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    492  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    494  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    495  \t\t\t\treturn rc;\n    496  \t\t\t}\n    497  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    498  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    499  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    501  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    502  \t\t\t\t\treturn rc;\n    503  \t\t\t\t}\n    504  \t\t\t}\n    505  \t\t}\n    508  \t\tHASH_FIND(hh, subhier->children, \"+\", 1, branch);\n    510  \t\tif(branch){\n    511  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    512  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    514  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    515  \t\t\t\treturn rc;\n    516  \t\t\t}\n    517  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    518  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    519  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    521  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    522  \t\t\t\t\treturn rc;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}\n    526  \t}\n    529  \tHASH_FIND(hh, subhier->children, \"#\", 1, branch);\n    530  \tif(branch && !branch->children){\n    535  \t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    536  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    538  \t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    539  \t\t\treturn rc;\n    540  \t\t}\n    541  \t}\n    548  }\nFunction: subs__process\nPath: /root/projects/mosquitto/src/subs.c:129\n    129  static int subs__process(struct mosquitto__subhier *hier, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    130  {\n    133  \tstruct mosquitto__subleaf *leaf;\n    135  \trc = subs__shared_process(hier, topic, qos, retain, stored);\n    137  \tleaf = hier->subs;\n    138  \twhile(source_id && leaf){\n    139  \t\tif(!leaf->context->id || (leaf->no_local && !strcmp(leaf->context->id, source_id))){\n    140  \t\t\tleaf = leaf->next;\n    142  \t\t}\n    147  \t\tleaf = leaf->next;\n    148  \t}\n    149  \tif(hier->subs || hier->shared){\n    150  \t\treturn rc;\n    151  \t}else{\n    152  \t\treturn MOSQ_ERR_NO_SUBSCRIBERS;\n    153  \t}\n    154  }\nFunction: subs__send\nPath: /root/projects/mosquitto/src/subs.c:63\n    63   static int subs__send(struct mosquitto__subleaf *leaf, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    64   {\n    65   \tbool client_retain;\n    66   \tuint16_t mid;\n    67   \tuint8_t client_qos, msg_qos;\n    68   \tmosquitto_property *properties = NULL;\n    72   \trc2 = mosquitto_acl_check(leaf->context, topic, stored->payloadlen, stored->payload, stored->qos, stored->retain, MOSQ_ACL_READ);\n    73   \tif(rc2 == MOSQ_ERR_ACL_DENIED){\n    74   \t\treturn MOSQ_ERR_SUCCESS;\n    75   \t}else if(rc2 == MOSQ_ERR_SUCCESS){\n    76   \t\tclient_qos = leaf->qos;\n    87   \t\tif(msg_qos){\n    88   \t\t\tmid = mosquitto__mid_generate(leaf->context);\n    89   \t\t}else{\n    92   \t\tif(leaf->retain_as_published){\n    93   \t\t\tclient_retain = retain;\n    94   \t\t}else{\n    97   \t\tif(leaf->identifier){\n    98   \t\t\tmosquitto_property_add_varint(&properties, MQTT_PROP_SUBSCRIPTION_IDENTIFIER, leaf->identifier);\n    99   \t\t}\n    100  \t\tif(db__message_insert(leaf->context, mid, mosq_md_out, msg_qos, client_retain, stored, properties, true) == 1){\n    101  \t\t\treturn 1;\n    102  \t\t}\n    103  \t}else{\n    104  \t\treturn 1; /* Application error */\n    105  \t}\n    107  }\nFunction: sub__clean_session\nPath: /root/projects/mosquitto/src/subs.c:746\n    746  int sub__clean_session(struct mosquitto *context)\n    747  {\n    748  \tint i;\n    749  \tstruct mosquitto__subleaf *leaf;\n    750  \tstruct mosquitto__subhier *hier;\n    752  \tfor(i=0; i<context->sub_count; i++){\n    753  \t\tif(context->subs[i] == NULL){\n    755  \t\t}\n    757  \t\thier = context->subs[i]->hier;\n    759  \t\tif(context->subs[i]->shared){\n    760  \t\t\tleaf = context->subs[i]->shared->subs;\n    761  \t\t\twhile(leaf){\n    762  \t\t\t\tif(leaf->context==context){\n    766  \t\t\t\t\tsub__remove_shared_leaf(context->subs[i]->hier, context->subs[i]->shared, leaf);\n    768  \t\t\t\t}\n    769  \t\t\t\tleaf = leaf->next;\n    770  \t\t\t}\n    771  \t\t}else{\n    772  \t\t\tleaf = hier->subs;\n    773  \t\t\twhile(leaf){\n    774  \t\t\t\tif(leaf->context==context){\n    778  \t\t\t\t\tDL_DELETE(hier->subs, leaf);\n    779  \t\t\t\t\tmosquitto__free(leaf);\n    781  \t\t\t\t}\n    782  \t\t\t\tleaf = leaf->next;\n    783  \t\t\t}\n    784  \t\t}\n    785  \t\tmosquitto__free(context->subs[i]);\n    786  \t\tcontext->subs[i] = NULL;\n    788  \t\tif(hier->subs == NULL\n    789  \t\t\t\t&& hier->children == NULL\n    790  \t\t\t\t&& hier->shared == NULL\n    791  \t\t\t\t&& hier->parent){\n    794  \t\t\t\thier = tmp_remove_subs(hier);\n    795  \t\t\t}while(hier);\n    796  \t\t}\n    797  \t}\n    798  \tmosquitto__free(context->subs);\n    799  \tcontext->subs = NULL;\n    800  \tcontext->sub_count = 0;\n    803  }\nFunction: tmp_remove_subs\nPath: /root/projects/mosquitto/src/subs.c:715\n    715  static struct mosquitto__subhier *tmp_remove_subs(struct mosquitto__subhier *sub)\n    716  {\n    719  \tif(!sub || !sub->parent){\n    720  \t\treturn NULL;\n    721  \t}\n    723  \tif(sub->children || sub->subs){\n    724  \t\treturn NULL;\n    725  \t}\n    727  \tparent = sub->parent;\n    728  \tHASH_DELETE(hh, parent->children, sub);\n    729  \tmosquitto__free(sub->topic);\n    730  \tmosquitto__free(sub);\n    732  \tif(parent->subs == NULL\n    733  \t\t\t&& parent->children == NULL\n    734  \t\t\t&& parent->shared == NULL\n    735  \t\t\t&& parent->parent){\n    737  \t\treturn parent;\n    738  \t}else{\n    739  \t\treturn NULL;\n    740  \t}\n    741  }\nFunction: mosquitto_validate_utf8\nPath: /root/projects/mosquitto/src/../lib/utf8_mosq.c:24\n    24   int mosquitto_validate_utf8(const char *str, int len)\n    25   {\n    26   \tint i;\n    27   \tint j;\n    28   \tint codelen;\n    29   \tint codepoint;\n    32   \tif(!str) return MOSQ_ERR_INVAL;\n    35   \tfor(i=0; i<len; i++){\n    36   \t\tif(ustr[i] == 0){\n    37   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    38   \t\t}else if(ustr[i] <= 0x7f){\n    40   \t\t\tcodepoint = ustr[i];\n    41   \t\t}else if((ustr[i] & 0xE0) == 0xC0){\n    43   \t\t\tif(ustr[i] == 0xC0 || ustr[i] == 0xC1){\n    45   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    46   \t\t\t}\n    48   \t\t\tcodepoint = (ustr[i] & 0x1F);\n    49   \t\t}else if((ustr[i] & 0xF0) == 0xE0){\n    52   \t\t\tcodepoint = (ustr[i] & 0x0F);\n    53   \t\t}else if((ustr[i] & 0xF8) == 0xF0){\n    55   \t\t\tif(ustr[i] > 0xF4){\n    57   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    58   \t\t\t}\n    60   \t\t\tcodepoint = (ustr[i] & 0x07);\n    61   \t\t}else{\n    63   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    64   \t\t}\n    67   \t\tif(i == len-codelen+1){\n    69   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    70   \t\t}\n    71   \t\tfor(j=0; j<codelen-1; j++){\n    72   \t\t\tif((ustr[++i] & 0xC0) != 0x80){\n    74   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    75   \t\t\t}\n    76   \t\t\tcodepoint = (codepoint<<6) | (ustr[i] & 0x3F);\n    77   \t\t}\n    80   \t\tif(codepoint >= 0xD800 && codepoint <= 0xDFFF){\n    81   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    82   \t\t}\n    88   \t\t *\t return MOSQ_ERR_MALFORMED_UTF8;\n    91   \t\tif(codelen == 3 && codepoint < 0x0800){\n    92   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    93   \t\t}else if(codelen == 4 && (codepoint < 0x10000 || codepoint > 0x10FFFF)){\n    94   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    95   \t\t}\n    98   \t\tif(codepoint >= 0xFDD0 && codepoint <= 0xFDEF){\n    99   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    100  \t\t}\n    101  \t\tif((codepoint & 0xFFFF) == 0xFFFE || (codepoint & 0xFFFF) == 0xFFFF){\n    102  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    103  \t\t}\n    105  \t\tif(codepoint <= 0x001F || (codepoint >= 0x007F && codepoint <= 0x009F)){\n    106  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    107  \t\t}\n    108  \t}\n    110  }\nFunction: util__increment_receive_quota\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:215\n    215  void util__increment_receive_quota(struct mosquitto *mosq)\n    216  {\n    217  \tif(mosq->msgs_in.inflight_quota < mosq->msgs_in.inflight_maximum){\n    218  \t\tmosq->msgs_in.inflight_quota++;\n    219  \t}\n    220  }\nFunction: will_delay__remove\nPath: /root/projects/mosquitto/src/will_delay.c:99\n    99   void will_delay__remove(struct mosquitto *mosq)\n    100  {\n    101  \tif(mosq->will_delay_entry != NULL){\n    102  \t\tDL_DELETE(delay_list, mosq->will_delay_entry);\n    103  \t\tmosquitto__free(mosq->will_delay_entry);\n    104  \t\tmosq->will_delay_entry = NULL;\n    105  \t}\n    106  }\nFunction: will__clear\nPath: /root/projects/mosquitto/src/../lib/will_mosq.c:111\n    111  int will__clear(struct mosquitto *mosq)\n    112  {\n    113  \tif(!mosq->will) return MOSQ_ERR_SUCCESS;\n    115  \tmosquitto__free(mosq->will->msg.topic);\n    116  \tmosq->will->msg.topic = NULL;\n    118  \tmosquitto__free(mosq->will->msg.payload);\n    119  \tmosq->will->msg.payload = NULL;\n    121  \tmosquitto_property_free_all(&mosq->will->properties);\n    123  \tmosquitto__free(mosq->will);\n    124  \tmosq->will = NULL;\n    125  \tmosq->will_delay_interval = 0;\n    128  }\n",
    "If the Password Flag is set to 1, a Password MUST be present in the Payload [MQTT-3.1.2-19].": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    221  \tplugin__handle_disconnect(context, -1);\n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    226  \tif(context->bridge == NULL)\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    232  \t\t\tif(context->will_delay_interval == 0){\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__read_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:178\n    178  int packet__read_uint32(struct mosquitto__packet *packet, uint32_t *word)\n    179  {\n    180  \tuint32_t val = 0;\n    181  \tint i;\n    183  \tassert(packet);\n    184  \tif(packet->pos+4 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    186  \tfor(i=0; i<4; i++){\n    187  \t\tval = (val << 8) + packet->payload[packet->pos];\n    188  \t\tpacket->pos++;\n    189  \t}\n    191  \t*word = val;\n    194  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    147  \tassert(mosq);\n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    153  \tpacket->next = NULL;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    187  \treturn packet__write(mosq);\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    353  }\nFunction: packet__check_oversize\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:211\n    211  int packet__check_oversize(struct mosquitto *mosq, uint32_t remaining_length)\n    212  {\n    215  \tif(mosq->maximum_packet_size == 0) return MOSQ_ERR_SUCCESS;\n    217  \tlen = remaining_length + packet__varint_bytes(remaining_length);\n    218  \tif(len > mosq->maximum_packet_size){\n    219  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    220  \t}else{\n    221  \t\treturn MOSQ_ERR_SUCCESS;\n    222  \t}\n    223  }\nFunction: property__process_connect\nPath: /root/projects/mosquitto/src/property_broker.c:30\n    30   int property__process_connect(struct mosquitto *context, mosquitto_property **props)\n    31   {\n    32   \tmosquitto_property *p;\n    34   \tp = *props;\n    36   \twhile(p){\n    37   \t\tif(p->identifier == MQTT_PROP_SESSION_EXPIRY_INTERVAL){\n    38   \t\t\tcontext->session_expiry_interval = p->value.i32;\n    39   \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM){\n    40   \t\t\tif(p->value.i16 == 0){\n    41   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    42   \t\t\t}\n    44   \t\t\tcontext->msgs_out.inflight_maximum = p->value.i16;\n    45   \t\t\tcontext->msgs_out.inflight_quota = context->msgs_out.inflight_maximum;\n    46   \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    47   \t\t\tif(p->value.i32 == 0){\n    48   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    49   \t\t\t}\n    50   \t\t\tcontext->maximum_packet_size = p->value.i32;\n    51   \t\t}\n    52   \t\tp = p->next;\n    53   \t}\n    56   }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__read\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:35\n    35   static int property__read(struct mosquitto__packet *packet, uint32_t *len, mosquitto_property *property)\n    36   {\n    38   \tuint32_t property_identifier;\n    39   \tuint8_t byte;\n    40   \tuint8_t byte_count;\n    41   \tuint16_t uint16;\n    42   \tuint32_t uint32;\n    43   \tuint32_t varint;\n    44   \tchar *str1, *str2;\n    45   \tuint16_t slen1, slen2;\n    47   \tif(!property) return MOSQ_ERR_INVAL;\n    49   \trc = packet__read_varint(packet, &property_identifier, NULL);\n    50   \tif(rc){\n    51   \t\treturn rc;\n    52   \t}\n    55   \tmemset(property, 0, sizeof(mosquitto_property));\n    57   \tproperty->identifier = (int32_t)property_identifier;\n    59   \tswitch(property_identifier){\n    60   \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    61   \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    62   \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    63   \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    64   \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    65   \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    66   \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    67   \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    68   \t\t\trc = packet__read_byte(packet, &byte);\n    69   \t\t\tif(rc) return rc;\n    71   \t\t\tproperty->value.i8 = byte;\n    72   \t\t\tbreak;\n    74   \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    75   \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    76   \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    77   \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    78   \t\t\trc = packet__read_uint16(packet, &uint16);\n    79   \t\t\tif(rc) return rc;\n    81   \t\t\tproperty->value.i16 = uint16;\n    82   \t\t\tbreak;\n    84   \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    85   \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    86   \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    87   \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    88   \t\t\trc = packet__read_uint32(packet, &uint32);\n    89   \t\t\tif(rc) return rc;\n    91   \t\t\tproperty->value.i32 = uint32;\n    92   \t\t\tbreak;\n    94   \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    95   \t\t\trc = packet__read_varint(packet, &varint, &byte_count);\n    96   \t\t\tif(rc) return rc;\n    98   \t\t\tproperty->value.varint = varint;\n    99   \t\t\tbreak;\n    101  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    102  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    103  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    104  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    105  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    106  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    107  \t\tcase MQTT_PROP_REASON_STRING:\n    108  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    109  \t\t\tif(rc) return rc;\n    111  \t\t\tproperty->value.s.v = str1;\n    112  \t\t\tproperty->value.s.len = slen1;\n    113  \t\t\tbreak;\n    115  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    116  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    117  \t\t\trc = packet__read_binary(packet, (uint8_t **)&str1, &slen1);\n    118  \t\t\tif(rc) return rc;\n    120  \t\t\tproperty->value.bin.v = str1;\n    121  \t\t\tproperty->value.bin.len = slen1;\n    122  \t\t\tbreak;\n    124  \t\tcase MQTT_PROP_USER_PROPERTY:\n    125  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    126  \t\t\tif(rc) return rc;\n    129  \t\t\trc = packet__read_string(packet, &str2, &slen2);\n    130  \t\t\tif(rc){\n    131  \t\t\t\tmosquitto__free(str1);\n    132  \t\t\t\treturn rc;\n    133  \t\t\t}\n    136  \t\t\tproperty->name.v = str1;\n    137  \t\t\tproperty->name.len = slen1;\n    138  \t\t\tproperty->value.s.v = str2;\n    139  \t\t\tproperty->value.s.len = slen2;\n    140  \t\t\tbreak;\n    142  \t\tdefault:\n    144  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property_identifier);\n    146  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    147  \t}\n    150  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: mosquitto_property_add_byte\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:716\n    716  int mosquitto_property_add_byte(mosquitto_property **proplist, int identifier, uint8_t value)\n    717  {\n    736  \tprop->identifier = identifier;\n    737  \tprop->value.i8 = value;\n    739  \tproperty__add(proplist, prop);\n    741  }\nFunction: db__expire_all_messages\nPath: /root/projects/mosquitto/src/database.c:1053\n    1053 void db__expire_all_messages(struct mosquitto *context)\n    1055 \tstruct mosquitto_client_msg *msg, *tmp;\n    1057 \tDL_FOREACH_SAFE(context->msgs_out.inflight, msg, tmp){\n    1058 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1059 \t\t\tif(msg->qos > 0){\n    1060 \t\t\t\tutil__increment_send_quota(context);\n    1062 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1065 \tDL_FOREACH_SAFE(context->msgs_out.queued, msg, tmp){\n    1066 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1067 \t\t\tdb__message_remove_from_queued(&context->msgs_out, msg);\n    1070 \tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n    1071 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1072 \t\t\tif(msg->qos > 0){\n    1073 \t\t\t\tutil__increment_receive_quota(context);\n    1075 \t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n    1078 \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n    1079 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1080 \t\t\tdb__message_remove_from_queued(&context->msgs_in, msg);\n    1083 }\nFunction: db__message_remove_from_queued\nPath: /root/projects/mosquitto/src/database.c:364\n    364  static void db__message_remove_from_queued(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    365  {\n    366  \tif(!msg_data || !item){\n    367  \t\treturn;\n    368  \t}\n    370  \tDL_DELETE(msg_data->queued, item);\n    377  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1183 \tstruct mosquitto_client_msg *tail, *tmp;\n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1190 \tDL_FOREACH_SAFE(context->msgs_out.inflight, tail, tmp){\n    1191 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1192 \t\tif(rc) return rc;\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    143  \t\t\t\tin_quota = context->msgs_in.inflight_quota;\n    144  \t\t\t\tout_quota = context->msgs_out.inflight_quota;\n    145  \t\t\t\tin_maximum = context->msgs_in.inflight_maximum;\n    146  \t\t\t\tout_maximum = context->msgs_out.inflight_maximum;\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    154  \t\t\t\tcontext->msgs_in.inflight_quota = in_quota;\n    155  \t\t\t\tcontext->msgs_out.inflight_quota = out_quota;\n    156  \t\t\t\tcontext->msgs_in.inflight_maximum = in_maximum;\n    157  \t\t\t\tcontext->msgs_out.inflight_maximum = out_maximum;\n    159  \t\t\t\tdb__message_reconnect_reset(context);\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    215  \trc = acl__find_acls(context);\n    216  \tif(rc){\n    218  \t\treturn rc;\n    219  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    250  \t}\n    252  \tcontext->ping_t = 0;\n    253  \tcontext->is_dropping = false;\n    255  \tconnection_check_acl(context, &context->msgs_in.inflight);\n    256  \tconnection_check_acl(context, &context->msgs_in.queued);\n    257  \tconnection_check_acl(context, &context->msgs_out.inflight);\n    258  \tconnection_check_acl(context, &context->msgs_out.queued);\n    260  \tcontext__add_to_by_id(context);\n    263  \tif(!context->clean_start){\n    267  \tcontext->max_qos = context->listener->max_qos;\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    315  \tkeepalive__add(context);\n    317  \tmosquitto__set_state(context, mosq_cs_active);\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    320  \tif(rc) return rc;\n    321  \tdb__expire_all_messages(context);\n    322  \trc = db__message_write_queued_out(context);\n    323  \tif(rc) return rc;\n    324  \trc = db__message_write_inflight_out_all(context);\n    330  }\nFunction: connection_check_acl\nPath: /root/projects/mosquitto/src/handle_connect.c:86\n    86   static void connection_check_acl(struct mosquitto *context, struct mosquitto_client_msg **head)\n    97   \t\tif(mosquitto_acl_check(context, msg_tail->store->topic,\n    99   \t\t\t\t\t\t\t   msg_tail->store->qos, msg_tail->store->retain, access) != MOSQ_ERR_SUCCESS){\n    101  \t\t\tDL_DELETE((*head), msg_tail);\n    107  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    248  \tmosquitto__set_state(context, mosq_cs_disused);\n    250  \tif(context->id){\n    251  \t\tcontext__remove_from_by_id(context);\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    256  \tcontext->for_free_next = db.ll_for_free;\n    257  \tdb.ll_for_free = context;\n    258  }\nFunction: db__msg_add_to_queued_stats\nPath: /root/projects/mosquitto/src/database.c:162\n    162  void db__msg_add_to_queued_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    163  {\n    164  \tmsg_data->queued_count++;\n    165  \tmsg_data->queued_bytes += msg->store->payloadlen;\n    166  \tif(msg->qos != 0){\n    167  \t\tmsg_data->queued_count12++;\n    168  \t\tmsg_data->queued_bytes12 += msg->store->payloadlen;\n    169  \t}\n    170  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    271  \tmosquitto__free(store->source_id);\n    272  \tmosquitto__free(store->source_username);\n    283  }\nFunction: db__message_remove_from_inflight\nPath: /root/projects/mosquitto/src/database.c:347\n    347  static void db__message_remove_from_inflight(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    348  {\n    349  \tif(!msg_data || !item){\n    350  \t\treturn;\n    351  \t}\n    353  \tDL_DELETE(msg_data->inflight, item);\n    354  \tif(item->store){\n    355  \t\tdb__msg_remove_from_inflight_stats(msg_data, item);\n    357  \t}\n    361  }\nFunction: db__message_write_inflight_out_latest\nPath: /root/projects/mosquitto/src/database.c:1198\n    1198 int db__message_write_inflight_out_latest(struct mosquitto *context)\n    1199 {\n    1200 \tstruct mosquitto_client_msg *tail, *next;\n    1203 \tif(context->state != mosq_cs_active\n    1204 \t\t\t|| context->sock == INVALID_SOCKET\n    1205 \t\t\t|| context->msgs_out.inflight == NULL){\n    1207 \t\treturn MOSQ_ERR_SUCCESS;\n    1208 \t}\n    1210 \tif(context->msgs_out.inflight->prev == context->msgs_out.inflight){\n    1212 \t\treturn db__message_write_inflight_out_single(context, context->msgs_out.inflight);\n    1213 \t}\n    1217 \ttail = context->msgs_out.inflight->prev;\n    1218 \twhile(tail != context->msgs_out.inflight &&\n    1219 \t\t\t(tail->state == mosq_ms_publish_qos0\n    1220 \t\t\t || tail->state == mosq_ms_publish_qos1\n    1221 \t\t\t || tail->state == mosq_ms_publish_qos2)){\n    1223 \t\ttail = tail->prev;\n    1224 \t}\n    1229 \tif(tail != context->msgs_out.inflight){\n    1230 \t\ttail = tail->next;\n    1231 \t}\n    1233 \twhile(tail){\n    1234 \t\tnext = tail->next;\n    1235 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1236 \t\tif(rc) return rc;\n    1238 \t}\n    1240 }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1097 \tuint32_t expiry_interval;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1103 \t\t\tif(msg->direction == mosq_md_out && msg->qos > 0){\n    1104 \t\t\t\tutil__increment_send_quota(context);\n    1105 \t\t\t}\n    1106 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1126 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1135 \t\t\t\tmsg->timestamp = db.now_s;\n    1136 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1137 \t\t\t\tmsg->state = mosq_ms_wait_for_puback;\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1139 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1148 \t\t\t\tmsg->timestamp = db.now_s;\n    1149 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1150 \t\t\t\tmsg->state = mosq_ms_wait_for_pubrec;\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1152 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1159 \t\t\trc = send__pubrel(context, mid, NULL);\n    1160 \t\t\tif(!rc){\n    1161 \t\t\t\tmsg->state = mosq_ms_wait_for_pubcomp;\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1176 \t}\n    1178 }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    449  \tstruct mosquitto_msg_data *msg_data;\n    450  \tenum mosquitto_msg_state state = mosq_ms_invalid;\n    452  \tint i;\n    457  \tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n    459  \tif(dir == mosq_md_out){\n    460  \t\tmsg_data = &context->msgs_out;\n    461  \t}else{\n    462  \t\tmsg_data = &context->msgs_in;\n    463  \t}\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    484  \tif(context->sock == INVALID_SOCKET){\n    486  \t\tif(qos == 0 && !db.config->queue_qos0_messages){\n    487  \t\t\tif(!context->bridge){\n    489  \t\t\t\treturn 2;\n    490  \t\t\t}else{\n    491  \t\t\t\tif(context->bridge->start_type != bst_lazy){\n    493  \t\t\t\t\treturn 2;\n    494  \t\t\t\t}\n    495  \t\t\t}\n    496  \t\t}\n    497  \t\tif(context->bridge && context->bridge->clean_start_local == true){\n    499  \t\t\treturn 2;\n    500  \t\t}\n    501  \t}\n    503  \tif(context->sock != INVALID_SOCKET){\n    504  \t\tif(db__ready_for_flight(context, dir, qos)){\n    517  \t\t\t}else{\n    520  \t\t\t\t}else{\n    522  \t\t\t\t\treturn 1;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n    528  \t\t}else{\n    530  \t\t\tif(context->is_dropping == false){\n    531  \t\t\t\tcontext->is_dropping = true;\n    532  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    534  \t\t\t\t\t\tcontext->id);\n    535  \t\t\t}\n    538  \t\t\treturn 2;\n    539  \t\t}\n    540  \t}else{\n    541  \t\tif (db__ready_for_queue(context, qos, msg_data)){\n    543  \t\t}else{\n    545  \t\t\tif(context->is_dropping == false){\n    546  \t\t\t\tcontext->is_dropping = true;\n    547  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    549  \t\t\t\t\t\tcontext->id);\n    550  \t\t\t}\n    552  \t\t\treturn 2;\n    553  \t\t}\n    554  \t}\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    582  \tif(state == mosq_ms_queued){\n    583  \t\tDL_APPEND(msg_data->queued, msg);\n    585  \t}else{\n    586  \t\tDL_APPEND(msg_data->inflight, msg);\n    588  \t}\n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    598  \t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n    599  \t\tif(dest_ids){\n    602  \t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t}\n    609  \t}\n    611  \tif(context->bridge && context->bridge->start_type == bst_lazy\n    612  \t\t\t&& context->sock == INVALID_SOCKET\n    613  \t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n    616  \t}\n    633  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    704  \tstruct mosquitto_msg_store *stored;\n    705  \tconst char *source_id;\n    706  \tenum mosquitto_msg_origin origin;\n    710  \tstored = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    711  \tif(stored == NULL) return MOSQ_ERR_NOMEM;\n    713  \tstored->topic = mosquitto__strdup(topic);\n    714  \tif(stored->topic == NULL){\n    715  \t\tdb__msg_store_free(stored);\n    716  \t\treturn MOSQ_ERR_INVAL;\n    717  \t}\n    719  \tstored->qos = qos;\n    720  \tif(db.config->retain_available == false){\n    721  \t\tstored->retain = 0;\n    722  \t}else{\n    723  \t\tstored->retain = retain;\n    724  \t}\n    726  \tstored->payloadlen = payloadlen;\n    727  \tif(payloadlen > 0){\n    728  \t\tstored->payload = mosquitto__malloc(stored->payloadlen+1);\n    729  \t\tif(stored->payload == NULL){\n    730  \t\t\tdb__msg_store_free(stored);\n    731  \t\t\treturn MOSQ_ERR_NOMEM;\n    732  \t\t}\n    734  \t\t((uint8_t *)stored->payload)[stored->payloadlen] = 0;\n    735  \t\tmemcpy(stored->payload, payload, stored->payloadlen);\n    736  \t}\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    746  \t}\n    748  \tif(context){\n    750  \t}else{\n    753  \tif(db__message_store(context, stored, message_expiry_interval, 0, origin)) return 1;\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    763  \tif(source && source->id){\n    764  \t\tstored->source_id = mosquitto__strdup(source->id);\n    765  \t}else{\n    766  \t\tstored->source_id = mosquitto__strdup(\"\");\n    767  \t}\n    768  \tif(!stored->source_id){\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    774  \tif(source && source->username){\n    775  \t\tstored->source_username = mosquitto__strdup(source->username);\n    776  \t\tif(!stored->source_username){\n    778  \t\t\treturn MOSQ_ERR_NOMEM;\n    779  \t\t}\n    780  \t}\n    781  \tif(source){\n    782  \t\tstored->source_listener = source->listener;\n    783  \t}\n    806  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    436  \tuint8_t username_flag, password_flag;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    448  \tX509 *client_cert = NULL;\n    460  \tif(!context->listener){\n    461  \t\treturn MOSQ_ERR_INVAL;\n    462  \t}\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    502  \t\tcontext->protocol = mosq_p_mqtt31;\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    504  \t\t\tcontext->is_bridge = true;\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    508  \t\t\tcontext->protocol = mosq_p_mqtt311;\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    511  \t\t\t\tcontext->is_bridge = true;\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    514  \t\t\tcontext->protocol = mosq_p_mqtt5;\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    563  \t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid Will QoS in CONNECT from %s.\",\n    564  \t\t\t\tcontext->address);\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    699  \t\t\trc = MOSQ_ERR_NOMEM;\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    703  \t\t\t\t/* Password flag given, but no password. Ignore. */\n    704  \t\t\t}else{\n    705  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    724  \tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    731  \t\tif(!context->ssl){\n    732  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    741  \t\tif(context->listener->psk_hint){\n    743  \t\t\tif(!context->username){\n    744  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    754  \t\t\tclient_cert = SSL_get_peer_certificate(context->ssl);\n    755  \t\t\tif(!client_cert){\n    756  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    764  \t\t\tname = X509_get_subject_name(client_cert);\n    765  \t\t\tif(!name){\n    766  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    774  \t\t\tif (context->listener->use_identity_as_username) { /* use_identity_as_username */\n    775  \t\t\t\ti = X509_NAME_get_index_by_NID(name, NID_commonName, -1);\n    776  \t\t\t\tif(i == -1){\n    777  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    785  \t\t\t\tname_entry = X509_NAME_get_entry(name, i);\n    786  \t\t\t\tif(name_entry){\n    787  \t\t\t\t\tname_asn1 = X509_NAME_ENTRY_get_data(name_entry);\n    788  \t\t\t\t\tif (name_asn1 == NULL) {\n    789  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    801  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_get0_data(name_asn1);\n    803  \t\t\t\t\tif(mosquitto_validate_utf8(new_username, (int)strlen(new_username))){\n    804  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    809  \t\t\t\t\t\tX509_free(client_cert);\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    814  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    824  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    835  \t\t\t\tX509_NAME_print_ex(subject_bio, X509_get_subject_name(client_cert), 0, XN_FLAG_RFC2253);\n    847  \t\t\t\tcontext->username = subject;\n    849  \t\t\tif(!context->username){\n    853  \t\t\tX509_free(client_cert);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    898  \t\t\tmosquitto__set_state(context, mosq_cs_authenticating);\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    905  \t\t\twill__clear(context);\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    925  \t\tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    973  \tif(client_cert) X509_free(client_cert);\n    976  \tcontext->clean_start = true;\n    977  \tcontext->session_expiry_interval = 0;\n    978  \tcontext->will_delay_interval = 0;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    55   \tint i;\n    56   \tint pos;\n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    335  \tint rc = MOSQ_ERR_SUCCESS;\n    337  \tuint16_t tlen;\n    340  \tuint16_t payloadlen;\n    341  \tmosquitto_property *properties = NULL;\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    349  \t\trc = property__read_all(CMD_WILL, &context->in_packet, &properties);\n    350  \t\tif(rc) goto error_cleanup;\n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    353  \t\tmosquitto_property_free_all(&properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    356  \trc = packet__read_string(&context->in_packet, &will_struct->msg.topic, &tlen);\n    357  \tif(rc) goto error_cleanup;\n    363  \tif(context->listener->mount_point){\n    364  \t\tslen = strlen(context->listener->mount_point) + strlen(will_struct->msg.topic) + 1;\n    365  \t\twill_topic_mount = mosquitto__malloc(slen+1);\n    366  \t\tif(!will_topic_mount){\n    368  \t\t\tgoto error_cleanup;\n    369  \t\t}\n    371  \t\tsnprintf(will_topic_mount, slen, \"%s%s\", context->listener->mount_point, will_struct->msg.topic);\n    372  \t\twill_topic_mount[slen] = '\\0';\n    374  \t\tmosquitto__free(will_struct->msg.topic);\n    375  \t\twill_struct->msg.topic = will_topic_mount;\n    376  \t}\n    378  \tif(!strncmp(will_struct->msg.topic, \"$CONTROL/\", strlen(\"$CONTROL/\"))){\n    380  \t\tgoto error_cleanup;\n    381  \t}\n    382  \trc = mosquitto_pub_topic_check(will_struct->msg.topic);\n    385  \trc = packet__read_uint16(&context->in_packet, &payloadlen);\n    386  \tif(rc) goto error_cleanup;\n    388  \twill_struct->msg.payloadlen = payloadlen;\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    391  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Client %s connected with too large Will payload\", client_id);\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    393  \t\t\t\tsend__connack(context, 0, MQTT_RC_PACKET_TOO_LARGE, NULL);\n    394  \t\t\t}else{\n    395  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    396  \t\t\t}\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    400  \t\twill_struct->msg.payload = mosquitto__malloc((size_t)will_struct->msg.payloadlen);\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    406  \t\trc = packet__read_bytes(&context->in_packet, will_struct->msg.payload, (uint32_t)will_struct->msg.payloadlen);\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    416  error_cleanup:\n    417  \tif(will_struct){\n    418  \t\tmosquitto__free(will_struct->msg.topic);\n    419  \t\tmosquitto__free(will_struct->msg.payload);\n    422  \t}\n    424  }\nFunction: net__write\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:996\n    996  ssize_t net__write(struct mosquitto *mosq, const void *buf, size_t count)\n    997  {\n    999  \tint ret;\n    1001 \tassert(mosq);\n    1005 \tif(mosq->ssl){\n    1007 \t\tmosq->want_write = false;\n    1008 \t\tret = SSL_write(mosq->ssl, buf, (int)count);\n    1009 \t\tif(ret < 0){\n    1010 \t\t\tret = net__handle_ssl(mosq, ret);\n    1011 \t\t}\n    1012 \t\treturn (ssize_t )ret;\n    1013 \t}else{\n    1017 \treturn send(mosq->sock, buf, count, MSG_NOSIGNAL);\n    1020 \t}\n    1022 }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    51   \tassert(packet);\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    73   \tassert(packet);\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    157  \tassert(packet);\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    371  \t\tmux__delete(context);\n    372  \t\tcontext__disconnect(context);\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto__malloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:83\n    83   void *mosquitto__malloc(size_t size)\n    84   {\n    88   \tif(mem_limit && memcount + size > mem_limit){\n    89   \t\treturn NULL;\n    90   \t}\n    93   \tmem = malloc(size);\n    96   \tif(mem){\n    97   \t\tmemcount += malloc_usable_size(mem);\n    101  \t}\n    105  }\nFunction: mosquitto__strdup\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:144\n    144  char *mosquitto__strdup(const char *s)\n    145  {\n    148  \tif(mem_limit && memcount + strlen(s) > mem_limit){\n    149  \t\treturn NULL;\n    150  \t}\n    152  \tstr = strdup(s);\n    155  \tif(str){\n    156  \t\tmemcount += malloc_usable_size(str);\n    160  \t}\n    164  }\nFunction: mux__delete\nPath: /root/projects/mosquitto/src/mux.c:61\n    61   int mux__delete(struct mosquitto *context)\n    64   \treturn mux_epoll__delete(context);\n    68   }\nFunction: send__auth\nPath: /root/projects/mosquitto/src/send_auth.c:28\n    28   int send__auth(struct mosquitto *context, uint8_t reason_code, const void *auth_data, uint16_t auth_data_len)\n    29   {\n    32   \tmosquitto_property *properties = NULL;\n    35   \tif(context->auth_method == NULL) return MOSQ_ERR_INVAL;\n    36   \tif(context->protocol != mosq_p_mqtt5) return MOSQ_ERR_PROTOCOL;\n    38   \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending AUTH to %s (rc%d, %s)\", context->id, reason_code, context->auth_method);\n    42   \trc = mosquitto_property_add_string(&properties, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method);\n    43   \tif(rc){\n    45   \t\treturn rc;\n    46   \t}\n    56   \tremaining_length += property__get_remaining_length(properties);\n    58   \tif(packet__check_oversize(context, remaining_length)){\n    61   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    62   \t}\n    67   \tpacket->command = CMD_AUTH;\n    68   \tpacket->remaining_length = remaining_length;\n    70   \trc = packet__alloc(packet);\n    76   \tpacket__write_byte(packet, reason_code);\n    77   \tproperty__write_all(packet, properties, true);\n    80   \treturn packet__queue(context, packet);\n    81   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    32   \tmosquitto_property *connack_props = NULL;\n    33   \tuint32_t remaining_length;\n    35   \trc = mosquitto_property_copy_all(&connack_props, properties);\n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    43   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->address, ack, reason_code);\n    44   \t}\n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    51   \t\t\tif(rc){\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    58   \t\t\tif(rc){\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    65   \t\t\tif(rc){\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    71   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_MAXIMUM_QOS, context->listener->max_qos);\n    72   \t\t\tif(rc){\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    78   \t\tremaining_length += property__get_remaining_length(connack_props);\n    79   \t}\n    81   \tif(packet__check_oversize(context, remaining_length)){\n    83   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    84   \t}\n    92   \tpacket->command = CMD_CONNACK;\n    93   \tpacket->remaining_length = remaining_length;\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    105  \t}\n    108  \treturn packet__queue(context, packet);\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    42   \tassert(mosq);\n    45   \tif(mosq->bridge){\n    46   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Bridge %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    47   \t}else\n    56   \tassert(mosq);\n    60   \tpacket->command = CMD_DISCONNECT;\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    62   \t\tpacket->remaining_length = 1;\n    63   \t\tif(properties){\n    64   \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    65   \t\t}\n    66   \t}else{\n    67   \t\tpacket->remaining_length = 0;\n    68   \t}\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    80   \t}\n    82   \treturn packet__queue(mosq, packet);\n    83   }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    126  \tassert(mosq);\n    130  \tpacket->command = command;\n    131  \tif(dup){\n    132  \t\tpacket->command |= 8;\n    133  \t}\n    134  \tpacket->remaining_length = 2;\n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    137  \t\tif(reason_code != 0 || properties){\n    138  \t\t\tpacket->remaining_length += 1;\n    139  \t\t}\n    141  \t\tif(properties){\n    142  \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    143  \t\t}\n    144  \t}\n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    161  \t}\n    163  \treturn packet__queue(mosq, packet);\n    164  }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    117  \treturn send__command_with_mid(mosq, CMD_PUBREL|2, mid, false, 0, properties);\n    118  }\nFunction: send__publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:42\n    42   int send__publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    43   {\n    47   \tint i;\n    49   \tbool match;\n    51   \tchar *mapped_topic = NULL;\n    55   \tassert(mosq);\n    60   \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    63   \tif(!mosq->retain_available){\n    65   \t}\n    68   \tif(mosq->listener && mosq->listener->mount_point){\n    69   \t\tlen = strlen(mosq->listener->mount_point);\n    70   \t\tif(len < strlen(topic)){\n    71   \t\t\ttopic += len;\n    72   \t\t}else{\n    74   \t\t\treturn MOSQ_ERR_SUCCESS;\n    75   \t\t}\n    76   \t}\n    78   \tif(mosq->bridge && mosq->bridge->topics && mosq->bridge->topic_remapping){\n    79   \t\tfor(i=0; i<mosq->bridge->topic_count; i++){\n    80   \t\t\tcur_topic = &mosq->bridge->topics[i];\n    81   \t\t\tif((cur_topic->direction == bd_both || cur_topic->direction == bd_out)\n    82   \t\t\t\t\t&& (cur_topic->remote_prefix || cur_topic->local_prefix)){\n    85   \t\t\t\trc = mosquitto_topic_matches_sub(cur_topic->local_topic, topic, &match);\n    86   \t\t\t\tif(rc){\n    87   \t\t\t\t\treturn rc;\n    88   \t\t\t\t}\n    89   \t\t\t\tif(match){\n    90   \t\t\t\t\tmapped_topic = mosquitto__strdup(topic);\n    91   \t\t\t\t\tif(!mapped_topic) return MOSQ_ERR_NOMEM;\n    92   \t\t\t\t\tif(cur_topic->local_prefix){\n    94   \t\t\t\t\t\tif(!strncmp(cur_topic->local_prefix, mapped_topic, strlen(cur_topic->local_prefix))){\n    95   \t\t\t\t\t\t\ttopic_temp = mosquitto__strdup(mapped_topic+strlen(cur_topic->local_prefix));\n    96   \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    97   \t\t\t\t\t\t\tif(!topic_temp){\n    98   \t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    99   \t\t\t\t\t\t\t}\n    101  \t\t\t\t\t\t}\n    102  \t\t\t\t\t}\n    104  \t\t\t\t\tif(cur_topic->remote_prefix){\n    106  \t\t\t\t\t\tlen = strlen(mapped_topic) + strlen(cur_topic->remote_prefix)+1;\n    107  \t\t\t\t\t\ttopic_temp = mosquitto__malloc(len+1);\n    108  \t\t\t\t\t\tif(!topic_temp){\n    109  \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    110  \t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    111  \t\t\t\t\t\t}\n    112  \t\t\t\t\t\tsnprintf(topic_temp, len, \"%s%s\", cur_topic->remote_prefix, mapped_topic);\n    113  \t\t\t\t\t\ttopic_temp[len] = '\\0';\n    114  \t\t\t\t\t\tmosquitto__free(mapped_topic);\n    116  \t\t\t\t\t}\n    117  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, mapped_topic, (long)payloadlen);\n    119  \t\t\t\t\trc =  send__real_publish(mosq, mid, mapped_topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    120  \t\t\t\t\tmosquitto__free(mapped_topic);\n    121  \t\t\t\t\treturn rc;\n    122  \t\t\t\t}\n    123  \t\t\t}\n    124  \t\t}\n    125  \t}\n    127  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, topic, (long)payloadlen);\n    133  \treturn send__real_publish(mosq, mid, topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    134  }\nFunction: send__real_publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:137\n    137  int send__real_publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    138  {\n    140  \tunsigned int packetlen;\n    141  \tunsigned int proplen = 0, varbytes;\n    143  \tmosquitto_property expiry_prop;\n    145  \tassert(mosq);\n    147  \tif(topic){\n    148  \t\tpacketlen = 2+(unsigned int)strlen(topic) + payloadlen;\n    149  \t}else{\n    150  \t\tpacketlen = 2 + payloadlen;\n    151  \t}\n    152  \tif(qos > 0) packetlen += 2; /* For message id */\n    153  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tproplen += property__get_length_all(cmsg_props);\n    156  \t\tproplen += property__get_length_all(store_props);\n    157  \t\tif(expiry_interval > 0){\n    158  \t\t\texpiry_prop.next = NULL;\n    160  \t\t\texpiry_prop.identifier = MQTT_PROP_MESSAGE_EXPIRY_INTERVAL;\n    163  \t\t\tproplen += property__get_length_all(&expiry_prop);\n    164  \t\t}\n    166  \t\tvarbytes = packet__varint_bytes(proplen);\n    172  \t\t}else{\n    173  \t\t\tpacketlen += proplen + varbytes;\n    174  \t\t}\n    175  \t}\n    176  \tif(packet__check_oversize(mosq, packetlen)){\n    178  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Dropping too large outgoing PUBLISH for %s (%d bytes)\", SAFE_PRINT(mosq->id), packetlen);\n    182  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    183  \t}\n    189  \tpacket->command = (uint8_t)(CMD_PUBLISH | (uint8_t)((dup&0x1)<<3) | (uint8_t)(qos<<1) | retain);\n    190  \tpacket->remaining_length = packetlen;\n    206  \tif(mosq->protocol == mosq_p_mqtt5){\n    213  \t}\n    220  \treturn packet__queue(mosq, packet);\n    221  }\nFunction: session_expiry__cmp\nPath: /root/projects/mosquitto/src/session_expiry.c:34\n    34   static int session_expiry__cmp(struct session_expiry_list *i1, struct session_expiry_list *i2)\n    35   {\n    36   \tif(i1->context->session_expiry_time == i2->context->session_expiry_time){\n    37   \t\treturn 0;\n    38   \t}else if(i1->context->session_expiry_time > i2->context->session_expiry_time){\n    39   \t\treturn 1;\n    40   \t}else{\n    41   \t\treturn -1;\n    42   \t}\n    43   }\nFunction: session_expiry__remove\nPath: /root/projects/mosquitto/src/session_expiry.c:121\n    121  void session_expiry__remove(struct mosquitto *context)\n    122  {\n    123  \tif(context->expiry_list_item){\n    124  \t\tDL_DELETE(expiry_list, context->expiry_list_item);\n    125  \t\tmosquitto__free(context->expiry_list_item);\n    126  \t\tcontext->expiry_list_item = NULL;\n    127  \t}\n    128  }\nFunction: acl__check_single\nPath: /root/projects/mosquitto/src/security.c:602\n    602  static int acl__check_single(struct mosquitto__auth_plugin_config *auth_plugin, struct mosquitto *context, struct mosquitto_acl_msg *msg, int access)\n    603  {\n    607  \tusername = mosquitto_client_username(context);\n    608  \tif(auth_plugin->deny_special_chars == true){\n    615  \t\tif(username && strpbrk(username, \"+#\")){\n    616  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous username \\\"%s\\\"\", username);\n    617  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    618  \t\t}\n    619  \t\tif(context->id && strpbrk(context->id, \"+#\")){\n    620  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous client id \\\"%s\\\"\", context->id);\n    621  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    622  \t\t}\n    623  \t}\n    625  \tif(auth_plugin->plugin.version == 4){\n    626  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    627  \t\t\treturn MOSQ_ERR_SUCCESS;\n    628  \t\t}\n    629  \t\treturn auth_plugin->plugin.acl_check_v4(auth_plugin->plugin.user_data, access, context, msg);\n    630  \t}else if(auth_plugin->plugin.version == 3){\n    631  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    632  \t\t\treturn MOSQ_ERR_SUCCESS;\n    633  \t\t}\n    634  \t\treturn auth_plugin->plugin.acl_check_v3(auth_plugin->plugin.user_data, access, context, msg);\n    635  \t}else if(auth_plugin->plugin.version == 2){\n    636  \t\tif(access == MOSQ_ACL_SUBSCRIBE || access == MOSQ_ACL_UNSUBSCRIBE){\n    637  \t\t\treturn MOSQ_ERR_SUCCESS;\n    638  \t\t}\n    639  \t\treturn auth_plugin->plugin.acl_check_v2(auth_plugin->plugin.user_data, context->id, username, topic, access);\n    640  \t}else{\n    641  \t\treturn MOSQ_ERR_INVAL;\n    642  \t}\n    643  }\nFunction: mosquitto_unpwd_check\nPath: /root/projects/mosquitto/src/security.c:755\n    755  int mosquitto_unpwd_check(struct mosquitto *context)\n    756  {\n    757  \tint rc;\n    758  \tint i;\n    759  \tstruct mosquitto__security_options *opts;\n    760  \tstruct mosquitto_evt_basic_auth event_data;\n    761  \tstruct mosquitto__callback *cb_base;\n    762  \tbool plugin_used = false;\n    766  \tif(db.config->per_listener_settings){\n    767  \t\tif(context->listener == NULL){\n    768  \t\t\treturn MOSQ_ERR_AUTH;\n    769  \t\t}\n    770  \t\topts = &context->listener->security_options;\n    771  \t}else{\n    772  \t\topts = &db.config->security_options;\n    773  \t}\n    775  \tDL_FOREACH(opts->plugin_callbacks.basic_auth, cb_base){\n    777  \t\tevent_data.client = context;\n    778  \t\tevent_data.username = context->username;\n    779  \t\tevent_data.password = context->password;\n    780  \t\trc = cb_base->cb(MOSQ_EVT_BASIC_AUTH, &event_data, cb_base->userdata);\n    781  \t\tif(rc != MOSQ_ERR_PLUGIN_DEFER){\n    787  \tfor(i=0; i<opts->auth_plugin_config_count; i++){\n    788  \t\tif(opts->auth_plugin_configs[i].plugin.version == 4\n    789  \t\t\t\t&& opts->auth_plugin_configs[i].plugin.unpwd_check_v4){\n    791  \t\t\trc = opts->auth_plugin_configs[i].plugin.unpwd_check_v4(\n    792  \t\t\t\t\topts->auth_plugin_configs[i].plugin.user_data,\n    794  \t\t\t\t\tcontext->username,\n    795  \t\t\t\t\tcontext->password);\n    798  \t\t}else if(opts->auth_plugin_configs[i].plugin.version == 3){\n    799  \t\t\trc = opts->auth_plugin_configs[i].plugin.unpwd_check_v3(\n    800  \t\t\t\t\topts->auth_plugin_configs[i].plugin.user_data,\n    802  \t\t\t\t\tcontext->username,\n    803  \t\t\t\t\tcontext->password);\n    806  \t\t}else if(opts->auth_plugin_configs[i].plugin.version == 2){\n    807  \t\t\trc = opts->auth_plugin_configs[i].plugin.unpwd_check_v2(\n    808  \t\t\t\t\topts->auth_plugin_configs[i].plugin.user_data,\n    809  \t\t\t\t\tcontext->username,\n    810  \t\t\t\t\tcontext->password);\n    812  \t\t}\n    813  \t}\n    817  \tif(plugin_used == false){\n    818  \t\tif((db.config->per_listener_settings && context->listener->security_options.allow_anonymous != false)\n    819  \t\t\t\t|| (!db.config->per_listener_settings && db.config->security_options.allow_anonymous != false)){\n    821  \t\t\treturn MOSQ_ERR_SUCCESS;\n    822  \t\t}else{\n    823  \t\t\treturn MOSQ_ERR_AUTH;\n    824  \t\t}\n    825  \t}else{\n    826  \t\tif(rc == MOSQ_ERR_PLUGIN_DEFER){\n    827  \t\t\tif(context->username == NULL &&\n    828  \t\t\t\t\t((db.config->per_listener_settings && context->listener->security_options.allow_anonymous != false)\n    829  \t\t\t\t\t|| (!db.config->per_listener_settings && db.config->security_options.allow_anonymous != false))){\n    831  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    832  \t\t\t}else{\n    833  \t\t\t\treturn MOSQ_ERR_AUTH;\n    834  \t\t\t}\n    835  \t\t}\n    836  \t}\n    839  }\nFunction: sub__remove_shared_leaf\nPath: /root/projects/mosquitto/src/subs.c:190\n    190  static void sub__remove_shared_leaf(struct mosquitto__subhier *subhier, struct mosquitto__subshared *shared, struct mosquitto__subleaf *leaf)\n    191  {\n    192  \tDL_DELETE(shared->subs, leaf);\n    193  \tif(shared->subs == NULL){\n    194  \t\tHASH_DELETE(hh, subhier->shared, shared);\n    195  \t\tmosquitto__free(shared->name);\n    196  \t\tmosquitto__free(shared);\n    197  \t}\n    199  }\nFunction: sub__messages_queue\nPath: /root/projects/mosquitto/src/subs.c:659\n    659  int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n    660  {\n    661  \tint rc = MOSQ_ERR_SUCCESS, rc2;\n    662  \tint rc_normal = MOSQ_ERR_NO_SUBSCRIBERS, rc_shared = MOSQ_ERR_NO_SUBSCRIBERS;\n    663  \tstruct mosquitto__subhier *subhier;\n    664  \tchar **split_topics = NULL;\n    677  \tHASH_FIND(hh, db.normal_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    678  \tif(subhier){\n    679  \t\trc_normal = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    680  \t\tif(rc_normal > 0){\n    682  \t\t\tgoto end;\n    683  \t\t}\n    684  \t}\n    686  \tHASH_FIND(hh, db.shared_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    687  \tif(subhier){\n    688  \t\trc_shared = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    689  \t\tif(rc_shared > 0){\n    691  \t\t\tgoto end;\n    692  \t\t}\n    693  \t}\n    695  \tif(rc_normal == MOSQ_ERR_NO_SUBSCRIBERS && rc_shared == MOSQ_ERR_NO_SUBSCRIBERS){\n    697  \t}\n    711  }\nFunction: sub__search\nPath: /root/projects/mosquitto/src/subs.c:479\n    479  static int sub__search(struct mosquitto__subhier *subhier, char **split_topics, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    480  {\n    482  \tstruct mosquitto__subhier *branch;\n    486  \tif(split_topics && split_topics[0]){\n    488  \t\tHASH_FIND(hh, subhier->children, split_topics[0], strlen(split_topics[0]), branch);\n    490  \t\tif(branch){\n    491  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    492  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    494  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    495  \t\t\t\treturn rc;\n    496  \t\t\t}\n    497  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    498  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    499  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    501  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    502  \t\t\t\t\treturn rc;\n    503  \t\t\t\t}\n    504  \t\t\t}\n    505  \t\t}\n    508  \t\tHASH_FIND(hh, subhier->children, \"+\", 1, branch);\n    510  \t\tif(branch){\n    511  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    512  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    514  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    515  \t\t\t\treturn rc;\n    516  \t\t\t}\n    517  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    518  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    519  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    521  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    522  \t\t\t\t\treturn rc;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}\n    526  \t}\n    529  \tHASH_FIND(hh, subhier->children, \"#\", 1, branch);\n    530  \tif(branch && !branch->children){\n    535  \t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    536  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    538  \t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    539  \t\t\treturn rc;\n    540  \t\t}\n    541  \t}\n    548  }\nFunction: subs__process\nPath: /root/projects/mosquitto/src/subs.c:129\n    129  static int subs__process(struct mosquitto__subhier *hier, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    130  {\n    133  \tstruct mosquitto__subleaf *leaf;\n    135  \trc = subs__shared_process(hier, topic, qos, retain, stored);\n    137  \tleaf = hier->subs;\n    138  \twhile(source_id && leaf){\n    139  \t\tif(!leaf->context->id || (leaf->no_local && !strcmp(leaf->context->id, source_id))){\n    140  \t\t\tleaf = leaf->next;\n    142  \t\t}\n    147  \t\tleaf = leaf->next;\n    148  \t}\n    149  \tif(hier->subs || hier->shared){\n    150  \t\treturn rc;\n    151  \t}else{\n    152  \t\treturn MOSQ_ERR_NO_SUBSCRIBERS;\n    153  \t}\n    154  }\nFunction: subs__send\nPath: /root/projects/mosquitto/src/subs.c:63\n    63   static int subs__send(struct mosquitto__subleaf *leaf, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    64   {\n    65   \tbool client_retain;\n    66   \tuint16_t mid;\n    67   \tuint8_t client_qos, msg_qos;\n    68   \tmosquitto_property *properties = NULL;\n    72   \trc2 = mosquitto_acl_check(leaf->context, topic, stored->payloadlen, stored->payload, stored->qos, stored->retain, MOSQ_ACL_READ);\n    73   \tif(rc2 == MOSQ_ERR_ACL_DENIED){\n    74   \t\treturn MOSQ_ERR_SUCCESS;\n    75   \t}else if(rc2 == MOSQ_ERR_SUCCESS){\n    76   \t\tclient_qos = leaf->qos;\n    87   \t\tif(msg_qos){\n    88   \t\t\tmid = mosquitto__mid_generate(leaf->context);\n    89   \t\t}else{\n    92   \t\tif(leaf->retain_as_published){\n    93   \t\t\tclient_retain = retain;\n    94   \t\t}else{\n    97   \t\tif(leaf->identifier){\n    98   \t\t\tmosquitto_property_add_varint(&properties, MQTT_PROP_SUBSCRIPTION_IDENTIFIER, leaf->identifier);\n    99   \t\t}\n    100  \t\tif(db__message_insert(leaf->context, mid, mosq_md_out, msg_qos, client_retain, stored, properties, true) == 1){\n    101  \t\t\treturn 1;\n    102  \t\t}\n    103  \t}else{\n    104  \t\treturn 1; /* Application error */\n    105  \t}\n    107  }\nFunction: sub__clean_session\nPath: /root/projects/mosquitto/src/subs.c:746\n    746  int sub__clean_session(struct mosquitto *context)\n    747  {\n    748  \tint i;\n    749  \tstruct mosquitto__subleaf *leaf;\n    750  \tstruct mosquitto__subhier *hier;\n    752  \tfor(i=0; i<context->sub_count; i++){\n    753  \t\tif(context->subs[i] == NULL){\n    755  \t\t}\n    757  \t\thier = context->subs[i]->hier;\n    759  \t\tif(context->subs[i]->shared){\n    760  \t\t\tleaf = context->subs[i]->shared->subs;\n    761  \t\t\twhile(leaf){\n    762  \t\t\t\tif(leaf->context==context){\n    766  \t\t\t\t\tsub__remove_shared_leaf(context->subs[i]->hier, context->subs[i]->shared, leaf);\n    768  \t\t\t\t}\n    769  \t\t\t\tleaf = leaf->next;\n    770  \t\t\t}\n    771  \t\t}else{\n    772  \t\t\tleaf = hier->subs;\n    773  \t\t\twhile(leaf){\n    774  \t\t\t\tif(leaf->context==context){\n    778  \t\t\t\t\tDL_DELETE(hier->subs, leaf);\n    779  \t\t\t\t\tmosquitto__free(leaf);\n    781  \t\t\t\t}\n    782  \t\t\t\tleaf = leaf->next;\n    783  \t\t\t}\n    784  \t\t}\n    785  \t\tmosquitto__free(context->subs[i]);\n    786  \t\tcontext->subs[i] = NULL;\n    788  \t\tif(hier->subs == NULL\n    789  \t\t\t\t&& hier->children == NULL\n    790  \t\t\t\t&& hier->shared == NULL\n    791  \t\t\t\t&& hier->parent){\n    794  \t\t\t\thier = tmp_remove_subs(hier);\n    795  \t\t\t}while(hier);\n    796  \t\t}\n    797  \t}\n    798  \tmosquitto__free(context->subs);\n    799  \tcontext->subs = NULL;\n    800  \tcontext->sub_count = 0;\n    803  }\nFunction: tmp_remove_subs\nPath: /root/projects/mosquitto/src/subs.c:715\n    715  static struct mosquitto__subhier *tmp_remove_subs(struct mosquitto__subhier *sub)\n    716  {\n    719  \tif(!sub || !sub->parent){\n    720  \t\treturn NULL;\n    721  \t}\n    723  \tif(sub->children || sub->subs){\n    724  \t\treturn NULL;\n    725  \t}\n    727  \tparent = sub->parent;\n    728  \tHASH_DELETE(hh, parent->children, sub);\n    729  \tmosquitto__free(sub->topic);\n    730  \tmosquitto__free(sub);\n    732  \tif(parent->subs == NULL\n    733  \t\t\t&& parent->children == NULL\n    734  \t\t\t&& parent->shared == NULL\n    735  \t\t\t&& parent->parent){\n    737  \t\treturn parent;\n    738  \t}else{\n    739  \t\treturn NULL;\n    740  \t}\n    741  }\nFunction: util__increment_send_quota\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:222\n    222  void util__increment_send_quota(struct mosquitto *mosq)\n    223  {\n    224  \tif(mosq->msgs_out.inflight_quota < mosq->msgs_out.inflight_maximum){\n    225  \t\tmosq->msgs_out.inflight_quota++;\n    226  \t}\n    227  }\nFunction: will_delay__remove\nPath: /root/projects/mosquitto/src/will_delay.c:99\n    99   void will_delay__remove(struct mosquitto *mosq)\n    100  {\n    101  \tif(mosq->will_delay_entry != NULL){\n    102  \t\tDL_DELETE(delay_list, mosq->will_delay_entry);\n    103  \t\tmosquitto__free(mosq->will_delay_entry);\n    104  \t\tmosq->will_delay_entry = NULL;\n    105  \t}\n    106  }\nFunction: will__clear\nPath: /root/projects/mosquitto/src/../lib/will_mosq.c:111\n    111  int will__clear(struct mosquitto *mosq)\n    112  {\n    113  \tif(!mosq->will) return MOSQ_ERR_SUCCESS;\n    115  \tmosquitto__free(mosq->will->msg.topic);\n    116  \tmosq->will->msg.topic = NULL;\n    118  \tmosquitto__free(mosq->will->msg.payload);\n    119  \tmosq->will->msg.payload = NULL;\n    121  \tmosquitto_property_free_all(&mosq->will->properties);\n    123  \tmosquitto__free(mosq->will);\n    124  \tmosq->will = NULL;\n    125  \tmosq->will_delay_interval = 0;\n    128  }\n",
    "If validation is successful and the ClientID represents a Client already connected to the Server, the Server sends a DISCONNECT packet to the existing Client with Reason Code of 0x8E (Session taken over) as described in section 4.13 and MUST close the Network Connection of the existing Client [MQTT-3.1.4-3].": "Function: context__remove_from_by_id\nPath: /root/projects/mosquitto/src/context.c:302\n    302  void context__remove_from_by_id(struct mosquitto *context)\n    303  {\n    304  \tstruct mosquitto *context_found;\n    306  \tif(context->in_by_id == true && context->id){\n    307  \t\tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), context_found);\n    308  \t\tif(context_found){\n    309  \t\t\tHASH_DELETE(hh_id, db.contexts_by_id, context_found);\n    310  \t\t}\n    312  \t}\n    313  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    208  }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    250  \t}\n    263  \tif(!context->clean_start){\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    320  \tif(rc) return rc;\n    330  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    250  \tif(context->id){\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    705  \tconst char *source_id;\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    557  \t}else{\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    976  \tcontext->clean_start = true;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    55   \tint i;\n    56   \tint pos;\n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    391  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Client %s connected with too large Will payload\", client_id);\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    424  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    54   \t*byte = packet->payload[packet->pos];\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    106  \t\t*length = 0;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    304  \t\tif(is_duplicate){\n    305  \t\t\t/* This occurs if another client is taking over the same client id.\n    306  \t\t\t * It is important to remove this from the by_id hash here, so it\n    307  \t\t\t * doesn't leave us with multiple clients in the hash with the same\n    308  \t\t\t * id. Websockets doesn't actually close the connection here,\n    309  \t\t\t * unlike for normal clients, which means there is extra time when\n    310  \t\t\t * there could be two clients with the same id in the hash. */\n    311  \t\t\tcontext__remove_from_by_id(context);\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    43   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->address, ack, reason_code);\n    44   \t}\n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    51   \t\t\tif(rc){\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    58   \t\t\tif(rc){\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    65   \t\t\tif(rc){\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    72   \t\t\tif(rc){\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    79   \t}\n    102  \tpacket__write_byte(packet, reason_code);\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    39   \tstruct mosquitto__packet *packet = NULL;\n    40   \tint rc;\n    41   \n    42   \tassert(mosq);\n    43   #ifdef WITH_BROKER\n    44   #  ifdef WITH_BRIDGE\n    45   \tif(mosq->bridge){\n    46   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Bridge %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    47   \t}else\n    48   #  else\n    49   \t{\n    50   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Sending DISCONNECT to %s (rc%d)\", SAFE_PRINT(mosq->id), reason_code);\n    51   \t}\n    52   #  endif\n    53   #else\n    54   \tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Client %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    55   #endif\n    56   \tassert(mosq);\n    57   \tpacket = mosquitto__calloc(1, sizeof(struct mosquitto__packet));\n    58   \tif(!packet) return MOSQ_ERR_NOMEM;\n    59   \n    60   \tpacket->command = CMD_DISCONNECT;\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    62   \t\tpacket->remaining_length = 1;\n    63   \t\tif(properties){\n    64   \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    65   \t\t}\n    66   \t}else{\n    67   \t\tpacket->remaining_length = 0;\n    68   \t}\n    69   \n    70   \trc = packet__alloc(packet);\n    71   \tif(rc){\n    72   \t\tmosquitto__free(packet);\n    73   \t\treturn rc;\n    74   \t}\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    76   \t\tpacket__write_byte(packet, reason_code);\n    77   \t\tif(properties){\n    78   \t\t\tproperty__write_all(packet, properties, true);\n    79   \t\t}\n    80   \t}\n    81   \n    82   \treturn packet__queue(mosq, packet);\n    83   }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    118  }\n",
    "If validation is successful, the Server MUST acknowledge the CONNECT packet with a CONNACK packet containing a 0x00 (Success) Reason Code [MQTT-3.1.4-5].": "Function: mosquitto_client_username\nPath: /root/projects/mosquitto/src/plugin_public.c:134\n    134  const char *mosquitto_client_username(const struct mosquitto *client)\n    135  {\n    136  \tif(client){\n    137  #ifdef WITH_BRIDGE\n    138  \t\tif(client->bridge){\n    139  \t\t\treturn client->bridge->local_username;\n    140  \t\t}else\n    141  #endif\n    142  \t\t{\n    143  \t\t\treturn client->username;\n    144  \t\t}\n    145  \t}else{\n    146  \t\treturn NULL;\n    147  \t}\n    148  }\nFunction: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    191  \n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    199  \n    200  \t\t\t/* Unexpected disconnect, queue the client will. */\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    220  \n    221  \tplugin__handle_disconnect(context, -1);\n    222  \n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    225  #ifdef WITH_BRIDGE\n    226  \tif(context->bridge == NULL)\n    227  \t/* Outgoing bridge connection never expire */\n    228  #endif\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    231  \t\t\t/* Client session is due to be expired now */\n    232  \t\t\tif(context->will_delay_interval == 0){\n    233  \t\t\t\t/* This will be done later, after the will is published for delay>0. */\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__read_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:178\n    178  int packet__read_uint32(struct mosquitto__packet *packet, uint32_t *word)\n    179  {\n    180  \tuint32_t val = 0;\n    181  \tint i;\n    182  \n    183  \tassert(packet);\n    184  \tif(packet->pos+4 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    185  \n    186  \tfor(i=0; i<4; i++){\n    187  \t\tval = (val << 8) + packet->payload[packet->pos];\n    188  \t\tpacket->pos++;\n    189  \t}\n    190  \n    191  \t*word = val;\n    192  \n    193  \treturn MOSQ_ERR_SUCCESS;\n    194  }\nFunction: packet__write_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:197\n    197  void packet__write_uint32(struct mosquitto__packet *packet, uint32_t word)\n    198  {\n    199  \tpacket__write_byte(packet, (uint8_t)((word & 0xFF000000) >> 24));\n    200  \tpacket__write_byte(packet, (uint8_t)((word & 0x00FF0000) >> 16));\n    201  \tpacket__write_byte(packet, (uint8_t)((word & 0x0000FF00) >> 8));\n    202  \tpacket__write_byte(packet, (uint8_t)((word & 0x000000FF)));\n    203  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    209  \tuint8_t byte;\n    210  \tunsigned int remaining_mult = 1;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    213  \n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    219  \t\t\tremaining_mult *= 128;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    223  \t\t\t\t\t/* Catch overlong encodings */\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    227  \t\t\t\t\tif(bytes) (*bytes) = lbytes;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    235  \treturn MOSQ_ERR_MALFORMED_PACKET;\n    236  }\nFunction: packet__write_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:239\n    239  int packet__write_varint(struct mosquitto__packet *packet, uint32_t word)\n    240  {\n    241  \tuint8_t byte;\n    242  \tint count = 0;\n    243  \n    244  \tdo{\n    245  \t\tbyte = (uint8_t)(word % 128);\n    246  \t\tword = word / 128;\n    247  \t\t/* If there are more digits to encode, set the top bit of this digit */\n    248  \t\tif(word > 0){\n    249  \t\t\tbyte = byte | 0x80;\n    250  \t\t}\n    251  \t\tpacket__write_byte(packet, byte);\n    252  \t\tcount++;\n    253  \t}while(word > 0 && count < 5);\n    254  \n    255  \tif(count == 5){\n    256  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    257  \t}\n    258  \treturn MOSQ_ERR_SUCCESS;\n    259  }\nFunction: packet__varint_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:262\n    262  unsigned int packet__varint_bytes(uint32_t word)\n    263  {\n    264  \tif(word < 128){\n    265  \t\treturn 1;\n    266  \t}else if(word < 16384){\n    267  \t\treturn 2;\n    268  \t}else if(word < 2097152){\n    269  \t\treturn 3;\n    270  \t}else if(word < 268435456){\n    271  \t\treturn 4;\n    272  \t}else{\n    273  \t\treturn 5;\n    274  \t}\n    275  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    54   \tint i;\n    55   \n    56   \tassert(packet);\n    57   \n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    61   \tdo{\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    64   \t\t/* If there are more digits to encode, set the top bit of this digit */\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    73   #ifdef WITH_WEBSOCKETS\n    74   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length + LWS_PRE);\n    75   #else\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    77   #endif\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    79   \n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    85   \n    86   \treturn MOSQ_ERR_SUCCESS;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    92   \n    93   \t/* Free data and reset values */\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    144  #ifndef WITH_BROKER\n    145  \tchar sockpair_data = 0;\n    146  #endif\n    147  \tassert(mosq);\n    148  \tassert(packet);\n    149  \n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    152  \n    153  \tpacket->next = NULL;\n    154  \tCOMPAT_pthread_mutex_lock(&mosq->out_packet_mutex);\n    155  \n    156  #ifdef WITH_BROKER\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    158  \t\tmosquitto__free(packet);\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    162  \t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    165  \t\tG_MSGS_DROPPED_INC();\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    168  #endif\n    169  \n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    177  \tCOMPAT_pthread_mutex_unlock(&mosq->out_packet_mutex);\n    178  #ifdef WITH_BROKER\n    179  #  ifdef WITH_WEBSOCKETS\n    180  \tif(mosq->wsi){\n    181  \t\tlws_callback_on_writable(mosq->wsi);\n    182  \t\treturn MOSQ_ERR_SUCCESS;\n    183  \t}else{\n    184  \t\treturn packet__write(mosq);\n    185  \t}\n    186  #  else\n    187  \treturn packet__write(mosq);\n    188  #  endif\n    189  #else\n    190  \n    191  \t/* Write a single byte to sockpairW (connected to sockpairR) to break out\n    192  \t * of select() if in threaded mode. */\n    193  \tif(mosq->sockpairW != INVALID_SOCKET){\n    194  #ifndef WIN32\n    195  \t\tif(write(mosq->sockpairW, &sockpair_data, 1)){\n    196  \t\t}\n    197  #else\n    198  \t\tsend(mosq->sockpairW, &sockpair_data, 1, 0);\n    199  #endif\n    200  \t}\n    201  \n    202  \tif(mosq->in_callback == false && mosq->threaded == mosq_ts_none){\n    203  \t\treturn packet__write(mosq);\n    204  \t}else{\n    205  \t\treturn MOSQ_ERR_SUCCESS;\n    206  \t}\n    207  #endif\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    228  \tssize_t write_length;\n    229  \tstruct mosquitto__packet *packet;\n    230  \tenum mosquitto_client_state state;\n    231  \n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    234  \n    235  \tCOMPAT_pthread_mutex_lock(&mosq->current_out_packet_mutex);\n    236  \tCOMPAT_pthread_mutex_lock(&mosq->out_packet_mutex);\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    245  \tCOMPAT_pthread_mutex_unlock(&mosq->out_packet_mutex);\n    246  \n    247  #ifdef WITH_BROKER\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    251  #endif\n    252  \n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    255  \t\tCOMPAT_pthread_mutex_unlock(&mosq->current_out_packet_mutex);\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    258  \n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    261  \n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    269  #ifdef WIN32\n    270  \t\t\t\terrno = WSAGetLastError();\n    271  #endif\n    272  \t\t\t\tif(errno == EAGAIN || errno == COMPAT_EWOULDBLOCK\n    273  #ifdef WIN32\n    274  \t\t\t\t\t\t|| errno == WSAENOTCONN\n    275  #endif\n    276  \t\t\t\t\t\t){\n    277  \t\t\t\t\tCOMPAT_pthread_mutex_unlock(&mosq->current_out_packet_mutex);\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    280  \t\t\t\t\tCOMPAT_pthread_mutex_unlock(&mosq->current_out_packet_mutex);\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    294  \n    295  \t\tG_MSGS_SENT_INC(1);\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    297  \t\t\tG_PUB_MSGS_SENT_INC(1);\n    298  #ifndef WITH_BROKER\n    299  \t\t\tCOMPAT_pthread_mutex_lock(&mosq->callback_mutex);\n    300  \t\t\tif(mosq->on_publish){\n    301  \t\t\t\t/* This is a QoS=0 message */\n    302  \t\t\t\tmosq->in_callback = true;\n    303  \t\t\t\tmosq->on_publish(mosq, mosq->userdata, packet->mid);\n    304  \t\t\t\tmosq->in_callback = false;\n    305  \t\t\t}\n    306  \t\t\tif(mosq->on_publish_v5){\n    307  \t\t\t\t/* This is a QoS=0 message */\n    308  \t\t\t\tmosq->in_callback = true;\n    309  \t\t\t\tmosq->on_publish_v5(mosq, mosq->userdata, packet->mid, 0, NULL);\n    310  \t\t\t\tmosq->in_callback = false;\n    311  \t\t\t}\n    312  \t\t\tCOMPAT_pthread_mutex_unlock(&mosq->callback_mutex);\n    313  \t\t}else if(((packet->command)&0xF0) == CMD_DISCONNECT){\n    314  \t\t\tdo_client_disconnect(mosq, MOSQ_ERR_SUCCESS, NULL);\n    315  \t\t\tpacket__cleanup(packet);\n    316  \t\t\tmosquitto__free(packet);\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    318  #endif\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    320  \t\t\tG_PUB_MSGS_SENT_INC(1);\n    321  \t\t}\n    322  \n    323  \t\t/* Free data and reset values */\n    324  \t\tCOMPAT_pthread_mutex_lock(&mosq->out_packet_mutex);\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    333  \t\tCOMPAT_pthread_mutex_unlock(&mosq->out_packet_mutex);\n    334  \n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    337  \n    338  #ifdef WITH_BROKER\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    340  #else\n    341  \t\tCOMPAT_pthread_mutex_lock(&mosq->msgtime_mutex);\n    342  \t\tmosq->next_msg_out = mosquitto_time() + mosq->keepalive;\n    343  \t\tCOMPAT_pthread_mutex_unlock(&mosq->msgtime_mutex);\n    344  #endif\n    345  \t}\n    346  #ifdef WITH_BROKER\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    350  #endif\n    351  \tCOMPAT_pthread_mutex_unlock(&mosq->current_out_packet_mutex);\n    352  \treturn MOSQ_ERR_SUCCESS;\n    353  }\nFunction: packet__check_oversize\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:211\n    211  int packet__check_oversize(struct mosquitto *mosq, uint32_t remaining_length)\n    212  {\n    213  \tuint32_t len;\n    214  \n    215  \tif(mosq->maximum_packet_size == 0) return MOSQ_ERR_SUCCESS;\n    216  \n    217  \tlen = remaining_length + packet__varint_bytes(remaining_length);\n    218  \tif(len > mosq->maximum_packet_size){\n    219  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    220  \t}else{\n    221  \t\treturn MOSQ_ERR_SUCCESS;\n    222  \t}\n    223  }\nFunction: property__process_connect\nPath: /root/projects/mosquitto/src/property_broker.c:30\n    30   int property__process_connect(struct mosquitto *context, mosquitto_property **props)\n    31   {\n    32   \tmosquitto_property *p;\n    33   \n    34   \tp = *props;\n    35   \n    36   \twhile(p){\n    37   \t\tif(p->identifier == MQTT_PROP_SESSION_EXPIRY_INTERVAL){\n    38   \t\t\tcontext->session_expiry_interval = p->value.i32;\n    39   \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM){\n    40   \t\t\tif(p->value.i16 == 0){\n    41   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    42   \t\t\t}\n    43   \n    44   \t\t\tcontext->msgs_out.inflight_maximum = p->value.i16;\n    45   \t\t\tcontext->msgs_out.inflight_quota = context->msgs_out.inflight_maximum;\n    46   \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    47   \t\t\tif(p->value.i32 == 0){\n    48   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    49   \t\t\t}\n    50   \t\t\tcontext->maximum_packet_size = p->value.i32;\n    51   \t\t}\n    52   \t\tp = p->next;\n    53   \t}\n    54   \n    55   \treturn MOSQ_ERR_SUCCESS;\n    56   }\nFunction: property__process_will\nPath: /root/projects/mosquitto/src/property_broker.c:59\n    59   int property__process_will(struct mosquitto *context, struct mosquitto_message_all *msg, mosquitto_property **props)\n    60   {\n    61   \tmosquitto_property *p, *p_prev;\n    62   \tmosquitto_property *msg_properties, *msg_properties_last;\n    63   \n    64   \tp = *props;\n    65   \tp_prev = NULL;\n    66   \tmsg_properties = NULL;\n    67   \tmsg_properties_last = NULL;\n    68   \twhile(p){\n    69   \t\tswitch(p->identifier){\n    70   \t\t\tcase MQTT_PROP_CONTENT_TYPE:\n    71   \t\t\tcase MQTT_PROP_CORRELATION_DATA:\n    72   \t\t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    73   \t\t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    74   \t\t\tcase MQTT_PROP_USER_PROPERTY:\n    75   \t\t\t\tif(msg_properties){\n    76   \t\t\t\t\tmsg_properties_last->next = p;\n    77   \t\t\t\t\tmsg_properties_last = p;\n    78   \t\t\t\t}else{\n    79   \t\t\t\t\tmsg_properties = p;\n    80   \t\t\t\t\tmsg_properties_last = p;\n    81   \t\t\t\t}\n    82   \t\t\t\tif(p_prev){\n    83   \t\t\t\t\tp_prev->next = p->next;\n    84   \t\t\t\t\tp = p_prev->next;\n    85   \t\t\t\t}else{\n    86   \t\t\t\t\t*props = p->next;\n    87   \t\t\t\t\tp = *props;\n    88   \t\t\t\t}\n    89   \t\t\t\tmsg_properties_last->next = NULL;\n    90   \t\t\t\tbreak;\n    91   \n    92   \t\t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    93   \t\t\t\tcontext->will_delay_interval = p->value.i32;\n    94   \t\t\t\tp_prev = p;\n    95   \t\t\t\tp = p->next;\n    96   \t\t\t\tbreak;\n    97   \n    98   \t\t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    99   \t\t\t\tmsg->expiry_interval = p->value.i32;\n    100  \t\t\t\tp_prev = p;\n    101  \t\t\t\tp = p->next;\n    102  \t\t\t\tbreak;\n    103  \n    104  \t\t\tdefault:\n    105  \t\t\t\tmsg->properties = msg_properties;\n    106  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    107  \t\t\t\tbreak;\n    108  \t\t}\n    109  \t}\n    110  \n    111  \tmsg->properties = msg_properties;\n    112  \treturn MOSQ_ERR_SUCCESS;\n    113  }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    155  \tint rc;\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    158  \n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    161  \n    162  \t*properties = NULL;\n    163  \n    164  \t/* The order of properties must be preserved for some types, so keep the\n    165  \t * same order for all */\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    172  \n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    175  \t\t\tmosquitto__free(p);\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    179  \n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    185  \t\ttail = p;\n    186  \n    187  \t}\n    188  \n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    194  \treturn MOSQ_ERR_SUCCESS;\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    252  \n    253  \tif(!property) return;\n    254  \n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__read\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:35\n    35   static int property__read(struct mosquitto__packet *packet, uint32_t *len, mosquitto_property *property)\n    36   {\n    37   \tint rc;\n    38   \tuint32_t property_identifier;\n    39   \tuint8_t byte;\n    40   \tuint8_t byte_count;\n    41   \tuint16_t uint16;\n    42   \tuint32_t uint32;\n    43   \tuint32_t varint;\n    44   \tchar *str1, *str2;\n    45   \tuint16_t slen1, slen2;\n    46   \n    47   \tif(!property) return MOSQ_ERR_INVAL;\n    48   \n    49   \trc = packet__read_varint(packet, &property_identifier, NULL);\n    50   \tif(rc){\n    51   \t\treturn rc;\n    52   \t}\n    53   \t*len -= 1;\n    54   \n    55   \tmemset(property, 0, sizeof(mosquitto_property));\n    56   \n    57   \tproperty->identifier = (int32_t)property_identifier;\n    58   \n    59   \tswitch(property_identifier){\n    60   \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    61   \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    62   \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    63   \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    64   \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    65   \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    66   \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    67   \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    68   \t\t\trc = packet__read_byte(packet, &byte);\n    69   \t\t\tif(rc) return rc;\n    70   \t\t\t*len -= 1; /* byte */\n    71   \t\t\tproperty->value.i8 = byte;\n    72   \t\t\tbreak;\n    73   \n    74   \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    75   \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    76   \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    77   \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    78   \t\t\trc = packet__read_uint16(packet, &uint16);\n    79   \t\t\tif(rc) return rc;\n    80   \t\t\t*len -= 2; /* uint16 */\n    81   \t\t\tproperty->value.i16 = uint16;\n    82   \t\t\tbreak;\n    83   \n    84   \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    85   \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    86   \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    87   \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    88   \t\t\trc = packet__read_uint32(packet, &uint32);\n    89   \t\t\tif(rc) return rc;\n    90   \t\t\t*len -= 4; /* uint32 */\n    91   \t\t\tproperty->value.i32 = uint32;\n    92   \t\t\tbreak;\n    93   \n    94   \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    95   \t\t\trc = packet__read_varint(packet, &varint, &byte_count);\n    96   \t\t\tif(rc) return rc;\n    97   \t\t\t*len -= byte_count;\n    98   \t\t\tproperty->value.varint = varint;\n    99   \t\t\tbreak;\n    100  \n    101  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    102  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    103  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    104  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    105  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    106  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    107  \t\tcase MQTT_PROP_REASON_STRING:\n    108  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    109  \t\t\tif(rc) return rc;\n    110  \t\t\t*len = (*len) - 2 - slen1; /* uint16, string len */\n    111  \t\t\tproperty->value.s.v = str1;\n    112  \t\t\tproperty->value.s.len = slen1;\n    113  \t\t\tbreak;\n    114  \n    115  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    116  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    117  \t\t\trc = packet__read_binary(packet, (uint8_t **)&str1, &slen1);\n    118  \t\t\tif(rc) return rc;\n    119  \t\t\t*len = (*len) - 2 - slen1; /* uint16, binary len */\n    120  \t\t\tproperty->value.bin.v = str1;\n    121  \t\t\tproperty->value.bin.len = slen1;\n    122  \t\t\tbreak;\n    123  \n    124  \t\tcase MQTT_PROP_USER_PROPERTY:\n    125  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    126  \t\t\tif(rc) return rc;\n    127  \t\t\t*len = (*len) - 2 - slen1; /* uint16, string len */\n    128  \n    129  \t\t\trc = packet__read_string(packet, &str2, &slen2);\n    130  \t\t\tif(rc){\n    131  \t\t\t\tmosquitto__free(str1);\n    132  \t\t\t\treturn rc;\n    133  \t\t\t}\n    134  \t\t\t*len = (*len) - 2 - slen2; /* uint16, string len */\n    135  \n    136  \t\t\tproperty->name.v = str1;\n    137  \t\t\tproperty->name.len = slen1;\n    138  \t\t\tproperty->value.s.v = str2;\n    139  \t\t\tproperty->value.s.len = slen2;\n    140  \t\t\tbreak;\n    141  \n    142  \t\tdefault:\n    143  #ifdef WITH_BROKER\n    144  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property_identifier);\n    145  #endif\n    146  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    147  \t}\n    148  \n    149  \treturn MOSQ_ERR_SUCCESS;\n    150  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    933  \tint rc;\n    934  \n    935  \tp = properties;\n    936  \n    937  \twhile(p){\n    938  \t\t/* Validity checks */\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    947  \n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    957  \n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    966  \n    967  \t\t/* Check for properties on incorrect commands */\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    970  \n    971  \t\t/* Check for duplicates */\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    981  \n    982  \t\tp = p->next;\n    983  \t}\n    984  \n    985  \treturn MOSQ_ERR_SUCCESS;\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    462  \n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    468  \n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    474  \n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    481  \n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    494  \n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    500  \n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    507  \n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    513  \n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    519  \n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    527  \n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    533  \n    534  \t\tcase MQTT_PROP_USER_PROPERTY:\n    535  \t\t\tbreak;\n    536  \n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    540  \treturn MOSQ_ERR_SUCCESS;\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    201  \n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    212  \n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    217  \n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    222  \n    223  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    224  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    225  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    226  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    227  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    228  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    229  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    230  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    231  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    232  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    233  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    234  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    235  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    236  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    237  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    238  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    239  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    240  \t\t\t/* Nothing to free */\n    241  \t\t\tbreak;\n    242  \t}\n    243  \n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: property__write_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:429\n    429  int property__write_all(struct mosquitto__packet *packet, const mosquitto_property *properties, bool write_len)\n    430  {\n    431  \tint rc;\n    432  \tconst mosquitto_property *p;\n    433  \n    434  \tif(write_len){\n    435  \t\trc = packet__write_varint(packet, property__get_length_all(properties));\n    436  \t\tif(rc) return rc;\n    437  \t}\n    438  \n    439  \tp = properties;\n    440  \twhile(p){\n    441  \t\trc = property__write(packet, p);\n    442  \t\tif(rc) return rc;\n    443  \t\tp = p->next;\n    444  \t}\n    445  \n    446  \treturn MOSQ_ERR_SUCCESS;\n    447  }\nFunction: property__write\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:361\n    361  static int property__write(struct mosquitto__packet *packet, const mosquitto_property *property)\n    362  {\n    363  \tint rc;\n    364  \n    365  \trc = packet__write_varint(packet, (uint32_t)property->identifier);\n    366  \tif(rc) return rc;\n    367  \n    368  \tswitch(property->identifier){\n    369  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    370  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    371  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    372  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    373  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    374  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    375  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    376  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    377  \t\t\tpacket__write_byte(packet, property->value.i8);\n    378  \t\t\tbreak;\n    379  \n    380  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    381  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    382  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    383  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    384  \t\t\tpacket__write_uint16(packet, property->value.i16);\n    385  \t\t\tbreak;\n    386  \n    387  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    388  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    389  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    390  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    391  \t\t\tpacket__write_uint32(packet, property->value.i32);\n    392  \t\t\tbreak;\n    393  \n    394  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    395  \t\t\treturn packet__write_varint(packet, property->value.varint);\n    396  \n    397  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    398  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    399  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    400  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    401  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    402  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    403  \t\tcase MQTT_PROP_REASON_STRING:\n    404  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    405  \t\t\tbreak;\n    406  \n    407  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    408  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    409  \t\t\tpacket__write_uint16(packet, property->value.bin.len);\n    410  \t\t\tpacket__write_bytes(packet, property->value.bin.v, property->value.bin.len);\n    411  \t\t\tbreak;\n    412  \n    413  \t\tcase MQTT_PROP_USER_PROPERTY:\n    414  \t\t\tpacket__write_string(packet, property->name.v, property->name.len);\n    415  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    416  \t\t\tbreak;\n    417  \n    418  \t\tdefault:\n    419  #ifdef WITH_BROKER\n    420  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property->identifier);\n    421  #endif\n    422  \t\t\treturn MOSQ_ERR_INVAL;\n    423  \t}\n    424  \n    425  \treturn MOSQ_ERR_SUCCESS;\n    426  }\nFunction: mosquitto_property_add_byte\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:716\n    716  int mosquitto_property_add_byte(mosquitto_property **proplist, int identifier, uint8_t value)\n    717  {\n    718  \tmosquitto_property *prop;\n    719  \n    720  \tif(!proplist) return MOSQ_ERR_INVAL;\n    721  \tif(identifier != MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    722  \t\t\t&& identifier != MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    723  \t\t\t&& identifier != MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    724  \t\t\t&& identifier != MQTT_PROP_MAXIMUM_QOS\n    725  \t\t\t&& identifier != MQTT_PROP_RETAIN_AVAILABLE\n    726  \t\t\t&& identifier != MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    727  \t\t\t&& identifier != MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    728  \t\t\t&& identifier != MQTT_PROP_SHARED_SUB_AVAILABLE){\n    729  \t\treturn MOSQ_ERR_INVAL;\n    730  \t}\n    731  \n    732  \tprop = mosquitto__calloc(1, sizeof(mosquitto_property));\n    733  \tif(!prop) return MOSQ_ERR_NOMEM;\n    734  \n    735  \tprop->client_generated = true;\n    736  \tprop->identifier = identifier;\n    737  \tprop->value.i8 = value;\n    738  \n    739  \tproperty__add(proplist, prop);\n    740  \treturn MOSQ_ERR_SUCCESS;\n    741  }\nFunction: mosquitto_property_add_int16\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:744\n    744  int mosquitto_property_add_int16(mosquitto_property **proplist, int identifier, uint16_t value)\n    745  {\n    746  \tmosquitto_property *prop;\n    747  \n    748  \tif(!proplist) return MOSQ_ERR_INVAL;\n    749  \tif(identifier != MQTT_PROP_SERVER_KEEP_ALIVE\n    750  \t\t\t&& identifier != MQTT_PROP_RECEIVE_MAXIMUM\n    751  \t\t\t&& identifier != MQTT_PROP_TOPIC_ALIAS_MAXIMUM\n    752  \t\t\t&& identifier != MQTT_PROP_TOPIC_ALIAS){\n    753  \t\treturn MOSQ_ERR_INVAL;\n    754  \t}\n    755  \n    756  \tprop = mosquitto__calloc(1, sizeof(mosquitto_property));\n    757  \tif(!prop) return MOSQ_ERR_NOMEM;\n    758  \n    759  \tprop->client_generated = true;\n    760  \tprop->identifier = identifier;\n    761  \tprop->value.i16 = value;\n    762  \n    763  \tproperty__add(proplist, prop);\n    764  \treturn MOSQ_ERR_SUCCESS;\n    765  }\nFunction: mosquitto_property_read_binary\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1106\n    1106 const mosquitto_property *mosquitto_property_read_binary(const mosquitto_property *proplist, int identifier, void **value, uint16_t *len, bool skip_first)\n    1107 {\n    1108 \tconst mosquitto_property *p;\n    1109 \tif(!proplist || (value && !len) || (!value && len)) return NULL;\n    1110 \n    1111 \tif(value) *value = NULL;\n    1112 \n    1113 \tp = property__get_property(proplist, identifier, skip_first);\n    1114 \tif(!p) return NULL;\n    1115 \tif(p->identifier != MQTT_PROP_CORRELATION_DATA\n    1116 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_DATA){\n    1117 \n    1118 \t\treturn NULL;\n    1119 \t}\n    1120 \n    1121 \tif(value){\n    1122 \t\t*len = p->value.bin.len;\n    1123 \t\t*value = calloc(1, *len + 1U);\n    1124 \t\tif(!(*value)) return NULL;\n    1125 \n    1126 \t\tmemcpy(*value, p->value.bin.v, *len);\n    1127 \t}\n    1128 \n    1129 \treturn p;\n    1130 }\nFunction: mosquitto_property_read_string\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1133\n    1133 const mosquitto_property *mosquitto_property_read_string(const mosquitto_property *proplist, int identifier, char **value, bool skip_first)\n    1134 {\n    1135 \tconst mosquitto_property *p;\n    1136 \tif(!proplist) return NULL;\n    1137 \n    1138 \tp = property__get_property(proplist, identifier, skip_first);\n    1139 \tif(!p) return NULL;\n    1140 \tif(p->identifier != MQTT_PROP_CONTENT_TYPE\n    1141 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_TOPIC\n    1142 \t\t\t&& p->identifier != MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER\n    1143 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_METHOD\n    1144 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_INFORMATION\n    1145 \t\t\t&& p->identifier != MQTT_PROP_SERVER_REFERENCE\n    1146 \t\t\t&& p->identifier != MQTT_PROP_REASON_STRING){\n    1147 \n    1148 \t\treturn NULL;\n    1149 \t}\n    1150 \n    1151 \tif(value){\n    1152 \t\t*value = calloc(1, (size_t)p->value.s.len+1);\n    1153 \t\tif(!(*value)) return NULL;\n    1154 \n    1155 \t\tmemcpy(*value, p->value.s.v, p->value.s.len);\n    1156 \t}\n    1157 \n    1158 \treturn p;\n    1159 }\nFunction: db__expire_all_messages\nPath: /root/projects/mosquitto/src/database.c:1053\n    1053 void db__expire_all_messages(struct mosquitto *context)\n    1054 {\n    1055 \tstruct mosquitto_client_msg *msg, *tmp;\n    1056 \n    1057 \tDL_FOREACH_SAFE(context->msgs_out.inflight, msg, tmp){\n    1058 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1059 \t\t\tif(msg->qos > 0){\n    1060 \t\t\t\tutil__increment_send_quota(context);\n    1061 \t\t\t}\n    1062 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1063 \t\t}\n    1064 \t}\n    1065 \tDL_FOREACH_SAFE(context->msgs_out.queued, msg, tmp){\n    1066 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1067 \t\t\tdb__message_remove_from_queued(&context->msgs_out, msg);\n    1068 \t\t}\n    1069 \t}\n    1070 \tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n    1071 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1072 \t\t\tif(msg->qos > 0){\n    1073 \t\t\t\tutil__increment_receive_quota(context);\n    1074 \t\t\t}\n    1075 \t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n    1076 \t\t}\n    1077 \t}\n    1078 \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n    1079 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1080 \t\t\tdb__message_remove_from_queued(&context->msgs_in, msg);\n    1081 \t\t}\n    1082 \t}\n    1083 }\nFunction: db__message_remove_from_queued\nPath: /root/projects/mosquitto/src/database.c:364\n    364  static void db__message_remove_from_queued(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    365  {\n    366  \tif(!msg_data || !item){\n    367  \t\treturn;\n    368  \t}\n    369  \n    370  \tDL_DELETE(msg_data->queued, item);\n    371  \tif(item->store){\n    372  \t\tdb__msg_store_ref_dec(&item->store);\n    373  \t}\n    374  \n    375  \tmosquitto_property_free_all(&item->properties);\n    376  \tmosquitto__free(item);\n    377  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1183 \tstruct mosquitto_client_msg *tail, *tmp;\n    1184 \tint rc;\n    1185 \n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1189 \n    1190 \tDL_FOREACH_SAFE(context->msgs_out.inflight, tail, tmp){\n    1191 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1192 \t\tif(rc) return rc;\n    1193 \t}\n    1194 \treturn MOSQ_ERR_SUCCESS;\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    115  \tint i;\n    116  \tint rc;\n    117  \tint in_quota, out_quota;\n    118  \tuint16_t in_maximum, out_maximum;\n    119  \n    120  \t/* Find if this client already has an entry. This must be done *after* any security checks. */\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    123  \t\t/* Found a matching client */\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    125  \t\t\t/* Client is reconnecting after a disconnect */\n    126  \t\t\t/* FIXME - does anything need to be done here? */\n    127  \t\t}else{\n    128  \t\t\t/* Client is already connected, disconnect old version. This is\n    129  \t\t\t * done in context__cleanup() below. */\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    134  \n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    139  \n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    142  \n    143  \t\t\t\tin_quota = context->msgs_in.inflight_quota;\n    144  \t\t\t\tout_quota = context->msgs_out.inflight_quota;\n    145  \t\t\t\tin_maximum = context->msgs_in.inflight_maximum;\n    146  \t\t\t\tout_maximum = context->msgs_out.inflight_maximum;\n    147  \n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    150  \n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    153  \n    154  \t\t\t\tcontext->msgs_in.inflight_quota = in_quota;\n    155  \t\t\t\tcontext->msgs_out.inflight_quota = out_quota;\n    156  \t\t\t\tcontext->msgs_in.inflight_maximum = in_maximum;\n    157  \t\t\t\tcontext->msgs_out.inflight_maximum = out_maximum;\n    158  \n    159  \t\t\t\tdb__message_reconnect_reset(context);\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    166  \n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    176  \n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    189  \n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    197  \n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    200  \n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    204  \n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    208  \n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    214  \n    215  \trc = acl__find_acls(context);\n    216  \tif(rc){\n    217  \t\tfree(auth_data_out);\n    218  \t\treturn rc;\n    219  \t}\n    220  \n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    239  \n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    245  \n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    248  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"No will message specified.\");\n    249  \t\t}\n    250  \t}\n    251  \n    252  \tcontext->ping_t = 0;\n    253  \tcontext->is_dropping = false;\n    254  \n    255  \tconnection_check_acl(context, &context->msgs_in.inflight);\n    256  \tconnection_check_acl(context, &context->msgs_in.queued);\n    257  \tconnection_check_acl(context, &context->msgs_out.inflight);\n    258  \tconnection_check_acl(context, &context->msgs_out.queued);\n    259  \n    260  \tcontext__add_to_by_id(context);\n    261  \n    262  #ifdef WITH_PERSISTENCE\n    263  \tif(!context->clean_start){\n    264  \t\tdb.persistence_changes++;\n    265  \t}\n    266  #endif\n    267  \tcontext->max_qos = context->listener->max_qos;\n    268  \n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    271  \n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    275  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    280  \t\t\trc = MOSQ_ERR_INVAL;\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    284  \n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    288  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    294  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    300  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    303  \n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    306  \t\t\t\t\trc = MOSQ_ERR_NOMEM;\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    312  \tfree(auth_data_out);\n    313  \tauth_data_out = NULL;\n    314  \n    315  \tkeepalive__add(context);\n    316  \n    317  \tmosquitto__set_state(context, mosq_cs_active);\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    319  \tmosquitto_property_free_all(&connack_props);\n    320  \tif(rc) return rc;\n    321  \tdb__expire_all_messages(context);\n    322  \trc = db__message_write_queued_out(context);\n    323  \tif(rc) return rc;\n    324  \trc = db__message_write_inflight_out_all(context);\n    325  \treturn rc;\n    326  error:\n    327  \tfree(auth_data_out);\n    328  \tmosquitto_property_free_all(&connack_props);\n    329  \treturn rc;\n    330  }\nFunction: connection_check_acl\nPath: /root/projects/mosquitto/src/handle_connect.c:86\n    86   static void connection_check_acl(struct mosquitto *context, struct mosquitto_client_msg **head)\n    87   {\n    88   \tstruct mosquitto_client_msg *msg_tail, *tmp;\n    89   \tint access;\n    90   \n    91   \tDL_FOREACH_SAFE((*head), msg_tail, tmp){\n    92   \t\tif(msg_tail->direction == mosq_md_out){\n    93   \t\t\taccess = MOSQ_ACL_READ;\n    94   \t\t}else{\n    95   \t\t\taccess = MOSQ_ACL_WRITE;\n    96   \t\t}\n    97   \t\tif(mosquitto_acl_check(context, msg_tail->store->topic,\n    98   \t\t\t\t\t\t\t   msg_tail->store->payloadlen, msg_tail->store->payload,\n    99   \t\t\t\t\t\t\t   msg_tail->store->qos, msg_tail->store->retain, access) != MOSQ_ERR_SUCCESS){\n    100  \n    101  \t\t\tDL_DELETE((*head), msg_tail);\n    102  \t\t\tdb__msg_store_ref_dec(&msg_tail->store);\n    103  \t\t\tmosquitto_property_free_all(&msg_tail->properties);\n    104  \t\t\tmosquitto__free(msg_tail);\n    105  \t\t}\n    106  \t}\n    107  }\nFunction: log__printf\nPath: /root/projects/mosquitto/src/logging.c:348\n    348  int log__printf(struct mosquitto *mosq, unsigned int priority, const char *fmt, ...)\n    349  {\n    350  \tva_list va;\n    351  \tint rc;\n    352  \n    353  \tUNUSED(mosq);\n    354  \n    355  \tva_start(va, fmt);\n    356  \trc = log__vprintf(priority, fmt, va);\n    357  \tva_end(va);\n    358  \n    359  \treturn rc;\n    360  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    247  \n    248  \tmosquitto__set_state(context, mosq_cs_disused);\n    249  \n    250  \tif(context->id){\n    251  \t\tcontext__remove_from_by_id(context);\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    255  \n    256  \tcontext->for_free_next = db.ll_for_free;\n    257  \tdb.ll_for_free = context;\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    296  \t\tcontext->in_by_id = true;\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__msg_store_remove\nPath: /root/projects/mosquitto/src/database.c:285\n    285  void db__msg_store_remove(struct mosquitto_msg_store *store)\n    286  {\n    287  \tif(store->prev){\n    288  \t\tstore->prev->next = store->next;\n    289  \t\tif(store->next){\n    290  \t\t\tstore->next->prev = store->prev;\n    291  \t\t}\n    292  \t}else{\n    293  \t\tdb.msg_store = store->next;\n    294  \t\tif(store->next){\n    295  \t\t\tstore->next->prev = NULL;\n    296  \t\t}\n    297  \t}\n    298  \tdb.msg_store_count--;\n    299  \tdb.msg_store_bytes -= store->payloadlen;\n    300  \n    301  \tdb__msg_store_free(store);\n    302  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    269  \tint i;\n    270  \n    271  \tmosquitto__free(store->source_id);\n    272  \tmosquitto__free(store->source_username);\n    273  \tif(store->dest_ids){\n    274  \t\tfor(i=0; i<store->dest_id_count; i++){\n    275  \t\t\tmosquitto__free(store->dest_ids[i]);\n    276  \t\t}\n    277  \t\tmosquitto__free(store->dest_ids);\n    278  \t}\n    279  \tmosquitto__free(store->topic);\n    280  \tmosquitto_property_free_all(&store->properties);\n    281  \tmosquitto__free(store->payload);\n    282  \tmosquitto__free(store);\n    283  }\nFunction: db__msg_store_ref_dec\nPath: /root/projects/mosquitto/src/database.c:322\n    322  void db__msg_store_ref_dec(struct mosquitto_msg_store **store)\n    323  {\n    324  \t(*store)->ref_count--;\n    325  \tif((*store)->ref_count == 0){\n    326  \t\tdb__msg_store_remove(*store);\n    327  \t\t*store = NULL;\n    328  \t}\n    329  }\nFunction: db__message_remove_from_inflight\nPath: /root/projects/mosquitto/src/database.c:347\n    347  static void db__message_remove_from_inflight(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    348  {\n    349  \tif(!msg_data || !item){\n    350  \t\treturn;\n    351  \t}\n    352  \n    353  \tDL_DELETE(msg_data->inflight, item);\n    354  \tif(item->store){\n    355  \t\tdb__msg_remove_from_inflight_stats(msg_data, item);\n    356  \t\tdb__msg_store_ref_dec(&item->store);\n    357  \t}\n    358  \n    359  \tmosquitto_property_free_all(&item->properties);\n    360  \tmosquitto__free(item);\n    361  }\nFunction: db__message_write_inflight_out_latest\nPath: /root/projects/mosquitto/src/database.c:1198\n    1198 int db__message_write_inflight_out_latest(struct mosquitto *context)\n    1199 {\n    1200 \tstruct mosquitto_client_msg *tail, *next;\n    1201 \tint rc;\n    1202 \n    1203 \tif(context->state != mosq_cs_active\n    1204 \t\t\t|| context->sock == INVALID_SOCKET\n    1205 \t\t\t|| context->msgs_out.inflight == NULL){\n    1206 \n    1207 \t\treturn MOSQ_ERR_SUCCESS;\n    1208 \t}\n    1209 \n    1210 \tif(context->msgs_out.inflight->prev == context->msgs_out.inflight){\n    1211 \t\t/* Only one message */\n    1212 \t\treturn db__message_write_inflight_out_single(context, context->msgs_out.inflight);\n    1213 \t}\n    1214 \n    1215 \t/* Start at the end of the list and work backwards looking for the first\n    1216 \t * message in a non-publish state */\n    1217 \ttail = context->msgs_out.inflight->prev;\n    1218 \twhile(tail != context->msgs_out.inflight &&\n    1219 \t\t\t(tail->state == mosq_ms_publish_qos0\n    1220 \t\t\t || tail->state == mosq_ms_publish_qos1\n    1221 \t\t\t || tail->state == mosq_ms_publish_qos2)){\n    1222 \n    1223 \t\ttail = tail->prev;\n    1224 \t}\n    1225 \n    1226 \t/* Tail is now either the head of the list, if that message is waiting for\n    1227 \t * publish, or the oldest message not waiting for a publish. In the latter\n    1228 \t * case, any pending publishes should be next after this message. */\n    1229 \tif(tail != context->msgs_out.inflight){\n    1230 \t\ttail = tail->next;\n    1231 \t}\n    1232 \n    1233 \twhile(tail){\n    1234 \t\tnext = tail->next;\n    1235 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1236 \t\tif(rc) return rc;\n    1237 \t\ttail = next;\n    1238 \t}\n    1239 \treturn MOSQ_ERR_SUCCESS;\n    1240 }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1088 \tmosquitto_property *cmsg_props = NULL, *store_props = NULL;\n    1089 \tint rc;\n    1090 \tuint16_t mid;\n    1091 \tint retries;\n    1092 \tint retain;\n    1093 \tconst char *topic;\n    1094 \tuint8_t qos;\n    1095 \tuint32_t payloadlen;\n    1096 \tconst void *payload;\n    1097 \tuint32_t expiry_interval;\n    1098 \n    1099 \texpiry_interval = 0;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1102 \t\t\t/* Message is expired, must not send. */\n    1103 \t\t\tif(msg->direction == mosq_md_out && msg->qos > 0){\n    1104 \t\t\t\tutil__increment_send_quota(context);\n    1105 \t\t\t}\n    1106 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1121 \n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1126 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1131 \n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1135 \t\t\t\tmsg->timestamp = db.now_s;\n    1136 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1137 \t\t\t\tmsg->state = mosq_ms_wait_for_puback;\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1139 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1144 \n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1148 \t\t\t\tmsg->timestamp = db.now_s;\n    1149 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1150 \t\t\t\tmsg->state = mosq_ms_wait_for_pubrec;\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1152 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1157 \n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1159 \t\t\trc = send__pubrel(context, mid, NULL);\n    1160 \t\t\tif(!rc){\n    1161 \t\t\t\tmsg->state = mosq_ms_wait_for_pubcomp;\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1166 \n    1167 \t\tcase mosq_ms_invalid:\n    1168 \t\tcase mosq_ms_send_pubrec:\n    1169 \t\tcase mosq_ms_resend_pubcomp:\n    1170 \t\tcase mosq_ms_wait_for_puback:\n    1171 \t\tcase mosq_ms_wait_for_pubrec:\n    1172 \t\tcase mosq_ms_wait_for_pubrel:\n    1173 \t\tcase mosq_ms_wait_for_pubcomp:\n    1174 \t\tcase mosq_ms_queued:\n    1175 \t\t\tbreak;\n    1176 \t}\n    1177 \treturn MOSQ_ERR_SUCCESS;\n    1178 }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    448  \tstruct mosquitto_client_msg *msg;\n    449  \tstruct mosquitto_msg_data *msg_data;\n    450  \tenum mosquitto_msg_state state = mosq_ms_invalid;\n    451  \tint rc = 0;\n    452  \tint i;\n    453  \tchar **dest_ids;\n    454  \n    455  \tassert(stored);\n    456  \tif(!context) return MOSQ_ERR_INVAL;\n    457  \tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n    458  \n    459  \tif(dir == mosq_md_out){\n    460  \t\tmsg_data = &context->msgs_out;\n    461  \t}else{\n    462  \t\tmsg_data = &context->msgs_in;\n    463  \t}\n    464  \n    465  \t/* Check whether we've already sent this message to this client\n    466  \t * for outgoing messages only.\n    467  \t * If retain==true then this is a stale retained message and so should be\n    468  \t * sent regardless. FIXME - this does mean retained messages will received\n    469  \t * multiple times for overlapping subscriptions, although this is only the\n    470  \t * case for SUBSCRIPTION with multiple subs in so is a minor concern.\n    471  \t */\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    475  \n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    478  \t\t\t\t/* We have already sent this message to this client. */\n    479  \t\t\t\tmosquitto_property_free_all(&properties);\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    484  \tif(context->sock == INVALID_SOCKET){\n    485  \t\t/* Client is not connected only queue messages with QoS>0. */\n    486  \t\tif(qos == 0 && !db.config->queue_qos0_messages){\n    487  \t\t\tif(!context->bridge){\n    488  \t\t\t\tmosquitto_property_free_all(&properties);\n    489  \t\t\t\treturn 2;\n    490  \t\t\t}else{\n    491  \t\t\t\tif(context->bridge->start_type != bst_lazy){\n    492  \t\t\t\t\tmosquitto_property_free_all(&properties);\n    493  \t\t\t\t\treturn 2;\n    494  \t\t\t\t}\n    495  \t\t\t}\n    496  \t\t}\n    497  \t\tif(context->bridge && context->bridge->clean_start_local == true){\n    498  \t\t\tmosquitto_property_free_all(&properties);\n    499  \t\t\treturn 2;\n    500  \t\t}\n    501  \t}\n    502  \n    503  \tif(context->sock != INVALID_SOCKET){\n    504  \t\tif(db__ready_for_flight(context, dir, qos)){\n    505  \t\t\tif(dir == mosq_md_out){\n    506  \t\t\t\tswitch(qos){\n    507  \t\t\t\t\tcase 0:\n    508  \t\t\t\t\t\tstate = mosq_ms_publish_qos0;\n    509  \t\t\t\t\t\tbreak;\n    510  \t\t\t\t\tcase 1:\n    511  \t\t\t\t\t\tstate = mosq_ms_publish_qos1;\n    512  \t\t\t\t\t\tbreak;\n    513  \t\t\t\t\tcase 2:\n    514  \t\t\t\t\t\tstate = mosq_ms_publish_qos2;\n    515  \t\t\t\t\t\tbreak;\n    516  \t\t\t\t}\n    517  \t\t\t}else{\n    518  \t\t\t\tif(qos == 2){\n    519  \t\t\t\t\tstate = mosq_ms_wait_for_pubrel;\n    520  \t\t\t\t}else{\n    521  \t\t\t\t\tmosquitto_property_free_all(&properties);\n    522  \t\t\t\t\treturn 1;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n    526  \t\t\tstate = mosq_ms_queued;\n    527  \t\t\trc = 2;\n    528  \t\t}else{\n    529  \t\t\t/* Dropping message due to full queue. */\n    530  \t\t\tif(context->is_dropping == false){\n    531  \t\t\t\tcontext->is_dropping = true;\n    532  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    533  \t\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n    534  \t\t\t\t\t\tcontext->id);\n    535  \t\t\t}\n    536  \t\t\tG_MSGS_DROPPED_INC();\n    537  \t\t\tmosquitto_property_free_all(&properties);\n    538  \t\t\treturn 2;\n    539  \t\t}\n    540  \t}else{\n    541  \t\tif (db__ready_for_queue(context, qos, msg_data)){\n    542  \t\t\tstate = mosq_ms_queued;\n    543  \t\t}else{\n    544  \t\t\tG_MSGS_DROPPED_INC();\n    545  \t\t\tif(context->is_dropping == false){\n    546  \t\t\t\tcontext->is_dropping = true;\n    547  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    548  \t\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n    549  \t\t\t\t\t\tcontext->id);\n    550  \t\t\t}\n    551  \t\t\tmosquitto_property_free_all(&properties);\n    552  \t\t\treturn 2;\n    553  \t\t}\n    554  \t}\n    555  \tassert(state != mosq_ms_invalid);\n    556  \n    557  #ifdef WITH_PERSISTENCE\n    558  \tif(state == mosq_ms_queued){\n    559  \t\tdb.persistence_changes++;\n    560  \t}\n    561  #endif\n    562  \n    563  \tmsg = mosquitto__calloc(1, sizeof(struct mosquitto_client_msg));\n    564  \tif(!msg) return MOSQ_ERR_NOMEM;\n    565  \tmsg->prev = NULL;\n    566  \tmsg->next = NULL;\n    567  \tmsg->store = stored;\n    568  \tdb__msg_store_ref_inc(msg->store);\n    569  \tmsg->mid = mid;\n    570  \tmsg->timestamp = db.now_s;\n    571  \tmsg->direction = dir;\n    572  \tmsg->state = state;\n    573  \tmsg->dup = false;\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    577  \t\tmsg->qos = qos;\n    578  \t}\n    579  \tmsg->retain = retain;\n    580  \tmsg->properties = properties;\n    581  \n    582  \tif(state == mosq_ms_queued){\n    583  \t\tDL_APPEND(msg_data->queued, msg);\n    584  \t\tdb__msg_add_to_queued_stats(msg_data, msg);\n    585  \t}else{\n    586  \t\tDL_APPEND(msg_data->inflight, msg);\n    587  \t\tdb__msg_add_to_inflight_stats(msg_data, msg);\n    588  \t}\n    589  \n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    591  \t\t/* Record which client ids this message has been sent to so we can avoid duplicates.\n    592  \t\t * Outgoing messages only.\n    593  \t\t * If retain==true then this is a stale retained message and so should be\n    594  \t\t * sent regardless. FIXME - this does mean retained messages will received\n    595  \t\t * multiple times for overlapping subscriptions, although this is only the\n    596  \t\t * case for SUBSCRIPTION with multiple subs in so is a minor concern.\n    597  \t\t */\n    598  \t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n    599  \t\tif(dest_ids){\n    600  \t\t\tstored->dest_ids = dest_ids;\n    601  \t\t\tstored->dest_id_count++;\n    602  \t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t}\n    609  \t}\n    610  #ifdef WITH_BRIDGE\n    611  \tif(context->bridge && context->bridge->start_type == bst_lazy\n    612  \t\t\t&& context->sock == INVALID_SOCKET\n    613  \t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n    614  \n    615  \t\tcontext->bridge->lazy_reconnect = true;\n    616  \t}\n    617  #endif\n    618  \n    619  \tif(dir == mosq_md_out && msg->qos > 0 && state != mosq_ms_queued){\n    620  \t\tutil__decrement_send_quota(context);\n    621  \t}else if(dir == mosq_md_in && msg->qos > 0 && state != mosq_ms_queued){\n    622  \t\tutil__decrement_receive_quota(context);\n    623  \t}\n    624  \n    625  \tif(dir == mosq_md_out && update){\n    626  \t\trc = db__message_write_inflight_out_latest(context);\n    627  \t\tif(rc) return rc;\n    628  \t\trc = db__message_write_queued_out(context);\n    629  \t\tif(rc) return rc;\n    630  \t}\n    631  \n    632  \treturn rc;\n    633  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    704  \tstruct mosquitto_msg_store *stored;\n    705  \tconst char *source_id;\n    706  \tenum mosquitto_msg_origin origin;\n    707  \n    708  \tif(!topic) return MOSQ_ERR_INVAL;\n    709  \n    710  \tstored = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    711  \tif(stored == NULL) return MOSQ_ERR_NOMEM;\n    712  \n    713  \tstored->topic = mosquitto__strdup(topic);\n    714  \tif(stored->topic == NULL){\n    715  \t\tdb__msg_store_free(stored);\n    716  \t\treturn MOSQ_ERR_INVAL;\n    717  \t}\n    718  \n    719  \tstored->qos = qos;\n    720  \tif(db.config->retain_available == false){\n    721  \t\tstored->retain = 0;\n    722  \t}else{\n    723  \t\tstored->retain = retain;\n    724  \t}\n    725  \n    726  \tstored->payloadlen = payloadlen;\n    727  \tif(payloadlen > 0){\n    728  \t\tstored->payload = mosquitto__malloc(stored->payloadlen+1);\n    729  \t\tif(stored->payload == NULL){\n    730  \t\t\tdb__msg_store_free(stored);\n    731  \t\t\treturn MOSQ_ERR_NOMEM;\n    732  \t\t}\n    733  \t\t/* Ensure payload is always zero terminated, this is the reason for the extra byte above */\n    734  \t\t((uint8_t *)stored->payload)[stored->payloadlen] = 0;\n    735  \t\tmemcpy(stored->payload, payload, stored->payloadlen);\n    736  \t}\n    737  \n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    741  \t\tsource_id = \"\";\n    742  \t}\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    745  \t\t*properties = NULL;\n    746  \t}\n    747  \n    748  \tif(context){\n    749  \t\torigin = mosq_mo_client;\n    750  \t}else{\n    751  \t\torigin = mosq_mo_broker;\n    752  \t}\n    753  \tif(db__message_store(context, stored, message_expiry_interval, 0, origin)) return 1;\n    754  \n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    761  \tassert(stored);\n    762  \n    763  \tif(source && source->id){\n    764  \t\tstored->source_id = mosquitto__strdup(source->id);\n    765  \t}else{\n    766  \t\tstored->source_id = mosquitto__strdup(\"\");\n    767  \t}\n    768  \tif(!stored->source_id){\n    769  \t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n    770  \t\tdb__msg_store_free(stored);\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    773  \n    774  \tif(source && source->username){\n    775  \t\tstored->source_username = mosquitto__strdup(source->username);\n    776  \t\tif(!stored->source_username){\n    777  \t\t\tdb__msg_store_free(stored);\n    778  \t\t\treturn MOSQ_ERR_NOMEM;\n    779  \t\t}\n    780  \t}\n    781  \tif(source){\n    782  \t\tstored->source_listener = source->listener;\n    783  \t}\n    784  \tstored->mid = 0;\n    785  \tstored->origin = origin;\n    786  \tif(message_expiry_interval > 0){\n    787  \t\tstored->message_expiry_time = db.now_real_s + message_expiry_interval;\n    788  \t}else{\n    789  \t\tstored->message_expiry_time = 0;\n    790  \t}\n    791  \n    792  \tstored->dest_ids = NULL;\n    793  \tstored->dest_id_count = 0;\n    794  \tdb.msg_store_count++;\n    795  \tdb.msg_store_bytes += stored->payloadlen;\n    796  \n    797  \tif(!store_id){\n    798  \t\tstored->db_id = ++db.last_db_id;\n    799  \t}else{\n    800  \t\tstored->db_id = store_id;\n    801  \t}\n    802  \n    803  \tdb__msg_store_add(stored);\n    804  \n    805  \treturn MOSQ_ERR_SUCCESS;\n    806  }\nFunction: net__socket_close\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:205\n    205  int net__socket_close(struct mosquitto *mosq)\n    206  {\n    207  \tint rc = 0;\n    208  #ifdef WITH_BROKER\n    209  \tstruct mosquitto *mosq_found;\n    210  #endif\n    211  \n    212  \tassert(mosq);\n    213  #ifdef WITH_TLS\n    214  #ifdef WITH_WEBSOCKETS\n    215  \tif(!mosq->wsi)\n    216  #endif\n    217  \t{\n    218  \t\tif(mosq->ssl){\n    219  \t\t\tif(!SSL_in_init(mosq->ssl)){\n    220  \t\t\t\tSSL_shutdown(mosq->ssl);\n    221  \t\t\t}\n    222  \t\t\tSSL_free(mosq->ssl);\n    223  \t\t\tmosq->ssl = NULL;\n    224  \t\t}\n    225  \t}\n    226  #endif\n    227  \n    228  #ifdef WITH_WEBSOCKETS\n    229  \tif(mosq->wsi)\n    230  \t{\n    231  \t\tif(mosq->state != mosq_cs_disconnecting){\n    232  \t\t\tmosquitto__set_state(mosq, mosq_cs_disconnect_ws);\n    233  \t\t}\n    234  \t\tlws_callback_on_writable(mosq->wsi);\n    235  \t}else\n    236  #endif\n    237  \t{\n    238  \t\tif(mosq->sock != INVALID_SOCKET){\n    239  #ifdef WITH_BROKER\n    240  \t\t\tHASH_FIND(hh_sock, db.contexts_by_sock, &mosq->sock, sizeof(mosq->sock), mosq_found);\n    241  \t\t\tif(mosq_found){\n    242  \t\t\t\tHASH_DELETE(hh_sock, db.contexts_by_sock, mosq_found);\n    243  \t\t\t}\n    244  #endif\n    245  \t\t\trc = COMPAT_CLOSE(mosq->sock);\n    246  \t\t\tmosq->sock = INVALID_SOCKET;\n    247  \t\t}\n    248  \t}\n    249  \n    250  #ifdef WITH_BROKER\n    251  \tif(mosq->listener){\n    252  \t\tmosq->listener->client_count--;\n    253  \t\tmosq->listener = NULL;\n    254  \t}\n    255  #endif\n    256  \n    257  \treturn rc;\n    258  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    435  \tuint8_t will, will_retain, will_qos, clean_start;\n    436  \tuint8_t username_flag, password_flag;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    445  \tbool allow_zero_length_clientid;\n    446  #ifdef WITH_TLS\n    447  \tint i;\n    448  \tX509 *client_cert = NULL;\n    449  \tX509_NAME *name;\n    450  \tX509_NAME_ENTRY *name_entry;\n    451  \tASN1_STRING *name_asn1 = NULL;\n    452  \tBIO *subject_bio;\n    453  \tchar *data_start;\n    454  \tlong name_length;\n    455  \tchar *subject;\n    456  #endif\n    457  \n    458  \tG_CONNECTION_COUNT_INC();\n    459  \n    460  \tif(!context->listener){\n    461  \t\treturn MOSQ_ERR_INVAL;\n    462  \t}\n    463  \n    464  \t/* Don't accept multiple CONNECT commands. */\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    467  \t\trc = MOSQ_ERR_PROTOCOL;\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    470  \n    471  \t/* Read protocol name as length then bytes rather than with read_string\n    472  \t * because the length is fixed and we can check that. Removes the need\n    473  \t * for another malloc as well. */\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    475  \t\trc = MOSQ_ERR_PROTOCOL;\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    479  \t\trc = MOSQ_ERR_PROTOCOL;\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    483  \t\trc = MOSQ_ERR_PROTOCOL;\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    487  \n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    489  \t\trc = MOSQ_ERR_PROTOCOL;\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    499  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    502  \t\tcontext->protocol = mosq_p_mqtt31;\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    504  \t\t\tcontext->is_bridge = true;\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    508  \t\t\tcontext->protocol = mosq_p_mqtt311;\n    509  \n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    511  \t\t\t\tcontext->is_bridge = true;\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    514  \t\t\tcontext->protocol = mosq_p_mqtt5;\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    521  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    525  \t\t\t/* Reserved flags not set to 0, must disconnect. */\n    526  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    534  \t\trc = MOSQ_ERR_PROTOCOL;\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    540  \n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    542  \t\trc = MOSQ_ERR_PROTOCOL;\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    547  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    551  \n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    553  \t/* session_expiry_interval will be overriden if the properties are read later */\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    555  \t\t/* v3* has clean_start == false mean the session never expires */\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    563  \t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid Will QoS in CONNECT from %s.\",\n    564  \t\t\t\tcontext->address);\n    565  \t\trc = MOSQ_ERR_PROTOCOL;\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    571  \n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    576  \t\trc = MOSQ_ERR_NOT_SUPPORTED;\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    579  \n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    581  \t\trc = MOSQ_ERR_PROTOCOL;\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    584  \n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    590  \n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    595  \t\trc = MOSQ_ERR_NOT_SUPPORTED;\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    598  \n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    602  \n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    604  \n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    606  \t\trc = MOSQ_ERR_PROTOCOL;\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    609  \n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    613  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    618  \n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    630  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    639  \t\t\t\t\trc = MOSQ_ERR_NOMEM;\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    646  \n    647  \t/* clientid_prefixes check */\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    655  \t\t\trc = MOSQ_ERR_AUTH;\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    659  \n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    666  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    671  \n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    675  \t\t\trc = MOSQ_ERR_NOMEM;\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    679  \t\t\t\t/* Username flag given, but no username. Ignore. */\n    680  \t\t\t\tusername_flag = 0;\n    681  \t\t\t}else{\n    682  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    689  \t\t\t\t/* username_flag == 0 && password_flag == 1 is forbidden */\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    691  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    699  \t\t\trc = MOSQ_ERR_NOMEM;\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    703  \t\t\t\t/* Password flag given, but no password. Ignore. */\n    704  \t\t\t}else{\n    705  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    710  \n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    712  \t\t/* Surplus data at end of packet, this must be an error. */\n    713  \t\trc = MOSQ_ERR_PROTOCOL;\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    716  \n    717  \t/* Once context->id is set, if we return from this function with an error\n    718  \t * we must make sure that context->id is freed and set to NULL, so that the\n    719  \t * client isn't erroneously removed from the by_id hash table. */\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    722  \n    723  #ifdef WITH_TLS\n    724  \tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    725  \t\t/* Don't need the username or password if provided */\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    730  \n    731  \t\tif(!context->ssl){\n    732  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    734  \t\t\t}else{\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    736  \t\t\t}\n    737  \t\t\trc = MOSQ_ERR_AUTH;\n    738  \t\t\tgoto handle_connect_error;\n    739  \t\t}\n    740  #ifdef FINAL_WITH_TLS_PSK\n    741  \t\tif(context->listener->psk_hint){\n    742  \t\t\t/* Client should have provided an identity to get this far. */\n    743  \t\t\tif(!context->username){\n    744  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    746  \t\t\t\t}else{\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    748  \t\t\t\t}\n    749  \t\t\t\trc = MOSQ_ERR_AUTH;\n    750  \t\t\t\tgoto handle_connect_error;\n    751  \t\t\t}\n    752  \t\t}else{\n    753  #endif /* FINAL_WITH_TLS_PSK */\n    754  \t\t\tclient_cert = SSL_get_peer_certificate(context->ssl);\n    755  \t\t\tif(!client_cert){\n    756  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    758  \t\t\t\t}else{\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    760  \t\t\t\t}\n    761  \t\t\t\trc = MOSQ_ERR_AUTH;\n    762  \t\t\t\tgoto handle_connect_error;\n    763  \t\t\t}\n    764  \t\t\tname = X509_get_subject_name(client_cert);\n    765  \t\t\tif(!name){\n    766  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    768  \t\t\t\t}else{\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    770  \t\t\t\t}\n    771  \t\t\t\trc = MOSQ_ERR_AUTH;\n    772  \t\t\t\tgoto handle_connect_error;\n    773  \t\t\t}\n    774  \t\t\tif (context->listener->use_identity_as_username) { /* use_identity_as_username */\n    775  \t\t\t\ti = X509_NAME_get_index_by_NID(name, NID_commonName, -1);\n    776  \t\t\t\tif(i == -1){\n    777  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    779  \t\t\t\t\t}else{\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    781  \t\t\t\t\t}\n    782  \t\t\t\t\trc = MOSQ_ERR_AUTH;\n    783  \t\t\t\t\tgoto handle_connect_error;\n    784  \t\t\t\t}\n    785  \t\t\t\tname_entry = X509_NAME_get_entry(name, i);\n    786  \t\t\t\tif(name_entry){\n    787  \t\t\t\t\tname_asn1 = X509_NAME_ENTRY_get_data(name_entry);\n    788  \t\t\t\t\tif (name_asn1 == NULL) {\n    789  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    791  \t\t\t\t\t\t}else{\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    793  \t\t\t\t\t\t}\n    794  \t\t\t\t\t\trc = MOSQ_ERR_AUTH;\n    795  \t\t\t\t\t\tgoto handle_connect_error;\n    796  \t\t\t\t\t}\n    797  \t\t\t\t\tconst char *new_username;\n    798  #if OPENSSL_VERSION_NUMBER < 0x10100000L\n    799  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_data(name_asn1);\n    800  #else\n    801  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_get0_data(name_asn1);\n    802  #endif\n    803  \t\t\t\t\tif(mosquitto_validate_utf8(new_username, (int)strlen(new_username))){\n    804  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    806  \t\t\t\t\t\t}else{\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    808  \t\t\t\t\t\t}\n    809  \t\t\t\t\t\tX509_free(client_cert);\n    810  \t\t\t\t\t\treturn MOSQ_ERR_AUTH;\n    811  \t\t\t\t\t}\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    814  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    816  \t\t\t\t\t\t}else{\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    818  \t\t\t\t\t\t}\n    819  \t\t\t\t\t\trc = MOSQ_ERR_NOMEM;\n    820  \t\t\t\t\t\tgoto handle_connect_error;\n    821  \t\t\t\t\t}\n    822  \t\t\t\t\t/* Make sure there isn't an embedded NUL character in the CN */\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    824  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    826  \t\t\t\t\t\t}else{\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    828  \t\t\t\t\t\t}\n    829  \t\t\t\t\t\trc = MOSQ_ERR_AUTH;\n    830  \t\t\t\t\t\tgoto handle_connect_error;\n    831  \t\t\t\t\t}\n    832  \t\t\t\t}\n    833  \t\t\t} else { /* use_subject_as_username */\n    834  \t\t\t\tsubject_bio = BIO_new(BIO_s_mem());\n    835  \t\t\t\tX509_NAME_print_ex(subject_bio, X509_get_subject_name(client_cert), 0, XN_FLAG_RFC2253);\n    836  \t\t\t\tdata_start = NULL;\n    837  \t\t\t\tname_length = BIO_get_mem_data(subject_bio, &data_start);\n    838  \t\t\t\tsubject = mosquitto__malloc(sizeof(char)*(size_t)(name_length+1));\n    839  \t\t\t\tif(!subject){\n    840  \t\t\t\t\tBIO_free(subject_bio);\n    841  \t\t\t\t\trc = MOSQ_ERR_NOMEM;\n    842  \t\t\t\t\tgoto handle_connect_error;\n    843  \t\t\t\t}\n    844  \t\t\t\tmemcpy(subject, data_start, (size_t)name_length);\n    845  \t\t\t\tsubject[name_length] = '\\0';\n    846  \t\t\t\tBIO_free(subject_bio);\n    847  \t\t\t\tcontext->username = subject;\n    848  \t\t\t}\n    849  \t\t\tif(!context->username){\n    850  \t\t\t\trc = MOSQ_ERR_AUTH;\n    851  \t\t\t\tgoto handle_connect_error;\n    852  \t\t\t}\n    853  \t\t\tX509_free(client_cert);\n    854  \t\t\tclient_cert = NULL;\n    855  #ifdef FINAL_WITH_TLS_PSK\n    856  \t\t}\n    857  #endif /* FINAL_WITH_TLS_PSK */\n    858  \t}else\n    859  #endif /* WITH_TLS */\n    860  \t{\n    861  \t\t/* FIXME - these ensure the mosquitto_client_id() and\n    862  \t\t * mosquitto_client_username() functions work, but is hacky */\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    867  \t}\n    868  \n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    874  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    883  \t\t\trc = MOSQ_ERR_AUTH;\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    890  \n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    893  \t\tmosquitto__free(auth_data);\n    894  \t\tauth_data = NULL;\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    898  \t\t\tmosquitto__set_state(context, mosq_cs_authenticating);\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    900  \t\t\tfree(auth_data_out);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    903  \t\t\tfree(auth_data_out);\n    904  \t\t\tauth_data_out = NULL;\n    905  \t\t\twill__clear(context);\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    912  \t\t\t\t/* Client has requested extended authentication, but we don't support it. */\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    924  #ifdef WITH_TLS\n    925  \t\tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    926  \t\t\t/* Authentication assumed to be cleared */\n    927  \t\t}else\n    928  #endif\n    929  \t\t{\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    932  \t\t\t\tcase MOSQ_ERR_SUCCESS:\n    933  \t\t\t\t\tbreak;\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    940  \t\t\t\t\trc = MOSQ_ERR_AUTH;\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    944  \t\t\t\t\trc = MOSQ_ERR_UNKNOWN;\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    948  \t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    951  \n    952  \n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    955  \tmosquitto__free(auth_data);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    972  #ifdef WITH_TLS\n    973  \tif(client_cert) X509_free(client_cert);\n    974  #endif\n    975  \t/* We return an error here which means the client is freed later on. */\n    976  \tcontext->clean_start = true;\n    977  \tcontext->session_expiry_interval = 0;\n    978  \tcontext->will_delay_interval = 0;\n    979  \treturn rc;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    53   \tchar *client_id;\n    54   \tuint8_t rnd[16];\n    55   \tint i;\n    56   \tint pos;\n    57   \n    58   \tif(util__random_bytes(rnd, 16)) return NULL;\n    59   \n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    61   \n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    69   \n    70   \tpos = 0;\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    80   \n    81   \treturn client_id;\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    335  \tint rc = MOSQ_ERR_SUCCESS;\n    336  \tsize_t slen;\n    337  \tuint16_t tlen;\n    338  \tstruct mosquitto_message_all *will_struct = NULL;\n    339  \tchar *will_topic_mount = NULL;\n    340  \tuint16_t payloadlen;\n    341  \tmosquitto_property *properties = NULL;\n    342  \n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    344  \tif(!will_struct){\n    345  \t\trc = MOSQ_ERR_NOMEM;\n    346  \t\tgoto error_cleanup;\n    347  \t}\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    349  \t\trc = property__read_all(CMD_WILL, &context->in_packet, &properties);\n    350  \t\tif(rc) goto error_cleanup;\n    351  \n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    353  \t\tmosquitto_property_free_all(&properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    356  \trc = packet__read_string(&context->in_packet, &will_struct->msg.topic, &tlen);\n    357  \tif(rc) goto error_cleanup;\n    358  \tif(!tlen){\n    359  \t\trc = MOSQ_ERR_PROTOCOL;\n    360  \t\tgoto error_cleanup;\n    361  \t}\n    362  \n    363  \tif(context->listener->mount_point){\n    364  \t\tslen = strlen(context->listener->mount_point) + strlen(will_struct->msg.topic) + 1;\n    365  \t\twill_topic_mount = mosquitto__malloc(slen+1);\n    366  \t\tif(!will_topic_mount){\n    367  \t\t\trc = MOSQ_ERR_NOMEM;\n    368  \t\t\tgoto error_cleanup;\n    369  \t\t}\n    370  \n    371  \t\tsnprintf(will_topic_mount, slen, \"%s%s\", context->listener->mount_point, will_struct->msg.topic);\n    372  \t\twill_topic_mount[slen] = '\\0';\n    373  \n    374  \t\tmosquitto__free(will_struct->msg.topic);\n    375  \t\twill_struct->msg.topic = will_topic_mount;\n    376  \t}\n    377  \n    378  \tif(!strncmp(will_struct->msg.topic, \"$CONTROL/\", strlen(\"$CONTROL/\"))){\n    379  \t\trc = MOSQ_ERR_ACL_DENIED;\n    380  \t\tgoto error_cleanup;\n    381  \t}\n    382  \trc = mosquitto_pub_topic_check(will_struct->msg.topic);\n    383  \tif(rc) goto error_cleanup;\n    384  \n    385  \trc = packet__read_uint16(&context->in_packet, &payloadlen);\n    386  \tif(rc) goto error_cleanup;\n    387  \n    388  \twill_struct->msg.payloadlen = payloadlen;\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    391  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Client %s connected with too large Will payload\", client_id);\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    393  \t\t\t\tsend__connack(context, 0, MQTT_RC_PACKET_TOO_LARGE, NULL);\n    394  \t\t\t}else{\n    395  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    396  \t\t\t}\n    397  \t\t\trc = MOSQ_ERR_PAYLOAD_SIZE;\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    400  \t\twill_struct->msg.payload = mosquitto__malloc((size_t)will_struct->msg.payloadlen);\n    401  \t\tif(!will_struct->msg.payload){\n    402  \t\t\trc = MOSQ_ERR_NOMEM;\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    405  \n    406  \t\trc = packet__read_bytes(&context->in_packet, will_struct->msg.payload, (uint32_t)will_struct->msg.payloadlen);\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    409  \n    410  \twill_struct->msg.qos = will_qos;\n    411  \twill_struct->msg.retain = will_retain;\n    412  \n    413  \t*will = will_struct;\n    414  \treturn MOSQ_ERR_SUCCESS;\n    415  \n    416  error_cleanup:\n    417  \tif(will_struct){\n    418  \t\tmosquitto__free(will_struct->msg.topic);\n    419  \t\tmosquitto__free(will_struct->msg.payload);\n    420  \t\tmosquitto_property_free_all(&will_struct->properties);\n    421  \t\tmosquitto__free(will_struct);\n    422  \t}\n    423  \treturn rc;\n    424  }\nFunction: net__handle_ssl\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:938\n    938  static int net__handle_ssl(struct mosquitto* mosq, int ret)\n    939  {\n    940  \tint err;\n    941  \n    942  \terr = SSL_get_error(mosq->ssl, ret);\n    943  \tif (err == SSL_ERROR_WANT_READ) {\n    944  \t\tret = -1;\n    945  \t\terrno = EAGAIN;\n    946  \t}\n    947  \telse if (err == SSL_ERROR_WANT_WRITE) {\n    948  \t\tret = -1;\n    949  #ifdef WITH_BROKER\n    950  \t\tmux__add_out(mosq);\n    951  #else\n    952  \t\tmosq->want_write = true;\n    953  #endif\n    954  \t\terrno = EAGAIN;\n    955  \t}\n    956  \telse {\n    957  \t\tnet__print_ssl_error(mosq);\n    958  \t\terrno = EPROTO;\n    959  \t}\n    960  \tERR_clear_error();\n    961  #ifdef WIN32\n    962  \tWSASetLastError(errno);\n    963  #endif\n    964  \n    965  \treturn ret;\n    966  }\nFunction: net__write\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:996\n    996  ssize_t net__write(struct mosquitto *mosq, const void *buf, size_t count)\n    997  {\n    998  #ifdef WITH_TLS\n    999  \tint ret;\n    1000 #endif\n    1001 \tassert(mosq);\n    1002 \n    1003 \terrno = 0;\n    1004 #ifdef WITH_TLS\n    1005 \tif(mosq->ssl){\n    1006 \t\tERR_clear_error();\n    1007 \t\tmosq->want_write = false;\n    1008 \t\tret = SSL_write(mosq->ssl, buf, (int)count);\n    1009 \t\tif(ret < 0){\n    1010 \t\t\tret = net__handle_ssl(mosq, ret);\n    1011 \t\t}\n    1012 \t\treturn (ssize_t )ret;\n    1013 \t}else{\n    1014 \t\t/* Call normal write/send */\n    1015 #endif\n    1016 \n    1017 \treturn send(mosq->sock, buf, count, MSG_NOSIGNAL);\n    1018 \n    1019 #ifdef WITH_TLS\n    1020 \t}\n    1021 #endif\n    1022 }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    51   \tassert(packet);\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    53   \n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    56   \n    57   \treturn MOSQ_ERR_SUCCESS;\n    58   }\nFunction: packet__write_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:61\n    61   void packet__write_byte(struct mosquitto__packet *packet, uint8_t byte)\n    62   {\n    63   \tassert(packet);\n    64   \tassert(packet->pos+1 <= packet->packet_length);\n    65   \n    66   \tpacket->payload[packet->pos] = byte;\n    67   \tpacket->pos++;\n    68   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    73   \tassert(packet);\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    75   \n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    78   \n    79   \treturn MOSQ_ERR_SUCCESS;\n    80   }\nFunction: packet__write_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:83\n    83   void packet__write_bytes(struct mosquitto__packet *packet, const void *bytes, uint32_t count)\n    84   {\n    85   \tassert(packet);\n    86   \tassert(packet->pos+count <= packet->packet_length);\n    87   \n    88   \tif(count > 0){\n    89   \t\tmemcpy(&(packet->payload[packet->pos]), bytes, count);\n    90   \t\tpacket->pos += count;\n    91   \t}\n    92   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    98   \tint rc;\n    99   \n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    103  \n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    106  \t\t*length = 0;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    109  \n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    111  \n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    120  \n    121  \t*length = slen;\n    122  \treturn MOSQ_ERR_SUCCESS;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    155  \tuint8_t msb, lsb;\n    156  \n    157  \tassert(packet);\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    159  \n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    164  \n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    166  \n    167  \treturn MOSQ_ERR_SUCCESS;\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    128  \tint rc;\n    129  \n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    133  \n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    140  \n    141  \treturn MOSQ_ERR_SUCCESS;\n    142  }\nFunction: packet__write_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:145\n    145  void packet__write_string(struct mosquitto__packet *packet, const char *str, uint16_t length)\n    146  {\n    147  \tassert(packet);\n    148  \tpacket__write_uint16(packet, length);\n    149  \tpacket__write_bytes(packet, str, length);\n    150  }\nFunction: packet__write_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:171\n    171  void packet__write_uint16(struct mosquitto__packet *packet, uint16_t word)\n    172  {\n    173  \tpacket__write_byte(packet, MOSQ_MSB(word));\n    174  \tpacket__write_byte(packet, MOSQ_LSB(word));\n    175  }\nFunction: mosquitto_property_add_string\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:845\n    845  int mosquitto_property_add_string(mosquitto_property **proplist, int identifier, const char *value)\n    846  {\n    847  \tmosquitto_property *prop;\n    848  \tsize_t slen = 0;\n    849  \n    850  \tif(!proplist) return MOSQ_ERR_INVAL;\n    851  \tif(value){\n    852  \t\tslen = strlen(value);\n    853  \t\tif(mosquitto_validate_utf8(value, (int)slen)) return MOSQ_ERR_MALFORMED_UTF8;\n    854  \t}\n    855  \n    856  \tif(identifier != MQTT_PROP_CONTENT_TYPE\n    857  \t\t\t&& identifier != MQTT_PROP_RESPONSE_TOPIC\n    858  \t\t\t&& identifier != MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER\n    859  \t\t\t&& identifier != MQTT_PROP_AUTHENTICATION_METHOD\n    860  \t\t\t&& identifier != MQTT_PROP_RESPONSE_INFORMATION\n    861  \t\t\t&& identifier != MQTT_PROP_SERVER_REFERENCE\n    862  \t\t\t&& identifier != MQTT_PROP_REASON_STRING){\n    863  \n    864  \t\treturn MOSQ_ERR_INVAL;\n    865  \t}\n    866  \n    867  \tprop = mosquitto__calloc(1, sizeof(mosquitto_property));\n    868  \tif(!prop) return MOSQ_ERR_NOMEM;\n    869  \n    870  \tprop->client_generated = true;\n    871  \tprop->identifier = identifier;\n    872  \tif(value && slen > 0){\n    873  \t\tprop->value.s.v = mosquitto__strdup(value);\n    874  \t\tif(!prop->value.s.v){\n    875  \t\t\tmosquitto__free(prop);\n    876  \t\t\treturn MOSQ_ERR_NOMEM;\n    877  \t\t}\n    878  \t\tprop->value.s.len = (uint16_t)slen;\n    879  \t}\n    880  \n    881  \tproperty__add(proplist, prop);\n    882  \treturn MOSQ_ERR_SUCCESS;\n    883  }\nFunction: property__get_property\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:988\n    988  static const mosquitto_property *property__get_property(const mosquitto_property *proplist, int identifier, bool skip_first)\n    989  {\n    990  \tconst mosquitto_property *p;\n    991  \tbool is_first = true;\n    992  \n    993  \tp = proplist;\n    994  \n    995  \twhile(p){\n    996  \t\tif(p->identifier == identifier){\n    997  \t\t\tif(!is_first || !skip_first){\n    998  \t\t\t\treturn p;\n    999  \t\t\t}\n    1000 \t\t\tis_first = false;\n    1001 \t\t}\n    1002 \t\tp = p->next;\n    1003 \t}\n    1004 \treturn NULL;\n    1005 }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    280  #ifdef WITH_WEBSOCKETS\n    281  \tbool is_duplicate = false;\n    282  #endif\n    283  \n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    287  #ifdef WITH_WEBSOCKETS\n    288  \tif(context->wsi){\n    289  \t\tif(context->state == mosq_cs_duplicate){\n    290  \t\t\tis_duplicate = true;\n    291  \t\t}\n    292  \n    293  \t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    294  \t\t\tmosquitto__set_state(context, mosq_cs_disconnect_ws);\n    295  \t\t}\n    296  \t\tif(context->wsi){\n    297  \t\t\tlws_callback_on_writable(context->wsi);\n    298  \t\t}\n    299  \t\tif(context->sock != INVALID_SOCKET){\n    300  \t\t\tHASH_DELETE(hh_sock, db.contexts_by_sock, context);\n    301  \t\t\tmux__delete(context);\n    302  \t\t\tcontext->sock = INVALID_SOCKET;\n    303  \t\t}\n    304  \t\tif(is_duplicate){\n    305  \t\t\t/* This occurs if another client is taking over the same client id.\n    306  \t\t\t * It is important to remove this from the by_id hash here, so it\n    307  \t\t\t * doesn't leave us with multiple clients in the hash with the same\n    308  \t\t\t * id. Websockets doesn't actually close the connection here,\n    309  \t\t\t * unlike for normal clients, which means there is extra time when\n    310  \t\t\t * there could be two clients with the same id in the hash. */\n    311  \t\t\tcontext__remove_from_by_id(context);\n    312  \t\t}\n    313  \t}else\n    314  #endif\n    315  \t{\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    320  \t\t\t\tid = \"<unknown>\";\n    321  \t\t\t}\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    324  \t\t\t\t\tcase MOSQ_ERR_SUCCESS:\n    325  \t\t\t\t\t\tbreak;\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    371  \t\tmux__delete(context);\n    372  \t\tcontext__disconnect(context);\n    373  \t}\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    52   \tvoid *mem;\n    53   #ifdef REAL_WITH_MEMORY_TRACKING\n    54   \tif(mem_limit && memcount + size > mem_limit){\n    55   \t\treturn NULL;\n    56   \t}\n    57   #endif\n    58   \tmem = calloc(nmemb, size);\n    59   \n    60   #ifdef REAL_WITH_MEMORY_TRACKING\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    63   \t\tif(memcount > max_memcount){\n    64   \t\t\tmax_memcount = memcount;\n    65   \t\t}\n    66   \t}\n    67   #endif\n    68   \n    69   \treturn mem;\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    74   #ifdef REAL_WITH_MEMORY_TRACKING\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    79   #endif\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto__malloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:83\n    83   void *mosquitto__malloc(size_t size)\n    84   {\n    85   \tvoid *mem;\n    86   \n    87   #ifdef REAL_WITH_MEMORY_TRACKING\n    88   \tif(mem_limit && memcount + size > mem_limit){\n    89   \t\treturn NULL;\n    90   \t}\n    91   #endif\n    92   \n    93   \tmem = malloc(size);\n    94   \n    95   #ifdef REAL_WITH_MEMORY_TRACKING\n    96   \tif(mem){\n    97   \t\tmemcount += malloc_usable_size(mem);\n    98   \t\tif(memcount > max_memcount){\n    99   \t\t\tmax_memcount = memcount;\n    100  \t\t}\n    101  \t}\n    102  #endif\n    103  \n    104  \treturn mem;\n    105  }\nFunction: mosquitto__realloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:119\n    119  void *mosquitto__realloc(void *ptr, size_t size)\n    120  {\n    121  \tvoid *mem;\n    122  #ifdef REAL_WITH_MEMORY_TRACKING\n    123  \tif(mem_limit && memcount + size > mem_limit){\n    124  \t\treturn NULL;\n    125  \t}\n    126  \tif(ptr){\n    127  \t\tmemcount -= malloc_usable_size(ptr);\n    128  \t}\n    129  #endif\n    130  \tmem = realloc(ptr, size);\n    131  \n    132  #ifdef REAL_WITH_MEMORY_TRACKING\n    133  \tif(mem){\n    134  \t\tmemcount += malloc_usable_size(mem);\n    135  \t\tif(memcount > max_memcount){\n    136  \t\t\tmax_memcount = memcount;\n    137  \t\t}\n    138  \t}\n    139  #endif\n    140  \n    141  \treturn mem;\n    142  }\nFunction: mosquitto__strdup\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:144\n    144  char *mosquitto__strdup(const char *s)\n    145  {\n    146  \tchar *str;\n    147  #ifdef REAL_WITH_MEMORY_TRACKING\n    148  \tif(mem_limit && memcount + strlen(s) > mem_limit){\n    149  \t\treturn NULL;\n    150  \t}\n    151  #endif\n    152  \tstr = strdup(s);\n    153  \n    154  #ifdef REAL_WITH_MEMORY_TRACKING\n    155  \tif(str){\n    156  \t\tmemcount += malloc_usable_size(str);\n    157  \t\tif(memcount > max_memcount){\n    158  \t\t\tmax_memcount = memcount;\n    159  \t\t}\n    160  \t}\n    161  #endif\n    162  \n    163  \treturn str;\n    164  }\nFunction: mosquitto_free\nPath: /root/projects/mosquitto/src/memory_public.c:27\n    27   void mosquitto_free(void *mem)\n    28   {\n    29   \tmosquitto__free(mem);\n    30   }\nFunction: mosquitto_malloc\nPath: /root/projects/mosquitto/src/memory_public.c:32\n    32   void *mosquitto_malloc(size_t size)\n    33   {\n    34   \treturn mosquitto__malloc(size);\n    35   }\nFunction: mux__add_out\nPath: /root/projects/mosquitto/src/mux.c:31\n    31   int mux__add_out(struct mosquitto *context)\n    32   {\n    33   #ifdef WITH_EPOLL\n    34   \treturn mux_epoll__add_out(context);\n    35   #else\n    36   \treturn mux_poll__add_out(context);\n    37   #endif\n    38   }\nFunction: mux__remove_out\nPath: /root/projects/mosquitto/src/mux.c:41\n    41   int mux__remove_out(struct mosquitto *context)\n    42   {\n    43   #ifdef WITH_EPOLL\n    44   \treturn mux_epoll__remove_out(context);\n    45   #else\n    46   \treturn mux_poll__remove_out(context);\n    47   #endif\n    48   }\nFunction: mux__delete\nPath: /root/projects/mosquitto/src/mux.c:61\n    61   int mux__delete(struct mosquitto *context)\n    62   {\n    63   #ifdef WITH_EPOLL\n    64   \treturn mux_epoll__delete(context);\n    65   #else\n    66   \treturn mux_poll__delete(context);\n    67   #endif\n    68   }\nFunction: mux_epoll__add_out\nPath: /root/projects/mosquitto/src/mux_epoll.c:108\n    108  int mux_epoll__add_out(struct mosquitto *context)\n    109  {\n    110  \tstruct epoll_event ev;\n    111  \n    112  \tif(!(context->events & EPOLLOUT)) {\n    113  \t\tmemset(&ev, 0, sizeof(struct epoll_event));\n    114  \t\tev.data.ptr = context;\n    115  \t\tev.events = EPOLLIN | EPOLLOUT;\n    116  \t\tif(epoll_ctl(db.epollfd, EPOLL_CTL_ADD, context->sock, &ev) == -1) {\n    117  \t\t\tif((errno != EEXIST)||(epoll_ctl(db.epollfd, EPOLL_CTL_MOD, context->sock, &ev) == -1)) {\n    118  \t\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Error in epoll re-registering to EPOLLOUT: %s\", strerror(errno));\n    119  \t\t\t}\n    120  \t\t}\n    121  \t\tcontext->events = EPOLLIN | EPOLLOUT;\n    122  \t}\n    123  \treturn MOSQ_ERR_SUCCESS;\n    124  }\nFunction: mux_epoll__remove_out\nPath: /root/projects/mosquitto/src/mux_epoll.c:127\n    127  int mux_epoll__remove_out(struct mosquitto *context)\n    128  {\n    129  \tstruct epoll_event ev;\n    130  \n    131  \tif(context->events & EPOLLOUT) {\n    132  \t\tmemset(&ev, 0, sizeof(struct epoll_event));\n    133  \t\tev.data.ptr = context;\n    134  \t\tev.events = EPOLLIN;\n    135  \t\tif(epoll_ctl(db.epollfd, EPOLL_CTL_ADD, context->sock, &ev) == -1) {\n    136  \t\t\tif((errno != EEXIST)||(epoll_ctl(db.epollfd, EPOLL_CTL_MOD, context->sock, &ev) == -1)) {\n    137  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Error in epoll re-registering to EPOLLIN: %s\", strerror(errno));\n    138  \t\t\t}\n    139  \t\t}\n    140  \t\tcontext->events = EPOLLIN;\n    141  \t}\n    142  \treturn MOSQ_ERR_SUCCESS;\n    143  }\nFunction: mux_epoll__delete\nPath: /root/projects/mosquitto/src/mux_epoll.c:163\n    163  int mux_epoll__delete(struct mosquitto *context)\n    164  {\n    165  \tstruct epoll_event ev;\n    166  \n    167  \tmemset(&ev, 0, sizeof(struct epoll_event));\n    168  \tif(context->sock != INVALID_SOCKET){\n    169  \t\tif(epoll_ctl(db.epollfd, EPOLL_CTL_DEL, context->sock, &ev) == -1){\n    170  \t\t\treturn 1;\n    171  \t\t}\n    172  \t}\n    173  \treturn 0;\n    174  }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    30   \tstruct mosquitto__packet *packet = NULL;\n    31   \tint rc;\n    32   \tmosquitto_property *connack_props = NULL;\n    33   \tuint32_t remaining_length;\n    34   \n    35   \trc = mosquitto_property_copy_all(&connack_props, properties);\n    36   \tif(rc){\n    37   \t\treturn rc;\n    38   \t}\n    39   \n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    43   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->address, ack, reason_code);\n    44   \t}\n    45   \n    46   \tremaining_length = 2;\n    47   \n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    50   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_RETAIN_AVAILABLE, 0);\n    51   \t\t\tif(rc){\n    52   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    57   \t\t\trc = mosquitto_property_add_int32(&connack_props, MQTT_PROP_MAXIMUM_PACKET_SIZE, db.config->max_packet_size);\n    58   \t\t\tif(rc){\n    59   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    64   \t\t\trc = mosquitto_property_add_int16(&connack_props, MQTT_PROP_RECEIVE_MAXIMUM, db.config->max_inflight_messages);\n    65   \t\t\tif(rc){\n    66   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    71   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_MAXIMUM_QOS, context->listener->max_qos);\n    72   \t\t\tif(rc){\n    73   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    77   \n    78   \t\tremaining_length += property__get_remaining_length(connack_props);\n    79   \t}\n    80   \n    81   \tif(packet__check_oversize(context, remaining_length)){\n    82   \t\tmosquitto_property_free_all(&connack_props);\n    83   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    84   \t}\n    85   \n    86   \tpacket = mosquitto__calloc(1, sizeof(struct mosquitto__packet));\n    87   \tif(!packet){\n    88   \t\tmosquitto_property_free_all(&connack_props);\n    89   \t\treturn MOSQ_ERR_NOMEM;\n    90   \t}\n    91   \n    92   \tpacket->command = CMD_CONNACK;\n    93   \tpacket->remaining_length = remaining_length;\n    94   \n    95   \trc = packet__alloc(packet);\n    96   \tif(rc){\n    97   \t\tmosquitto_property_free_all(&connack_props);\n    98   \t\tmosquitto__free(packet);\n    99   \t\treturn rc;\n    100  \t}\n    101  \tpacket__write_byte(packet, ack);\n    102  \tpacket__write_byte(packet, reason_code);\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    104  \t\tproperty__write_all(packet, connack_props, true);\n    105  \t}\n    106  \tmosquitto_property_free_all(&connack_props);\n    107  \n    108  \treturn packet__queue(context, packet);\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    39   \tstruct mosquitto__packet *packet = NULL;\n    40   \tint rc;\n    41   \n    42   \tassert(mosq);\n    43   #ifdef WITH_BROKER\n    44   #  ifdef WITH_BRIDGE\n    45   \tif(mosq->bridge){\n    46   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Bridge %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    47   \t}else\n    48   #  else\n    49   \t{\n    50   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Sending DISCONNECT to %s (rc%d)\", SAFE_PRINT(mosq->id), reason_code);\n    51   \t}\n    52   #  endif\n    53   #else\n    54   \tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Client %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    55   #endif\n    56   \tassert(mosq);\n    57   \tpacket = mosquitto__calloc(1, sizeof(struct mosquitto__packet));\n    58   \tif(!packet) return MOSQ_ERR_NOMEM;\n    59   \n    60   \tpacket->command = CMD_DISCONNECT;\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    62   \t\tpacket->remaining_length = 1;\n    63   \t\tif(properties){\n    64   \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    65   \t\t}\n    66   \t}else{\n    67   \t\tpacket->remaining_length = 0;\n    68   \t}\n    69   \n    70   \trc = packet__alloc(packet);\n    71   \tif(rc){\n    72   \t\tmosquitto__free(packet);\n    73   \t\treturn rc;\n    74   \t}\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    76   \t\tpacket__write_byte(packet, reason_code);\n    77   \t\tif(properties){\n    78   \t\t\tproperty__write_all(packet, properties, true);\n    79   \t\t}\n    80   \t}\n    81   \n    82   \treturn packet__queue(mosq, packet);\n    83   }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    123  \tstruct mosquitto__packet *packet = NULL;\n    124  \tint rc;\n    125  \n    126  \tassert(mosq);\n    127  \tpacket = mosquitto__calloc(1, sizeof(struct mosquitto__packet));\n    128  \tif(!packet) return MOSQ_ERR_NOMEM;\n    129  \n    130  \tpacket->command = command;\n    131  \tif(dup){\n    132  \t\tpacket->command |= 8;\n    133  \t}\n    134  \tpacket->remaining_length = 2;\n    135  \n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    137  \t\tif(reason_code != 0 || properties){\n    138  \t\t\tpacket->remaining_length += 1;\n    139  \t\t}\n    140  \n    141  \t\tif(properties){\n    142  \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    143  \t\t}\n    144  \t}\n    145  \n    146  \trc = packet__alloc(packet);\n    147  \tif(rc){\n    148  \t\tmosquitto__free(packet);\n    149  \t\treturn rc;\n    150  \t}\n    151  \n    152  \tpacket__write_uint16(packet, mid);\n    153  \n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tif(reason_code != 0 || properties){\n    156  \t\t\tpacket__write_byte(packet, reason_code);\n    157  \t\t}\n    158  \t\tif(properties){\n    159  \t\t\tproperty__write_all(packet, properties, true);\n    160  \t\t}\n    161  \t}\n    162  \n    163  \treturn packet__queue(mosq, packet);\n    164  }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    110  {\n    111  #ifdef WITH_BROKER\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    113  #else\n    114  \tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Client %s sending PUBREL (m%d)\", SAFE_PRINT(mosq->id), mid);\n    115  #endif\n    116  \t/* We don't use Reason String or User Property yet. */\n    117  \treturn send__command_with_mid(mosq, CMD_PUBREL|2, mid, false, 0, properties);\n    118  }\nFunction: session_expiry__add\nPath: /root/projects/mosquitto/src/session_expiry.c:66\n    66   int session_expiry__add(struct mosquitto *context)\n    67   {\n    68   \tstruct session_expiry_list *item;\n    69   \n    70   \tif(db.config->persistent_client_expiration == 0){\n    71   \t\tif(context->session_expiry_interval == UINT32_MAX){\n    72   \t\t\t/* There isn't a global expiry set, and the client has asked to\n    73   \t\t\t * never expire, so we don't add it to the list. */\n    74   \t\t\treturn MOSQ_ERR_SUCCESS;\n    75   \t\t}\n    76   \t}\n    77   \n    78   \titem = mosquitto__calloc(1, sizeof(struct session_expiry_list));\n    79   \tif(!item) return MOSQ_ERR_NOMEM;\n    80   \n    81   \titem->context = context;\n    82   \tset_session_expiry_time(item->context);\n    83   \tcontext->expiry_list_item = item;\n    84   \n    85   \tDL_INSERT_INORDER(expiry_list, item, session_expiry__cmp);\n    86   \n    87   \treturn MOSQ_ERR_SUCCESS;\n    88   }\nFunction: set_session_expiry_time\nPath: /root/projects/mosquitto/src/session_expiry.c:46\n    46   static void set_session_expiry_time(struct mosquitto *context)\n    47   {\n    48   \tcontext->session_expiry_time = db.now_real_s;\n    49   \n    50   \tif(db.config->persistent_client_expiration == 0){\n    51   \t\t/* No global expiry, so use the client expiration interval */\n    52   \t\tcontext->session_expiry_time += context->session_expiry_interval;\n    53   \t}else{\n    54   \t\t/* We have a global expiry interval */\n    55   \t\tif(db.config->persistent_client_expiration < context->session_expiry_interval){\n    56   \t\t\t/* The client expiry is longer than the global expiry, so use the global */\n    57   \t\t\tcontext->session_expiry_time += db.config->persistent_client_expiration;\n    58   \t\t}else{\n    59   \t\t\t/* The global expiry is longer than the client expiry, so use the client */\n    60   \t\t\tcontext->session_expiry_time += context->session_expiry_interval;\n    61   \t\t}\n    62   \t}\n    63   }\nFunction: session_expiry__cmp\nPath: /root/projects/mosquitto/src/session_expiry.c:34\n    34   static int session_expiry__cmp(struct session_expiry_list *i1, struct session_expiry_list *i2)\n    35   {\n    36   \tif(i1->context->session_expiry_time == i2->context->session_expiry_time){\n    37   \t\treturn 0;\n    38   \t}else if(i1->context->session_expiry_time > i2->context->session_expiry_time){\n    39   \t\treturn 1;\n    40   \t}else{\n    41   \t\treturn -1;\n    42   \t}\n    43   }\nFunction: session_expiry__remove\nPath: /root/projects/mosquitto/src/session_expiry.c:121\n    121  void session_expiry__remove(struct mosquitto *context)\n    122  {\n    123  \tif(context->expiry_list_item){\n    124  \t\tDL_DELETE(expiry_list, context->expiry_list_item);\n    125  \t\tmosquitto__free(context->expiry_list_item);\n    126  \t\tcontext->expiry_list_item = NULL;\n    127  \t}\n    128  }\nFunction: mosquitto_acl_check\nPath: /root/projects/mosquitto/src/security.c:679\n    679  int mosquitto_acl_check(struct mosquitto *context, const char *topic, uint32_t payloadlen, void* payload, uint8_t qos, bool retain, int access)\n    680  {\n    681  \tint rc;\n    682  \tint i;\n    683  \tstruct mosquitto__security_options *opts;\n    684  \tstruct mosquitto_acl_msg msg;\n    685  \tstruct mosquitto__callback *cb_base;\n    686  \tstruct mosquitto_evt_acl_check event_data;\n    687  \n    688  \tif(!context->id){\n    689  \t\treturn MOSQ_ERR_ACL_DENIED;\n    690  \t}\n    691  \tif(context->bridge){\n    692  \t\treturn MOSQ_ERR_SUCCESS;\n    693  \t}\n    694  \n    695  \trc = acl__check_dollar(topic, access);\n    696  \tif(rc) return rc;\n    697  \n    698  \t/*\n    699  \t * If no plugins exist we should accept at this point so set rc to success.\n    700  \t */\n    701  \trc = MOSQ_ERR_SUCCESS;\n    702  \n    703  \tif(db.config->per_listener_settings){\n    704  \t\tif(context->listener){\n    705  \t\t\topts = &context->listener->security_options;\n    706  \t\t}else{\n    707  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    708  \t\t}\n    709  \t}else{\n    710  \t\topts = &db.config->security_options;\n    711  \t}\n    712  \n    713  \tmemset(&msg, 0, sizeof(msg));\n    714  \tmsg.topic = topic;\n    715  \tmsg.payloadlen = payloadlen;\n    716  \tmsg.payload = payload;\n    717  \tmsg.qos = qos;\n    718  \tmsg.retain = retain;\n    719  \n    720  \tDL_FOREACH(opts->plugin_callbacks.acl_check, cb_base){\n    721  \t\t/* FIXME - username deny special chars */\n    722  \n    723  \t\tmemset(&event_data, 0, sizeof(event_data));\n    724  \t\tevent_data.client = context;\n    725  \t\tevent_data.access = access;\n    726  \t\tevent_data.topic = topic;\n    727  \t\tevent_data.payloadlen = payloadlen;\n    728  \t\tevent_data.payload = payload;\n    729  \t\tevent_data.qos = qos;\n    730  \t\tevent_data.retain = retain;\n    731  \t\tevent_data.properties = NULL;\n    732  \t\trc = cb_base->cb(MOSQ_EVT_ACL_CHECK, &event_data, cb_base->userdata);\n    733  \t\tif(rc != MOSQ_ERR_PLUGIN_DEFER){\n    734  \t\t\treturn rc;\n    735  \t\t}\n    736  \t}\n    737  \n    738  \tfor(i=0; i<opts->auth_plugin_config_count; i++){\n    739  \t\tif(opts->auth_plugin_configs[i].plugin.version < 5){\n    740  \t\t\trc = acl__check_single(&opts->auth_plugin_configs[i], context, &msg, access);\n    741  \t\t\tif(rc != MOSQ_ERR_PLUGIN_DEFER){\n    742  \t\t\t\treturn rc;\n    743  \t\t\t}\n    744  \t\t}\n    745  \t}\n    746  \n    747  \t/* If all plugins deferred, this is a denial. If rc == MOSQ_ERR_SUCCESS\n    748  \t * here, then no plugins were configured. */\n    749  \tif(rc == MOSQ_ERR_PLUGIN_DEFER){\n    750  \t\trc = MOSQ_ERR_ACL_DENIED;\n    751  \t}\n    752  \treturn rc;\n    753  }\nFunction: acl__check_single\nPath: /root/projects/mosquitto/src/security.c:602\n    602  static int acl__check_single(struct mosquitto__auth_plugin_config *auth_plugin, struct mosquitto *context, struct mosquitto_acl_msg *msg, int access)\n    603  {\n    604  \tconst char *username;\n    605  \tconst char *topic = msg->topic;\n    606  \n    607  \tusername = mosquitto_client_username(context);\n    608  \tif(auth_plugin->deny_special_chars == true){\n    609  \t\t/* Check whether the client id or username contains a +, # or / and if\n    610  \t\t* so deny access.\n    611  \t\t*\n    612  \t\t* Do this check for every message regardless, we have to protect the\n    613  \t\t* plugins against possible pattern based attacks.\n    614  \t\t*/\n    615  \t\tif(username && strpbrk(username, \"+#\")){\n    616  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous username \\\"%s\\\"\", username);\n    617  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    618  \t\t}\n    619  \t\tif(context->id && strpbrk(context->id, \"+#\")){\n    620  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous client id \\\"%s\\\"\", context->id);\n    621  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    622  \t\t}\n    623  \t}\n    624  \n    625  \tif(auth_plugin->plugin.version == 4){\n    626  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    627  \t\t\treturn MOSQ_ERR_SUCCESS;\n    628  \t\t}\n    629  \t\treturn auth_plugin->plugin.acl_check_v4(auth_plugin->plugin.user_data, access, context, msg);\n    630  \t}else if(auth_plugin->plugin.version == 3){\n    631  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    632  \t\t\treturn MOSQ_ERR_SUCCESS;\n    633  \t\t}\n    634  \t\treturn auth_plugin->plugin.acl_check_v3(auth_plugin->plugin.user_data, access, context, msg);\n    635  \t}else if(auth_plugin->plugin.version == 2){\n    636  \t\tif(access == MOSQ_ACL_SUBSCRIBE || access == MOSQ_ACL_UNSUBSCRIBE){\n    637  \t\t\treturn MOSQ_ERR_SUCCESS;\n    638  \t\t}\n    639  \t\treturn auth_plugin->plugin.acl_check_v2(auth_plugin->plugin.user_data, context->id, username, topic, access);\n    640  \t}else{\n    641  \t\treturn MOSQ_ERR_INVAL;\n    642  \t}\n    643  }\nFunction: mosquitto_unpwd_check\nPath: /root/projects/mosquitto/src/security.c:755\n    755  int mosquitto_unpwd_check(struct mosquitto *context)\n    756  {\n    757  \tint rc;\n    758  \tint i;\n    759  \tstruct mosquitto__security_options *opts;\n    760  \tstruct mosquitto_evt_basic_auth event_data;\n    761  \tstruct mosquitto__callback *cb_base;\n    762  \tbool plugin_used = false;\n    763  \n    764  \trc = MOSQ_ERR_PLUGIN_DEFER;\n    765  \n    766  \tif(db.config->per_listener_settings){\n    767  \t\tif(context->listener == NULL){\n    768  \t\t\treturn MOSQ_ERR_AUTH;\n    769  \t\t}\n    770  \t\topts = &context->listener->security_options;\n    771  \t}else{\n    772  \t\topts = &db.config->security_options;\n    773  \t}\n    774  \n    775  \tDL_FOREACH(opts->plugin_callbacks.basic_auth, cb_base){\n    776  \t\tmemset(&event_data, 0, sizeof(event_data));\n    777  \t\tevent_data.client = context;\n    778  \t\tevent_data.username = context->username;\n    779  \t\tevent_data.password = context->password;\n    780  \t\trc = cb_base->cb(MOSQ_EVT_BASIC_AUTH, &event_data, cb_base->userdata);\n    781  \t\tif(rc != MOSQ_ERR_PLUGIN_DEFER){\n    782  \t\t\treturn rc;\n    783  \t\t}\n    784  \t\tplugin_used = true;\n    785  \t}\n    786  \n    787  \tfor(i=0; i<opts->auth_plugin_config_count; i++){\n    788  \t\tif(opts->auth_plugin_configs[i].plugin.version == 4\n    789  \t\t\t\t&& opts->auth_plugin_configs[i].plugin.unpwd_check_v4){\n    790  \n    791  \t\t\trc = opts->auth_plugin_configs[i].plugin.unpwd_check_v4(\n    792  \t\t\t\t\topts->auth_plugin_configs[i].plugin.user_data,\n    793  \t\t\t\t\tcontext,\n    794  \t\t\t\t\tcontext->username,\n    795  \t\t\t\t\tcontext->password);\n    796  \t\t\tplugin_used = true;\n    797  \n    798  \t\t}else if(opts->auth_plugin_configs[i].plugin.version == 3){\n    799  \t\t\trc = opts->auth_plugin_configs[i].plugin.unpwd_check_v3(\n    800  \t\t\t\t\topts->auth_plugin_configs[i].plugin.user_data,\n    801  \t\t\t\t\tcontext,\n    802  \t\t\t\t\tcontext->username,\n    803  \t\t\t\t\tcontext->password);\n    804  \t\t\tplugin_used = true;\n    805  \n    806  \t\t}else if(opts->auth_plugin_configs[i].plugin.version == 2){\n    807  \t\t\trc = opts->auth_plugin_configs[i].plugin.unpwd_check_v2(\n    808  \t\t\t\t\topts->auth_plugin_configs[i].plugin.user_data,\n    809  \t\t\t\t\tcontext->username,\n    810  \t\t\t\t\tcontext->password);\n    811  \t\t\tplugin_used = true;\n    812  \t\t}\n    813  \t}\n    814  \t/* If all plugins deferred, this is a denial. If rc == MOSQ_ERR_SUCCESS\n    815  \t * here, then no plugins were configured. Unless we have all deferred, and\n    816  \t * anonymous logins are allowed. */\n    817  \tif(plugin_used == false){\n    818  \t\tif((db.config->per_listener_settings && context->listener->security_options.allow_anonymous != false)\n    819  \t\t\t\t|| (!db.config->per_listener_settings && db.config->security_options.allow_anonymous != false)){\n    820  \n    821  \t\t\treturn MOSQ_ERR_SUCCESS;\n    822  \t\t}else{\n    823  \t\t\treturn MOSQ_ERR_AUTH;\n    824  \t\t}\n    825  \t}else{\n    826  \t\tif(rc == MOSQ_ERR_PLUGIN_DEFER){\n    827  \t\t\tif(context->username == NULL &&\n    828  \t\t\t\t\t((db.config->per_listener_settings && context->listener->security_options.allow_anonymous != false)\n    829  \t\t\t\t\t|| (!db.config->per_listener_settings && db.config->security_options.allow_anonymous != false))){\n    830  \n    831  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    832  \t\t\t}else{\n    833  \t\t\t\treturn MOSQ_ERR_AUTH;\n    834  \t\t\t}\n    835  \t\t}\n    836  \t}\n    837  \n    838  \treturn rc;\n    839  }\nFunction: mosquitto_security_auth_start\nPath: /root/projects/mosquitto/src/security.c:922\n    922  int mosquitto_security_auth_start(struct mosquitto *context, bool reauth, const void *data_in, uint16_t data_in_len, void **data_out, uint16_t *data_out_len)\n    923  {\n    924  \tint rc = MOSQ_ERR_PLUGIN_DEFER;\n    925  \tint i;\n    926  \tstruct mosquitto__security_options *opts;\n    927  \tstruct mosquitto_evt_extended_auth event_data;\n    928  \tstruct mosquitto__callback *cb_base;\n    929  \n    930  \tif(!context || !context->listener || !context->auth_method) return MOSQ_ERR_INVAL;\n    931  \tif(!data_out || !data_out_len) return MOSQ_ERR_INVAL;\n    932  \n    933  \tif(db.config->per_listener_settings){\n    934  \t\topts = &context->listener->security_options;\n    935  \t}else{\n    936  \t\topts = &db.config->security_options;\n    937  \t}\n    938  \n    939  \tDL_FOREACH(opts->plugin_callbacks.ext_auth_start, cb_base){\n    940  \t\tmemset(&event_data, 0, sizeof(event_data));\n    941  \t\tevent_data.client = context;\n    942  \t\tevent_data.auth_method = context->auth_method;\n    943  \t\tevent_data.data_in = data_in;\n    944  \t\tevent_data.data_out = NULL;\n    945  \t\tevent_data.data_in_len = data_in_len;\n    946  \t\tevent_data.data_out_len = 0;\n    947  \t\trc = cb_base->cb(MOSQ_EVT_EXT_AUTH_START, &event_data, cb_base->userdata);\n    948  \t\tif(rc != MOSQ_ERR_PLUGIN_DEFER){\n    949  \t\t\t*data_out = event_data.data_out;\n    950  \t\t\t*data_out_len = event_data.data_out_len;\n    951  \t\t\treturn rc;\n    952  \t\t}\n    953  \t}\n    954  \n    955  \tfor(i=0; i<opts->auth_plugin_config_count; i++){\n    956  \t\tif(opts->auth_plugin_configs[i].plugin.auth_start_v4){\n    957  \t\t\t*data_out = NULL;\n    958  \t\t\t*data_out_len = 0;\n    959  \n    960  \t\t\trc = opts->auth_plugin_configs[i].plugin.auth_start_v4(\n    961  \t\t\t\t\topts->auth_plugin_configs[i].plugin.user_data,\n    962  \t\t\t\t\tcontext,\n    963  \t\t\t\t\tcontext->auth_method,\n    964  \t\t\t\t\treauth,\n    965  \t\t\t\t\tdata_in, data_in_len,\n    966  \t\t\t\t\tdata_out, data_out_len);\n    967  \n    968  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    969  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    970  \t\t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    971  \t\t\t\treturn MOSQ_ERR_AUTH_CONTINUE;\n    972  \t\t\t}else if(rc != MOSQ_ERR_NOT_SUPPORTED){\n    973  \t\t\t\treturn rc;\n    974  \t\t\t}\n    975  \t\t}\n    976  \t}\n    977  \n    978  \treturn MOSQ_ERR_NOT_SUPPORTED;\n    979  }\nFunction: sub__remove_shared_leaf\nPath: /root/projects/mosquitto/src/subs.c:190\n    190  static void sub__remove_shared_leaf(struct mosquitto__subhier *subhier, struct mosquitto__subshared *shared, struct mosquitto__subleaf *leaf)\n    191  {\n    192  \tDL_DELETE(shared->subs, leaf);\n    193  \tif(shared->subs == NULL){\n    194  \t\tHASH_DELETE(hh, subhier->shared, shared);\n    195  \t\tmosquitto__free(shared->name);\n    196  \t\tmosquitto__free(shared);\n    197  \t}\n    198  \tmosquitto__free(leaf);\n    199  }\nFunction: sub__messages_queue\nPath: /root/projects/mosquitto/src/subs.c:659\n    659  int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n    660  {\n    661  \tint rc = MOSQ_ERR_SUCCESS, rc2;\n    662  \tint rc_normal = MOSQ_ERR_NO_SUBSCRIBERS, rc_shared = MOSQ_ERR_NO_SUBSCRIBERS;\n    663  \tstruct mosquitto__subhier *subhier;\n    664  \tchar **split_topics = NULL;\n    665  \tchar *local_topic = NULL;\n    666  \n    667  \tassert(topic);\n    668  \n    669  \tif(sub__topic_tokenise(topic, &local_topic, &split_topics, NULL)) return 1;\n    670  \n    671  \t/* Protect this message until we have sent it to all\n    672  \tclients - this is required because websockets client calls\n    673  \tdb__message_write(), which could remove the message if ref_count==0.\n    674  \t*/\n    675  \tdb__msg_store_ref_inc(*stored);\n    676  \n    677  \tHASH_FIND(hh, db.normal_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    678  \tif(subhier){\n    679  \t\trc_normal = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    680  \t\tif(rc_normal > 0){\n    681  \t\t\trc = rc_normal;\n    682  \t\t\tgoto end;\n    683  \t\t}\n    684  \t}\n    685  \n    686  \tHASH_FIND(hh, db.shared_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    687  \tif(subhier){\n    688  \t\trc_shared = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    689  \t\tif(rc_shared > 0){\n    690  \t\t\trc = rc_shared;\n    691  \t\t\tgoto end;\n    692  \t\t}\n    693  \t}\n    694  \n    695  \tif(rc_normal == MOSQ_ERR_NO_SUBSCRIBERS && rc_shared == MOSQ_ERR_NO_SUBSCRIBERS){\n    696  \t\trc = MOSQ_ERR_NO_SUBSCRIBERS;\n    697  \t}\n    698  \n    699  \tif(retain){\n    700  \t\trc2 = retain__store(topic, *stored, split_topics);\n    701  \t\tif(rc2) rc = rc2;\n    702  \t}\n    703  \n    704  end:\n    705  \tmosquitto__free(split_topics);\n    706  \tmosquitto__free(local_topic);\n    707  \t/* Remove our reference and free if needed. */\n    708  \tdb__msg_store_ref_dec(stored);\n    709  \n    710  \treturn rc;\n    711  }\nFunction: sub__search\nPath: /root/projects/mosquitto/src/subs.c:479\n    479  static int sub__search(struct mosquitto__subhier *subhier, char **split_topics, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    480  {\n    481  \t/* FIXME - need to take into account source_id if the client is a bridge */\n    482  \tstruct mosquitto__subhier *branch;\n    483  \tint rc;\n    484  \tbool have_subscribers = false;\n    485  \n    486  \tif(split_topics && split_topics[0]){\n    487  \t\t/* Check for literal match */\n    488  \t\tHASH_FIND(hh, subhier->children, split_topics[0], strlen(split_topics[0]), branch);\n    489  \n    490  \t\tif(branch){\n    491  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    492  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    493  \t\t\t\thave_subscribers = true;\n    494  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    495  \t\t\t\treturn rc;\n    496  \t\t\t}\n    497  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    498  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    499  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    500  \t\t\t\t\thave_subscribers = true;\n    501  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    502  \t\t\t\t\treturn rc;\n    503  \t\t\t\t}\n    504  \t\t\t}\n    505  \t\t}\n    506  \n    507  \t\t/* Check for + match */\n    508  \t\tHASH_FIND(hh, subhier->children, \"+\", 1, branch);\n    509  \n    510  \t\tif(branch){\n    511  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    512  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    513  \t\t\t\thave_subscribers = true;\n    514  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    515  \t\t\t\treturn rc;\n    516  \t\t\t}\n    517  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    518  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    519  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    520  \t\t\t\t\thave_subscribers = true;\n    521  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    522  \t\t\t\t\treturn rc;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}\n    526  \t}\n    527  \n    528  \t/* Check for # match */\n    529  \tHASH_FIND(hh, subhier->children, \"#\", 1, branch);\n    530  \tif(branch && !branch->children){\n    531  \t\t/* The topic matches due to a # wildcard - process the\n    532  \t\t * subscriptions but *don't* return. Although this branch has ended\n    533  \t\t * there may still be other subscriptions to deal with.\n    534  \t\t */\n    535  \t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    536  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    537  \t\t\thave_subscribers = true;\n    538  \t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    539  \t\t\treturn rc;\n    540  \t\t}\n    541  \t}\n    542  \n    543  \tif(have_subscribers){\n    544  \t\treturn MOSQ_ERR_SUCCESS;\n    545  \t}else{\n    546  \t\treturn MOSQ_ERR_NO_SUBSCRIBERS;\n    547  \t}\n    548  }\nFunction: subs__process\nPath: /root/projects/mosquitto/src/subs.c:129\n    129  static int subs__process(struct mosquitto__subhier *hier, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    130  {\n    131  \tint rc = 0;\n    132  \tint rc2;\n    133  \tstruct mosquitto__subleaf *leaf;\n    134  \n    135  \trc = subs__shared_process(hier, topic, qos, retain, stored);\n    136  \n    137  \tleaf = hier->subs;\n    138  \twhile(source_id && leaf){\n    139  \t\tif(!leaf->context->id || (leaf->no_local && !strcmp(leaf->context->id, source_id))){\n    140  \t\t\tleaf = leaf->next;\n    141  \t\t\tcontinue;\n    142  \t\t}\n    143  \t\trc2 = subs__send(leaf, topic, qos, retain, stored);\n    144  \t\tif(rc2){\n    145  \t\t\trc = 1;\n    146  \t\t}\n    147  \t\tleaf = leaf->next;\n    148  \t}\n    149  \tif(hier->subs || hier->shared){\n    150  \t\treturn rc;\n    151  \t}else{\n    152  \t\treturn MOSQ_ERR_NO_SUBSCRIBERS;\n    153  \t}\n    154  }\nFunction: subs__send\nPath: /root/projects/mosquitto/src/subs.c:63\n    63   static int subs__send(struct mosquitto__subleaf *leaf, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    64   {\n    65   \tbool client_retain;\n    66   \tuint16_t mid;\n    67   \tuint8_t client_qos, msg_qos;\n    68   \tmosquitto_property *properties = NULL;\n    69   \tint rc2;\n    70   \n    71   \t/* Check for ACL topic access. */\n    72   \trc2 = mosquitto_acl_check(leaf->context, topic, stored->payloadlen, stored->payload, stored->qos, stored->retain, MOSQ_ACL_READ);\n    73   \tif(rc2 == MOSQ_ERR_ACL_DENIED){\n    74   \t\treturn MOSQ_ERR_SUCCESS;\n    75   \t}else if(rc2 == MOSQ_ERR_SUCCESS){\n    76   \t\tclient_qos = leaf->qos;\n    77   \n    78   \t\tif(db.config->upgrade_outgoing_qos){\n    79   \t\t\tmsg_qos = client_qos;\n    80   \t\t}else{\n    81   \t\t\tif(qos > client_qos){\n    82   \t\t\t\tmsg_qos = client_qos;\n    83   \t\t\t}else{\n    84   \t\t\t\tmsg_qos = qos;\n    85   \t\t\t}\n    86   \t\t}\n    87   \t\tif(msg_qos){\n    88   \t\t\tmid = mosquitto__mid_generate(leaf->context);\n    89   \t\t}else{\n    90   \t\t\tmid = 0;\n    91   \t\t}\n    92   \t\tif(leaf->retain_as_published){\n    93   \t\t\tclient_retain = retain;\n    94   \t\t}else{\n    95   \t\t\tclient_retain = false;\n    96   \t\t}\n    97   \t\tif(leaf->identifier){\n    98   \t\t\tmosquitto_property_add_varint(&properties, MQTT_PROP_SUBSCRIPTION_IDENTIFIER, leaf->identifier);\n    99   \t\t}\n    100  \t\tif(db__message_insert(leaf->context, mid, mosq_md_out, msg_qos, client_retain, stored, properties, true) == 1){\n    101  \t\t\treturn 1;\n    102  \t\t}\n    103  \t}else{\n    104  \t\treturn 1; /* Application error */\n    105  \t}\n    106  \treturn 0;\n    107  }\nFunction: sub__clean_session\nPath: /root/projects/mosquitto/src/subs.c:746\n    746  int sub__clean_session(struct mosquitto *context)\n    747  {\n    748  \tint i;\n    749  \tstruct mosquitto__subleaf *leaf;\n    750  \tstruct mosquitto__subhier *hier;\n    751  \n    752  \tfor(i=0; i<context->sub_count; i++){\n    753  \t\tif(context->subs[i] == NULL){\n    754  \t\t\tcontinue;\n    755  \t\t}\n    756  \n    757  \t\thier = context->subs[i]->hier;\n    758  \n    759  \t\tif(context->subs[i]->shared){\n    760  \t\t\tleaf = context->subs[i]->shared->subs;\n    761  \t\t\twhile(leaf){\n    762  \t\t\t\tif(leaf->context==context){\n    763  #ifdef WITH_SYS_TREE\n    764  \t\t\t\t\tdb.shared_subscription_count--;\n    765  #endif\n    766  \t\t\t\t\tsub__remove_shared_leaf(context->subs[i]->hier, context->subs[i]->shared, leaf);\n    767  \t\t\t\t\tbreak;\n    768  \t\t\t\t}\n    769  \t\t\t\tleaf = leaf->next;\n    770  \t\t\t}\n    771  \t\t}else{\n    772  \t\t\tleaf = hier->subs;\n    773  \t\t\twhile(leaf){\n    774  \t\t\t\tif(leaf->context==context){\n    775  #ifdef WITH_SYS_TREE\n    776  \t\t\t\t\tdb.subscription_count--;\n    777  #endif\n    778  \t\t\t\t\tDL_DELETE(hier->subs, leaf);\n    779  \t\t\t\t\tmosquitto__free(leaf);\n    780  \t\t\t\t\tbreak;\n    781  \t\t\t\t}\n    782  \t\t\t\tleaf = leaf->next;\n    783  \t\t\t}\n    784  \t\t}\n    785  \t\tmosquitto__free(context->subs[i]);\n    786  \t\tcontext->subs[i] = NULL;\n    787  \n    788  \t\tif(hier->subs == NULL\n    789  \t\t\t\t&& hier->children == NULL\n    790  \t\t\t\t&& hier->shared == NULL\n    791  \t\t\t\t&& hier->parent){\n    792  \n    793  \t\t\tdo{\n    794  \t\t\t\thier = tmp_remove_subs(hier);\n    795  \t\t\t}while(hier);\n    796  \t\t}\n    797  \t}\n    798  \tmosquitto__free(context->subs);\n    799  \tcontext->subs = NULL;\n    800  \tcontext->sub_count = 0;\n    801  \n    802  \treturn MOSQ_ERR_SUCCESS;\n    803  }\nFunction: tmp_remove_subs\nPath: /root/projects/mosquitto/src/subs.c:715\n    715  static struct mosquitto__subhier *tmp_remove_subs(struct mosquitto__subhier *sub)\n    716  {\n    717  \tstruct mosquitto__subhier *parent;\n    718  \n    719  \tif(!sub || !sub->parent){\n    720  \t\treturn NULL;\n    721  \t}\n    722  \n    723  \tif(sub->children || sub->subs){\n    724  \t\treturn NULL;\n    725  \t}\n    726  \n    727  \tparent = sub->parent;\n    728  \tHASH_DELETE(hh, parent->children, sub);\n    729  \tmosquitto__free(sub->topic);\n    730  \tmosquitto__free(sub);\n    731  \n    732  \tif(parent->subs == NULL\n    733  \t\t\t&& parent->children == NULL\n    734  \t\t\t&& parent->shared == NULL\n    735  \t\t\t&& parent->parent){\n    736  \n    737  \t\treturn parent;\n    738  \t}else{\n    739  \t\treturn NULL;\n    740  \t}\n    741  }\nFunction: sub__topic_tokenise\nPath: /root/projects/mosquitto/src/topic_tok.c:58\n    58   int sub__topic_tokenise(const char *subtopic, char **local_sub, char ***topics, const char **sharename)\n    59   {\n    60   \tchar *saveptr = NULL;\n    61   \tchar *token;\n    62   \tint count;\n    63   \tint topic_index = 0;\n    64   \tint i;\n    65   \tsize_t len;\n    66   \n    67   \tlen = strlen(subtopic);\n    68   \tif(len == 0){\n    69   \t\treturn MOSQ_ERR_INVAL;\n    70   \t}\n    71   \n    72   \t*local_sub = mosquitto__strdup(subtopic);\n    73   \tif((*local_sub) == NULL) return MOSQ_ERR_NOMEM;\n    74   \n    75   \tcount = 0;\n    76   \tsaveptr = *local_sub;\n    77   \twhile(saveptr){\n    78   \t\tsaveptr = strchr(&saveptr[1], '/');\n    79   \t\tcount++;\n    80   \t}\n    81   \t*topics = mosquitto__calloc((size_t)(count+3) /* 3=$shared,sharename,NULL */, sizeof(char *));\n    82   \tif((*topics) == NULL){\n    83   \t\tmosquitto__free(*local_sub);\n    84   \t\treturn MOSQ_ERR_NOMEM;\n    85   \t}\n    86   \n    87   \tif((*local_sub)[0] != '$'){\n    88   \t\t(*topics)[topic_index] = \"\";\n    89   \t\ttopic_index++;\n    90   \t}\n    91   \n    92   \ttoken = strtok_hier((*local_sub), &saveptr);\n    93   \twhile(token){\n    94   \t\t(*topics)[topic_index] = token;\n    95   \t\ttopic_index++;\n    96   \t\ttoken = strtok_hier(NULL, &saveptr);\n    97   \t}\n    98   \n    99   \tif(!strcmp((*topics)[0], \"$share\")){\n    100  \t\tif(count < 3 || (count == 3 && strlen((*topics)[2]) == 0)){\n    101  \t\t\tmosquitto__free(*local_sub);\n    102  \t\t\tmosquitto__free(*topics);\n    103  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    104  \t\t}\n    105  \n    106  \t\tif(sharename){\n    107  \t\t\t(*sharename) = (*topics)[1];\n    108  \t\t}\n    109  \n    110  \t\tfor(i=1; i<count-1; i++){\n    111  \t\t\t(*topics)[i] = (*topics)[i+1];\n    112  \t\t}\n    113  \t\t(*topics)[0] = \"\";\n    114  \t\t(*topics)[count-1] = NULL;\n    115  \t}\n    116  \treturn MOSQ_ERR_SUCCESS;\n    117  }\nFunction: mosquitto_validate_utf8\nPath: /root/projects/mosquitto/src/../lib/utf8_mosq.c:24\n    24   int mosquitto_validate_utf8(const char *str, int len)\n    25   {\n    26   \tint i;\n    27   \tint j;\n    28   \tint codelen;\n    29   \tint codepoint;\n    30   \tconst unsigned char *ustr = (const unsigned char *)str;\n    31   \n    32   \tif(!str) return MOSQ_ERR_INVAL;\n    33   \tif(len < 0 || len > 65536) return MOSQ_ERR_INVAL;\n    34   \n    35   \tfor(i=0; i<len; i++){\n    36   \t\tif(ustr[i] == 0){\n    37   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    38   \t\t}else if(ustr[i] <= 0x7f){\n    39   \t\t\tcodelen = 1;\n    40   \t\t\tcodepoint = ustr[i];\n    41   \t\t}else if((ustr[i] & 0xE0) == 0xC0){\n    42   \t\t\t/* 110xxxxx - 2 byte sequence */\n    43   \t\t\tif(ustr[i] == 0xC0 || ustr[i] == 0xC1){\n    44   \t\t\t\t/* Invalid bytes */\n    45   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    46   \t\t\t}\n    47   \t\t\tcodelen = 2;\n    48   \t\t\tcodepoint = (ustr[i] & 0x1F);\n    49   \t\t}else if((ustr[i] & 0xF0) == 0xE0){\n    50   \t\t\t/* 1110xxxx - 3 byte sequence */\n    51   \t\t\tcodelen = 3;\n    52   \t\t\tcodepoint = (ustr[i] & 0x0F);\n    53   \t\t}else if((ustr[i] & 0xF8) == 0xF0){\n    54   \t\t\t/* 11110xxx - 4 byte sequence */\n    55   \t\t\tif(ustr[i] > 0xF4){\n    56   \t\t\t\t/* Invalid, this would produce values > 0x10FFFF. */\n    57   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    58   \t\t\t}\n    59   \t\t\tcodelen = 4;\n    60   \t\t\tcodepoint = (ustr[i] & 0x07);\n    61   \t\t}else{\n    62   \t\t\t/* Unexpected continuation byte. */\n    63   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    64   \t\t}\n    65   \n    66   \t\t/* Reconstruct full code point */\n    67   \t\tif(i == len-codelen+1){\n    68   \t\t\t/* Not enough data */\n    69   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    70   \t\t}\n    71   \t\tfor(j=0; j<codelen-1; j++){\n    72   \t\t\tif((ustr[++i] & 0xC0) != 0x80){\n    73   \t\t\t\t/* Not a continuation byte */\n    74   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    75   \t\t\t}\n    76   \t\t\tcodepoint = (codepoint<<6) | (ustr[i] & 0x3F);\n    77   \t\t}\n    78   \n    79   \t\t/* Check for UTF-16 high/low surrogates */\n    80   \t\tif(codepoint >= 0xD800 && codepoint <= 0xDFFF){\n    81   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    82   \t\t}\n    83   \n    84   \t\t/* Check for overlong or out of range encodings */\n    85   \t\t/* Checking codelen == 2 isn't necessary here, because it is already\n    86   \t\t * covered above in the C0 and C1 checks.\n    87   \t\t * if(codelen == 2 && codepoint < 0x0080){\n    88   \t\t *\t return MOSQ_ERR_MALFORMED_UTF8;\n    89   \t\t * }else\n    90   \t\t*/\n    91   \t\tif(codelen == 3 && codepoint < 0x0800){\n    92   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    93   \t\t}else if(codelen == 4 && (codepoint < 0x10000 || codepoint > 0x10FFFF)){\n    94   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    95   \t\t}\n    96   \n    97   \t\t/* Check for non-characters */\n    98   \t\tif(codepoint >= 0xFDD0 && codepoint <= 0xFDEF){\n    99   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    100  \t\t}\n    101  \t\tif((codepoint & 0xFFFF) == 0xFFFE || (codepoint & 0xFFFF) == 0xFFFF){\n    102  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    103  \t\t}\n    104  \t\t/* Check for control characters */\n    105  \t\tif(codepoint <= 0x001F || (codepoint >= 0x007F && codepoint <= 0x009F)){\n    106  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    107  \t\t}\n    108  \t}\n    109  \treturn MOSQ_ERR_SUCCESS;\n    110  }\nFunction: mosquitto__get_state\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:295\n    295  enum mosquitto_client_state mosquitto__get_state(struct mosquitto *mosq)\n    296  {\n    297  \tenum mosquitto_client_state state;\n    298  \n    299  \tCOMPAT_pthread_mutex_lock(&mosq->state_mutex);\n    300  \tstate = mosq->state;\n    301  \tCOMPAT_pthread_mutex_unlock(&mosq->state_mutex);\n    302  \n    303  \treturn state;\n    304  }\nFunction: mosquitto__set_state\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:281\n    281  int mosquitto__set_state(struct mosquitto *mosq, enum mosquitto_client_state state)\n    282  {\n    283  \tCOMPAT_pthread_mutex_lock(&mosq->state_mutex);\n    284  #ifdef WITH_BROKER\n    285  \tif(mosq->state != mosq_cs_disused)\n    286  #endif\n    287  \t{\n    288  \t\tmosq->state = state;\n    289  \t}\n    290  \tCOMPAT_pthread_mutex_unlock(&mosq->state_mutex);\n    291  \n    292  \treturn MOSQ_ERR_SUCCESS;\n    293  }\nFunction: mosquitto_pub_topic_check\nPath: /root/projects/mosquitto/src/../lib/util_topic.c:50\n    50   int mosquitto_pub_topic_check(const char *str)\n    51   {\n    52   \tint len = 0;\n    53   #ifdef WITH_BROKER\n    54   \tint hier_count = 0;\n    55   #endif\n    56   \n    57   \tif(str == NULL){\n    58   \t\treturn MOSQ_ERR_INVAL;\n    59   \t}\n    60   \n    61   \twhile(str && str[0]){\n    62   \t\tif(str[0] == '+' || str[0] == '#'){\n    63   \t\t\treturn MOSQ_ERR_INVAL;\n    64   \t\t}\n    65   #ifdef WITH_BROKER\n    66   \t\telse if(str[0] == '/'){\n    67   \t\t\thier_count++;\n    68   \t\t}\n    69   #endif\n    70   \t\tlen++;\n    71   \t\tstr = &str[1];\n    72   \t}\n    73   \tif(len > 65535) return MOSQ_ERR_INVAL;\n    74   #ifdef WITH_BROKER\n    75   \tif(hier_count > TOPIC_HIERARCHY_LIMIT) return MOSQ_ERR_INVAL;\n    76   #endif\n    77   \n    78   \treturn MOSQ_ERR_SUCCESS;\n    79   }\nFunction: will_delay__add\nPath: /root/projects/mosquitto/src/will_delay.c:39\n    39   int will_delay__add(struct mosquitto *context)\n    40   {\n    41   \tstruct will_delay_list *item;\n    42   \n    43   \tif(context->will_delay_entry){\n    44   \t\treturn MOSQ_ERR_SUCCESS;\n    45   \t}\n    46   \n    47   \titem = mosquitto__calloc(1, sizeof(struct will_delay_list));\n    48   \tif(!item) return MOSQ_ERR_NOMEM;\n    49   \n    50   \titem->context = context;\n    51   \tcontext->will_delay_entry = item;\n    52   \titem->context->will_delay_time = db.now_real_s + item->context->will_delay_interval;\n    53   \n    54   \tDL_INSERT_INORDER(delay_list, item, will_delay__cmp);\n    55   \n    56   \treturn MOSQ_ERR_SUCCESS;\n    57   }\nFunction: will_delay__remove\nPath: /root/projects/mosquitto/src/will_delay.c:99\n    99   void will_delay__remove(struct mosquitto *mosq)\n    100  {\n    101  \tif(mosq->will_delay_entry != NULL){\n    102  \t\tDL_DELETE(delay_list, mosq->will_delay_entry);\n    103  \t\tmosquitto__free(mosq->will_delay_entry);\n    104  \t\tmosq->will_delay_entry = NULL;\n    105  \t}\n    106  }\nFunction: will__clear\nPath: /root/projects/mosquitto/src/../lib/will_mosq.c:111\n    111  int will__clear(struct mosquitto *mosq)\n    112  {\n    113  \tif(!mosq->will) return MOSQ_ERR_SUCCESS;\n    114  \n    115  \tmosquitto__free(mosq->will->msg.topic);\n    116  \tmosq->will->msg.topic = NULL;\n    117  \n    118  \tmosquitto__free(mosq->will->msg.payload);\n    119  \tmosq->will->msg.payload = NULL;\n    120  \n    121  \tmosquitto_property_free_all(&mosq->will->properties);\n    122  \n    123  \tmosquitto__free(mosq->will);\n    124  \tmosq->will = NULL;\n    125  \tmosq->will_delay_interval = 0;\n    126  \n    127  \treturn MOSQ_ERR_SUCCESS;\n    128  }\n",
    "It is a Protocol Error to include Authentication Method more than once.": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    221  \tplugin__handle_disconnect(context, -1);\n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    226  \tif(context->bridge == NULL)\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    232  \t\t\tif(context->will_delay_interval == 0){\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__read_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:178\n    178  int packet__read_uint32(struct mosquitto__packet *packet, uint32_t *word)\n    179  {\n    180  \tuint32_t val = 0;\n    181  \tint i;\n    183  \tassert(packet);\n    184  \tif(packet->pos+4 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    186  \tfor(i=0; i<4; i++){\n    187  \t\tval = (val << 8) + packet->payload[packet->pos];\n    188  \t\tpacket->pos++;\n    189  \t}\n    191  \t*word = val;\n    194  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    147  \tassert(mosq);\n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    153  \tpacket->next = NULL;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    187  \treturn packet__write(mosq);\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    353  }\nFunction: property__process_connect\nPath: /root/projects/mosquitto/src/property_broker.c:30\n    30   int property__process_connect(struct mosquitto *context, mosquitto_property **props)\n    31   {\n    32   \tmosquitto_property *p;\n    34   \tp = *props;\n    36   \twhile(p){\n    37   \t\tif(p->identifier == MQTT_PROP_SESSION_EXPIRY_INTERVAL){\n    38   \t\t\tcontext->session_expiry_interval = p->value.i32;\n    39   \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM){\n    40   \t\t\tif(p->value.i16 == 0){\n    41   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    42   \t\t\t}\n    44   \t\t\tcontext->msgs_out.inflight_maximum = p->value.i16;\n    45   \t\t\tcontext->msgs_out.inflight_quota = context->msgs_out.inflight_maximum;\n    46   \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    47   \t\t\tif(p->value.i32 == 0){\n    48   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    49   \t\t\t}\n    50   \t\t\tcontext->maximum_packet_size = p->value.i32;\n    51   \t\t}\n    52   \t\tp = p->next;\n    53   \t}\n    56   }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__read\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:35\n    35   static int property__read(struct mosquitto__packet *packet, uint32_t *len, mosquitto_property *property)\n    36   {\n    38   \tuint32_t property_identifier;\n    39   \tuint8_t byte;\n    40   \tuint8_t byte_count;\n    41   \tuint16_t uint16;\n    42   \tuint32_t uint32;\n    43   \tuint32_t varint;\n    44   \tchar *str1, *str2;\n    45   \tuint16_t slen1, slen2;\n    47   \tif(!property) return MOSQ_ERR_INVAL;\n    49   \trc = packet__read_varint(packet, &property_identifier, NULL);\n    50   \tif(rc){\n    51   \t\treturn rc;\n    52   \t}\n    55   \tmemset(property, 0, sizeof(mosquitto_property));\n    57   \tproperty->identifier = (int32_t)property_identifier;\n    59   \tswitch(property_identifier){\n    60   \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    61   \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    62   \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    63   \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    64   \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    65   \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    66   \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    67   \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    68   \t\t\trc = packet__read_byte(packet, &byte);\n    69   \t\t\tif(rc) return rc;\n    71   \t\t\tproperty->value.i8 = byte;\n    72   \t\t\tbreak;\n    74   \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    75   \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    76   \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    77   \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    78   \t\t\trc = packet__read_uint16(packet, &uint16);\n    79   \t\t\tif(rc) return rc;\n    81   \t\t\tproperty->value.i16 = uint16;\n    82   \t\t\tbreak;\n    84   \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    85   \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    86   \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    87   \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    88   \t\t\trc = packet__read_uint32(packet, &uint32);\n    89   \t\t\tif(rc) return rc;\n    91   \t\t\tproperty->value.i32 = uint32;\n    92   \t\t\tbreak;\n    94   \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    95   \t\t\trc = packet__read_varint(packet, &varint, &byte_count);\n    96   \t\t\tif(rc) return rc;\n    98   \t\t\tproperty->value.varint = varint;\n    99   \t\t\tbreak;\n    101  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    102  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    103  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    104  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    105  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    106  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    107  \t\tcase MQTT_PROP_REASON_STRING:\n    108  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    109  \t\t\tif(rc) return rc;\n    111  \t\t\tproperty->value.s.v = str1;\n    112  \t\t\tproperty->value.s.len = slen1;\n    113  \t\t\tbreak;\n    115  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    116  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    117  \t\t\trc = packet__read_binary(packet, (uint8_t **)&str1, &slen1);\n    118  \t\t\tif(rc) return rc;\n    120  \t\t\tproperty->value.bin.v = str1;\n    121  \t\t\tproperty->value.bin.len = slen1;\n    122  \t\t\tbreak;\n    124  \t\tcase MQTT_PROP_USER_PROPERTY:\n    125  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    126  \t\t\tif(rc) return rc;\n    129  \t\t\trc = packet__read_string(packet, &str2, &slen2);\n    130  \t\t\tif(rc){\n    131  \t\t\t\tmosquitto__free(str1);\n    132  \t\t\t\treturn rc;\n    133  \t\t\t}\n    136  \t\t\tproperty->name.v = str1;\n    137  \t\t\tproperty->name.len = slen1;\n    138  \t\t\tproperty->value.s.v = str2;\n    139  \t\t\tproperty->value.s.len = slen2;\n    140  \t\t\tbreak;\n    142  \t\tdefault:\n    144  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property_identifier);\n    146  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    147  \t}\n    150  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: property__get_length_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:335\n    335  unsigned int property__get_length_all(const mosquitto_property *property)\n    336  {\n    337  \tconst mosquitto_property *p;\n    338  \tunsigned int len = 0;\n    341  \twhile(p){\n    342  \t\tlen += property__get_length(p);\n    343  \t\tp = p->next;\n    344  \t}\n    345  \treturn len;\n    346  }\nFunction: property__write_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:429\n    429  int property__write_all(struct mosquitto__packet *packet, const mosquitto_property *properties, bool write_len)\n    430  {\n    432  \tconst mosquitto_property *p;\n    440  \twhile(p){\n    441  \t\trc = property__write(packet, p);\n    442  \t\tif(rc) return rc;\n    443  \t\tp = p->next;\n    444  \t}\n    447  }\nFunction: property__write\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:361\n    361  static int property__write(struct mosquitto__packet *packet, const mosquitto_property *property)\n    362  {\n    365  \trc = packet__write_varint(packet, (uint32_t)property->identifier);\n    366  \tif(rc) return rc;\n    368  \tswitch(property->identifier){\n    394  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    395  \t\t\treturn packet__write_varint(packet, property->value.varint);\n    397  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    398  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    399  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    400  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    401  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    402  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    403  \t\tcase MQTT_PROP_REASON_STRING:\n    404  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    405  \t\t\tbreak;\n    407  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    408  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    409  \t\t\tpacket__write_uint16(packet, property->value.bin.len);\n    410  \t\t\tpacket__write_bytes(packet, property->value.bin.v, property->value.bin.len);\n    411  \t\t\tbreak;\n    413  \t\tcase MQTT_PROP_USER_PROPERTY:\n    414  \t\t\tpacket__write_string(packet, property->name.v, property->name.len);\n    415  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    416  \t\t\tbreak;\n    418  \t\tdefault:\n    420  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property->identifier);\n    422  \t\t\treturn MOSQ_ERR_INVAL;\n    423  \t}\n    426  }\nFunction: mosquitto_property_read_binary\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1106\n    1106 const mosquitto_property *mosquitto_property_read_binary(const mosquitto_property *proplist, int identifier, void **value, uint16_t *len, bool skip_first)\n    1107 {\n    1109 \tif(!proplist || (value && !len) || (!value && len)) return NULL;\n    1113 \tp = property__get_property(proplist, identifier, skip_first);\n    1114 \tif(!p) return NULL;\n    1115 \tif(p->identifier != MQTT_PROP_CORRELATION_DATA\n    1116 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_DATA){\n    1118 \t\treturn NULL;\n    1119 \t}\n    1121 \tif(value){\n    1122 \t\t*len = p->value.bin.len;\n    1123 \t\t*value = calloc(1, *len + 1U);\n    1124 \t\tif(!(*value)) return NULL;\n    1126 \t\tmemcpy(*value, p->value.bin.v, *len);\n    1127 \t}\n    1130 }\nFunction: mosquitto_property_read_string\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1133\n    1133 const mosquitto_property *mosquitto_property_read_string(const mosquitto_property *proplist, int identifier, char **value, bool skip_first)\n    1134 {\n    1136 \tif(!proplist) return NULL;\n    1138 \tp = property__get_property(proplist, identifier, skip_first);\n    1139 \tif(!p) return NULL;\n    1140 \tif(p->identifier != MQTT_PROP_CONTENT_TYPE\n    1141 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_TOPIC\n    1142 \t\t\t&& p->identifier != MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER\n    1143 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_METHOD\n    1144 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_INFORMATION\n    1145 \t\t\t&& p->identifier != MQTT_PROP_SERVER_REFERENCE\n    1146 \t\t\t&& p->identifier != MQTT_PROP_REASON_STRING){\n    1148 \t\treturn NULL;\n    1149 \t}\n    1151 \tif(value){\n    1152 \t\t*value = calloc(1, (size_t)p->value.s.len+1);\n    1153 \t\tif(!(*value)) return NULL;\n    1155 \t\tmemcpy(*value, p->value.s.v, p->value.s.len);\n    1156 \t}\n    1159 }\nFunction: db__expire_all_messages\nPath: /root/projects/mosquitto/src/database.c:1053\n    1053 void db__expire_all_messages(struct mosquitto *context)\n    1055 \tstruct mosquitto_client_msg *msg, *tmp;\n    1057 \tDL_FOREACH_SAFE(context->msgs_out.inflight, msg, tmp){\n    1058 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1059 \t\t\tif(msg->qos > 0){\n    1060 \t\t\t\tutil__increment_send_quota(context);\n    1062 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1065 \tDL_FOREACH_SAFE(context->msgs_out.queued, msg, tmp){\n    1066 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1067 \t\t\tdb__message_remove_from_queued(&context->msgs_out, msg);\n    1070 \tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n    1071 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1072 \t\t\tif(msg->qos > 0){\n    1073 \t\t\t\tutil__increment_receive_quota(context);\n    1075 \t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n    1078 \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n    1079 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1080 \t\t\tdb__message_remove_from_queued(&context->msgs_in, msg);\n    1083 }\nFunction: db__message_remove_from_queued\nPath: /root/projects/mosquitto/src/database.c:364\n    364  static void db__message_remove_from_queued(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    365  {\n    366  \tif(!msg_data || !item){\n    367  \t\treturn;\n    368  \t}\n    370  \tDL_DELETE(msg_data->queued, item);\n    377  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1183 \tstruct mosquitto_client_msg *tail, *tmp;\n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1190 \tDL_FOREACH_SAFE(context->msgs_out.inflight, tail, tmp){\n    1191 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1192 \t\tif(rc) return rc;\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    143  \t\t\t\tin_quota = context->msgs_in.inflight_quota;\n    144  \t\t\t\tout_quota = context->msgs_out.inflight_quota;\n    145  \t\t\t\tin_maximum = context->msgs_in.inflight_maximum;\n    146  \t\t\t\tout_maximum = context->msgs_out.inflight_maximum;\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    154  \t\t\t\tcontext->msgs_in.inflight_quota = in_quota;\n    155  \t\t\t\tcontext->msgs_out.inflight_quota = out_quota;\n    156  \t\t\t\tcontext->msgs_in.inflight_maximum = in_maximum;\n    157  \t\t\t\tcontext->msgs_out.inflight_maximum = out_maximum;\n    159  \t\t\t\tdb__message_reconnect_reset(context);\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    215  \trc = acl__find_acls(context);\n    216  \tif(rc){\n    218  \t\treturn rc;\n    219  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    250  \t}\n    252  \tcontext->ping_t = 0;\n    253  \tcontext->is_dropping = false;\n    255  \tconnection_check_acl(context, &context->msgs_in.inflight);\n    256  \tconnection_check_acl(context, &context->msgs_in.queued);\n    257  \tconnection_check_acl(context, &context->msgs_out.inflight);\n    258  \tconnection_check_acl(context, &context->msgs_out.queued);\n    260  \tcontext__add_to_by_id(context);\n    263  \tif(!context->clean_start){\n    267  \tcontext->max_qos = context->listener->max_qos;\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    300  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    315  \tkeepalive__add(context);\n    317  \tmosquitto__set_state(context, mosq_cs_active);\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    320  \tif(rc) return rc;\n    321  \tdb__expire_all_messages(context);\n    322  \trc = db__message_write_queued_out(context);\n    323  \tif(rc) return rc;\n    324  \trc = db__message_write_inflight_out_all(context);\n    330  }\nFunction: connection_check_acl\nPath: /root/projects/mosquitto/src/handle_connect.c:86\n    86   static void connection_check_acl(struct mosquitto *context, struct mosquitto_client_msg **head)\n    97   \t\tif(mosquitto_acl_check(context, msg_tail->store->topic,\n    99   \t\t\t\t\t\t\t   msg_tail->store->qos, msg_tail->store->retain, access) != MOSQ_ERR_SUCCESS){\n    101  \t\t\tDL_DELETE((*head), msg_tail);\n    107  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    248  \tmosquitto__set_state(context, mosq_cs_disused);\n    250  \tif(context->id){\n    251  \t\tcontext__remove_from_by_id(context);\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    256  \tcontext->for_free_next = db.ll_for_free;\n    257  \tdb.ll_for_free = context;\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    296  \t\tcontext->in_by_id = true;\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__msg_add_to_queued_stats\nPath: /root/projects/mosquitto/src/database.c:162\n    162  void db__msg_add_to_queued_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    163  {\n    164  \tmsg_data->queued_count++;\n    165  \tmsg_data->queued_bytes += msg->store->payloadlen;\n    166  \tif(msg->qos != 0){\n    167  \t\tmsg_data->queued_count12++;\n    168  \t\tmsg_data->queued_bytes12 += msg->store->payloadlen;\n    169  \t}\n    170  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    271  \tmosquitto__free(store->source_id);\n    272  \tmosquitto__free(store->source_username);\n    283  }\nFunction: db__message_remove_from_inflight\nPath: /root/projects/mosquitto/src/database.c:347\n    347  static void db__message_remove_from_inflight(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    348  {\n    349  \tif(!msg_data || !item){\n    350  \t\treturn;\n    351  \t}\n    353  \tDL_DELETE(msg_data->inflight, item);\n    354  \tif(item->store){\n    355  \t\tdb__msg_remove_from_inflight_stats(msg_data, item);\n    357  \t}\n    361  }\nFunction: db__message_write_inflight_out_latest\nPath: /root/projects/mosquitto/src/database.c:1198\n    1198 int db__message_write_inflight_out_latest(struct mosquitto *context)\n    1199 {\n    1200 \tstruct mosquitto_client_msg *tail, *next;\n    1203 \tif(context->state != mosq_cs_active\n    1204 \t\t\t|| context->sock == INVALID_SOCKET\n    1205 \t\t\t|| context->msgs_out.inflight == NULL){\n    1207 \t\treturn MOSQ_ERR_SUCCESS;\n    1208 \t}\n    1210 \tif(context->msgs_out.inflight->prev == context->msgs_out.inflight){\n    1212 \t\treturn db__message_write_inflight_out_single(context, context->msgs_out.inflight);\n    1213 \t}\n    1217 \ttail = context->msgs_out.inflight->prev;\n    1218 \twhile(tail != context->msgs_out.inflight &&\n    1219 \t\t\t(tail->state == mosq_ms_publish_qos0\n    1220 \t\t\t || tail->state == mosq_ms_publish_qos1\n    1221 \t\t\t || tail->state == mosq_ms_publish_qos2)){\n    1223 \t\ttail = tail->prev;\n    1224 \t}\n    1229 \tif(tail != context->msgs_out.inflight){\n    1230 \t\ttail = tail->next;\n    1231 \t}\n    1233 \twhile(tail){\n    1234 \t\tnext = tail->next;\n    1235 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1236 \t\tif(rc) return rc;\n    1238 \t}\n    1240 }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1097 \tuint32_t expiry_interval;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1103 \t\t\tif(msg->direction == mosq_md_out && msg->qos > 0){\n    1104 \t\t\t\tutil__increment_send_quota(context);\n    1105 \t\t\t}\n    1106 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1126 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1135 \t\t\t\tmsg->timestamp = db.now_s;\n    1136 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1137 \t\t\t\tmsg->state = mosq_ms_wait_for_puback;\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1139 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1148 \t\t\t\tmsg->timestamp = db.now_s;\n    1149 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1150 \t\t\t\tmsg->state = mosq_ms_wait_for_pubrec;\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1152 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1159 \t\t\trc = send__pubrel(context, mid, NULL);\n    1160 \t\t\tif(!rc){\n    1161 \t\t\t\tmsg->state = mosq_ms_wait_for_pubcomp;\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1176 \t}\n    1178 }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    449  \tstruct mosquitto_msg_data *msg_data;\n    450  \tenum mosquitto_msg_state state = mosq_ms_invalid;\n    452  \tint i;\n    457  \tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n    459  \tif(dir == mosq_md_out){\n    460  \t\tmsg_data = &context->msgs_out;\n    461  \t}else{\n    462  \t\tmsg_data = &context->msgs_in;\n    463  \t}\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    484  \tif(context->sock == INVALID_SOCKET){\n    486  \t\tif(qos == 0 && !db.config->queue_qos0_messages){\n    487  \t\t\tif(!context->bridge){\n    489  \t\t\t\treturn 2;\n    490  \t\t\t}else{\n    491  \t\t\t\tif(context->bridge->start_type != bst_lazy){\n    493  \t\t\t\t\treturn 2;\n    494  \t\t\t\t}\n    495  \t\t\t}\n    496  \t\t}\n    497  \t\tif(context->bridge && context->bridge->clean_start_local == true){\n    499  \t\t\treturn 2;\n    500  \t\t}\n    501  \t}\n    503  \tif(context->sock != INVALID_SOCKET){\n    504  \t\tif(db__ready_for_flight(context, dir, qos)){\n    517  \t\t\t}else{\n    520  \t\t\t\t}else{\n    522  \t\t\t\t\treturn 1;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n    528  \t\t}else{\n    530  \t\t\tif(context->is_dropping == false){\n    531  \t\t\t\tcontext->is_dropping = true;\n    532  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    534  \t\t\t\t\t\tcontext->id);\n    535  \t\t\t}\n    538  \t\t\treturn 2;\n    539  \t\t}\n    540  \t}else{\n    541  \t\tif (db__ready_for_queue(context, qos, msg_data)){\n    543  \t\t}else{\n    545  \t\t\tif(context->is_dropping == false){\n    546  \t\t\t\tcontext->is_dropping = true;\n    547  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    549  \t\t\t\t\t\tcontext->id);\n    550  \t\t\t}\n    552  \t\t\treturn 2;\n    553  \t\t}\n    554  \t}\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    582  \tif(state == mosq_ms_queued){\n    583  \t\tDL_APPEND(msg_data->queued, msg);\n    585  \t}else{\n    586  \t\tDL_APPEND(msg_data->inflight, msg);\n    588  \t}\n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    598  \t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n    599  \t\tif(dest_ids){\n    602  \t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t}\n    609  \t}\n    611  \tif(context->bridge && context->bridge->start_type == bst_lazy\n    612  \t\t\t&& context->sock == INVALID_SOCKET\n    613  \t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n    616  \t}\n    633  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    704  \tstruct mosquitto_msg_store *stored;\n    705  \tconst char *source_id;\n    706  \tenum mosquitto_msg_origin origin;\n    710  \tstored = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    711  \tif(stored == NULL) return MOSQ_ERR_NOMEM;\n    713  \tstored->topic = mosquitto__strdup(topic);\n    714  \tif(stored->topic == NULL){\n    715  \t\tdb__msg_store_free(stored);\n    716  \t\treturn MOSQ_ERR_INVAL;\n    717  \t}\n    719  \tstored->qos = qos;\n    720  \tif(db.config->retain_available == false){\n    721  \t\tstored->retain = 0;\n    722  \t}else{\n    723  \t\tstored->retain = retain;\n    724  \t}\n    726  \tstored->payloadlen = payloadlen;\n    727  \tif(payloadlen > 0){\n    728  \t\tstored->payload = mosquitto__malloc(stored->payloadlen+1);\n    729  \t\tif(stored->payload == NULL){\n    730  \t\t\tdb__msg_store_free(stored);\n    731  \t\t\treturn MOSQ_ERR_NOMEM;\n    732  \t\t}\n    734  \t\t((uint8_t *)stored->payload)[stored->payloadlen] = 0;\n    735  \t\tmemcpy(stored->payload, payload, stored->payloadlen);\n    736  \t}\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    746  \t}\n    748  \tif(context){\n    750  \t}else{\n    753  \tif(db__message_store(context, stored, message_expiry_interval, 0, origin)) return 1;\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    763  \tif(source && source->id){\n    764  \t\tstored->source_id = mosquitto__strdup(source->id);\n    765  \t}else{\n    766  \t\tstored->source_id = mosquitto__strdup(\"\");\n    767  \t}\n    768  \tif(!stored->source_id){\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    774  \tif(source && source->username){\n    775  \t\tstored->source_username = mosquitto__strdup(source->username);\n    776  \t\tif(!stored->source_username){\n    778  \t\t\treturn MOSQ_ERR_NOMEM;\n    779  \t\t}\n    780  \t}\n    781  \tif(source){\n    782  \t\tstored->source_listener = source->listener;\n    783  \t}\n    806  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    448  \tX509 *client_cert = NULL;\n    460  \tif(!context->listener){\n    461  \t\treturn MOSQ_ERR_INVAL;\n    462  \t}\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    502  \t\tcontext->protocol = mosq_p_mqtt31;\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    504  \t\t\tcontext->is_bridge = true;\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    508  \t\t\tcontext->protocol = mosq_p_mqtt311;\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    511  \t\t\t\tcontext->is_bridge = true;\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    514  \t\t\tcontext->protocol = mosq_p_mqtt5;\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    563  \t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid Will QoS in CONNECT from %s.\",\n    564  \t\t\t\tcontext->address);\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    724  \tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    731  \t\tif(!context->ssl){\n    732  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    741  \t\tif(context->listener->psk_hint){\n    743  \t\t\tif(!context->username){\n    744  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    754  \t\t\tclient_cert = SSL_get_peer_certificate(context->ssl);\n    755  \t\t\tif(!client_cert){\n    756  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    764  \t\t\tname = X509_get_subject_name(client_cert);\n    765  \t\t\tif(!name){\n    766  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    774  \t\t\tif (context->listener->use_identity_as_username) { /* use_identity_as_username */\n    775  \t\t\t\ti = X509_NAME_get_index_by_NID(name, NID_commonName, -1);\n    776  \t\t\t\tif(i == -1){\n    777  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    785  \t\t\t\tname_entry = X509_NAME_get_entry(name, i);\n    786  \t\t\t\tif(name_entry){\n    787  \t\t\t\t\tname_asn1 = X509_NAME_ENTRY_get_data(name_entry);\n    788  \t\t\t\t\tif (name_asn1 == NULL) {\n    789  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    801  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_get0_data(name_asn1);\n    803  \t\t\t\t\tif(mosquitto_validate_utf8(new_username, (int)strlen(new_username))){\n    804  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    809  \t\t\t\t\t\tX509_free(client_cert);\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    814  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    824  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    835  \t\t\t\tX509_NAME_print_ex(subject_bio, X509_get_subject_name(client_cert), 0, XN_FLAG_RFC2253);\n    847  \t\t\t\tcontext->username = subject;\n    849  \t\t\tif(!context->username){\n    853  \t\t\tX509_free(client_cert);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    898  \t\t\tmosquitto__set_state(context, mosq_cs_authenticating);\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    905  \t\t\twill__clear(context);\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    925  \t\tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    973  \tif(client_cert) X509_free(client_cert);\n    976  \tcontext->clean_start = true;\n    977  \tcontext->session_expiry_interval = 0;\n    978  \tcontext->will_delay_interval = 0;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    55   \tint i;\n    56   \tint pos;\n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    335  \tint rc = MOSQ_ERR_SUCCESS;\n    337  \tuint16_t tlen;\n    340  \tuint16_t payloadlen;\n    341  \tmosquitto_property *properties = NULL;\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    349  \t\trc = property__read_all(CMD_WILL, &context->in_packet, &properties);\n    350  \t\tif(rc) goto error_cleanup;\n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    353  \t\tmosquitto_property_free_all(&properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    356  \trc = packet__read_string(&context->in_packet, &will_struct->msg.topic, &tlen);\n    357  \tif(rc) goto error_cleanup;\n    363  \tif(context->listener->mount_point){\n    364  \t\tslen = strlen(context->listener->mount_point) + strlen(will_struct->msg.topic) + 1;\n    365  \t\twill_topic_mount = mosquitto__malloc(slen+1);\n    366  \t\tif(!will_topic_mount){\n    368  \t\t\tgoto error_cleanup;\n    369  \t\t}\n    371  \t\tsnprintf(will_topic_mount, slen, \"%s%s\", context->listener->mount_point, will_struct->msg.topic);\n    372  \t\twill_topic_mount[slen] = '\\0';\n    374  \t\tmosquitto__free(will_struct->msg.topic);\n    375  \t\twill_struct->msg.topic = will_topic_mount;\n    376  \t}\n    378  \tif(!strncmp(will_struct->msg.topic, \"$CONTROL/\", strlen(\"$CONTROL/\"))){\n    380  \t\tgoto error_cleanup;\n    381  \t}\n    382  \trc = mosquitto_pub_topic_check(will_struct->msg.topic);\n    385  \trc = packet__read_uint16(&context->in_packet, &payloadlen);\n    386  \tif(rc) goto error_cleanup;\n    388  \twill_struct->msg.payloadlen = payloadlen;\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    393  \t\t\t\tsend__connack(context, 0, MQTT_RC_PACKET_TOO_LARGE, NULL);\n    394  \t\t\t}else{\n    395  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    396  \t\t\t}\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    400  \t\twill_struct->msg.payload = mosquitto__malloc((size_t)will_struct->msg.payloadlen);\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    406  \t\trc = packet__read_bytes(&context->in_packet, will_struct->msg.payload, (uint32_t)will_struct->msg.payloadlen);\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    416  error_cleanup:\n    417  \tif(will_struct){\n    418  \t\tmosquitto__free(will_struct->msg.topic);\n    419  \t\tmosquitto__free(will_struct->msg.payload);\n    422  \t}\n    424  }\nFunction: net__write\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:996\n    996  ssize_t net__write(struct mosquitto *mosq, const void *buf, size_t count)\n    997  {\n    999  \tint ret;\n    1001 \tassert(mosq);\n    1005 \tif(mosq->ssl){\n    1007 \t\tmosq->want_write = false;\n    1008 \t\tret = SSL_write(mosq->ssl, buf, (int)count);\n    1009 \t\tif(ret < 0){\n    1010 \t\t\tret = net__handle_ssl(mosq, ret);\n    1011 \t\t}\n    1012 \t\treturn (ssize_t )ret;\n    1013 \t}else{\n    1017 \treturn send(mosq->sock, buf, count, MSG_NOSIGNAL);\n    1020 \t}\n    1022 }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    51   \tassert(packet);\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    73   \tassert(packet);\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    106  \t\t*length = 0;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    157  \tassert(packet);\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: mosquitto_property_add_string\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:845\n    845  int mosquitto_property_add_string(mosquitto_property **proplist, int identifier, const char *value)\n    846  {\n    848  \tsize_t slen = 0;\n    851  \tif(value){\n    852  \t\tslen = strlen(value);\n    853  \t\tif(mosquitto_validate_utf8(value, (int)slen)) return MOSQ_ERR_MALFORMED_UTF8;\n    854  \t}\n    859  \t\t\t&& identifier != MQTT_PROP_AUTHENTICATION_METHOD\n    867  \tprop = mosquitto__calloc(1, sizeof(mosquitto_property));\n    871  \tprop->identifier = identifier;\n    872  \tif(value && slen > 0){\n    873  \t\tprop->value.s.v = mosquitto__strdup(value);\n    874  \t\tif(!prop->value.s.v){\n    876  \t\t\treturn MOSQ_ERR_NOMEM;\n    877  \t\t}\n    878  \t\tprop->value.s.len = (uint16_t)slen;\n    879  \t}\n    883  }\nFunction: property__get_property\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:988\n    988  static const mosquitto_property *property__get_property(const mosquitto_property *proplist, int identifier, bool skip_first)\n    989  {\n    990  \tconst mosquitto_property *p;\n    995  \twhile(p){\n    996  \t\tif(p->identifier == identifier){\n    997  \t\t\tif(!is_first || !skip_first){\n    998  \t\t\t\treturn p;\n    999  \t\t\t}\n    1001 \t\t}\n    1002 \t\tp = p->next;\n    1003 \t}\n    1005 }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    371  \t\tmux__delete(context);\n    372  \t\tcontext__disconnect(context);\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto__malloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:83\n    83   void *mosquitto__malloc(size_t size)\n    84   {\n    88   \tif(mem_limit && memcount + size > mem_limit){\n    89   \t\treturn NULL;\n    90   \t}\n    93   \tmem = malloc(size);\n    96   \tif(mem){\n    97   \t\tmemcount += malloc_usable_size(mem);\n    101  \t}\n    105  }\nFunction: mosquitto__strdup\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:144\n    144  char *mosquitto__strdup(const char *s)\n    145  {\n    148  \tif(mem_limit && memcount + strlen(s) > mem_limit){\n    149  \t\treturn NULL;\n    150  \t}\n    152  \tstr = strdup(s);\n    155  \tif(str){\n    156  \t\tmemcount += malloc_usable_size(str);\n    160  \t}\n    164  }\nFunction: mosquitto_free\nPath: /root/projects/mosquitto/src/memory_public.c:27\n    27   void mosquitto_free(void *mem)\n    29   \tmosquitto__free(mem);\n    30   }\nFunction: mosquitto_malloc\nPath: /root/projects/mosquitto/src/memory_public.c:32\n    32   void *mosquitto_malloc(size_t size)\n    34   \treturn mosquitto__malloc(size);\n    35   }\nFunction: mux_epoll__add_out\nPath: /root/projects/mosquitto/src/mux_epoll.c:108\n    108  int mux_epoll__add_out(struct mosquitto *context)\n    109  {\n    110  \tstruct epoll_event ev;\n    112  \tif(!(context->events & EPOLLOUT)) {\n    114  \t\tev.data.ptr = context;\n    116  \t\tif(epoll_ctl(db.epollfd, EPOLL_CTL_ADD, context->sock, &ev) == -1) {\n    117  \t\t\tif((errno != EEXIST)||(epoll_ctl(db.epollfd, EPOLL_CTL_MOD, context->sock, &ev) == -1)) {\n    119  \t\t\t}\n    120  \t\t}\n    121  \t\tcontext->events = EPOLLIN | EPOLLOUT;\n    122  \t}\n    124  }\nFunction: send__auth\nPath: /root/projects/mosquitto/src/send_auth.c:28\n    28   int send__auth(struct mosquitto *context, uint8_t reason_code, const void *auth_data, uint16_t auth_data_len)\n    29   {\n    32   \tmosquitto_property *properties = NULL;\n    35   \tif(context->auth_method == NULL) return MOSQ_ERR_INVAL;\n    36   \tif(context->protocol != mosq_p_mqtt5) return MOSQ_ERR_PROTOCOL;\n    38   \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending AUTH to %s (rc%d, %s)\", context->id, reason_code, context->auth_method);\n    42   \trc = mosquitto_property_add_string(&properties, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method);\n    43   \tif(rc){\n    45   \t\treturn rc;\n    46   \t}\n    56   \tremaining_length += property__get_remaining_length(properties);\n    58   \tif(packet__check_oversize(context, remaining_length)){\n    61   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    62   \t}\n    67   \tpacket->command = CMD_AUTH;\n    68   \tpacket->remaining_length = remaining_length;\n    70   \trc = packet__alloc(packet);\n    76   \tpacket__write_byte(packet, reason_code);\n    77   \tproperty__write_all(packet, properties, true);\n    80   \treturn packet__queue(context, packet);\n    81   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    32   \tmosquitto_property *connack_props = NULL;\n    33   \tuint32_t remaining_length;\n    35   \trc = mosquitto_property_copy_all(&connack_props, properties);\n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    43   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->address, ack, reason_code);\n    44   \t}\n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    51   \t\t\tif(rc){\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    58   \t\t\tif(rc){\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    65   \t\t\tif(rc){\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    71   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_MAXIMUM_QOS, context->listener->max_qos);\n    72   \t\t\tif(rc){\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    78   \t\tremaining_length += property__get_remaining_length(connack_props);\n    79   \t}\n    81   \tif(packet__check_oversize(context, remaining_length)){\n    83   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    84   \t}\n    92   \tpacket->command = CMD_CONNACK;\n    93   \tpacket->remaining_length = remaining_length;\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    105  \t}\n    108  \treturn packet__queue(context, packet);\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    42   \tassert(mosq);\n    45   \tif(mosq->bridge){\n    46   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Bridge %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    47   \t}else\n    56   \tassert(mosq);\n    60   \tpacket->command = CMD_DISCONNECT;\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    62   \t\tpacket->remaining_length = 1;\n    63   \t\tif(properties){\n    64   \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    65   \t\t}\n    66   \t}else{\n    67   \t\tpacket->remaining_length = 0;\n    68   \t}\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    80   \t}\n    82   \treturn packet__queue(mosq, packet);\n    83   }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    126  \tassert(mosq);\n    130  \tpacket->command = command;\n    131  \tif(dup){\n    132  \t\tpacket->command |= 8;\n    133  \t}\n    134  \tpacket->remaining_length = 2;\n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    137  \t\tif(reason_code != 0 || properties){\n    138  \t\t\tpacket->remaining_length += 1;\n    139  \t\t}\n    141  \t\tif(properties){\n    142  \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    143  \t\t}\n    144  \t}\n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    161  \t}\n    163  \treturn packet__queue(mosq, packet);\n    164  }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    117  \treturn send__command_with_mid(mosq, CMD_PUBREL|2, mid, false, 0, properties);\n    118  }\nFunction: send__publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:42\n    42   int send__publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    43   {\n    47   \tint i;\n    49   \tbool match;\n    51   \tchar *mapped_topic = NULL;\n    55   \tassert(mosq);\n    60   \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    63   \tif(!mosq->retain_available){\n    65   \t}\n    68   \tif(mosq->listener && mosq->listener->mount_point){\n    69   \t\tlen = strlen(mosq->listener->mount_point);\n    70   \t\tif(len < strlen(topic)){\n    71   \t\t\ttopic += len;\n    72   \t\t}else{\n    74   \t\t\treturn MOSQ_ERR_SUCCESS;\n    75   \t\t}\n    76   \t}\n    78   \tif(mosq->bridge && mosq->bridge->topics && mosq->bridge->topic_remapping){\n    79   \t\tfor(i=0; i<mosq->bridge->topic_count; i++){\n    80   \t\t\tcur_topic = &mosq->bridge->topics[i];\n    81   \t\t\tif((cur_topic->direction == bd_both || cur_topic->direction == bd_out)\n    82   \t\t\t\t\t&& (cur_topic->remote_prefix || cur_topic->local_prefix)){\n    85   \t\t\t\trc = mosquitto_topic_matches_sub(cur_topic->local_topic, topic, &match);\n    86   \t\t\t\tif(rc){\n    87   \t\t\t\t\treturn rc;\n    88   \t\t\t\t}\n    89   \t\t\t\tif(match){\n    90   \t\t\t\t\tmapped_topic = mosquitto__strdup(topic);\n    91   \t\t\t\t\tif(!mapped_topic) return MOSQ_ERR_NOMEM;\n    92   \t\t\t\t\tif(cur_topic->local_prefix){\n    94   \t\t\t\t\t\tif(!strncmp(cur_topic->local_prefix, mapped_topic, strlen(cur_topic->local_prefix))){\n    95   \t\t\t\t\t\t\ttopic_temp = mosquitto__strdup(mapped_topic+strlen(cur_topic->local_prefix));\n    96   \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    97   \t\t\t\t\t\t\tif(!topic_temp){\n    98   \t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    99   \t\t\t\t\t\t\t}\n    101  \t\t\t\t\t\t}\n    102  \t\t\t\t\t}\n    104  \t\t\t\t\tif(cur_topic->remote_prefix){\n    106  \t\t\t\t\t\tlen = strlen(mapped_topic) + strlen(cur_topic->remote_prefix)+1;\n    107  \t\t\t\t\t\ttopic_temp = mosquitto__malloc(len+1);\n    108  \t\t\t\t\t\tif(!topic_temp){\n    109  \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    110  \t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    111  \t\t\t\t\t\t}\n    112  \t\t\t\t\t\tsnprintf(topic_temp, len, \"%s%s\", cur_topic->remote_prefix, mapped_topic);\n    113  \t\t\t\t\t\ttopic_temp[len] = '\\0';\n    114  \t\t\t\t\t\tmosquitto__free(mapped_topic);\n    116  \t\t\t\t\t}\n    117  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, mapped_topic, (long)payloadlen);\n    119  \t\t\t\t\trc =  send__real_publish(mosq, mid, mapped_topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    120  \t\t\t\t\tmosquitto__free(mapped_topic);\n    121  \t\t\t\t\treturn rc;\n    122  \t\t\t\t}\n    123  \t\t\t}\n    124  \t\t}\n    125  \t}\n    127  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, topic, (long)payloadlen);\n    133  \treturn send__real_publish(mosq, mid, topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    134  }\nFunction: send__real_publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:137\n    137  int send__real_publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    138  {\n    140  \tunsigned int packetlen;\n    141  \tunsigned int proplen = 0, varbytes;\n    143  \tmosquitto_property expiry_prop;\n    145  \tassert(mosq);\n    147  \tif(topic){\n    148  \t\tpacketlen = 2+(unsigned int)strlen(topic) + payloadlen;\n    149  \t}else{\n    150  \t\tpacketlen = 2 + payloadlen;\n    151  \t}\n    152  \tif(qos > 0) packetlen += 2; /* For message id */\n    153  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tproplen += property__get_length_all(cmsg_props);\n    156  \t\tproplen += property__get_length_all(store_props);\n    157  \t\tif(expiry_interval > 0){\n    158  \t\t\texpiry_prop.next = NULL;\n    160  \t\t\texpiry_prop.identifier = MQTT_PROP_MESSAGE_EXPIRY_INTERVAL;\n    163  \t\t\tproplen += property__get_length_all(&expiry_prop);\n    164  \t\t}\n    166  \t\tvarbytes = packet__varint_bytes(proplen);\n    172  \t\t}else{\n    173  \t\t\tpacketlen += proplen + varbytes;\n    174  \t\t}\n    175  \t}\n    176  \tif(packet__check_oversize(mosq, packetlen)){\n    178  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Dropping too large outgoing PUBLISH for %s (%d bytes)\", SAFE_PRINT(mosq->id), packetlen);\n    182  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    183  \t}\n    189  \tpacket->command = (uint8_t)(CMD_PUBLISH | (uint8_t)((dup&0x1)<<3) | (uint8_t)(qos<<1) | retain);\n    190  \tpacket->remaining_length = packetlen;\n    206  \tif(mosq->protocol == mosq_p_mqtt5){\n    213  \t}\n    220  \treturn packet__queue(mosq, packet);\n    221  }\nFunction: session_expiry__cmp\nPath: /root/projects/mosquitto/src/session_expiry.c:34\n    34   static int session_expiry__cmp(struct session_expiry_list *i1, struct session_expiry_list *i2)\n    35   {\n    36   \tif(i1->context->session_expiry_time == i2->context->session_expiry_time){\n    37   \t\treturn 0;\n    38   \t}else if(i1->context->session_expiry_time > i2->context->session_expiry_time){\n    39   \t\treturn 1;\n    40   \t}else{\n    41   \t\treturn -1;\n    42   \t}\n    43   }\nFunction: session_expiry__remove\nPath: /root/projects/mosquitto/src/session_expiry.c:121\n    121  void session_expiry__remove(struct mosquitto *context)\n    122  {\n    123  \tif(context->expiry_list_item){\n    124  \t\tDL_DELETE(expiry_list, context->expiry_list_item);\n    125  \t\tmosquitto__free(context->expiry_list_item);\n    126  \t\tcontext->expiry_list_item = NULL;\n    127  \t}\n    128  }\nFunction: acl__check_single\nPath: /root/projects/mosquitto/src/security.c:602\n    602  static int acl__check_single(struct mosquitto__auth_plugin_config *auth_plugin, struct mosquitto *context, struct mosquitto_acl_msg *msg, int access)\n    603  {\n    607  \tusername = mosquitto_client_username(context);\n    608  \tif(auth_plugin->deny_special_chars == true){\n    615  \t\tif(username && strpbrk(username, \"+#\")){\n    616  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous username \\\"%s\\\"\", username);\n    617  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    618  \t\t}\n    619  \t\tif(context->id && strpbrk(context->id, \"+#\")){\n    620  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous client id \\\"%s\\\"\", context->id);\n    621  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    622  \t\t}\n    623  \t}\n    625  \tif(auth_plugin->plugin.version == 4){\n    626  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    627  \t\t\treturn MOSQ_ERR_SUCCESS;\n    628  \t\t}\n    629  \t\treturn auth_plugin->plugin.acl_check_v4(auth_plugin->plugin.user_data, access, context, msg);\n    630  \t}else if(auth_plugin->plugin.version == 3){\n    631  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    632  \t\t\treturn MOSQ_ERR_SUCCESS;\n    633  \t\t}\n    634  \t\treturn auth_plugin->plugin.acl_check_v3(auth_plugin->plugin.user_data, access, context, msg);\n    635  \t}else if(auth_plugin->plugin.version == 2){\n    636  \t\tif(access == MOSQ_ACL_SUBSCRIBE || access == MOSQ_ACL_UNSUBSCRIBE){\n    637  \t\t\treturn MOSQ_ERR_SUCCESS;\n    638  \t\t}\n    639  \t\treturn auth_plugin->plugin.acl_check_v2(auth_plugin->plugin.user_data, context->id, username, topic, access);\n    640  \t}else{\n    641  \t\treturn MOSQ_ERR_INVAL;\n    642  \t}\n    643  }\nFunction: sub__remove_shared_leaf\nPath: /root/projects/mosquitto/src/subs.c:190\n    190  static void sub__remove_shared_leaf(struct mosquitto__subhier *subhier, struct mosquitto__subshared *shared, struct mosquitto__subleaf *leaf)\n    191  {\n    192  \tDL_DELETE(shared->subs, leaf);\n    193  \tif(shared->subs == NULL){\n    194  \t\tHASH_DELETE(hh, subhier->shared, shared);\n    195  \t\tmosquitto__free(shared->name);\n    196  \t\tmosquitto__free(shared);\n    197  \t}\n    199  }\nFunction: sub__messages_queue\nPath: /root/projects/mosquitto/src/subs.c:659\n    659  int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n    660  {\n    661  \tint rc = MOSQ_ERR_SUCCESS, rc2;\n    662  \tint rc_normal = MOSQ_ERR_NO_SUBSCRIBERS, rc_shared = MOSQ_ERR_NO_SUBSCRIBERS;\n    663  \tstruct mosquitto__subhier *subhier;\n    664  \tchar **split_topics = NULL;\n    677  \tHASH_FIND(hh, db.normal_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    678  \tif(subhier){\n    679  \t\trc_normal = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    680  \t\tif(rc_normal > 0){\n    682  \t\t\tgoto end;\n    683  \t\t}\n    684  \t}\n    686  \tHASH_FIND(hh, db.shared_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    687  \tif(subhier){\n    688  \t\trc_shared = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    689  \t\tif(rc_shared > 0){\n    691  \t\t\tgoto end;\n    692  \t\t}\n    693  \t}\n    695  \tif(rc_normal == MOSQ_ERR_NO_SUBSCRIBERS && rc_shared == MOSQ_ERR_NO_SUBSCRIBERS){\n    697  \t}\n    711  }\nFunction: sub__search\nPath: /root/projects/mosquitto/src/subs.c:479\n    479  static int sub__search(struct mosquitto__subhier *subhier, char **split_topics, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    480  {\n    482  \tstruct mosquitto__subhier *branch;\n    486  \tif(split_topics && split_topics[0]){\n    488  \t\tHASH_FIND(hh, subhier->children, split_topics[0], strlen(split_topics[0]), branch);\n    490  \t\tif(branch){\n    491  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    492  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    494  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    495  \t\t\t\treturn rc;\n    496  \t\t\t}\n    497  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    498  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    499  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    501  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    502  \t\t\t\t\treturn rc;\n    503  \t\t\t\t}\n    504  \t\t\t}\n    505  \t\t}\n    508  \t\tHASH_FIND(hh, subhier->children, \"+\", 1, branch);\n    510  \t\tif(branch){\n    511  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    512  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    514  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    515  \t\t\t\treturn rc;\n    516  \t\t\t}\n    517  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    518  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    519  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    521  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    522  \t\t\t\t\treturn rc;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}\n    526  \t}\n    529  \tHASH_FIND(hh, subhier->children, \"#\", 1, branch);\n    530  \tif(branch && !branch->children){\n    535  \t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    536  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    538  \t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    539  \t\t\treturn rc;\n    540  \t\t}\n    541  \t}\n    548  }\nFunction: subs__process\nPath: /root/projects/mosquitto/src/subs.c:129\n    129  static int subs__process(struct mosquitto__subhier *hier, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    130  {\n    133  \tstruct mosquitto__subleaf *leaf;\n    135  \trc = subs__shared_process(hier, topic, qos, retain, stored);\n    137  \tleaf = hier->subs;\n    138  \twhile(source_id && leaf){\n    139  \t\tif(!leaf->context->id || (leaf->no_local && !strcmp(leaf->context->id, source_id))){\n    140  \t\t\tleaf = leaf->next;\n    142  \t\t}\n    147  \t\tleaf = leaf->next;\n    148  \t}\n    149  \tif(hier->subs || hier->shared){\n    150  \t\treturn rc;\n    151  \t}else{\n    152  \t\treturn MOSQ_ERR_NO_SUBSCRIBERS;\n    153  \t}\n    154  }\nFunction: subs__send\nPath: /root/projects/mosquitto/src/subs.c:63\n    63   static int subs__send(struct mosquitto__subleaf *leaf, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    64   {\n    65   \tbool client_retain;\n    66   \tuint16_t mid;\n    67   \tuint8_t client_qos, msg_qos;\n    68   \tmosquitto_property *properties = NULL;\n    72   \trc2 = mosquitto_acl_check(leaf->context, topic, stored->payloadlen, stored->payload, stored->qos, stored->retain, MOSQ_ACL_READ);\n    73   \tif(rc2 == MOSQ_ERR_ACL_DENIED){\n    74   \t\treturn MOSQ_ERR_SUCCESS;\n    75   \t}else if(rc2 == MOSQ_ERR_SUCCESS){\n    76   \t\tclient_qos = leaf->qos;\n    87   \t\tif(msg_qos){\n    88   \t\t\tmid = mosquitto__mid_generate(leaf->context);\n    89   \t\t}else{\n    92   \t\tif(leaf->retain_as_published){\n    93   \t\t\tclient_retain = retain;\n    94   \t\t}else{\n    97   \t\tif(leaf->identifier){\n    98   \t\t\tmosquitto_property_add_varint(&properties, MQTT_PROP_SUBSCRIPTION_IDENTIFIER, leaf->identifier);\n    99   \t\t}\n    100  \t\tif(db__message_insert(leaf->context, mid, mosq_md_out, msg_qos, client_retain, stored, properties, true) == 1){\n    101  \t\t\treturn 1;\n    102  \t\t}\n    103  \t}else{\n    104  \t\treturn 1; /* Application error */\n    105  \t}\n    107  }\nFunction: sub__clean_session\nPath: /root/projects/mosquitto/src/subs.c:746\n    746  int sub__clean_session(struct mosquitto *context)\n    747  {\n    748  \tint i;\n    749  \tstruct mosquitto__subleaf *leaf;\n    750  \tstruct mosquitto__subhier *hier;\n    752  \tfor(i=0; i<context->sub_count; i++){\n    753  \t\tif(context->subs[i] == NULL){\n    755  \t\t}\n    757  \t\thier = context->subs[i]->hier;\n    759  \t\tif(context->subs[i]->shared){\n    760  \t\t\tleaf = context->subs[i]->shared->subs;\n    761  \t\t\twhile(leaf){\n    762  \t\t\t\tif(leaf->context==context){\n    766  \t\t\t\t\tsub__remove_shared_leaf(context->subs[i]->hier, context->subs[i]->shared, leaf);\n    768  \t\t\t\t}\n    769  \t\t\t\tleaf = leaf->next;\n    770  \t\t\t}\n    771  \t\t}else{\n    772  \t\t\tleaf = hier->subs;\n    773  \t\t\twhile(leaf){\n    774  \t\t\t\tif(leaf->context==context){\n    778  \t\t\t\t\tDL_DELETE(hier->subs, leaf);\n    779  \t\t\t\t\tmosquitto__free(leaf);\n    781  \t\t\t\t}\n    782  \t\t\t\tleaf = leaf->next;\n    783  \t\t\t}\n    784  \t\t}\n    785  \t\tmosquitto__free(context->subs[i]);\n    786  \t\tcontext->subs[i] = NULL;\n    788  \t\tif(hier->subs == NULL\n    789  \t\t\t\t&& hier->children == NULL\n    790  \t\t\t\t&& hier->shared == NULL\n    791  \t\t\t\t&& hier->parent){\n    794  \t\t\t\thier = tmp_remove_subs(hier);\n    795  \t\t\t}while(hier);\n    796  \t\t}\n    797  \t}\n    798  \tmosquitto__free(context->subs);\n    799  \tcontext->subs = NULL;\n    800  \tcontext->sub_count = 0;\n    803  }\nFunction: tmp_remove_subs\nPath: /root/projects/mosquitto/src/subs.c:715\n    715  static struct mosquitto__subhier *tmp_remove_subs(struct mosquitto__subhier *sub)\n    716  {\n    719  \tif(!sub || !sub->parent){\n    720  \t\treturn NULL;\n    721  \t}\n    723  \tif(sub->children || sub->subs){\n    724  \t\treturn NULL;\n    725  \t}\n    727  \tparent = sub->parent;\n    728  \tHASH_DELETE(hh, parent->children, sub);\n    729  \tmosquitto__free(sub->topic);\n    730  \tmosquitto__free(sub);\n    732  \tif(parent->subs == NULL\n    733  \t\t\t&& parent->children == NULL\n    734  \t\t\t&& parent->shared == NULL\n    735  \t\t\t&& parent->parent){\n    737  \t\treturn parent;\n    738  \t}else{\n    739  \t\treturn NULL;\n    740  \t}\n    741  }\nFunction: util__increment_send_quota\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:222\n    222  void util__increment_send_quota(struct mosquitto *mosq)\n    223  {\n    224  \tif(mosq->msgs_out.inflight_quota < mosq->msgs_out.inflight_maximum){\n    225  \t\tmosq->msgs_out.inflight_quota++;\n    226  \t}\n    227  }\nFunction: will_delay__remove\nPath: /root/projects/mosquitto/src/will_delay.c:99\n    99   void will_delay__remove(struct mosquitto *mosq)\n    100  {\n    101  \tif(mosq->will_delay_entry != NULL){\n    102  \t\tDL_DELETE(delay_list, mosq->will_delay_entry);\n    103  \t\tmosquitto__free(mosq->will_delay_entry);\n    104  \t\tmosq->will_delay_entry = NULL;\n    105  \t}\n    106  }\nFunction: will__clear\nPath: /root/projects/mosquitto/src/../lib/will_mosq.c:111\n    111  int will__clear(struct mosquitto *mosq)\n    112  {\n    113  \tif(!mosq->will) return MOSQ_ERR_SUCCESS;\n    115  \tmosquitto__free(mosq->will->msg.topic);\n    116  \tmosq->will->msg.topic = NULL;\n    118  \tmosquitto__free(mosq->will->msg.payload);\n    119  \tmosq->will->msg.payload = NULL;\n    121  \tmosquitto_property_free_all(&mosq->will->properties);\n    123  \tmosquitto__free(mosq->will);\n    124  \tmosq->will = NULL;\n    125  \tmosq->will_delay_interval = 0;\n    128  }\n",
    "The Server sending the CONNACK packet MUST use one of the Connect Reason Code values from Table 3-1 [MQTT-3.2.2-8].": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    191  \n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    199  \n    200  \t\t\t/* Unexpected disconnect, queue the client will. */\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    220  \n    221  \tplugin__handle_disconnect(context, -1);\n    222  \n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    225  #ifdef WITH_BRIDGE\n    226  \tif(context->bridge == NULL)\n    227  \t/* Outgoing bridge connection never expire */\n    228  #endif\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    231  \t\t\t/* Client session is due to be expired now */\n    232  \t\t\tif(context->will_delay_interval == 0){\n    233  \t\t\t\t/* This will be done later, after the will is published for delay>0. */\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__read_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:178\n    178  int packet__read_uint32(struct mosquitto__packet *packet, uint32_t *word)\n    179  {\n    180  \tuint32_t val = 0;\n    181  \tint i;\n    182  \n    183  \tassert(packet);\n    184  \tif(packet->pos+4 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    185  \n    186  \tfor(i=0; i<4; i++){\n    187  \t\tval = (val << 8) + packet->payload[packet->pos];\n    188  \t\tpacket->pos++;\n    189  \t}\n    190  \n    191  \t*word = val;\n    192  \n    193  \treturn MOSQ_ERR_SUCCESS;\n    194  }\nFunction: packet__write_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:197\n    197  void packet__write_uint32(struct mosquitto__packet *packet, uint32_t word)\n    198  {\n    199  \tpacket__write_byte(packet, (uint8_t)((word & 0xFF000000) >> 24));\n    200  \tpacket__write_byte(packet, (uint8_t)((word & 0x00FF0000) >> 16));\n    201  \tpacket__write_byte(packet, (uint8_t)((word & 0x0000FF00) >> 8));\n    202  \tpacket__write_byte(packet, (uint8_t)((word & 0x000000FF)));\n    203  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    209  \tuint8_t byte;\n    210  \tunsigned int remaining_mult = 1;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    213  \n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    219  \t\t\tremaining_mult *= 128;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    223  \t\t\t\t\t/* Catch overlong encodings */\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    227  \t\t\t\t\tif(bytes) (*bytes) = lbytes;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    235  \treturn MOSQ_ERR_MALFORMED_PACKET;\n    236  }\nFunction: packet__write_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:239\n    239  int packet__write_varint(struct mosquitto__packet *packet, uint32_t word)\n    240  {\n    241  \tuint8_t byte;\n    242  \tint count = 0;\n    243  \n    244  \tdo{\n    245  \t\tbyte = (uint8_t)(word % 128);\n    246  \t\tword = word / 128;\n    247  \t\t/* If there are more digits to encode, set the top bit of this digit */\n    248  \t\tif(word > 0){\n    249  \t\t\tbyte = byte | 0x80;\n    250  \t\t}\n    251  \t\tpacket__write_byte(packet, byte);\n    252  \t\tcount++;\n    253  \t}while(word > 0 && count < 5);\n    254  \n    255  \tif(count == 5){\n    256  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    257  \t}\n    258  \treturn MOSQ_ERR_SUCCESS;\n    259  }\nFunction: packet__varint_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:262\n    262  unsigned int packet__varint_bytes(uint32_t word)\n    263  {\n    264  \tif(word < 128){\n    265  \t\treturn 1;\n    266  \t}else if(word < 16384){\n    267  \t\treturn 2;\n    268  \t}else if(word < 2097152){\n    269  \t\treturn 3;\n    270  \t}else if(word < 268435456){\n    271  \t\treturn 4;\n    272  \t}else{\n    273  \t\treturn 5;\n    274  \t}\n    275  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    54   \tint i;\n    55   \n    56   \tassert(packet);\n    57   \n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    61   \tdo{\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    64   \t\t/* If there are more digits to encode, set the top bit of this digit */\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    73   #ifdef WITH_WEBSOCKETS\n    74   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length + LWS_PRE);\n    75   #else\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    77   #endif\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    79   \n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    85   \n    86   \treturn MOSQ_ERR_SUCCESS;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    92   \n    93   \t/* Free data and reset values */\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    144  #ifndef WITH_BROKER\n    145  \tchar sockpair_data = 0;\n    146  #endif\n    147  \tassert(mosq);\n    148  \tassert(packet);\n    149  \n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    152  \n    153  \tpacket->next = NULL;\n    154  \tCOMPAT_pthread_mutex_lock(&mosq->out_packet_mutex);\n    155  \n    156  #ifdef WITH_BROKER\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    158  \t\tmosquitto__free(packet);\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    162  \t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    165  \t\tG_MSGS_DROPPED_INC();\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    168  #endif\n    169  \n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    177  \tCOMPAT_pthread_mutex_unlock(&mosq->out_packet_mutex);\n    178  #ifdef WITH_BROKER\n    179  #  ifdef WITH_WEBSOCKETS\n    180  \tif(mosq->wsi){\n    181  \t\tlws_callback_on_writable(mosq->wsi);\n    182  \t\treturn MOSQ_ERR_SUCCESS;\n    183  \t}else{\n    184  \t\treturn packet__write(mosq);\n    185  \t}\n    186  #  else\n    187  \treturn packet__write(mosq);\n    188  #  endif\n    189  #else\n    190  \n    191  \t/* Write a single byte to sockpairW (connected to sockpairR) to break out\n    192  \t * of select() if in threaded mode. */\n    193  \tif(mosq->sockpairW != INVALID_SOCKET){\n    194  #ifndef WIN32\n    195  \t\tif(write(mosq->sockpairW, &sockpair_data, 1)){\n    196  \t\t}\n    197  #else\n    198  \t\tsend(mosq->sockpairW, &sockpair_data, 1, 0);\n    199  #endif\n    200  \t}\n    201  \n    202  \tif(mosq->in_callback == false && mosq->threaded == mosq_ts_none){\n    203  \t\treturn packet__write(mosq);\n    204  \t}else{\n    205  \t\treturn MOSQ_ERR_SUCCESS;\n    206  \t}\n    207  #endif\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    228  \tssize_t write_length;\n    229  \tstruct mosquitto__packet *packet;\n    230  \tenum mosquitto_client_state state;\n    231  \n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    234  \n    235  \tCOMPAT_pthread_mutex_lock(&mosq->current_out_packet_mutex);\n    236  \tCOMPAT_pthread_mutex_lock(&mosq->out_packet_mutex);\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    245  \tCOMPAT_pthread_mutex_unlock(&mosq->out_packet_mutex);\n    246  \n    247  #ifdef WITH_BROKER\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    251  #endif\n    252  \n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    255  \t\tCOMPAT_pthread_mutex_unlock(&mosq->current_out_packet_mutex);\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    258  \n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    261  \n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    269  #ifdef WIN32\n    270  \t\t\t\terrno = WSAGetLastError();\n    271  #endif\n    272  \t\t\t\tif(errno == EAGAIN || errno == COMPAT_EWOULDBLOCK\n    273  #ifdef WIN32\n    274  \t\t\t\t\t\t|| errno == WSAENOTCONN\n    275  #endif\n    276  \t\t\t\t\t\t){\n    277  \t\t\t\t\tCOMPAT_pthread_mutex_unlock(&mosq->current_out_packet_mutex);\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    280  \t\t\t\t\tCOMPAT_pthread_mutex_unlock(&mosq->current_out_packet_mutex);\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    294  \n    295  \t\tG_MSGS_SENT_INC(1);\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    297  \t\t\tG_PUB_MSGS_SENT_INC(1);\n    298  #ifndef WITH_BROKER\n    299  \t\t\tCOMPAT_pthread_mutex_lock(&mosq->callback_mutex);\n    300  \t\t\tif(mosq->on_publish){\n    301  \t\t\t\t/* This is a QoS=0 message */\n    302  \t\t\t\tmosq->in_callback = true;\n    303  \t\t\t\tmosq->on_publish(mosq, mosq->userdata, packet->mid);\n    304  \t\t\t\tmosq->in_callback = false;\n    305  \t\t\t}\n    306  \t\t\tif(mosq->on_publish_v5){\n    307  \t\t\t\t/* This is a QoS=0 message */\n    308  \t\t\t\tmosq->in_callback = true;\n    309  \t\t\t\tmosq->on_publish_v5(mosq, mosq->userdata, packet->mid, 0, NULL);\n    310  \t\t\t\tmosq->in_callback = false;\n    311  \t\t\t}\n    312  \t\t\tCOMPAT_pthread_mutex_unlock(&mosq->callback_mutex);\n    313  \t\t}else if(((packet->command)&0xF0) == CMD_DISCONNECT){\n    314  \t\t\tdo_client_disconnect(mosq, MOSQ_ERR_SUCCESS, NULL);\n    315  \t\t\tpacket__cleanup(packet);\n    316  \t\t\tmosquitto__free(packet);\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    318  #endif\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    320  \t\t\tG_PUB_MSGS_SENT_INC(1);\n    321  \t\t}\n    322  \n    323  \t\t/* Free data and reset values */\n    324  \t\tCOMPAT_pthread_mutex_lock(&mosq->out_packet_mutex);\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    333  \t\tCOMPAT_pthread_mutex_unlock(&mosq->out_packet_mutex);\n    334  \n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    337  \n    338  #ifdef WITH_BROKER\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    340  #else\n    341  \t\tCOMPAT_pthread_mutex_lock(&mosq->msgtime_mutex);\n    342  \t\tmosq->next_msg_out = mosquitto_time() + mosq->keepalive;\n    343  \t\tCOMPAT_pthread_mutex_unlock(&mosq->msgtime_mutex);\n    344  #endif\n    345  \t}\n    346  #ifdef WITH_BROKER\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    350  #endif\n    351  \tCOMPAT_pthread_mutex_unlock(&mosq->current_out_packet_mutex);\n    352  \treturn MOSQ_ERR_SUCCESS;\n    353  }\nFunction: packet__check_oversize\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:211\n    211  int packet__check_oversize(struct mosquitto *mosq, uint32_t remaining_length)\n    212  {\n    213  \tuint32_t len;\n    214  \n    215  \tif(mosq->maximum_packet_size == 0) return MOSQ_ERR_SUCCESS;\n    216  \n    217  \tlen = remaining_length + packet__varint_bytes(remaining_length);\n    218  \tif(len > mosq->maximum_packet_size){\n    219  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    220  \t}else{\n    221  \t\treturn MOSQ_ERR_SUCCESS;\n    222  \t}\n    223  }\nFunction: property__process_connect\nPath: /root/projects/mosquitto/src/property_broker.c:30\n    30   int property__process_connect(struct mosquitto *context, mosquitto_property **props)\n    31   {\n    32   \tmosquitto_property *p;\n    33   \n    34   \tp = *props;\n    35   \n    36   \twhile(p){\n    37   \t\tif(p->identifier == MQTT_PROP_SESSION_EXPIRY_INTERVAL){\n    38   \t\t\tcontext->session_expiry_interval = p->value.i32;\n    39   \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM){\n    40   \t\t\tif(p->value.i16 == 0){\n    41   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    42   \t\t\t}\n    43   \n    44   \t\t\tcontext->msgs_out.inflight_maximum = p->value.i16;\n    45   \t\t\tcontext->msgs_out.inflight_quota = context->msgs_out.inflight_maximum;\n    46   \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    47   \t\t\tif(p->value.i32 == 0){\n    48   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    49   \t\t\t}\n    50   \t\t\tcontext->maximum_packet_size = p->value.i32;\n    51   \t\t}\n    52   \t\tp = p->next;\n    53   \t}\n    54   \n    55   \treturn MOSQ_ERR_SUCCESS;\n    56   }\nFunction: property__process_will\nPath: /root/projects/mosquitto/src/property_broker.c:59\n    59   int property__process_will(struct mosquitto *context, struct mosquitto_message_all *msg, mosquitto_property **props)\n    60   {\n    61   \tmosquitto_property *p, *p_prev;\n    62   \tmosquitto_property *msg_properties, *msg_properties_last;\n    63   \n    64   \tp = *props;\n    65   \tp_prev = NULL;\n    66   \tmsg_properties = NULL;\n    67   \tmsg_properties_last = NULL;\n    68   \twhile(p){\n    69   \t\tswitch(p->identifier){\n    70   \t\t\tcase MQTT_PROP_CONTENT_TYPE:\n    71   \t\t\tcase MQTT_PROP_CORRELATION_DATA:\n    72   \t\t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    73   \t\t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    74   \t\t\tcase MQTT_PROP_USER_PROPERTY:\n    75   \t\t\t\tif(msg_properties){\n    76   \t\t\t\t\tmsg_properties_last->next = p;\n    77   \t\t\t\t\tmsg_properties_last = p;\n    78   \t\t\t\t}else{\n    79   \t\t\t\t\tmsg_properties = p;\n    80   \t\t\t\t\tmsg_properties_last = p;\n    81   \t\t\t\t}\n    82   \t\t\t\tif(p_prev){\n    83   \t\t\t\t\tp_prev->next = p->next;\n    84   \t\t\t\t\tp = p_prev->next;\n    85   \t\t\t\t}else{\n    86   \t\t\t\t\t*props = p->next;\n    87   \t\t\t\t\tp = *props;\n    88   \t\t\t\t}\n    89   \t\t\t\tmsg_properties_last->next = NULL;\n    90   \t\t\t\tbreak;\n    91   \n    92   \t\t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    93   \t\t\t\tcontext->will_delay_interval = p->value.i32;\n    94   \t\t\t\tp_prev = p;\n    95   \t\t\t\tp = p->next;\n    96   \t\t\t\tbreak;\n    97   \n    98   \t\t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    99   \t\t\t\tmsg->expiry_interval = p->value.i32;\n    100  \t\t\t\tp_prev = p;\n    101  \t\t\t\tp = p->next;\n    102  \t\t\t\tbreak;\n    103  \n    104  \t\t\tdefault:\n    105  \t\t\t\tmsg->properties = msg_properties;\n    106  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    107  \t\t\t\tbreak;\n    108  \t\t}\n    109  \t}\n    110  \n    111  \tmsg->properties = msg_properties;\n    112  \treturn MOSQ_ERR_SUCCESS;\n    113  }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    155  \tint rc;\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    158  \n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    161  \n    162  \t*properties = NULL;\n    163  \n    164  \t/* The order of properties must be preserved for some types, so keep the\n    165  \t * same order for all */\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    172  \n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    175  \t\t\tmosquitto__free(p);\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    179  \n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    185  \t\ttail = p;\n    186  \n    187  \t}\n    188  \n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    194  \treturn MOSQ_ERR_SUCCESS;\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    252  \n    253  \tif(!property) return;\n    254  \n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__read\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:35\n    35   static int property__read(struct mosquitto__packet *packet, uint32_t *len, mosquitto_property *property)\n    36   {\n    37   \tint rc;\n    38   \tuint32_t property_identifier;\n    39   \tuint8_t byte;\n    40   \tuint8_t byte_count;\n    41   \tuint16_t uint16;\n    42   \tuint32_t uint32;\n    43   \tuint32_t varint;\n    44   \tchar *str1, *str2;\n    45   \tuint16_t slen1, slen2;\n    46   \n    47   \tif(!property) return MOSQ_ERR_INVAL;\n    48   \n    49   \trc = packet__read_varint(packet, &property_identifier, NULL);\n    50   \tif(rc){\n    51   \t\treturn rc;\n    52   \t}\n    53   \t*len -= 1;\n    54   \n    55   \tmemset(property, 0, sizeof(mosquitto_property));\n    56   \n    57   \tproperty->identifier = (int32_t)property_identifier;\n    58   \n    59   \tswitch(property_identifier){\n    60   \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    61   \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    62   \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    63   \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    64   \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    65   \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    66   \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    67   \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    68   \t\t\trc = packet__read_byte(packet, &byte);\n    69   \t\t\tif(rc) return rc;\n    70   \t\t\t*len -= 1; /* byte */\n    71   \t\t\tproperty->value.i8 = byte;\n    72   \t\t\tbreak;\n    73   \n    74   \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    75   \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    76   \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    77   \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    78   \t\t\trc = packet__read_uint16(packet, &uint16);\n    79   \t\t\tif(rc) return rc;\n    80   \t\t\t*len -= 2; /* uint16 */\n    81   \t\t\tproperty->value.i16 = uint16;\n    82   \t\t\tbreak;\n    83   \n    84   \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    85   \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    86   \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    87   \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    88   \t\t\trc = packet__read_uint32(packet, &uint32);\n    89   \t\t\tif(rc) return rc;\n    90   \t\t\t*len -= 4; /* uint32 */\n    91   \t\t\tproperty->value.i32 = uint32;\n    92   \t\t\tbreak;\n    93   \n    94   \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    95   \t\t\trc = packet__read_varint(packet, &varint, &byte_count);\n    96   \t\t\tif(rc) return rc;\n    97   \t\t\t*len -= byte_count;\n    98   \t\t\tproperty->value.varint = varint;\n    99   \t\t\tbreak;\n    100  \n    101  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    102  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    103  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    104  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    105  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    106  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    107  \t\tcase MQTT_PROP_REASON_STRING:\n    108  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    109  \t\t\tif(rc) return rc;\n    110  \t\t\t*len = (*len) - 2 - slen1; /* uint16, string len */\n    111  \t\t\tproperty->value.s.v = str1;\n    112  \t\t\tproperty->value.s.len = slen1;\n    113  \t\t\tbreak;\n    114  \n    115  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    116  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    117  \t\t\trc = packet__read_binary(packet, (uint8_t **)&str1, &slen1);\n    118  \t\t\tif(rc) return rc;\n    119  \t\t\t*len = (*len) - 2 - slen1; /* uint16, binary len */\n    120  \t\t\tproperty->value.bin.v = str1;\n    121  \t\t\tproperty->value.bin.len = slen1;\n    122  \t\t\tbreak;\n    123  \n    124  \t\tcase MQTT_PROP_USER_PROPERTY:\n    125  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    126  \t\t\tif(rc) return rc;\n    127  \t\t\t*len = (*len) - 2 - slen1; /* uint16, string len */\n    128  \n    129  \t\t\trc = packet__read_string(packet, &str2, &slen2);\n    130  \t\t\tif(rc){\n    131  \t\t\t\tmosquitto__free(str1);\n    132  \t\t\t\treturn rc;\n    133  \t\t\t}\n    134  \t\t\t*len = (*len) - 2 - slen2; /* uint16, string len */\n    135  \n    136  \t\t\tproperty->name.v = str1;\n    137  \t\t\tproperty->name.len = slen1;\n    138  \t\t\tproperty->value.s.v = str2;\n    139  \t\t\tproperty->value.s.len = slen2;\n    140  \t\t\tbreak;\n    141  \n    142  \t\tdefault:\n    143  #ifdef WITH_BROKER\n    144  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property_identifier);\n    145  #endif\n    146  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    147  \t}\n    148  \n    149  \treturn MOSQ_ERR_SUCCESS;\n    150  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    933  \tint rc;\n    934  \n    935  \tp = properties;\n    936  \n    937  \twhile(p){\n    938  \t\t/* Validity checks */\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    947  \n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    957  \n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    966  \n    967  \t\t/* Check for properties on incorrect commands */\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    970  \n    971  \t\t/* Check for duplicates */\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    981  \n    982  \t\tp = p->next;\n    983  \t}\n    984  \n    985  \treturn MOSQ_ERR_SUCCESS;\n    986  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    201  \n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    212  \n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    217  \n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    222  \n    223  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    224  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    225  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    226  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    227  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    228  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    229  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    230  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    231  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    232  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    233  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    234  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    235  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    236  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    237  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    238  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    239  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    240  \t\t\t/* Nothing to free */\n    241  \t\t\tbreak;\n    242  \t}\n    243  \n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: property__write_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:429\n    429  int property__write_all(struct mosquitto__packet *packet, const mosquitto_property *properties, bool write_len)\n    430  {\n    431  \tint rc;\n    432  \tconst mosquitto_property *p;\n    433  \n    434  \tif(write_len){\n    435  \t\trc = packet__write_varint(packet, property__get_length_all(properties));\n    436  \t\tif(rc) return rc;\n    437  \t}\n    438  \n    439  \tp = properties;\n    440  \twhile(p){\n    441  \t\trc = property__write(packet, p);\n    442  \t\tif(rc) return rc;\n    443  \t\tp = p->next;\n    444  \t}\n    445  \n    446  \treturn MOSQ_ERR_SUCCESS;\n    447  }\nFunction: property__write\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:361\n    361  static int property__write(struct mosquitto__packet *packet, const mosquitto_property *property)\n    362  {\n    363  \tint rc;\n    364  \n    365  \trc = packet__write_varint(packet, (uint32_t)property->identifier);\n    366  \tif(rc) return rc;\n    367  \n    368  \tswitch(property->identifier){\n    369  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    370  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    371  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    372  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    373  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    374  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    375  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    376  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    377  \t\t\tpacket__write_byte(packet, property->value.i8);\n    378  \t\t\tbreak;\n    379  \n    380  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    381  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    382  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    383  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    384  \t\t\tpacket__write_uint16(packet, property->value.i16);\n    385  \t\t\tbreak;\n    386  \n    387  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    388  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    389  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    390  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    391  \t\t\tpacket__write_uint32(packet, property->value.i32);\n    392  \t\t\tbreak;\n    393  \n    394  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    395  \t\t\treturn packet__write_varint(packet, property->value.varint);\n    396  \n    397  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    398  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    399  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    400  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    401  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    402  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    403  \t\tcase MQTT_PROP_REASON_STRING:\n    404  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    405  \t\t\tbreak;\n    406  \n    407  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    408  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    409  \t\t\tpacket__write_uint16(packet, property->value.bin.len);\n    410  \t\t\tpacket__write_bytes(packet, property->value.bin.v, property->value.bin.len);\n    411  \t\t\tbreak;\n    412  \n    413  \t\tcase MQTT_PROP_USER_PROPERTY:\n    414  \t\t\tpacket__write_string(packet, property->name.v, property->name.len);\n    415  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    416  \t\t\tbreak;\n    417  \n    418  \t\tdefault:\n    419  #ifdef WITH_BROKER\n    420  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property->identifier);\n    421  #endif\n    422  \t\t\treturn MOSQ_ERR_INVAL;\n    423  \t}\n    424  \n    425  \treturn MOSQ_ERR_SUCCESS;\n    426  }\nFunction: db__expire_all_messages\nPath: /root/projects/mosquitto/src/database.c:1053\n    1053 void db__expire_all_messages(struct mosquitto *context)\n    1054 {\n    1055 \tstruct mosquitto_client_msg *msg, *tmp;\n    1056 \n    1057 \tDL_FOREACH_SAFE(context->msgs_out.inflight, msg, tmp){\n    1058 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1059 \t\t\tif(msg->qos > 0){\n    1060 \t\t\t\tutil__increment_send_quota(context);\n    1061 \t\t\t}\n    1062 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1063 \t\t}\n    1064 \t}\n    1065 \tDL_FOREACH_SAFE(context->msgs_out.queued, msg, tmp){\n    1066 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1067 \t\t\tdb__message_remove_from_queued(&context->msgs_out, msg);\n    1068 \t\t}\n    1069 \t}\n    1070 \tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n    1071 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1072 \t\t\tif(msg->qos > 0){\n    1073 \t\t\t\tutil__increment_receive_quota(context);\n    1074 \t\t\t}\n    1075 \t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n    1076 \t\t}\n    1077 \t}\n    1078 \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n    1079 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1080 \t\t\tdb__message_remove_from_queued(&context->msgs_in, msg);\n    1081 \t\t}\n    1082 \t}\n    1083 }\nFunction: db__message_remove_from_queued\nPath: /root/projects/mosquitto/src/database.c:364\n    364  static void db__message_remove_from_queued(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    365  {\n    366  \tif(!msg_data || !item){\n    367  \t\treturn;\n    368  \t}\n    369  \n    370  \tDL_DELETE(msg_data->queued, item);\n    371  \tif(item->store){\n    372  \t\tdb__msg_store_ref_dec(&item->store);\n    373  \t}\n    374  \n    375  \tmosquitto_property_free_all(&item->properties);\n    376  \tmosquitto__free(item);\n    377  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1183 \tstruct mosquitto_client_msg *tail, *tmp;\n    1184 \tint rc;\n    1185 \n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1189 \n    1190 \tDL_FOREACH_SAFE(context->msgs_out.inflight, tail, tmp){\n    1191 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1192 \t\tif(rc) return rc;\n    1193 \t}\n    1194 \treturn MOSQ_ERR_SUCCESS;\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    115  \tint i;\n    116  \tint rc;\n    117  \tint in_quota, out_quota;\n    118  \tuint16_t in_maximum, out_maximum;\n    119  \n    120  \t/* Find if this client already has an entry. This must be done *after* any security checks. */\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    123  \t\t/* Found a matching client */\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    125  \t\t\t/* Client is reconnecting after a disconnect */\n    126  \t\t\t/* FIXME - does anything need to be done here? */\n    127  \t\t}else{\n    128  \t\t\t/* Client is already connected, disconnect old version. This is\n    129  \t\t\t * done in context__cleanup() below. */\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    134  \n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    139  \n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    142  \n    143  \t\t\t\tin_quota = context->msgs_in.inflight_quota;\n    144  \t\t\t\tout_quota = context->msgs_out.inflight_quota;\n    145  \t\t\t\tin_maximum = context->msgs_in.inflight_maximum;\n    146  \t\t\t\tout_maximum = context->msgs_out.inflight_maximum;\n    147  \n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    150  \n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    153  \n    154  \t\t\t\tcontext->msgs_in.inflight_quota = in_quota;\n    155  \t\t\t\tcontext->msgs_out.inflight_quota = out_quota;\n    156  \t\t\t\tcontext->msgs_in.inflight_maximum = in_maximum;\n    157  \t\t\t\tcontext->msgs_out.inflight_maximum = out_maximum;\n    158  \n    159  \t\t\t\tdb__message_reconnect_reset(context);\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    166  \n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    176  \n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    189  \n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    197  \n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    200  \n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    204  \n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    208  \n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    214  \n    215  \trc = acl__find_acls(context);\n    216  \tif(rc){\n    217  \t\tfree(auth_data_out);\n    218  \t\treturn rc;\n    219  \t}\n    220  \n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    239  \n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    245  \n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    248  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"No will message specified.\");\n    249  \t\t}\n    250  \t}\n    251  \n    252  \tcontext->ping_t = 0;\n    253  \tcontext->is_dropping = false;\n    254  \n    255  \tconnection_check_acl(context, &context->msgs_in.inflight);\n    256  \tconnection_check_acl(context, &context->msgs_in.queued);\n    257  \tconnection_check_acl(context, &context->msgs_out.inflight);\n    258  \tconnection_check_acl(context, &context->msgs_out.queued);\n    259  \n    260  \tcontext__add_to_by_id(context);\n    261  \n    262  #ifdef WITH_PERSISTENCE\n    263  \tif(!context->clean_start){\n    264  \t\tdb.persistence_changes++;\n    265  \t}\n    266  #endif\n    267  \tcontext->max_qos = context->listener->max_qos;\n    268  \n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    271  \n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    275  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    280  \t\t\trc = MOSQ_ERR_INVAL;\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    284  \n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    288  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    294  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    300  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    303  \n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    306  \t\t\t\t\trc = MOSQ_ERR_NOMEM;\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    312  \tfree(auth_data_out);\n    313  \tauth_data_out = NULL;\n    314  \n    315  \tkeepalive__add(context);\n    316  \n    317  \tmosquitto__set_state(context, mosq_cs_active);\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    319  \tmosquitto_property_free_all(&connack_props);\n    320  \tif(rc) return rc;\n    321  \tdb__expire_all_messages(context);\n    322  \trc = db__message_write_queued_out(context);\n    323  \tif(rc) return rc;\n    324  \trc = db__message_write_inflight_out_all(context);\n    325  \treturn rc;\n    326  error:\n    327  \tfree(auth_data_out);\n    328  \tmosquitto_property_free_all(&connack_props);\n    329  \treturn rc;\n    330  }\nFunction: connection_check_acl\nPath: /root/projects/mosquitto/src/handle_connect.c:86\n    86   static void connection_check_acl(struct mosquitto *context, struct mosquitto_client_msg **head)\n    87   {\n    88   \tstruct mosquitto_client_msg *msg_tail, *tmp;\n    89   \tint access;\n    90   \n    91   \tDL_FOREACH_SAFE((*head), msg_tail, tmp){\n    92   \t\tif(msg_tail->direction == mosq_md_out){\n    93   \t\t\taccess = MOSQ_ACL_READ;\n    94   \t\t}else{\n    95   \t\t\taccess = MOSQ_ACL_WRITE;\n    96   \t\t}\n    97   \t\tif(mosquitto_acl_check(context, msg_tail->store->topic,\n    98   \t\t\t\t\t\t\t   msg_tail->store->payloadlen, msg_tail->store->payload,\n    99   \t\t\t\t\t\t\t   msg_tail->store->qos, msg_tail->store->retain, access) != MOSQ_ERR_SUCCESS){\n    100  \n    101  \t\t\tDL_DELETE((*head), msg_tail);\n    102  \t\t\tdb__msg_store_ref_dec(&msg_tail->store);\n    103  \t\t\tmosquitto_property_free_all(&msg_tail->properties);\n    104  \t\t\tmosquitto__free(msg_tail);\n    105  \t\t}\n    106  \t}\n    107  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    247  \n    248  \tmosquitto__set_state(context, mosq_cs_disused);\n    249  \n    250  \tif(context->id){\n    251  \t\tcontext__remove_from_by_id(context);\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    255  \n    256  \tcontext->for_free_next = db.ll_for_free;\n    257  \tdb.ll_for_free = context;\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    296  \t\tcontext->in_by_id = true;\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    269  \tint i;\n    270  \n    271  \tmosquitto__free(store->source_id);\n    272  \tmosquitto__free(store->source_username);\n    273  \tif(store->dest_ids){\n    274  \t\tfor(i=0; i<store->dest_id_count; i++){\n    275  \t\t\tmosquitto__free(store->dest_ids[i]);\n    276  \t\t}\n    277  \t\tmosquitto__free(store->dest_ids);\n    278  \t}\n    279  \tmosquitto__free(store->topic);\n    280  \tmosquitto_property_free_all(&store->properties);\n    281  \tmosquitto__free(store->payload);\n    282  \tmosquitto__free(store);\n    283  }\nFunction: db__message_remove_from_inflight\nPath: /root/projects/mosquitto/src/database.c:347\n    347  static void db__message_remove_from_inflight(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    348  {\n    349  \tif(!msg_data || !item){\n    350  \t\treturn;\n    351  \t}\n    352  \n    353  \tDL_DELETE(msg_data->inflight, item);\n    354  \tif(item->store){\n    355  \t\tdb__msg_remove_from_inflight_stats(msg_data, item);\n    356  \t\tdb__msg_store_ref_dec(&item->store);\n    357  \t}\n    358  \n    359  \tmosquitto_property_free_all(&item->properties);\n    360  \tmosquitto__free(item);\n    361  }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1088 \tmosquitto_property *cmsg_props = NULL, *store_props = NULL;\n    1089 \tint rc;\n    1090 \tuint16_t mid;\n    1091 \tint retries;\n    1092 \tint retain;\n    1093 \tconst char *topic;\n    1094 \tuint8_t qos;\n    1095 \tuint32_t payloadlen;\n    1096 \tconst void *payload;\n    1097 \tuint32_t expiry_interval;\n    1098 \n    1099 \texpiry_interval = 0;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1102 \t\t\t/* Message is expired, must not send. */\n    1103 \t\t\tif(msg->direction == mosq_md_out && msg->qos > 0){\n    1104 \t\t\t\tutil__increment_send_quota(context);\n    1105 \t\t\t}\n    1106 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1121 \n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1126 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1131 \n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1135 \t\t\t\tmsg->timestamp = db.now_s;\n    1136 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1137 \t\t\t\tmsg->state = mosq_ms_wait_for_puback;\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1139 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1144 \n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1148 \t\t\t\tmsg->timestamp = db.now_s;\n    1149 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1150 \t\t\t\tmsg->state = mosq_ms_wait_for_pubrec;\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1152 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1157 \n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1159 \t\t\trc = send__pubrel(context, mid, NULL);\n    1160 \t\t\tif(!rc){\n    1161 \t\t\t\tmsg->state = mosq_ms_wait_for_pubcomp;\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1166 \n    1167 \t\tcase mosq_ms_invalid:\n    1168 \t\tcase mosq_ms_send_pubrec:\n    1169 \t\tcase mosq_ms_resend_pubcomp:\n    1170 \t\tcase mosq_ms_wait_for_puback:\n    1171 \t\tcase mosq_ms_wait_for_pubrec:\n    1172 \t\tcase mosq_ms_wait_for_pubrel:\n    1173 \t\tcase mosq_ms_wait_for_pubcomp:\n    1174 \t\tcase mosq_ms_queued:\n    1175 \t\t\tbreak;\n    1176 \t}\n    1177 \treturn MOSQ_ERR_SUCCESS;\n    1178 }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    448  \tstruct mosquitto_client_msg *msg;\n    449  \tstruct mosquitto_msg_data *msg_data;\n    450  \tenum mosquitto_msg_state state = mosq_ms_invalid;\n    451  \tint rc = 0;\n    452  \tint i;\n    453  \tchar **dest_ids;\n    454  \n    455  \tassert(stored);\n    456  \tif(!context) return MOSQ_ERR_INVAL;\n    457  \tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n    458  \n    459  \tif(dir == mosq_md_out){\n    460  \t\tmsg_data = &context->msgs_out;\n    461  \t}else{\n    462  \t\tmsg_data = &context->msgs_in;\n    463  \t}\n    464  \n    465  \t/* Check whether we've already sent this message to this client\n    466  \t * for outgoing messages only.\n    467  \t * If retain==true then this is a stale retained message and so should be\n    468  \t * sent regardless. FIXME - this does mean retained messages will received\n    469  \t * multiple times for overlapping subscriptions, although this is only the\n    470  \t * case for SUBSCRIPTION with multiple subs in so is a minor concern.\n    471  \t */\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    475  \n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    478  \t\t\t\t/* We have already sent this message to this client. */\n    479  \t\t\t\tmosquitto_property_free_all(&properties);\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    484  \tif(context->sock == INVALID_SOCKET){\n    485  \t\t/* Client is not connected only queue messages with QoS>0. */\n    486  \t\tif(qos == 0 && !db.config->queue_qos0_messages){\n    487  \t\t\tif(!context->bridge){\n    488  \t\t\t\tmosquitto_property_free_all(&properties);\n    489  \t\t\t\treturn 2;\n    490  \t\t\t}else{\n    491  \t\t\t\tif(context->bridge->start_type != bst_lazy){\n    492  \t\t\t\t\tmosquitto_property_free_all(&properties);\n    493  \t\t\t\t\treturn 2;\n    494  \t\t\t\t}\n    495  \t\t\t}\n    496  \t\t}\n    497  \t\tif(context->bridge && context->bridge->clean_start_local == true){\n    498  \t\t\tmosquitto_property_free_all(&properties);\n    499  \t\t\treturn 2;\n    500  \t\t}\n    501  \t}\n    502  \n    503  \tif(context->sock != INVALID_SOCKET){\n    504  \t\tif(db__ready_for_flight(context, dir, qos)){\n    505  \t\t\tif(dir == mosq_md_out){\n    506  \t\t\t\tswitch(qos){\n    507  \t\t\t\t\tcase 0:\n    508  \t\t\t\t\t\tstate = mosq_ms_publish_qos0;\n    509  \t\t\t\t\t\tbreak;\n    510  \t\t\t\t\tcase 1:\n    511  \t\t\t\t\t\tstate = mosq_ms_publish_qos1;\n    512  \t\t\t\t\t\tbreak;\n    513  \t\t\t\t\tcase 2:\n    514  \t\t\t\t\t\tstate = mosq_ms_publish_qos2;\n    515  \t\t\t\t\t\tbreak;\n    516  \t\t\t\t}\n    517  \t\t\t}else{\n    518  \t\t\t\tif(qos == 2){\n    519  \t\t\t\t\tstate = mosq_ms_wait_for_pubrel;\n    520  \t\t\t\t}else{\n    521  \t\t\t\t\tmosquitto_property_free_all(&properties);\n    522  \t\t\t\t\treturn 1;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n    526  \t\t\tstate = mosq_ms_queued;\n    527  \t\t\trc = 2;\n    528  \t\t}else{\n    529  \t\t\t/* Dropping message due to full queue. */\n    530  \t\t\tif(context->is_dropping == false){\n    531  \t\t\t\tcontext->is_dropping = true;\n    532  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    533  \t\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n    534  \t\t\t\t\t\tcontext->id);\n    535  \t\t\t}\n    536  \t\t\tG_MSGS_DROPPED_INC();\n    537  \t\t\tmosquitto_property_free_all(&properties);\n    538  \t\t\treturn 2;\n    539  \t\t}\n    540  \t}else{\n    541  \t\tif (db__ready_for_queue(context, qos, msg_data)){\n    542  \t\t\tstate = mosq_ms_queued;\n    543  \t\t}else{\n    544  \t\t\tG_MSGS_DROPPED_INC();\n    545  \t\t\tif(context->is_dropping == false){\n    546  \t\t\t\tcontext->is_dropping = true;\n    547  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    548  \t\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n    549  \t\t\t\t\t\tcontext->id);\n    550  \t\t\t}\n    551  \t\t\tmosquitto_property_free_all(&properties);\n    552  \t\t\treturn 2;\n    553  \t\t}\n    554  \t}\n    555  \tassert(state != mosq_ms_invalid);\n    556  \n    557  #ifdef WITH_PERSISTENCE\n    558  \tif(state == mosq_ms_queued){\n    559  \t\tdb.persistence_changes++;\n    560  \t}\n    561  #endif\n    562  \n    563  \tmsg = mosquitto__calloc(1, sizeof(struct mosquitto_client_msg));\n    564  \tif(!msg) return MOSQ_ERR_NOMEM;\n    565  \tmsg->prev = NULL;\n    566  \tmsg->next = NULL;\n    567  \tmsg->store = stored;\n    568  \tdb__msg_store_ref_inc(msg->store);\n    569  \tmsg->mid = mid;\n    570  \tmsg->timestamp = db.now_s;\n    571  \tmsg->direction = dir;\n    572  \tmsg->state = state;\n    573  \tmsg->dup = false;\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    577  \t\tmsg->qos = qos;\n    578  \t}\n    579  \tmsg->retain = retain;\n    580  \tmsg->properties = properties;\n    581  \n    582  \tif(state == mosq_ms_queued){\n    583  \t\tDL_APPEND(msg_data->queued, msg);\n    584  \t\tdb__msg_add_to_queued_stats(msg_data, msg);\n    585  \t}else{\n    586  \t\tDL_APPEND(msg_data->inflight, msg);\n    587  \t\tdb__msg_add_to_inflight_stats(msg_data, msg);\n    588  \t}\n    589  \n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    591  \t\t/* Record which client ids this message has been sent to so we can avoid duplicates.\n    592  \t\t * Outgoing messages only.\n    593  \t\t * If retain==true then this is a stale retained message and so should be\n    594  \t\t * sent regardless. FIXME - this does mean retained messages will received\n    595  \t\t * multiple times for overlapping subscriptions, although this is only the\n    596  \t\t * case for SUBSCRIPTION with multiple subs in so is a minor concern.\n    597  \t\t */\n    598  \t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n    599  \t\tif(dest_ids){\n    600  \t\t\tstored->dest_ids = dest_ids;\n    601  \t\t\tstored->dest_id_count++;\n    602  \t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t}\n    609  \t}\n    610  #ifdef WITH_BRIDGE\n    611  \tif(context->bridge && context->bridge->start_type == bst_lazy\n    612  \t\t\t&& context->sock == INVALID_SOCKET\n    613  \t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n    614  \n    615  \t\tcontext->bridge->lazy_reconnect = true;\n    616  \t}\n    617  #endif\n    618  \n    619  \tif(dir == mosq_md_out && msg->qos > 0 && state != mosq_ms_queued){\n    620  \t\tutil__decrement_send_quota(context);\n    621  \t}else if(dir == mosq_md_in && msg->qos > 0 && state != mosq_ms_queued){\n    622  \t\tutil__decrement_receive_quota(context);\n    623  \t}\n    624  \n    625  \tif(dir == mosq_md_out && update){\n    626  \t\trc = db__message_write_inflight_out_latest(context);\n    627  \t\tif(rc) return rc;\n    628  \t\trc = db__message_write_queued_out(context);\n    629  \t\tif(rc) return rc;\n    630  \t}\n    631  \n    632  \treturn rc;\n    633  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    704  \tstruct mosquitto_msg_store *stored;\n    705  \tconst char *source_id;\n    706  \tenum mosquitto_msg_origin origin;\n    707  \n    708  \tif(!topic) return MOSQ_ERR_INVAL;\n    709  \n    710  \tstored = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    711  \tif(stored == NULL) return MOSQ_ERR_NOMEM;\n    712  \n    713  \tstored->topic = mosquitto__strdup(topic);\n    714  \tif(stored->topic == NULL){\n    715  \t\tdb__msg_store_free(stored);\n    716  \t\treturn MOSQ_ERR_INVAL;\n    717  \t}\n    718  \n    719  \tstored->qos = qos;\n    720  \tif(db.config->retain_available == false){\n    721  \t\tstored->retain = 0;\n    722  \t}else{\n    723  \t\tstored->retain = retain;\n    724  \t}\n    725  \n    726  \tstored->payloadlen = payloadlen;\n    727  \tif(payloadlen > 0){\n    728  \t\tstored->payload = mosquitto__malloc(stored->payloadlen+1);\n    729  \t\tif(stored->payload == NULL){\n    730  \t\t\tdb__msg_store_free(stored);\n    731  \t\t\treturn MOSQ_ERR_NOMEM;\n    732  \t\t}\n    733  \t\t/* Ensure payload is always zero terminated, this is the reason for the extra byte above */\n    734  \t\t((uint8_t *)stored->payload)[stored->payloadlen] = 0;\n    735  \t\tmemcpy(stored->payload, payload, stored->payloadlen);\n    736  \t}\n    737  \n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    741  \t\tsource_id = \"\";\n    742  \t}\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    745  \t\t*properties = NULL;\n    746  \t}\n    747  \n    748  \tif(context){\n    749  \t\torigin = mosq_mo_client;\n    750  \t}else{\n    751  \t\torigin = mosq_mo_broker;\n    752  \t}\n    753  \tif(db__message_store(context, stored, message_expiry_interval, 0, origin)) return 1;\n    754  \n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    761  \tassert(stored);\n    762  \n    763  \tif(source && source->id){\n    764  \t\tstored->source_id = mosquitto__strdup(source->id);\n    765  \t}else{\n    766  \t\tstored->source_id = mosquitto__strdup(\"\");\n    767  \t}\n    768  \tif(!stored->source_id){\n    769  \t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n    770  \t\tdb__msg_store_free(stored);\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    773  \n    774  \tif(source && source->username){\n    775  \t\tstored->source_username = mosquitto__strdup(source->username);\n    776  \t\tif(!stored->source_username){\n    777  \t\t\tdb__msg_store_free(stored);\n    778  \t\t\treturn MOSQ_ERR_NOMEM;\n    779  \t\t}\n    780  \t}\n    781  \tif(source){\n    782  \t\tstored->source_listener = source->listener;\n    783  \t}\n    784  \tstored->mid = 0;\n    785  \tstored->origin = origin;\n    786  \tif(message_expiry_interval > 0){\n    787  \t\tstored->message_expiry_time = db.now_real_s + message_expiry_interval;\n    788  \t}else{\n    789  \t\tstored->message_expiry_time = 0;\n    790  \t}\n    791  \n    792  \tstored->dest_ids = NULL;\n    793  \tstored->dest_id_count = 0;\n    794  \tdb.msg_store_count++;\n    795  \tdb.msg_store_bytes += stored->payloadlen;\n    796  \n    797  \tif(!store_id){\n    798  \t\tstored->db_id = ++db.last_db_id;\n    799  \t}else{\n    800  \t\tstored->db_id = store_id;\n    801  \t}\n    802  \n    803  \tdb__msg_store_add(stored);\n    804  \n    805  \treturn MOSQ_ERR_SUCCESS;\n    806  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    435  \tuint8_t will, will_retain, will_qos, clean_start;\n    436  \tuint8_t username_flag, password_flag;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    445  \tbool allow_zero_length_clientid;\n    446  #ifdef WITH_TLS\n    447  \tint i;\n    448  \tX509 *client_cert = NULL;\n    449  \tX509_NAME *name;\n    450  \tX509_NAME_ENTRY *name_entry;\n    451  \tASN1_STRING *name_asn1 = NULL;\n    452  \tBIO *subject_bio;\n    453  \tchar *data_start;\n    454  \tlong name_length;\n    455  \tchar *subject;\n    456  #endif\n    457  \n    458  \tG_CONNECTION_COUNT_INC();\n    459  \n    460  \tif(!context->listener){\n    461  \t\treturn MOSQ_ERR_INVAL;\n    462  \t}\n    463  \n    464  \t/* Don't accept multiple CONNECT commands. */\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    467  \t\trc = MOSQ_ERR_PROTOCOL;\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    470  \n    471  \t/* Read protocol name as length then bytes rather than with read_string\n    472  \t * because the length is fixed and we can check that. Removes the need\n    473  \t * for another malloc as well. */\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    475  \t\trc = MOSQ_ERR_PROTOCOL;\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    479  \t\trc = MOSQ_ERR_PROTOCOL;\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    483  \t\trc = MOSQ_ERR_PROTOCOL;\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    487  \n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    489  \t\trc = MOSQ_ERR_PROTOCOL;\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    499  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    502  \t\tcontext->protocol = mosq_p_mqtt31;\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    504  \t\t\tcontext->is_bridge = true;\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    508  \t\t\tcontext->protocol = mosq_p_mqtt311;\n    509  \n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    511  \t\t\t\tcontext->is_bridge = true;\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    514  \t\t\tcontext->protocol = mosq_p_mqtt5;\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    521  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    525  \t\t\t/* Reserved flags not set to 0, must disconnect. */\n    526  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    534  \t\trc = MOSQ_ERR_PROTOCOL;\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    540  \n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    542  \t\trc = MOSQ_ERR_PROTOCOL;\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    547  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    551  \n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    553  \t/* session_expiry_interval will be overriden if the properties are read later */\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    555  \t\t/* v3* has clean_start == false mean the session never expires */\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    563  \t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid Will QoS in CONNECT from %s.\",\n    564  \t\t\t\tcontext->address);\n    565  \t\trc = MOSQ_ERR_PROTOCOL;\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    571  \n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    576  \t\trc = MOSQ_ERR_NOT_SUPPORTED;\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    579  \n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    581  \t\trc = MOSQ_ERR_PROTOCOL;\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    584  \n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    590  \n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    595  \t\trc = MOSQ_ERR_NOT_SUPPORTED;\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    598  \n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    602  \n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    604  \n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    606  \t\trc = MOSQ_ERR_PROTOCOL;\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    609  \n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    613  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    618  \n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    630  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    639  \t\t\t\t\trc = MOSQ_ERR_NOMEM;\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    646  \n    647  \t/* clientid_prefixes check */\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    655  \t\t\trc = MOSQ_ERR_AUTH;\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    659  \n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    666  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    671  \n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    675  \t\t\trc = MOSQ_ERR_NOMEM;\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    679  \t\t\t\t/* Username flag given, but no username. Ignore. */\n    680  \t\t\t\tusername_flag = 0;\n    681  \t\t\t}else{\n    682  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    689  \t\t\t\t/* username_flag == 0 && password_flag == 1 is forbidden */\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    691  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    699  \t\t\trc = MOSQ_ERR_NOMEM;\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    703  \t\t\t\t/* Password flag given, but no password. Ignore. */\n    704  \t\t\t}else{\n    705  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    710  \n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    712  \t\t/* Surplus data at end of packet, this must be an error. */\n    713  \t\trc = MOSQ_ERR_PROTOCOL;\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    716  \n    717  \t/* Once context->id is set, if we return from this function with an error\n    718  \t * we must make sure that context->id is freed and set to NULL, so that the\n    719  \t * client isn't erroneously removed from the by_id hash table. */\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    722  \n    723  #ifdef WITH_TLS\n    724  \tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    725  \t\t/* Don't need the username or password if provided */\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    730  \n    731  \t\tif(!context->ssl){\n    732  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    734  \t\t\t}else{\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    736  \t\t\t}\n    737  \t\t\trc = MOSQ_ERR_AUTH;\n    738  \t\t\tgoto handle_connect_error;\n    739  \t\t}\n    740  #ifdef FINAL_WITH_TLS_PSK\n    741  \t\tif(context->listener->psk_hint){\n    742  \t\t\t/* Client should have provided an identity to get this far. */\n    743  \t\t\tif(!context->username){\n    744  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    746  \t\t\t\t}else{\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    748  \t\t\t\t}\n    749  \t\t\t\trc = MOSQ_ERR_AUTH;\n    750  \t\t\t\tgoto handle_connect_error;\n    751  \t\t\t}\n    752  \t\t}else{\n    753  #endif /* FINAL_WITH_TLS_PSK */\n    754  \t\t\tclient_cert = SSL_get_peer_certificate(context->ssl);\n    755  \t\t\tif(!client_cert){\n    756  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    758  \t\t\t\t}else{\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    760  \t\t\t\t}\n    761  \t\t\t\trc = MOSQ_ERR_AUTH;\n    762  \t\t\t\tgoto handle_connect_error;\n    763  \t\t\t}\n    764  \t\t\tname = X509_get_subject_name(client_cert);\n    765  \t\t\tif(!name){\n    766  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    768  \t\t\t\t}else{\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    770  \t\t\t\t}\n    771  \t\t\t\trc = MOSQ_ERR_AUTH;\n    772  \t\t\t\tgoto handle_connect_error;\n    773  \t\t\t}\n    774  \t\t\tif (context->listener->use_identity_as_username) { /* use_identity_as_username */\n    775  \t\t\t\ti = X509_NAME_get_index_by_NID(name, NID_commonName, -1);\n    776  \t\t\t\tif(i == -1){\n    777  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    779  \t\t\t\t\t}else{\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    781  \t\t\t\t\t}\n    782  \t\t\t\t\trc = MOSQ_ERR_AUTH;\n    783  \t\t\t\t\tgoto handle_connect_error;\n    784  \t\t\t\t}\n    785  \t\t\t\tname_entry = X509_NAME_get_entry(name, i);\n    786  \t\t\t\tif(name_entry){\n    787  \t\t\t\t\tname_asn1 = X509_NAME_ENTRY_get_data(name_entry);\n    788  \t\t\t\t\tif (name_asn1 == NULL) {\n    789  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    791  \t\t\t\t\t\t}else{\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    793  \t\t\t\t\t\t}\n    794  \t\t\t\t\t\trc = MOSQ_ERR_AUTH;\n    795  \t\t\t\t\t\tgoto handle_connect_error;\n    796  \t\t\t\t\t}\n    797  \t\t\t\t\tconst char *new_username;\n    798  #if OPENSSL_VERSION_NUMBER < 0x10100000L\n    799  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_data(name_asn1);\n    800  #else\n    801  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_get0_data(name_asn1);\n    802  #endif\n    803  \t\t\t\t\tif(mosquitto_validate_utf8(new_username, (int)strlen(new_username))){\n    804  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    806  \t\t\t\t\t\t}else{\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    808  \t\t\t\t\t\t}\n    809  \t\t\t\t\t\tX509_free(client_cert);\n    810  \t\t\t\t\t\treturn MOSQ_ERR_AUTH;\n    811  \t\t\t\t\t}\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    814  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    816  \t\t\t\t\t\t}else{\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    818  \t\t\t\t\t\t}\n    819  \t\t\t\t\t\trc = MOSQ_ERR_NOMEM;\n    820  \t\t\t\t\t\tgoto handle_connect_error;\n    821  \t\t\t\t\t}\n    822  \t\t\t\t\t/* Make sure there isn't an embedded NUL character in the CN */\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    824  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    826  \t\t\t\t\t\t}else{\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    828  \t\t\t\t\t\t}\n    829  \t\t\t\t\t\trc = MOSQ_ERR_AUTH;\n    830  \t\t\t\t\t\tgoto handle_connect_error;\n    831  \t\t\t\t\t}\n    832  \t\t\t\t}\n    833  \t\t\t} else { /* use_subject_as_username */\n    834  \t\t\t\tsubject_bio = BIO_new(BIO_s_mem());\n    835  \t\t\t\tX509_NAME_print_ex(subject_bio, X509_get_subject_name(client_cert), 0, XN_FLAG_RFC2253);\n    836  \t\t\t\tdata_start = NULL;\n    837  \t\t\t\tname_length = BIO_get_mem_data(subject_bio, &data_start);\n    838  \t\t\t\tsubject = mosquitto__malloc(sizeof(char)*(size_t)(name_length+1));\n    839  \t\t\t\tif(!subject){\n    840  \t\t\t\t\tBIO_free(subject_bio);\n    841  \t\t\t\t\trc = MOSQ_ERR_NOMEM;\n    842  \t\t\t\t\tgoto handle_connect_error;\n    843  \t\t\t\t}\n    844  \t\t\t\tmemcpy(subject, data_start, (size_t)name_length);\n    845  \t\t\t\tsubject[name_length] = '\\0';\n    846  \t\t\t\tBIO_free(subject_bio);\n    847  \t\t\t\tcontext->username = subject;\n    848  \t\t\t}\n    849  \t\t\tif(!context->username){\n    850  \t\t\t\trc = MOSQ_ERR_AUTH;\n    851  \t\t\t\tgoto handle_connect_error;\n    852  \t\t\t}\n    853  \t\t\tX509_free(client_cert);\n    854  \t\t\tclient_cert = NULL;\n    855  #ifdef FINAL_WITH_TLS_PSK\n    856  \t\t}\n    857  #endif /* FINAL_WITH_TLS_PSK */\n    858  \t}else\n    859  #endif /* WITH_TLS */\n    860  \t{\n    861  \t\t/* FIXME - these ensure the mosquitto_client_id() and\n    862  \t\t * mosquitto_client_username() functions work, but is hacky */\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    867  \t}\n    868  \n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    874  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    883  \t\t\trc = MOSQ_ERR_AUTH;\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    890  \n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    893  \t\tmosquitto__free(auth_data);\n    894  \t\tauth_data = NULL;\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    898  \t\t\tmosquitto__set_state(context, mosq_cs_authenticating);\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    900  \t\t\tfree(auth_data_out);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    903  \t\t\tfree(auth_data_out);\n    904  \t\t\tauth_data_out = NULL;\n    905  \t\t\twill__clear(context);\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    912  \t\t\t\t/* Client has requested extended authentication, but we don't support it. */\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    924  #ifdef WITH_TLS\n    925  \t\tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    926  \t\t\t/* Authentication assumed to be cleared */\n    927  \t\t}else\n    928  #endif\n    929  \t\t{\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    932  \t\t\t\tcase MOSQ_ERR_SUCCESS:\n    933  \t\t\t\t\tbreak;\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    940  \t\t\t\t\trc = MOSQ_ERR_AUTH;\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    944  \t\t\t\t\trc = MOSQ_ERR_UNKNOWN;\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    948  \t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    951  \n    952  \n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    955  \tmosquitto__free(auth_data);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    972  #ifdef WITH_TLS\n    973  \tif(client_cert) X509_free(client_cert);\n    974  #endif\n    975  \t/* We return an error here which means the client is freed later on. */\n    976  \tcontext->clean_start = true;\n    977  \tcontext->session_expiry_interval = 0;\n    978  \tcontext->will_delay_interval = 0;\n    979  \treturn rc;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    53   \tchar *client_id;\n    54   \tuint8_t rnd[16];\n    55   \tint i;\n    56   \tint pos;\n    57   \n    58   \tif(util__random_bytes(rnd, 16)) return NULL;\n    59   \n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    61   \n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    69   \n    70   \tpos = 0;\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    80   \n    81   \treturn client_id;\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    335  \tint rc = MOSQ_ERR_SUCCESS;\n    336  \tsize_t slen;\n    337  \tuint16_t tlen;\n    338  \tstruct mosquitto_message_all *will_struct = NULL;\n    339  \tchar *will_topic_mount = NULL;\n    340  \tuint16_t payloadlen;\n    341  \tmosquitto_property *properties = NULL;\n    342  \n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    344  \tif(!will_struct){\n    345  \t\trc = MOSQ_ERR_NOMEM;\n    346  \t\tgoto error_cleanup;\n    347  \t}\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    349  \t\trc = property__read_all(CMD_WILL, &context->in_packet, &properties);\n    350  \t\tif(rc) goto error_cleanup;\n    351  \n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    353  \t\tmosquitto_property_free_all(&properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    356  \trc = packet__read_string(&context->in_packet, &will_struct->msg.topic, &tlen);\n    357  \tif(rc) goto error_cleanup;\n    358  \tif(!tlen){\n    359  \t\trc = MOSQ_ERR_PROTOCOL;\n    360  \t\tgoto error_cleanup;\n    361  \t}\n    362  \n    363  \tif(context->listener->mount_point){\n    364  \t\tslen = strlen(context->listener->mount_point) + strlen(will_struct->msg.topic) + 1;\n    365  \t\twill_topic_mount = mosquitto__malloc(slen+1);\n    366  \t\tif(!will_topic_mount){\n    367  \t\t\trc = MOSQ_ERR_NOMEM;\n    368  \t\t\tgoto error_cleanup;\n    369  \t\t}\n    370  \n    371  \t\tsnprintf(will_topic_mount, slen, \"%s%s\", context->listener->mount_point, will_struct->msg.topic);\n    372  \t\twill_topic_mount[slen] = '\\0';\n    373  \n    374  \t\tmosquitto__free(will_struct->msg.topic);\n    375  \t\twill_struct->msg.topic = will_topic_mount;\n    376  \t}\n    377  \n    378  \tif(!strncmp(will_struct->msg.topic, \"$CONTROL/\", strlen(\"$CONTROL/\"))){\n    379  \t\trc = MOSQ_ERR_ACL_DENIED;\n    380  \t\tgoto error_cleanup;\n    381  \t}\n    382  \trc = mosquitto_pub_topic_check(will_struct->msg.topic);\n    383  \tif(rc) goto error_cleanup;\n    384  \n    385  \trc = packet__read_uint16(&context->in_packet, &payloadlen);\n    386  \tif(rc) goto error_cleanup;\n    387  \n    388  \twill_struct->msg.payloadlen = payloadlen;\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    391  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Client %s connected with too large Will payload\", client_id);\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    393  \t\t\t\tsend__connack(context, 0, MQTT_RC_PACKET_TOO_LARGE, NULL);\n    394  \t\t\t}else{\n    395  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    396  \t\t\t}\n    397  \t\t\trc = MOSQ_ERR_PAYLOAD_SIZE;\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    400  \t\twill_struct->msg.payload = mosquitto__malloc((size_t)will_struct->msg.payloadlen);\n    401  \t\tif(!will_struct->msg.payload){\n    402  \t\t\trc = MOSQ_ERR_NOMEM;\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    405  \n    406  \t\trc = packet__read_bytes(&context->in_packet, will_struct->msg.payload, (uint32_t)will_struct->msg.payloadlen);\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    409  \n    410  \twill_struct->msg.qos = will_qos;\n    411  \twill_struct->msg.retain = will_retain;\n    412  \n    413  \t*will = will_struct;\n    414  \treturn MOSQ_ERR_SUCCESS;\n    415  \n    416  error_cleanup:\n    417  \tif(will_struct){\n    418  \t\tmosquitto__free(will_struct->msg.topic);\n    419  \t\tmosquitto__free(will_struct->msg.payload);\n    420  \t\tmosquitto_property_free_all(&will_struct->properties);\n    421  \t\tmosquitto__free(will_struct);\n    422  \t}\n    423  \treturn rc;\n    424  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    51   \tassert(packet);\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    53   \n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    56   \n    57   \treturn MOSQ_ERR_SUCCESS;\n    58   }\nFunction: packet__write_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:61\n    61   void packet__write_byte(struct mosquitto__packet *packet, uint8_t byte)\n    62   {\n    63   \tassert(packet);\n    64   \tassert(packet->pos+1 <= packet->packet_length);\n    65   \n    66   \tpacket->payload[packet->pos] = byte;\n    67   \tpacket->pos++;\n    68   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    73   \tassert(packet);\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    75   \n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    78   \n    79   \treturn MOSQ_ERR_SUCCESS;\n    80   }\nFunction: packet__write_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:83\n    83   void packet__write_bytes(struct mosquitto__packet *packet, const void *bytes, uint32_t count)\n    84   {\n    85   \tassert(packet);\n    86   \tassert(packet->pos+count <= packet->packet_length);\n    87   \n    88   \tif(count > 0){\n    89   \t\tmemcpy(&(packet->payload[packet->pos]), bytes, count);\n    90   \t\tpacket->pos += count;\n    91   \t}\n    92   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    98   \tint rc;\n    99   \n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    103  \n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    106  \t\t*length = 0;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    109  \n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    111  \n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    120  \n    121  \t*length = slen;\n    122  \treturn MOSQ_ERR_SUCCESS;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    155  \tuint8_t msb, lsb;\n    156  \n    157  \tassert(packet);\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    159  \n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    164  \n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    166  \n    167  \treturn MOSQ_ERR_SUCCESS;\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    128  \tint rc;\n    129  \n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    133  \n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    140  \n    141  \treturn MOSQ_ERR_SUCCESS;\n    142  }\nFunction: packet__write_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:145\n    145  void packet__write_string(struct mosquitto__packet *packet, const char *str, uint16_t length)\n    146  {\n    147  \tassert(packet);\n    148  \tpacket__write_uint16(packet, length);\n    149  \tpacket__write_bytes(packet, str, length);\n    150  }\nFunction: packet__write_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:171\n    171  void packet__write_uint16(struct mosquitto__packet *packet, uint16_t word)\n    172  {\n    173  \tpacket__write_byte(packet, MOSQ_MSB(word));\n    174  \tpacket__write_byte(packet, MOSQ_LSB(word));\n    175  }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    280  #ifdef WITH_WEBSOCKETS\n    281  \tbool is_duplicate = false;\n    282  #endif\n    283  \n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    287  #ifdef WITH_WEBSOCKETS\n    288  \tif(context->wsi){\n    289  \t\tif(context->state == mosq_cs_duplicate){\n    290  \t\t\tis_duplicate = true;\n    291  \t\t}\n    292  \n    293  \t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    294  \t\t\tmosquitto__set_state(context, mosq_cs_disconnect_ws);\n    295  \t\t}\n    296  \t\tif(context->wsi){\n    297  \t\t\tlws_callback_on_writable(context->wsi);\n    298  \t\t}\n    299  \t\tif(context->sock != INVALID_SOCKET){\n    300  \t\t\tHASH_DELETE(hh_sock, db.contexts_by_sock, context);\n    301  \t\t\tmux__delete(context);\n    302  \t\t\tcontext->sock = INVALID_SOCKET;\n    303  \t\t}\n    304  \t\tif(is_duplicate){\n    305  \t\t\t/* This occurs if another client is taking over the same client id.\n    306  \t\t\t * It is important to remove this from the by_id hash here, so it\n    307  \t\t\t * doesn't leave us with multiple clients in the hash with the same\n    308  \t\t\t * id. Websockets doesn't actually close the connection here,\n    309  \t\t\t * unlike for normal clients, which means there is extra time when\n    310  \t\t\t * there could be two clients with the same id in the hash. */\n    311  \t\t\tcontext__remove_from_by_id(context);\n    312  \t\t}\n    313  \t}else\n    314  #endif\n    315  \t{\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    320  \t\t\t\tid = \"<unknown>\";\n    321  \t\t\t}\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    324  \t\t\t\t\tcase MOSQ_ERR_SUCCESS:\n    325  \t\t\t\t\t\tbreak;\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    371  \t\tmux__delete(context);\n    372  \t\tcontext__disconnect(context);\n    373  \t}\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    52   \tvoid *mem;\n    53   #ifdef REAL_WITH_MEMORY_TRACKING\n    54   \tif(mem_limit && memcount + size > mem_limit){\n    55   \t\treturn NULL;\n    56   \t}\n    57   #endif\n    58   \tmem = calloc(nmemb, size);\n    59   \n    60   #ifdef REAL_WITH_MEMORY_TRACKING\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    63   \t\tif(memcount > max_memcount){\n    64   \t\t\tmax_memcount = memcount;\n    65   \t\t}\n    66   \t}\n    67   #endif\n    68   \n    69   \treturn mem;\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    74   #ifdef REAL_WITH_MEMORY_TRACKING\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    79   #endif\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto__malloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:83\n    83   void *mosquitto__malloc(size_t size)\n    84   {\n    85   \tvoid *mem;\n    86   \n    87   #ifdef REAL_WITH_MEMORY_TRACKING\n    88   \tif(mem_limit && memcount + size > mem_limit){\n    89   \t\treturn NULL;\n    90   \t}\n    91   #endif\n    92   \n    93   \tmem = malloc(size);\n    94   \n    95   #ifdef REAL_WITH_MEMORY_TRACKING\n    96   \tif(mem){\n    97   \t\tmemcount += malloc_usable_size(mem);\n    98   \t\tif(memcount > max_memcount){\n    99   \t\t\tmax_memcount = memcount;\n    100  \t\t}\n    101  \t}\n    102  #endif\n    103  \n    104  \treturn mem;\n    105  }\nFunction: mosquitto__realloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:119\n    119  void *mosquitto__realloc(void *ptr, size_t size)\n    120  {\n    121  \tvoid *mem;\n    122  #ifdef REAL_WITH_MEMORY_TRACKING\n    123  \tif(mem_limit && memcount + size > mem_limit){\n    124  \t\treturn NULL;\n    125  \t}\n    126  \tif(ptr){\n    127  \t\tmemcount -= malloc_usable_size(ptr);\n    128  \t}\n    129  #endif\n    130  \tmem = realloc(ptr, size);\n    131  \n    132  #ifdef REAL_WITH_MEMORY_TRACKING\n    133  \tif(mem){\n    134  \t\tmemcount += malloc_usable_size(mem);\n    135  \t\tif(memcount > max_memcount){\n    136  \t\t\tmax_memcount = memcount;\n    137  \t\t}\n    138  \t}\n    139  #endif\n    140  \n    141  \treturn mem;\n    142  }\nFunction: mosquitto__strdup\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:144\n    144  char *mosquitto__strdup(const char *s)\n    145  {\n    146  \tchar *str;\n    147  #ifdef REAL_WITH_MEMORY_TRACKING\n    148  \tif(mem_limit && memcount + strlen(s) > mem_limit){\n    149  \t\treturn NULL;\n    150  \t}\n    151  #endif\n    152  \tstr = strdup(s);\n    153  \n    154  #ifdef REAL_WITH_MEMORY_TRACKING\n    155  \tif(str){\n    156  \t\tmemcount += malloc_usable_size(str);\n    157  \t\tif(memcount > max_memcount){\n    158  \t\t\tmax_memcount = memcount;\n    159  \t\t}\n    160  \t}\n    161  #endif\n    162  \n    163  \treturn str;\n    164  }\nFunction: mosquitto_free\nPath: /root/projects/mosquitto/src/memory_public.c:27\n    27   void mosquitto_free(void *mem)\n    28   {\n    29   \tmosquitto__free(mem);\n    30   }\nFunction: mosquitto_malloc\nPath: /root/projects/mosquitto/src/memory_public.c:32\n    32   void *mosquitto_malloc(size_t size)\n    33   {\n    34   \treturn mosquitto__malloc(size);\n    35   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    30   \tstruct mosquitto__packet *packet = NULL;\n    31   \tint rc;\n    32   \tmosquitto_property *connack_props = NULL;\n    33   \tuint32_t remaining_length;\n    34   \n    35   \trc = mosquitto_property_copy_all(&connack_props, properties);\n    36   \tif(rc){\n    37   \t\treturn rc;\n    38   \t}\n    39   \n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    43   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->address, ack, reason_code);\n    44   \t}\n    45   \n    46   \tremaining_length = 2;\n    47   \n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    50   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_RETAIN_AVAILABLE, 0);\n    51   \t\t\tif(rc){\n    52   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    57   \t\t\trc = mosquitto_property_add_int32(&connack_props, MQTT_PROP_MAXIMUM_PACKET_SIZE, db.config->max_packet_size);\n    58   \t\t\tif(rc){\n    59   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    64   \t\t\trc = mosquitto_property_add_int16(&connack_props, MQTT_PROP_RECEIVE_MAXIMUM, db.config->max_inflight_messages);\n    65   \t\t\tif(rc){\n    66   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    71   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_MAXIMUM_QOS, context->listener->max_qos);\n    72   \t\t\tif(rc){\n    73   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    77   \n    78   \t\tremaining_length += property__get_remaining_length(connack_props);\n    79   \t}\n    80   \n    81   \tif(packet__check_oversize(context, remaining_length)){\n    82   \t\tmosquitto_property_free_all(&connack_props);\n    83   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    84   \t}\n    85   \n    86   \tpacket = mosquitto__calloc(1, sizeof(struct mosquitto__packet));\n    87   \tif(!packet){\n    88   \t\tmosquitto_property_free_all(&connack_props);\n    89   \t\treturn MOSQ_ERR_NOMEM;\n    90   \t}\n    91   \n    92   \tpacket->command = CMD_CONNACK;\n    93   \tpacket->remaining_length = remaining_length;\n    94   \n    95   \trc = packet__alloc(packet);\n    96   \tif(rc){\n    97   \t\tmosquitto_property_free_all(&connack_props);\n    98   \t\tmosquitto__free(packet);\n    99   \t\treturn rc;\n    100  \t}\n    101  \tpacket__write_byte(packet, ack);\n    102  \tpacket__write_byte(packet, reason_code);\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    104  \t\tproperty__write_all(packet, connack_props, true);\n    105  \t}\n    106  \tmosquitto_property_free_all(&connack_props);\n    107  \n    108  \treturn packet__queue(context, packet);\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    39   \tstruct mosquitto__packet *packet = NULL;\n    40   \tint rc;\n    41   \n    42   \tassert(mosq);\n    43   #ifdef WITH_BROKER\n    44   #  ifdef WITH_BRIDGE\n    45   \tif(mosq->bridge){\n    46   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Bridge %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    47   \t}else\n    48   #  else\n    49   \t{\n    50   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Sending DISCONNECT to %s (rc%d)\", SAFE_PRINT(mosq->id), reason_code);\n    51   \t}\n    52   #  endif\n    53   #else\n    54   \tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Client %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    55   #endif\n    56   \tassert(mosq);\n    57   \tpacket = mosquitto__calloc(1, sizeof(struct mosquitto__packet));\n    58   \tif(!packet) return MOSQ_ERR_NOMEM;\n    59   \n    60   \tpacket->command = CMD_DISCONNECT;\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    62   \t\tpacket->remaining_length = 1;\n    63   \t\tif(properties){\n    64   \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    65   \t\t}\n    66   \t}else{\n    67   \t\tpacket->remaining_length = 0;\n    68   \t}\n    69   \n    70   \trc = packet__alloc(packet);\n    71   \tif(rc){\n    72   \t\tmosquitto__free(packet);\n    73   \t\treturn rc;\n    74   \t}\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    76   \t\tpacket__write_byte(packet, reason_code);\n    77   \t\tif(properties){\n    78   \t\t\tproperty__write_all(packet, properties, true);\n    79   \t\t}\n    80   \t}\n    81   \n    82   \treturn packet__queue(mosq, packet);\n    83   }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    123  \tstruct mosquitto__packet *packet = NULL;\n    124  \tint rc;\n    125  \n    126  \tassert(mosq);\n    127  \tpacket = mosquitto__calloc(1, sizeof(struct mosquitto__packet));\n    128  \tif(!packet) return MOSQ_ERR_NOMEM;\n    129  \n    130  \tpacket->command = command;\n    131  \tif(dup){\n    132  \t\tpacket->command |= 8;\n    133  \t}\n    134  \tpacket->remaining_length = 2;\n    135  \n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    137  \t\tif(reason_code != 0 || properties){\n    138  \t\t\tpacket->remaining_length += 1;\n    139  \t\t}\n    140  \n    141  \t\tif(properties){\n    142  \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    143  \t\t}\n    144  \t}\n    145  \n    146  \trc = packet__alloc(packet);\n    147  \tif(rc){\n    148  \t\tmosquitto__free(packet);\n    149  \t\treturn rc;\n    150  \t}\n    151  \n    152  \tpacket__write_uint16(packet, mid);\n    153  \n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tif(reason_code != 0 || properties){\n    156  \t\t\tpacket__write_byte(packet, reason_code);\n    157  \t\t}\n    158  \t\tif(properties){\n    159  \t\t\tproperty__write_all(packet, properties, true);\n    160  \t\t}\n    161  \t}\n    162  \n    163  \treturn packet__queue(mosq, packet);\n    164  }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    110  {\n    111  #ifdef WITH_BROKER\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    113  #else\n    114  \tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Client %s sending PUBREL (m%d)\", SAFE_PRINT(mosq->id), mid);\n    115  #endif\n    116  \t/* We don't use Reason String or User Property yet. */\n    117  \treturn send__command_with_mid(mosq, CMD_PUBREL|2, mid, false, 0, properties);\n    118  }\nFunction: session_expiry__remove\nPath: /root/projects/mosquitto/src/session_expiry.c:121\n    121  void session_expiry__remove(struct mosquitto *context)\n    122  {\n    123  \tif(context->expiry_list_item){\n    124  \t\tDL_DELETE(expiry_list, context->expiry_list_item);\n    125  \t\tmosquitto__free(context->expiry_list_item);\n    126  \t\tcontext->expiry_list_item = NULL;\n    127  \t}\n    128  }\nFunction: mosquitto_acl_check\nPath: /root/projects/mosquitto/src/security.c:679\n    679  int mosquitto_acl_check(struct mosquitto *context, const char *topic, uint32_t payloadlen, void* payload, uint8_t qos, bool retain, int access)\n    680  {\n    681  \tint rc;\n    682  \tint i;\n    683  \tstruct mosquitto__security_options *opts;\n    684  \tstruct mosquitto_acl_msg msg;\n    685  \tstruct mosquitto__callback *cb_base;\n    686  \tstruct mosquitto_evt_acl_check event_data;\n    687  \n    688  \tif(!context->id){\n    689  \t\treturn MOSQ_ERR_ACL_DENIED;\n    690  \t}\n    691  \tif(context->bridge){\n    692  \t\treturn MOSQ_ERR_SUCCESS;\n    693  \t}\n    694  \n    695  \trc = acl__check_dollar(topic, access);\n    696  \tif(rc) return rc;\n    697  \n    698  \t/*\n    699  \t * If no plugins exist we should accept at this point so set rc to success.\n    700  \t */\n    701  \trc = MOSQ_ERR_SUCCESS;\n    702  \n    703  \tif(db.config->per_listener_settings){\n    704  \t\tif(context->listener){\n    705  \t\t\topts = &context->listener->security_options;\n    706  \t\t}else{\n    707  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    708  \t\t}\n    709  \t}else{\n    710  \t\topts = &db.config->security_options;\n    711  \t}\n    712  \n    713  \tmemset(&msg, 0, sizeof(msg));\n    714  \tmsg.topic = topic;\n    715  \tmsg.payloadlen = payloadlen;\n    716  \tmsg.payload = payload;\n    717  \tmsg.qos = qos;\n    718  \tmsg.retain = retain;\n    719  \n    720  \tDL_FOREACH(opts->plugin_callbacks.acl_check, cb_base){\n    721  \t\t/* FIXME - username deny special chars */\n    722  \n    723  \t\tmemset(&event_data, 0, sizeof(event_data));\n    724  \t\tevent_data.client = context;\n    725  \t\tevent_data.access = access;\n    726  \t\tevent_data.topic = topic;\n    727  \t\tevent_data.payloadlen = payloadlen;\n    728  \t\tevent_data.payload = payload;\n    729  \t\tevent_data.qos = qos;\n    730  \t\tevent_data.retain = retain;\n    731  \t\tevent_data.properties = NULL;\n    732  \t\trc = cb_base->cb(MOSQ_EVT_ACL_CHECK, &event_data, cb_base->userdata);\n    733  \t\tif(rc != MOSQ_ERR_PLUGIN_DEFER){\n    734  \t\t\treturn rc;\n    735  \t\t}\n    736  \t}\n    737  \n    738  \tfor(i=0; i<opts->auth_plugin_config_count; i++){\n    739  \t\tif(opts->auth_plugin_configs[i].plugin.version < 5){\n    740  \t\t\trc = acl__check_single(&opts->auth_plugin_configs[i], context, &msg, access);\n    741  \t\t\tif(rc != MOSQ_ERR_PLUGIN_DEFER){\n    742  \t\t\t\treturn rc;\n    743  \t\t\t}\n    744  \t\t}\n    745  \t}\n    746  \n    747  \t/* If all plugins deferred, this is a denial. If rc == MOSQ_ERR_SUCCESS\n    748  \t * here, then no plugins were configured. */\n    749  \tif(rc == MOSQ_ERR_PLUGIN_DEFER){\n    750  \t\trc = MOSQ_ERR_ACL_DENIED;\n    751  \t}\n    752  \treturn rc;\n    753  }\nFunction: acl__check_dollar\nPath: /root/projects/mosquitto/src/security.c:646\n    646  static int acl__check_dollar(const char *topic, int access)\n    647  {\n    648  \tint rc;\n    649  \tbool match = false;\n    650  \n    651  \tif(topic[0] != '$') return MOSQ_ERR_SUCCESS;\n    652  \n    653  \tif(!strncmp(topic, \"$SYS\", 4)){\n    654  \t\tif(access == MOSQ_ACL_WRITE){\n    655  \t\t\t/* Potentially allow write access for bridge status, otherwise explicitly deny. */\n    656  \t\t\trc = mosquitto_topic_matches_sub(\"$SYS/broker/connection/+/state\", topic, &match);\n    657  \t\t\tif(rc == MOSQ_ERR_SUCCESS && match == true){\n    658  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    659  \t\t\t}else{\n    660  \t\t\t\treturn MOSQ_ERR_ACL_DENIED;\n    661  \t\t\t}\n    662  \t\t}else{\n    663  \t\t\treturn MOSQ_ERR_SUCCESS;\n    664  \t\t}\n    665  \t}else if(!strncmp(topic, \"$share\", 6)){\n    666  \t\t/* Only allow sub/unsub to shared subscriptions */\n    667  \t\tif(access == MOSQ_ACL_SUBSCRIBE || access == MOSQ_ACL_UNSUBSCRIBE){\n    668  \t\t\treturn MOSQ_ERR_SUCCESS;\n    669  \t\t}else{\n    670  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    671  \t\t}\n    672  \t}else{\n    673  \t\t/* This is an unknown $ topic, for the moment just defer to actual tests. */\n    674  \t\treturn MOSQ_ERR_SUCCESS;\n    675  \t}\n    676  }\nFunction: acl__check_single\nPath: /root/projects/mosquitto/src/security.c:602\n    602  static int acl__check_single(struct mosquitto__auth_plugin_config *auth_plugin, struct mosquitto *context, struct mosquitto_acl_msg *msg, int access)\n    603  {\n    604  \tconst char *username;\n    605  \tconst char *topic = msg->topic;\n    606  \n    607  \tusername = mosquitto_client_username(context);\n    608  \tif(auth_plugin->deny_special_chars == true){\n    609  \t\t/* Check whether the client id or username contains a +, # or / and if\n    610  \t\t* so deny access.\n    611  \t\t*\n    612  \t\t* Do this check for every message regardless, we have to protect the\n    613  \t\t* plugins against possible pattern based attacks.\n    614  \t\t*/\n    615  \t\tif(username && strpbrk(username, \"+#\")){\n    616  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous username \\\"%s\\\"\", username);\n    617  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    618  \t\t}\n    619  \t\tif(context->id && strpbrk(context->id, \"+#\")){\n    620  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous client id \\\"%s\\\"\", context->id);\n    621  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    622  \t\t}\n    623  \t}\n    624  \n    625  \tif(auth_plugin->plugin.version == 4){\n    626  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    627  \t\t\treturn MOSQ_ERR_SUCCESS;\n    628  \t\t}\n    629  \t\treturn auth_plugin->plugin.acl_check_v4(auth_plugin->plugin.user_data, access, context, msg);\n    630  \t}else if(auth_plugin->plugin.version == 3){\n    631  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    632  \t\t\treturn MOSQ_ERR_SUCCESS;\n    633  \t\t}\n    634  \t\treturn auth_plugin->plugin.acl_check_v3(auth_plugin->plugin.user_data, access, context, msg);\n    635  \t}else if(auth_plugin->plugin.version == 2){\n    636  \t\tif(access == MOSQ_ACL_SUBSCRIBE || access == MOSQ_ACL_UNSUBSCRIBE){\n    637  \t\t\treturn MOSQ_ERR_SUCCESS;\n    638  \t\t}\n    639  \t\treturn auth_plugin->plugin.acl_check_v2(auth_plugin->plugin.user_data, context->id, username, topic, access);\n    640  \t}else{\n    641  \t\treturn MOSQ_ERR_INVAL;\n    642  \t}\n    643  }\nFunction: mosquitto_unpwd_check\nPath: /root/projects/mosquitto/src/security.c:755\n    755  int mosquitto_unpwd_check(struct mosquitto *context)\n    756  {\n    757  \tint rc;\n    758  \tint i;\n    759  \tstruct mosquitto__security_options *opts;\n    760  \tstruct mosquitto_evt_basic_auth event_data;\n    761  \tstruct mosquitto__callback *cb_base;\n    762  \tbool plugin_used = false;\n    763  \n    764  \trc = MOSQ_ERR_PLUGIN_DEFER;\n    765  \n    766  \tif(db.config->per_listener_settings){\n    767  \t\tif(context->listener == NULL){\n    768  \t\t\treturn MOSQ_ERR_AUTH;\n    769  \t\t}\n    770  \t\topts = &context->listener->security_options;\n    771  \t}else{\n    772  \t\topts = &db.config->security_options;\n    773  \t}\n    774  \n    775  \tDL_FOREACH(opts->plugin_callbacks.basic_auth, cb_base){\n    776  \t\tmemset(&event_data, 0, sizeof(event_data));\n    777  \t\tevent_data.client = context;\n    778  \t\tevent_data.username = context->username;\n    779  \t\tevent_data.password = context->password;\n    780  \t\trc = cb_base->cb(MOSQ_EVT_BASIC_AUTH, &event_data, cb_base->userdata);\n    781  \t\tif(rc != MOSQ_ERR_PLUGIN_DEFER){\n    782  \t\t\treturn rc;\n    783  \t\t}\n    784  \t\tplugin_used = true;\n    785  \t}\n    786  \n    787  \tfor(i=0; i<opts->auth_plugin_config_count; i++){\n    788  \t\tif(opts->auth_plugin_configs[i].plugin.version == 4\n    789  \t\t\t\t&& opts->auth_plugin_configs[i].plugin.unpwd_check_v4){\n    790  \n    791  \t\t\trc = opts->auth_plugin_configs[i].plugin.unpwd_check_v4(\n    792  \t\t\t\t\topts->auth_plugin_configs[i].plugin.user_data,\n    793  \t\t\t\t\tcontext,\n    794  \t\t\t\t\tcontext->username,\n    795  \t\t\t\t\tcontext->password);\n    796  \t\t\tplugin_used = true;\n    797  \n    798  \t\t}else if(opts->auth_plugin_configs[i].plugin.version == 3){\n    799  \t\t\trc = opts->auth_plugin_configs[i].plugin.unpwd_check_v3(\n    800  \t\t\t\t\topts->auth_plugin_configs[i].plugin.user_data,\n    801  \t\t\t\t\tcontext,\n    802  \t\t\t\t\tcontext->username,\n    803  \t\t\t\t\tcontext->password);\n    804  \t\t\tplugin_used = true;\n    805  \n    806  \t\t}else if(opts->auth_plugin_configs[i].plugin.version == 2){\n    807  \t\t\trc = opts->auth_plugin_configs[i].plugin.unpwd_check_v2(\n    808  \t\t\t\t\topts->auth_plugin_configs[i].plugin.user_data,\n    809  \t\t\t\t\tcontext->username,\n    810  \t\t\t\t\tcontext->password);\n    811  \t\t\tplugin_used = true;\n    812  \t\t}\n    813  \t}\n    814  \t/* If all plugins deferred, this is a denial. If rc == MOSQ_ERR_SUCCESS\n    815  \t * here, then no plugins were configured. Unless we have all deferred, and\n    816  \t * anonymous logins are allowed. */\n    817  \tif(plugin_used == false){\n    818  \t\tif((db.config->per_listener_settings && context->listener->security_options.allow_anonymous != false)\n    819  \t\t\t\t|| (!db.config->per_listener_settings && db.config->security_options.allow_anonymous != false)){\n    820  \n    821  \t\t\treturn MOSQ_ERR_SUCCESS;\n    822  \t\t}else{\n    823  \t\t\treturn MOSQ_ERR_AUTH;\n    824  \t\t}\n    825  \t}else{\n    826  \t\tif(rc == MOSQ_ERR_PLUGIN_DEFER){\n    827  \t\t\tif(context->username == NULL &&\n    828  \t\t\t\t\t((db.config->per_listener_settings && context->listener->security_options.allow_anonymous != false)\n    829  \t\t\t\t\t|| (!db.config->per_listener_settings && db.config->security_options.allow_anonymous != false))){\n    830  \n    831  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    832  \t\t\t}else{\n    833  \t\t\t\treturn MOSQ_ERR_AUTH;\n    834  \t\t\t}\n    835  \t\t}\n    836  \t}\n    837  \n    838  \treturn rc;\n    839  }\nFunction: mosquitto_security_auth_start\nPath: /root/projects/mosquitto/src/security.c:922\n    922  int mosquitto_security_auth_start(struct mosquitto *context, bool reauth, const void *data_in, uint16_t data_in_len, void **data_out, uint16_t *data_out_len)\n    923  {\n    924  \tint rc = MOSQ_ERR_PLUGIN_DEFER;\n    925  \tint i;\n    926  \tstruct mosquitto__security_options *opts;\n    927  \tstruct mosquitto_evt_extended_auth event_data;\n    928  \tstruct mosquitto__callback *cb_base;\n    929  \n    930  \tif(!context || !context->listener || !context->auth_method) return MOSQ_ERR_INVAL;\n    931  \tif(!data_out || !data_out_len) return MOSQ_ERR_INVAL;\n    932  \n    933  \tif(db.config->per_listener_settings){\n    934  \t\topts = &context->listener->security_options;\n    935  \t}else{\n    936  \t\topts = &db.config->security_options;\n    937  \t}\n    938  \n    939  \tDL_FOREACH(opts->plugin_callbacks.ext_auth_start, cb_base){\n    940  \t\tmemset(&event_data, 0, sizeof(event_data));\n    941  \t\tevent_data.client = context;\n    942  \t\tevent_data.auth_method = context->auth_method;\n    943  \t\tevent_data.data_in = data_in;\n    944  \t\tevent_data.data_out = NULL;\n    945  \t\tevent_data.data_in_len = data_in_len;\n    946  \t\tevent_data.data_out_len = 0;\n    947  \t\trc = cb_base->cb(MOSQ_EVT_EXT_AUTH_START, &event_data, cb_base->userdata);\n    948  \t\tif(rc != MOSQ_ERR_PLUGIN_DEFER){\n    949  \t\t\t*data_out = event_data.data_out;\n    950  \t\t\t*data_out_len = event_data.data_out_len;\n    951  \t\t\treturn rc;\n    952  \t\t}\n    953  \t}\n    954  \n    955  \tfor(i=0; i<opts->auth_plugin_config_count; i++){\n    956  \t\tif(opts->auth_plugin_configs[i].plugin.auth_start_v4){\n    957  \t\t\t*data_out = NULL;\n    958  \t\t\t*data_out_len = 0;\n    959  \n    960  \t\t\trc = opts->auth_plugin_configs[i].plugin.auth_start_v4(\n    961  \t\t\t\t\topts->auth_plugin_configs[i].plugin.user_data,\n    962  \t\t\t\t\tcontext,\n    963  \t\t\t\t\tcontext->auth_method,\n    964  \t\t\t\t\treauth,\n    965  \t\t\t\t\tdata_in, data_in_len,\n    966  \t\t\t\t\tdata_out, data_out_len);\n    967  \n    968  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    969  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    970  \t\t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    971  \t\t\t\treturn MOSQ_ERR_AUTH_CONTINUE;\n    972  \t\t\t}else if(rc != MOSQ_ERR_NOT_SUPPORTED){\n    973  \t\t\t\treturn rc;\n    974  \t\t\t}\n    975  \t\t}\n    976  \t}\n    977  \n    978  \treturn MOSQ_ERR_NOT_SUPPORTED;\n    979  }\nFunction: acl__find_acls\nPath: /root/projects/mosquitto/src/security_default.c:704\n    704  int acl__find_acls(struct mosquitto *context)\n    705  {\n    706  \tstruct mosquitto__acl_user *acl_tail;\n    707  \tstruct mosquitto__security_options *security_opts;\n    708  \n    709  \t/* Associate user with its ACL, assuming we have ACLs loaded. */\n    710  \tif(db.config->per_listener_settings){\n    711  \t\tif(!context->listener){\n    712  \t\t\treturn MOSQ_ERR_INVAL;\n    713  \t\t}\n    714  \t\tsecurity_opts = &context->listener->security_options;\n    715  \t}else{\n    716  \t\tsecurity_opts = &db.config->security_options;\n    717  \t}\n    718  \n    719  \tif(security_opts->acl_list){\n    720  \t\tacl_tail = security_opts->acl_list;\n    721  \t\twhile(acl_tail){\n    722  \t\t\tif(context->username){\n    723  \t\t\t\tif(acl_tail->username && !strcmp(context->username, acl_tail->username)){\n    724  \t\t\t\t\tcontext->acl_list = acl_tail;\n    725  \t\t\t\t\tbreak;\n    726  \t\t\t\t}\n    727  \t\t\t}else{\n    728  \t\t\t\tif(acl_tail->username == NULL){\n    729  \t\t\t\t\tcontext->acl_list = acl_tail;\n    730  \t\t\t\t\tbreak;\n    731  \t\t\t\t}\n    732  \t\t\t}\n    733  \t\t\tacl_tail = acl_tail->next;\n    734  \t\t}\n    735  \t}else{\n    736  \t\tcontext->acl_list = NULL;\n    737  \t}\n    738  \n    739  \treturn MOSQ_ERR_SUCCESS;\n    740  }\nFunction: sub__remove_shared_leaf\nPath: /root/projects/mosquitto/src/subs.c:190\n    190  static void sub__remove_shared_leaf(struct mosquitto__subhier *subhier, struct mosquitto__subshared *shared, struct mosquitto__subleaf *leaf)\n    191  {\n    192  \tDL_DELETE(shared->subs, leaf);\n    193  \tif(shared->subs == NULL){\n    194  \t\tHASH_DELETE(hh, subhier->shared, shared);\n    195  \t\tmosquitto__free(shared->name);\n    196  \t\tmosquitto__free(shared);\n    197  \t}\n    198  \tmosquitto__free(leaf);\n    199  }\nFunction: sub__messages_queue\nPath: /root/projects/mosquitto/src/subs.c:659\n    659  int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n    660  {\n    661  \tint rc = MOSQ_ERR_SUCCESS, rc2;\n    662  \tint rc_normal = MOSQ_ERR_NO_SUBSCRIBERS, rc_shared = MOSQ_ERR_NO_SUBSCRIBERS;\n    663  \tstruct mosquitto__subhier *subhier;\n    664  \tchar **split_topics = NULL;\n    665  \tchar *local_topic = NULL;\n    666  \n    667  \tassert(topic);\n    668  \n    669  \tif(sub__topic_tokenise(topic, &local_topic, &split_topics, NULL)) return 1;\n    670  \n    671  \t/* Protect this message until we have sent it to all\n    672  \tclients - this is required because websockets client calls\n    673  \tdb__message_write(), which could remove the message if ref_count==0.\n    674  \t*/\n    675  \tdb__msg_store_ref_inc(*stored);\n    676  \n    677  \tHASH_FIND(hh, db.normal_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    678  \tif(subhier){\n    679  \t\trc_normal = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    680  \t\tif(rc_normal > 0){\n    681  \t\t\trc = rc_normal;\n    682  \t\t\tgoto end;\n    683  \t\t}\n    684  \t}\n    685  \n    686  \tHASH_FIND(hh, db.shared_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    687  \tif(subhier){\n    688  \t\trc_shared = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    689  \t\tif(rc_shared > 0){\n    690  \t\t\trc = rc_shared;\n    691  \t\t\tgoto end;\n    692  \t\t}\n    693  \t}\n    694  \n    695  \tif(rc_normal == MOSQ_ERR_NO_SUBSCRIBERS && rc_shared == MOSQ_ERR_NO_SUBSCRIBERS){\n    696  \t\trc = MOSQ_ERR_NO_SUBSCRIBERS;\n    697  \t}\n    698  \n    699  \tif(retain){\n    700  \t\trc2 = retain__store(topic, *stored, split_topics);\n    701  \t\tif(rc2) rc = rc2;\n    702  \t}\n    703  \n    704  end:\n    705  \tmosquitto__free(split_topics);\n    706  \tmosquitto__free(local_topic);\n    707  \t/* Remove our reference and free if needed. */\n    708  \tdb__msg_store_ref_dec(stored);\n    709  \n    710  \treturn rc;\n    711  }\nFunction: sub__search\nPath: /root/projects/mosquitto/src/subs.c:479\n    479  static int sub__search(struct mosquitto__subhier *subhier, char **split_topics, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    480  {\n    481  \t/* FIXME - need to take into account source_id if the client is a bridge */\n    482  \tstruct mosquitto__subhier *branch;\n    483  \tint rc;\n    484  \tbool have_subscribers = false;\n    485  \n    486  \tif(split_topics && split_topics[0]){\n    487  \t\t/* Check for literal match */\n    488  \t\tHASH_FIND(hh, subhier->children, split_topics[0], strlen(split_topics[0]), branch);\n    489  \n    490  \t\tif(branch){\n    491  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    492  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    493  \t\t\t\thave_subscribers = true;\n    494  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    495  \t\t\t\treturn rc;\n    496  \t\t\t}\n    497  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    498  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    499  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    500  \t\t\t\t\thave_subscribers = true;\n    501  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    502  \t\t\t\t\treturn rc;\n    503  \t\t\t\t}\n    504  \t\t\t}\n    505  \t\t}\n    506  \n    507  \t\t/* Check for + match */\n    508  \t\tHASH_FIND(hh, subhier->children, \"+\", 1, branch);\n    509  \n    510  \t\tif(branch){\n    511  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    512  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    513  \t\t\t\thave_subscribers = true;\n    514  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    515  \t\t\t\treturn rc;\n    516  \t\t\t}\n    517  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    518  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    519  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    520  \t\t\t\t\thave_subscribers = true;\n    521  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    522  \t\t\t\t\treturn rc;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}\n    526  \t}\n    527  \n    528  \t/* Check for # match */\n    529  \tHASH_FIND(hh, subhier->children, \"#\", 1, branch);\n    530  \tif(branch && !branch->children){\n    531  \t\t/* The topic matches due to a # wildcard - process the\n    532  \t\t * subscriptions but *don't* return. Although this branch has ended\n    533  \t\t * there may still be other subscriptions to deal with.\n    534  \t\t */\n    535  \t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    536  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    537  \t\t\thave_subscribers = true;\n    538  \t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    539  \t\t\treturn rc;\n    540  \t\t}\n    541  \t}\n    542  \n    543  \tif(have_subscribers){\n    544  \t\treturn MOSQ_ERR_SUCCESS;\n    545  \t}else{\n    546  \t\treturn MOSQ_ERR_NO_SUBSCRIBERS;\n    547  \t}\n    548  }\nFunction: subs__process\nPath: /root/projects/mosquitto/src/subs.c:129\n    129  static int subs__process(struct mosquitto__subhier *hier, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    130  {\n    131  \tint rc = 0;\n    132  \tint rc2;\n    133  \tstruct mosquitto__subleaf *leaf;\n    134  \n    135  \trc = subs__shared_process(hier, topic, qos, retain, stored);\n    136  \n    137  \tleaf = hier->subs;\n    138  \twhile(source_id && leaf){\n    139  \t\tif(!leaf->context->id || (leaf->no_local && !strcmp(leaf->context->id, source_id))){\n    140  \t\t\tleaf = leaf->next;\n    141  \t\t\tcontinue;\n    142  \t\t}\n    143  \t\trc2 = subs__send(leaf, topic, qos, retain, stored);\n    144  \t\tif(rc2){\n    145  \t\t\trc = 1;\n    146  \t\t}\n    147  \t\tleaf = leaf->next;\n    148  \t}\n    149  \tif(hier->subs || hier->shared){\n    150  \t\treturn rc;\n    151  \t}else{\n    152  \t\treturn MOSQ_ERR_NO_SUBSCRIBERS;\n    153  \t}\n    154  }\nFunction: subs__send\nPath: /root/projects/mosquitto/src/subs.c:63\n    63   static int subs__send(struct mosquitto__subleaf *leaf, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    64   {\n    65   \tbool client_retain;\n    66   \tuint16_t mid;\n    67   \tuint8_t client_qos, msg_qos;\n    68   \tmosquitto_property *properties = NULL;\n    69   \tint rc2;\n    70   \n    71   \t/* Check for ACL topic access. */\n    72   \trc2 = mosquitto_acl_check(leaf->context, topic, stored->payloadlen, stored->payload, stored->qos, stored->retain, MOSQ_ACL_READ);\n    73   \tif(rc2 == MOSQ_ERR_ACL_DENIED){\n    74   \t\treturn MOSQ_ERR_SUCCESS;\n    75   \t}else if(rc2 == MOSQ_ERR_SUCCESS){\n    76   \t\tclient_qos = leaf->qos;\n    77   \n    78   \t\tif(db.config->upgrade_outgoing_qos){\n    79   \t\t\tmsg_qos = client_qos;\n    80   \t\t}else{\n    81   \t\t\tif(qos > client_qos){\n    82   \t\t\t\tmsg_qos = client_qos;\n    83   \t\t\t}else{\n    84   \t\t\t\tmsg_qos = qos;\n    85   \t\t\t}\n    86   \t\t}\n    87   \t\tif(msg_qos){\n    88   \t\t\tmid = mosquitto__mid_generate(leaf->context);\n    89   \t\t}else{\n    90   \t\t\tmid = 0;\n    91   \t\t}\n    92   \t\tif(leaf->retain_as_published){\n    93   \t\t\tclient_retain = retain;\n    94   \t\t}else{\n    95   \t\t\tclient_retain = false;\n    96   \t\t}\n    97   \t\tif(leaf->identifier){\n    98   \t\t\tmosquitto_property_add_varint(&properties, MQTT_PROP_SUBSCRIPTION_IDENTIFIER, leaf->identifier);\n    99   \t\t}\n    100  \t\tif(db__message_insert(leaf->context, mid, mosq_md_out, msg_qos, client_retain, stored, properties, true) == 1){\n    101  \t\t\treturn 1;\n    102  \t\t}\n    103  \t}else{\n    104  \t\treturn 1; /* Application error */\n    105  \t}\n    106  \treturn 0;\n    107  }\nFunction: sub__clean_session\nPath: /root/projects/mosquitto/src/subs.c:746\n    746  int sub__clean_session(struct mosquitto *context)\n    747  {\n    748  \tint i;\n    749  \tstruct mosquitto__subleaf *leaf;\n    750  \tstruct mosquitto__subhier *hier;\n    751  \n    752  \tfor(i=0; i<context->sub_count; i++){\n    753  \t\tif(context->subs[i] == NULL){\n    754  \t\t\tcontinue;\n    755  \t\t}\n    756  \n    757  \t\thier = context->subs[i]->hier;\n    758  \n    759  \t\tif(context->subs[i]->shared){\n    760  \t\t\tleaf = context->subs[i]->shared->subs;\n    761  \t\t\twhile(leaf){\n    762  \t\t\t\tif(leaf->context==context){\n    763  #ifdef WITH_SYS_TREE\n    764  \t\t\t\t\tdb.shared_subscription_count--;\n    765  #endif\n    766  \t\t\t\t\tsub__remove_shared_leaf(context->subs[i]->hier, context->subs[i]->shared, leaf);\n    767  \t\t\t\t\tbreak;\n    768  \t\t\t\t}\n    769  \t\t\t\tleaf = leaf->next;\n    770  \t\t\t}\n    771  \t\t}else{\n    772  \t\t\tleaf = hier->subs;\n    773  \t\t\twhile(leaf){\n    774  \t\t\t\tif(leaf->context==context){\n    775  #ifdef WITH_SYS_TREE\n    776  \t\t\t\t\tdb.subscription_count--;\n    777  #endif\n    778  \t\t\t\t\tDL_DELETE(hier->subs, leaf);\n    779  \t\t\t\t\tmosquitto__free(leaf);\n    780  \t\t\t\t\tbreak;\n    781  \t\t\t\t}\n    782  \t\t\t\tleaf = leaf->next;\n    783  \t\t\t}\n    784  \t\t}\n    785  \t\tmosquitto__free(context->subs[i]);\n    786  \t\tcontext->subs[i] = NULL;\n    787  \n    788  \t\tif(hier->subs == NULL\n    789  \t\t\t\t&& hier->children == NULL\n    790  \t\t\t\t&& hier->shared == NULL\n    791  \t\t\t\t&& hier->parent){\n    792  \n    793  \t\t\tdo{\n    794  \t\t\t\thier = tmp_remove_subs(hier);\n    795  \t\t\t}while(hier);\n    796  \t\t}\n    797  \t}\n    798  \tmosquitto__free(context->subs);\n    799  \tcontext->subs = NULL;\n    800  \tcontext->sub_count = 0;\n    801  \n    802  \treturn MOSQ_ERR_SUCCESS;\n    803  }\nFunction: tmp_remove_subs\nPath: /root/projects/mosquitto/src/subs.c:715\n    715  static struct mosquitto__subhier *tmp_remove_subs(struct mosquitto__subhier *sub)\n    716  {\n    717  \tstruct mosquitto__subhier *parent;\n    718  \n    719  \tif(!sub || !sub->parent){\n    720  \t\treturn NULL;\n    721  \t}\n    722  \n    723  \tif(sub->children || sub->subs){\n    724  \t\treturn NULL;\n    725  \t}\n    726  \n    727  \tparent = sub->parent;\n    728  \tHASH_DELETE(hh, parent->children, sub);\n    729  \tmosquitto__free(sub->topic);\n    730  \tmosquitto__free(sub);\n    731  \n    732  \tif(parent->subs == NULL\n    733  \t\t\t&& parent->children == NULL\n    734  \t\t\t&& parent->shared == NULL\n    735  \t\t\t&& parent->parent){\n    736  \n    737  \t\treturn parent;\n    738  \t}else{\n    739  \t\treturn NULL;\n    740  \t}\n    741  }\nFunction: sub__topic_tokenise\nPath: /root/projects/mosquitto/src/topic_tok.c:58\n    58   int sub__topic_tokenise(const char *subtopic, char **local_sub, char ***topics, const char **sharename)\n    59   {\n    60   \tchar *saveptr = NULL;\n    61   \tchar *token;\n    62   \tint count;\n    63   \tint topic_index = 0;\n    64   \tint i;\n    65   \tsize_t len;\n    66   \n    67   \tlen = strlen(subtopic);\n    68   \tif(len == 0){\n    69   \t\treturn MOSQ_ERR_INVAL;\n    70   \t}\n    71   \n    72   \t*local_sub = mosquitto__strdup(subtopic);\n    73   \tif((*local_sub) == NULL) return MOSQ_ERR_NOMEM;\n    74   \n    75   \tcount = 0;\n    76   \tsaveptr = *local_sub;\n    77   \twhile(saveptr){\n    78   \t\tsaveptr = strchr(&saveptr[1], '/');\n    79   \t\tcount++;\n    80   \t}\n    81   \t*topics = mosquitto__calloc((size_t)(count+3) /* 3=$shared,sharename,NULL */, sizeof(char *));\n    82   \tif((*topics) == NULL){\n    83   \t\tmosquitto__free(*local_sub);\n    84   \t\treturn MOSQ_ERR_NOMEM;\n    85   \t}\n    86   \n    87   \tif((*local_sub)[0] != '$'){\n    88   \t\t(*topics)[topic_index] = \"\";\n    89   \t\ttopic_index++;\n    90   \t}\n    91   \n    92   \ttoken = strtok_hier((*local_sub), &saveptr);\n    93   \twhile(token){\n    94   \t\t(*topics)[topic_index] = token;\n    95   \t\ttopic_index++;\n    96   \t\ttoken = strtok_hier(NULL, &saveptr);\n    97   \t}\n    98   \n    99   \tif(!strcmp((*topics)[0], \"$share\")){\n    100  \t\tif(count < 3 || (count == 3 && strlen((*topics)[2]) == 0)){\n    101  \t\t\tmosquitto__free(*local_sub);\n    102  \t\t\tmosquitto__free(*topics);\n    103  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    104  \t\t}\n    105  \n    106  \t\tif(sharename){\n    107  \t\t\t(*sharename) = (*topics)[1];\n    108  \t\t}\n    109  \n    110  \t\tfor(i=1; i<count-1; i++){\n    111  \t\t\t(*topics)[i] = (*topics)[i+1];\n    112  \t\t}\n    113  \t\t(*topics)[0] = \"\";\n    114  \t\t(*topics)[count-1] = NULL;\n    115  \t}\n    116  \treturn MOSQ_ERR_SUCCESS;\n    117  }\nFunction: mosquitto_validate_utf8\nPath: /root/projects/mosquitto/src/../lib/utf8_mosq.c:24\n    24   int mosquitto_validate_utf8(const char *str, int len)\n    25   {\n    26   \tint i;\n    27   \tint j;\n    28   \tint codelen;\n    29   \tint codepoint;\n    30   \tconst unsigned char *ustr = (const unsigned char *)str;\n    31   \n    32   \tif(!str) return MOSQ_ERR_INVAL;\n    33   \tif(len < 0 || len > 65536) return MOSQ_ERR_INVAL;\n    34   \n    35   \tfor(i=0; i<len; i++){\n    36   \t\tif(ustr[i] == 0){\n    37   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    38   \t\t}else if(ustr[i] <= 0x7f){\n    39   \t\t\tcodelen = 1;\n    40   \t\t\tcodepoint = ustr[i];\n    41   \t\t}else if((ustr[i] & 0xE0) == 0xC0){\n    42   \t\t\t/* 110xxxxx - 2 byte sequence */\n    43   \t\t\tif(ustr[i] == 0xC0 || ustr[i] == 0xC1){\n    44   \t\t\t\t/* Invalid bytes */\n    45   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    46   \t\t\t}\n    47   \t\t\tcodelen = 2;\n    48   \t\t\tcodepoint = (ustr[i] & 0x1F);\n    49   \t\t}else if((ustr[i] & 0xF0) == 0xE0){\n    50   \t\t\t/* 1110xxxx - 3 byte sequence */\n    51   \t\t\tcodelen = 3;\n    52   \t\t\tcodepoint = (ustr[i] & 0x0F);\n    53   \t\t}else if((ustr[i] & 0xF8) == 0xF0){\n    54   \t\t\t/* 11110xxx - 4 byte sequence */\n    55   \t\t\tif(ustr[i] > 0xF4){\n    56   \t\t\t\t/* Invalid, this would produce values > 0x10FFFF. */\n    57   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    58   \t\t\t}\n    59   \t\t\tcodelen = 4;\n    60   \t\t\tcodepoint = (ustr[i] & 0x07);\n    61   \t\t}else{\n    62   \t\t\t/* Unexpected continuation byte. */\n    63   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    64   \t\t}\n    65   \n    66   \t\t/* Reconstruct full code point */\n    67   \t\tif(i == len-codelen+1){\n    68   \t\t\t/* Not enough data */\n    69   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    70   \t\t}\n    71   \t\tfor(j=0; j<codelen-1; j++){\n    72   \t\t\tif((ustr[++i] & 0xC0) != 0x80){\n    73   \t\t\t\t/* Not a continuation byte */\n    74   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    75   \t\t\t}\n    76   \t\t\tcodepoint = (codepoint<<6) | (ustr[i] & 0x3F);\n    77   \t\t}\n    78   \n    79   \t\t/* Check for UTF-16 high/low surrogates */\n    80   \t\tif(codepoint >= 0xD800 && codepoint <= 0xDFFF){\n    81   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    82   \t\t}\n    83   \n    84   \t\t/* Check for overlong or out of range encodings */\n    85   \t\t/* Checking codelen == 2 isn't necessary here, because it is already\n    86   \t\t * covered above in the C0 and C1 checks.\n    87   \t\t * if(codelen == 2 && codepoint < 0x0080){\n    88   \t\t *\t return MOSQ_ERR_MALFORMED_UTF8;\n    89   \t\t * }else\n    90   \t\t*/\n    91   \t\tif(codelen == 3 && codepoint < 0x0800){\n    92   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    93   \t\t}else if(codelen == 4 && (codepoint < 0x10000 || codepoint > 0x10FFFF)){\n    94   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    95   \t\t}\n    96   \n    97   \t\t/* Check for non-characters */\n    98   \t\tif(codepoint >= 0xFDD0 && codepoint <= 0xFDEF){\n    99   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    100  \t\t}\n    101  \t\tif((codepoint & 0xFFFF) == 0xFFFE || (codepoint & 0xFFFF) == 0xFFFF){\n    102  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    103  \t\t}\n    104  \t\t/* Check for control characters */\n    105  \t\tif(codepoint <= 0x001F || (codepoint >= 0x007F && codepoint <= 0x009F)){\n    106  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    107  \t\t}\n    108  \t}\n    109  \treturn MOSQ_ERR_SUCCESS;\n    110  }\nFunction: mosquitto__get_state\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:295\n    295  enum mosquitto_client_state mosquitto__get_state(struct mosquitto *mosq)\n    296  {\n    297  \tenum mosquitto_client_state state;\n    298  \n    299  \tCOMPAT_pthread_mutex_lock(&mosq->state_mutex);\n    300  \tstate = mosq->state;\n    301  \tCOMPAT_pthread_mutex_unlock(&mosq->state_mutex);\n    302  \n    303  \treturn state;\n    304  }\nFunction: mosquitto__set_state\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:281\n    281  int mosquitto__set_state(struct mosquitto *mosq, enum mosquitto_client_state state)\n    282  {\n    283  \tCOMPAT_pthread_mutex_lock(&mosq->state_mutex);\n    284  #ifdef WITH_BROKER\n    285  \tif(mosq->state != mosq_cs_disused)\n    286  #endif\n    287  \t{\n    288  \t\tmosq->state = state;\n    289  \t}\n    290  \tCOMPAT_pthread_mutex_unlock(&mosq->state_mutex);\n    291  \n    292  \treturn MOSQ_ERR_SUCCESS;\n    293  }\nFunction: mosquitto_pub_topic_check\nPath: /root/projects/mosquitto/src/../lib/util_topic.c:50\n    50   int mosquitto_pub_topic_check(const char *str)\n    51   {\n    52   \tint len = 0;\n    53   #ifdef WITH_BROKER\n    54   \tint hier_count = 0;\n    55   #endif\n    56   \n    57   \tif(str == NULL){\n    58   \t\treturn MOSQ_ERR_INVAL;\n    59   \t}\n    60   \n    61   \twhile(str && str[0]){\n    62   \t\tif(str[0] == '+' || str[0] == '#'){\n    63   \t\t\treturn MOSQ_ERR_INVAL;\n    64   \t\t}\n    65   #ifdef WITH_BROKER\n    66   \t\telse if(str[0] == '/'){\n    67   \t\t\thier_count++;\n    68   \t\t}\n    69   #endif\n    70   \t\tlen++;\n    71   \t\tstr = &str[1];\n    72   \t}\n    73   \tif(len > 65535) return MOSQ_ERR_INVAL;\n    74   #ifdef WITH_BROKER\n    75   \tif(hier_count > TOPIC_HIERARCHY_LIMIT) return MOSQ_ERR_INVAL;\n    76   #endif\n    77   \n    78   \treturn MOSQ_ERR_SUCCESS;\n    79   }\nFunction: will_delay__remove\nPath: /root/projects/mosquitto/src/will_delay.c:99\n    99   void will_delay__remove(struct mosquitto *mosq)\n    100  {\n    101  \tif(mosq->will_delay_entry != NULL){\n    102  \t\tDL_DELETE(delay_list, mosq->will_delay_entry);\n    103  \t\tmosquitto__free(mosq->will_delay_entry);\n    104  \t\tmosq->will_delay_entry = NULL;\n    105  \t}\n    106  }\nFunction: will__clear\nPath: /root/projects/mosquitto/src/../lib/will_mosq.c:111\n    111  int will__clear(struct mosquitto *mosq)\n    112  {\n    113  \tif(!mosq->will) return MOSQ_ERR_SUCCESS;\n    114  \n    115  \tmosquitto__free(mosq->will->msg.topic);\n    116  \tmosq->will->msg.topic = NULL;\n    117  \n    118  \tmosquitto__free(mosq->will->msg.payload);\n    119  \tmosq->will->msg.payload = NULL;\n    120  \n    121  \tmosquitto_property_free_all(&mosq->will->properties);\n    122  \n    123  \tmosquitto__free(mosq->will);\n    124  \tmosq->will = NULL;\n    125  \tmosq->will_delay_interval = 0;\n    126  \n    127  \treturn MOSQ_ERR_SUCCESS;\n    128  }\n",
    "If the Server determines that the protocol is MQTT v5.0, it MUST validate that the CONNECT packet matches the format described in section 3.1 and close the Network Connection if the CONNECT packet does not match [MQTT-3.1.4-1].": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    221  \tplugin__handle_disconnect(context, -1);\n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    226  \tif(context->bridge == NULL)\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    232  \t\t\tif(context->will_delay_interval == 0){\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__read_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:178\n    178  int packet__read_uint32(struct mosquitto__packet *packet, uint32_t *word)\n    179  {\n    180  \tuint32_t val = 0;\n    181  \tint i;\n    184  \tif(packet->pos+4 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    186  \tfor(i=0; i<4; i++){\n    187  \t\tval = (val << 8) + packet->payload[packet->pos];\n    188  \t\tpacket->pos++;\n    189  \t}\n    191  \t*word = val;\n    194  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    235  \treturn MOSQ_ERR_MALFORMED_PACKET;\n    236  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    147  \tassert(mosq);\n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    153  \tpacket->next = NULL;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    187  \treturn packet__write(mosq);\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    353  }\nFunction: packet__check_oversize\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:211\n    211  int packet__check_oversize(struct mosquitto *mosq, uint32_t remaining_length)\n    212  {\n    215  \tif(mosq->maximum_packet_size == 0) return MOSQ_ERR_SUCCESS;\n    217  \tlen = remaining_length + packet__varint_bytes(remaining_length);\n    218  \tif(len > mosq->maximum_packet_size){\n    219  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    220  \t}else{\n    221  \t\treturn MOSQ_ERR_SUCCESS;\n    222  \t}\n    223  }\nFunction: property__process_connect\nPath: /root/projects/mosquitto/src/property_broker.c:30\n    30   int property__process_connect(struct mosquitto *context, mosquitto_property **props)\n    31   {\n    32   \tmosquitto_property *p;\n    34   \tp = *props;\n    36   \twhile(p){\n    37   \t\tif(p->identifier == MQTT_PROP_SESSION_EXPIRY_INTERVAL){\n    38   \t\t\tcontext->session_expiry_interval = p->value.i32;\n    39   \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM){\n    40   \t\t\tif(p->value.i16 == 0){\n    41   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    42   \t\t\t}\n    44   \t\t\tcontext->msgs_out.inflight_maximum = p->value.i16;\n    45   \t\t\tcontext->msgs_out.inflight_quota = context->msgs_out.inflight_maximum;\n    46   \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    47   \t\t\tif(p->value.i32 == 0){\n    48   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    49   \t\t\t}\n    50   \t\t\tcontext->maximum_packet_size = p->value.i32;\n    51   \t\t}\n    52   \t\tp = p->next;\n    53   \t}\n    56   }\nFunction: property__process_will\nPath: /root/projects/mosquitto/src/property_broker.c:59\n    59   int property__process_will(struct mosquitto *context, struct mosquitto_message_all *msg, mosquitto_property **props)\n    60   {\n    61   \tmosquitto_property *p, *p_prev;\n    64   \tp = *props;\n    68   \twhile(p){\n    69   \t\tswitch(p->identifier){\n    70   \t\t\tcase MQTT_PROP_CONTENT_TYPE:\n    71   \t\t\tcase MQTT_PROP_CORRELATION_DATA:\n    72   \t\t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    73   \t\t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    74   \t\t\tcase MQTT_PROP_USER_PROPERTY:\n    82   \t\t\t\tif(p_prev){\n    84   \t\t\t\t\tp = p_prev->next;\n    85   \t\t\t\t}else{\n    87   \t\t\t\t\tp = *props;\n    88   \t\t\t\t}\n    90   \t\t\t\tbreak;\n    92   \t\t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    93   \t\t\t\tcontext->will_delay_interval = p->value.i32;\n    95   \t\t\t\tp = p->next;\n    96   \t\t\t\tbreak;\n    98   \t\t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    101  \t\t\t\tp = p->next;\n    102  \t\t\t\tbreak;\n    104  \t\t\tdefault:\n    105  \t\t\t\tmsg->properties = msg_properties;\n    106  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    107  \t\t\t\tbreak;\n    108  \t\t}\n    109  \t}\n    113  }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    462  \n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    468  \n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    474  \n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    481  \n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    494  \n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    500  \n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    507  \n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    513  \n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    519  \n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    527  \n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    533  \n    534  \t\tcase MQTT_PROP_USER_PROPERTY:\n    535  \t\t\tbreak;\n    536  \n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    540  \treturn MOSQ_ERR_SUCCESS;\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: mosquitto_property_add_int16\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:744\n    744  int mosquitto_property_add_int16(mosquitto_property **proplist, int identifier, uint16_t value)\n    745  {\n    761  \tprop->value.i16 = value;\n    765  }\nFunction: mosquitto_property_read_binary\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1106\n    1106 const mosquitto_property *mosquitto_property_read_binary(const mosquitto_property *proplist, int identifier, void **value, uint16_t *len, bool skip_first)\n    1107 {\n    1109 \tif(!proplist || (value && !len) || (!value && len)) return NULL;\n    1113 \tp = property__get_property(proplist, identifier, skip_first);\n    1114 \tif(!p) return NULL;\n    1115 \tif(p->identifier != MQTT_PROP_CORRELATION_DATA\n    1116 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_DATA){\n    1118 \t\treturn NULL;\n    1119 \t}\n    1121 \tif(value){\n    1122 \t\t*len = p->value.bin.len;\n    1123 \t\t*value = calloc(1, *len + 1U);\n    1124 \t\tif(!(*value)) return NULL;\n    1126 \t\tmemcpy(*value, p->value.bin.v, *len);\n    1127 \t}\n    1130 }\nFunction: mosquitto_property_read_string\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1133\n    1133 const mosquitto_property *mosquitto_property_read_string(const mosquitto_property *proplist, int identifier, char **value, bool skip_first)\n    1134 {\n    1136 \tif(!proplist) return NULL;\n    1138 \tp = property__get_property(proplist, identifier, skip_first);\n    1139 \tif(!p) return NULL;\n    1140 \tif(p->identifier != MQTT_PROP_CONTENT_TYPE\n    1141 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_TOPIC\n    1142 \t\t\t&& p->identifier != MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER\n    1143 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_METHOD\n    1144 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_INFORMATION\n    1145 \t\t\t&& p->identifier != MQTT_PROP_SERVER_REFERENCE\n    1146 \t\t\t&& p->identifier != MQTT_PROP_REASON_STRING){\n    1148 \t\treturn NULL;\n    1149 \t}\n    1151 \tif(value){\n    1152 \t\t*value = calloc(1, (size_t)p->value.s.len+1);\n    1153 \t\tif(!(*value)) return NULL;\n    1155 \t\tmemcpy(*value, p->value.s.v, p->value.s.len);\n    1156 \t}\n    1159 }\nFunction: db__expire_all_messages\nPath: /root/projects/mosquitto/src/database.c:1053\n    1053 void db__expire_all_messages(struct mosquitto *context)\n    1055 \tstruct mosquitto_client_msg *msg, *tmp;\n    1057 \tDL_FOREACH_SAFE(context->msgs_out.inflight, msg, tmp){\n    1058 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1059 \t\t\tif(msg->qos > 0){\n    1060 \t\t\t\tutil__increment_send_quota(context);\n    1062 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1065 \tDL_FOREACH_SAFE(context->msgs_out.queued, msg, tmp){\n    1066 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1067 \t\t\tdb__message_remove_from_queued(&context->msgs_out, msg);\n    1070 \tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n    1071 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1072 \t\t\tif(msg->qos > 0){\n    1073 \t\t\t\tutil__increment_receive_quota(context);\n    1075 \t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n    1078 \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n    1079 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1080 \t\t\tdb__message_remove_from_queued(&context->msgs_in, msg);\n    1083 }\nFunction: db__message_remove_from_queued\nPath: /root/projects/mosquitto/src/database.c:364\n    364  static void db__message_remove_from_queued(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    365  {\n    366  \tif(!msg_data || !item){\n    367  \t\treturn;\n    368  \t}\n    370  \tDL_DELETE(msg_data->queued, item);\n    377  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1183 \tstruct mosquitto_client_msg *tail, *tmp;\n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1190 \tDL_FOREACH_SAFE(context->msgs_out.inflight, tail, tmp){\n    1191 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1192 \t\tif(rc) return rc;\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    143  \t\t\t\tin_quota = context->msgs_in.inflight_quota;\n    144  \t\t\t\tout_quota = context->msgs_out.inflight_quota;\n    145  \t\t\t\tin_maximum = context->msgs_in.inflight_maximum;\n    146  \t\t\t\tout_maximum = context->msgs_out.inflight_maximum;\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    154  \t\t\t\tcontext->msgs_in.inflight_quota = in_quota;\n    155  \t\t\t\tcontext->msgs_out.inflight_quota = out_quota;\n    156  \t\t\t\tcontext->msgs_in.inflight_maximum = in_maximum;\n    157  \t\t\t\tcontext->msgs_out.inflight_maximum = out_maximum;\n    159  \t\t\t\tdb__message_reconnect_reset(context);\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    215  \trc = acl__find_acls(context);\n    216  \tif(rc){\n    218  \t\treturn rc;\n    219  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    250  \t}\n    252  \tcontext->ping_t = 0;\n    253  \tcontext->is_dropping = false;\n    255  \tconnection_check_acl(context, &context->msgs_in.inflight);\n    256  \tconnection_check_acl(context, &context->msgs_in.queued);\n    257  \tconnection_check_acl(context, &context->msgs_out.inflight);\n    258  \tconnection_check_acl(context, &context->msgs_out.queued);\n    260  \tcontext__add_to_by_id(context);\n    263  \tif(!context->clean_start){\n    267  \tcontext->max_qos = context->listener->max_qos;\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    315  \tkeepalive__add(context);\n    317  \tmosquitto__set_state(context, mosq_cs_active);\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    320  \tif(rc) return rc;\n    321  \tdb__expire_all_messages(context);\n    322  \trc = db__message_write_queued_out(context);\n    323  \tif(rc) return rc;\n    324  \trc = db__message_write_inflight_out_all(context);\n    330  }\nFunction: connection_check_acl\nPath: /root/projects/mosquitto/src/handle_connect.c:86\n    86   static void connection_check_acl(struct mosquitto *context, struct mosquitto_client_msg **head)\n    97   \t\tif(mosquitto_acl_check(context, msg_tail->store->topic,\n    99   \t\t\t\t\t\t\t   msg_tail->store->qos, msg_tail->store->retain, access) != MOSQ_ERR_SUCCESS){\n    101  \t\t\tDL_DELETE((*head), msg_tail);\n    107  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    248  \tmosquitto__set_state(context, mosq_cs_disused);\n    250  \tif(context->id){\n    251  \t\tcontext__remove_from_by_id(context);\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    256  \tcontext->for_free_next = db.ll_for_free;\n    257  \tdb.ll_for_free = context;\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    296  \t\tcontext->in_by_id = true;\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__msg_add_to_inflight_stats\nPath: /root/projects/mosquitto/src/database.c:141\n    141  void db__msg_add_to_inflight_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    142  {\n    143  \tmsg_data->inflight_count++;\n    144  \tmsg_data->inflight_bytes += msg->store->payloadlen;\n    145  \tif(msg->qos != 0){\n    146  \t\tmsg_data->inflight_count12++;\n    147  \t\tmsg_data->inflight_bytes12 += msg->store->payloadlen;\n    148  \t}\n    149  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    271  \tmosquitto__free(store->source_id);\n    272  \tmosquitto__free(store->source_username);\n    283  }\nFunction: db__msg_remove_from_queued_stats\nPath: /root/projects/mosquitto/src/database.c:172\n    172  static void db__msg_remove_from_queued_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    173  {\n    174  \tmsg_data->queued_count--;\n    175  \tmsg_data->queued_bytes -= msg->store->payloadlen;\n    176  \tif(msg->qos != 0){\n    177  \t\tmsg_data->queued_count12--;\n    178  \t\tmsg_data->queued_bytes12 -= msg->store->payloadlen;\n    179  \t}\n    180  }\nFunction: db__message_remove_from_inflight\nPath: /root/projects/mosquitto/src/database.c:347\n    347  static void db__message_remove_from_inflight(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    348  {\n    349  \tif(!msg_data || !item){\n    350  \t\treturn;\n    351  \t}\n    353  \tDL_DELETE(msg_data->inflight, item);\n    354  \tif(item->store){\n    355  \t\tdb__msg_remove_from_inflight_stats(msg_data, item);\n    357  \t}\n    361  }\nFunction: db__message_write_inflight_out_latest\nPath: /root/projects/mosquitto/src/database.c:1198\n    1198 int db__message_write_inflight_out_latest(struct mosquitto *context)\n    1199 {\n    1200 \tstruct mosquitto_client_msg *tail, *next;\n    1203 \tif(context->state != mosq_cs_active\n    1204 \t\t\t|| context->sock == INVALID_SOCKET\n    1205 \t\t\t|| context->msgs_out.inflight == NULL){\n    1207 \t\treturn MOSQ_ERR_SUCCESS;\n    1208 \t}\n    1210 \tif(context->msgs_out.inflight->prev == context->msgs_out.inflight){\n    1212 \t\treturn db__message_write_inflight_out_single(context, context->msgs_out.inflight);\n    1213 \t}\n    1217 \ttail = context->msgs_out.inflight->prev;\n    1218 \twhile(tail != context->msgs_out.inflight &&\n    1219 \t\t\t(tail->state == mosq_ms_publish_qos0\n    1220 \t\t\t || tail->state == mosq_ms_publish_qos1\n    1221 \t\t\t || tail->state == mosq_ms_publish_qos2)){\n    1223 \t\ttail = tail->prev;\n    1224 \t}\n    1229 \tif(tail != context->msgs_out.inflight){\n    1230 \t\ttail = tail->next;\n    1231 \t}\n    1233 \twhile(tail){\n    1234 \t\tnext = tail->next;\n    1235 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1236 \t\tif(rc) return rc;\n    1238 \t}\n    1240 }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1097 \tuint32_t expiry_interval;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1103 \t\t\tif(msg->direction == mosq_md_out && msg->qos > 0){\n    1104 \t\t\t\tutil__increment_send_quota(context);\n    1105 \t\t\t}\n    1106 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1126 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1135 \t\t\t\tmsg->timestamp = db.now_s;\n    1136 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1137 \t\t\t\tmsg->state = mosq_ms_wait_for_puback;\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1139 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1148 \t\t\t\tmsg->timestamp = db.now_s;\n    1149 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1150 \t\t\t\tmsg->state = mosq_ms_wait_for_pubrec;\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1152 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1159 \t\t\trc = send__pubrel(context, mid, NULL);\n    1160 \t\t\tif(!rc){\n    1161 \t\t\t\tmsg->state = mosq_ms_wait_for_pubcomp;\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1176 \t}\n    1178 }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    449  \tstruct mosquitto_msg_data *msg_data;\n    450  \tenum mosquitto_msg_state state = mosq_ms_invalid;\n    452  \tint i;\n    457  \tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n    459  \tif(dir == mosq_md_out){\n    460  \t\tmsg_data = &context->msgs_out;\n    461  \t}else{\n    462  \t\tmsg_data = &context->msgs_in;\n    463  \t}\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    484  \tif(context->sock == INVALID_SOCKET){\n    486  \t\tif(qos == 0 && !db.config->queue_qos0_messages){\n    487  \t\t\tif(!context->bridge){\n    489  \t\t\t\treturn 2;\n    490  \t\t\t}else{\n    491  \t\t\t\tif(context->bridge->start_type != bst_lazy){\n    493  \t\t\t\t\treturn 2;\n    494  \t\t\t\t}\n    495  \t\t\t}\n    496  \t\t}\n    497  \t\tif(context->bridge && context->bridge->clean_start_local == true){\n    499  \t\t\treturn 2;\n    500  \t\t}\n    501  \t}\n    503  \tif(context->sock != INVALID_SOCKET){\n    504  \t\tif(db__ready_for_flight(context, dir, qos)){\n    517  \t\t\t}else{\n    520  \t\t\t\t}else{\n    522  \t\t\t\t\treturn 1;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n    528  \t\t}else{\n    530  \t\t\tif(context->is_dropping == false){\n    531  \t\t\t\tcontext->is_dropping = true;\n    532  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    534  \t\t\t\t\t\tcontext->id);\n    535  \t\t\t}\n    538  \t\t\treturn 2;\n    539  \t\t}\n    540  \t}else{\n    541  \t\tif (db__ready_for_queue(context, qos, msg_data)){\n    543  \t\t}else{\n    545  \t\t\tif(context->is_dropping == false){\n    546  \t\t\t\tcontext->is_dropping = true;\n    547  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    549  \t\t\t\t\t\tcontext->id);\n    550  \t\t\t}\n    552  \t\t\treturn 2;\n    553  \t\t}\n    554  \t}\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    582  \tif(state == mosq_ms_queued){\n    583  \t\tDL_APPEND(msg_data->queued, msg);\n    585  \t}else{\n    586  \t\tDL_APPEND(msg_data->inflight, msg);\n    588  \t}\n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    598  \t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n    599  \t\tif(dest_ids){\n    602  \t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t}\n    609  \t}\n    611  \tif(context->bridge && context->bridge->start_type == bst_lazy\n    612  \t\t\t&& context->sock == INVALID_SOCKET\n    613  \t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n    616  \t}\n    633  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    704  \tstruct mosquitto_msg_store *stored;\n    705  \tconst char *source_id;\n    706  \tenum mosquitto_msg_origin origin;\n    710  \tstored = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    711  \tif(stored == NULL) return MOSQ_ERR_NOMEM;\n    713  \tstored->topic = mosquitto__strdup(topic);\n    714  \tif(stored->topic == NULL){\n    715  \t\tdb__msg_store_free(stored);\n    716  \t\treturn MOSQ_ERR_INVAL;\n    717  \t}\n    719  \tstored->qos = qos;\n    720  \tif(db.config->retain_available == false){\n    721  \t\tstored->retain = 0;\n    722  \t}else{\n    723  \t\tstored->retain = retain;\n    724  \t}\n    726  \tstored->payloadlen = payloadlen;\n    727  \tif(payloadlen > 0){\n    728  \t\tstored->payload = mosquitto__malloc(stored->payloadlen+1);\n    729  \t\tif(stored->payload == NULL){\n    730  \t\t\tdb__msg_store_free(stored);\n    731  \t\t\treturn MOSQ_ERR_NOMEM;\n    732  \t\t}\n    734  \t\t((uint8_t *)stored->payload)[stored->payloadlen] = 0;\n    735  \t\tmemcpy(stored->payload, payload, stored->payloadlen);\n    736  \t}\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    746  \t}\n    748  \tif(context){\n    750  \t}else{\n    753  \tif(db__message_store(context, stored, message_expiry_interval, 0, origin)) return 1;\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    763  \tif(source && source->id){\n    764  \t\tstored->source_id = mosquitto__strdup(source->id);\n    765  \t}else{\n    766  \t\tstored->source_id = mosquitto__strdup(\"\");\n    767  \t}\n    768  \tif(!stored->source_id){\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    774  \tif(source && source->username){\n    775  \t\tstored->source_username = mosquitto__strdup(source->username);\n    776  \t\tif(!stored->source_username){\n    778  \t\t\treturn MOSQ_ERR_NOMEM;\n    779  \t\t}\n    780  \t}\n    781  \tif(source){\n    782  \t\tstored->source_listener = source->listener;\n    783  \t}\n    806  }\nFunction: net__socket_close\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:205\n    205  int net__socket_close(struct mosquitto *mosq)\n    206  {\n    207  \tint rc = 0;\n    209  \tstruct mosquitto *mosq_found;\n    212  \tassert(mosq);\n    218  \t\tif(mosq->ssl){\n    219  \t\t\tif(!SSL_in_init(mosq->ssl)){\n    220  \t\t\t\tSSL_shutdown(mosq->ssl);\n    221  \t\t\t}\n    222  \t\t\tSSL_free(mosq->ssl);\n    223  \t\t\tmosq->ssl = NULL;\n    224  \t\t}\n    238  \t\tif(mosq->sock != INVALID_SOCKET){\n    240  \t\t\tHASH_FIND(hh_sock, db.contexts_by_sock, &mosq->sock, sizeof(mosq->sock), mosq_found);\n    241  \t\t\tif(mosq_found){\n    242  \t\t\t\tHASH_DELETE(hh_sock, db.contexts_by_sock, mosq_found);\n    243  \t\t\t}\n    245  \t\t\trc = COMPAT_CLOSE(mosq->sock);\n    246  \t\t\tmosq->sock = INVALID_SOCKET;\n    247  \t\t}\n    251  \tif(mosq->listener){\n    252  \t\tmosq->listener->client_count--;\n    253  \t\tmosq->listener = NULL;\n    254  \t}\n    257  \treturn rc;\n    258  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    448  \tX509 *client_cert = NULL;\n    460  \tif(!context->listener){\n    461  \t\treturn MOSQ_ERR_INVAL;\n    462  \t}\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    502  \t\tcontext->protocol = mosq_p_mqtt31;\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    504  \t\t\tcontext->is_bridge = true;\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    508  \t\t\tcontext->protocol = mosq_p_mqtt311;\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    511  \t\t\t\tcontext->is_bridge = true;\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    514  \t\t\tcontext->protocol = mosq_p_mqtt5;\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    521  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    525  \t\t\t/* Reserved flags not set to 0, must disconnect. */\n    526  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    563  \t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid Will QoS in CONNECT from %s.\",\n    564  \t\t\t\tcontext->address);\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    724  \tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    731  \t\tif(!context->ssl){\n    732  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    741  \t\tif(context->listener->psk_hint){\n    743  \t\t\tif(!context->username){\n    744  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    754  \t\t\tclient_cert = SSL_get_peer_certificate(context->ssl);\n    755  \t\t\tif(!client_cert){\n    756  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    764  \t\t\tname = X509_get_subject_name(client_cert);\n    765  \t\t\tif(!name){\n    766  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    774  \t\t\tif (context->listener->use_identity_as_username) { /* use_identity_as_username */\n    775  \t\t\t\ti = X509_NAME_get_index_by_NID(name, NID_commonName, -1);\n    776  \t\t\t\tif(i == -1){\n    777  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    785  \t\t\t\tname_entry = X509_NAME_get_entry(name, i);\n    786  \t\t\t\tif(name_entry){\n    787  \t\t\t\t\tname_asn1 = X509_NAME_ENTRY_get_data(name_entry);\n    788  \t\t\t\t\tif (name_asn1 == NULL) {\n    789  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    801  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_get0_data(name_asn1);\n    803  \t\t\t\t\tif(mosquitto_validate_utf8(new_username, (int)strlen(new_username))){\n    804  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    809  \t\t\t\t\t\tX509_free(client_cert);\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    814  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    824  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    835  \t\t\t\tX509_NAME_print_ex(subject_bio, X509_get_subject_name(client_cert), 0, XN_FLAG_RFC2253);\n    847  \t\t\t\tcontext->username = subject;\n    849  \t\t\tif(!context->username){\n    853  \t\t\tX509_free(client_cert);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    898  \t\t\tmosquitto__set_state(context, mosq_cs_authenticating);\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    905  \t\t\twill__clear(context);\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    925  \t\tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    973  \tif(client_cert) X509_free(client_cert);\n    976  \tcontext->clean_start = true;\n    977  \tcontext->session_expiry_interval = 0;\n    978  \tcontext->will_delay_interval = 0;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    55   \tint i;\n    56   \tint pos;\n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    349  \t\trc = property__read_all(CMD_WILL, &context->in_packet, &properties);\n    350  \t\tif(rc) goto error_cleanup;\n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    353  \t\tmosquitto_property_free_all(&properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    356  \trc = packet__read_string(&context->in_packet, &will_struct->msg.topic, &tlen);\n    363  \tif(context->listener->mount_point){\n    364  \t\tslen = strlen(context->listener->mount_point) + strlen(will_struct->msg.topic) + 1;\n    366  \t\tif(!will_topic_mount){\n    368  \t\t\tgoto error_cleanup;\n    369  \t\t}\n    371  \t\tsnprintf(will_topic_mount, slen, \"%s%s\", context->listener->mount_point, will_struct->msg.topic);\n    374  \t\tmosquitto__free(will_struct->msg.topic);\n    375  \t\twill_struct->msg.topic = will_topic_mount;\n    376  \t}\n    378  \tif(!strncmp(will_struct->msg.topic, \"$CONTROL/\", strlen(\"$CONTROL/\"))){\n    380  \t\tgoto error_cleanup;\n    381  \t}\n    382  \trc = mosquitto_pub_topic_check(will_struct->msg.topic);\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    391  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Client %s connected with too large Will payload\", client_id);\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    394  \t\t\t}else{\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    400  \t\twill_struct->msg.payload = mosquitto__malloc((size_t)will_struct->msg.payloadlen);\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    406  \t\trc = packet__read_bytes(&context->in_packet, will_struct->msg.payload, (uint32_t)will_struct->msg.payloadlen);\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    416  error_cleanup:\n    417  \tif(will_struct){\n    418  \t\tmosquitto__free(will_struct->msg.topic);\n    419  \t\tmosquitto__free(will_struct->msg.payload);\n    422  \t}\n    424  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    157  \tassert(packet);\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: property__get_property\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:988\n    988  static const mosquitto_property *property__get_property(const mosquitto_property *proplist, int identifier, bool skip_first)\n    989  {\n    990  \tconst mosquitto_property *p;\n    995  \twhile(p){\n    996  \t\tif(p->identifier == identifier){\n    997  \t\t\tif(!is_first || !skip_first){\n    998  \t\t\t\treturn p;\n    999  \t\t\t}\n    1001 \t\t}\n    1002 \t\tp = p->next;\n    1003 \t}\n    1005 }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    371  \t\tmux__delete(context);\n    372  \t\tcontext__disconnect(context);\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto__malloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:83\n    83   void *mosquitto__malloc(size_t size)\n    84   {\n    88   \tif(mem_limit && memcount + size > mem_limit){\n    89   \t\treturn NULL;\n    90   \t}\n    93   \tmem = malloc(size);\n    96   \tif(mem){\n    97   \t\tmemcount += malloc_usable_size(mem);\n    101  \t}\n    105  }\nFunction: mosquitto__strdup\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:144\n    144  char *mosquitto__strdup(const char *s)\n    145  {\n    148  \tif(mem_limit && memcount + strlen(s) > mem_limit){\n    149  \t\treturn NULL;\n    150  \t}\n    152  \tstr = strdup(s);\n    155  \tif(str){\n    156  \t\tmemcount += malloc_usable_size(str);\n    160  \t}\n    164  }\nFunction: mosquitto_free\nPath: /root/projects/mosquitto/src/memory_public.c:27\n    27   void mosquitto_free(void *mem)\n    29   \tmosquitto__free(mem);\n    30   }\nFunction: mosquitto_malloc\nPath: /root/projects/mosquitto/src/memory_public.c:32\n    32   void *mosquitto_malloc(size_t size)\n    34   \treturn mosquitto__malloc(size);\n    35   }\nFunction: mux__delete\nPath: /root/projects/mosquitto/src/mux.c:61\n    61   int mux__delete(struct mosquitto *context)\n    64   \treturn mux_epoll__delete(context);\n    68   }\nFunction: mux_epoll__delete\nPath: /root/projects/mosquitto/src/mux_epoll.c:163\n    163  int mux_epoll__delete(struct mosquitto *context)\n    164  {\n    165  \tstruct epoll_event ev;\n    168  \tif(context->sock != INVALID_SOCKET){\n    169  \t\tif(epoll_ctl(db.epollfd, EPOLL_CTL_DEL, context->sock, &ev) == -1){\n    170  \t\t\treturn 1;\n    171  \t\t}\n    172  \t}\n    174  }\nFunction: send__auth\nPath: /root/projects/mosquitto/src/send_auth.c:28\n    28   int send__auth(struct mosquitto *context, uint8_t reason_code, const void *auth_data, uint16_t auth_data_len)\n    29   {\n    32   \tmosquitto_property *properties = NULL;\n    35   \tif(context->auth_method == NULL) return MOSQ_ERR_INVAL;\n    36   \tif(context->protocol != mosq_p_mqtt5) return MOSQ_ERR_PROTOCOL;\n    38   \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending AUTH to %s (rc%d, %s)\", context->id, reason_code, context->auth_method);\n    42   \trc = mosquitto_property_add_string(&properties, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method);\n    43   \tif(rc){\n    45   \t\treturn rc;\n    46   \t}\n    56   \tremaining_length += property__get_remaining_length(properties);\n    58   \tif(packet__check_oversize(context, remaining_length)){\n    61   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    62   \t}\n    67   \tpacket->command = CMD_AUTH;\n    68   \tpacket->remaining_length = remaining_length;\n    70   \trc = packet__alloc(packet);\n    76   \tpacket__write_byte(packet, reason_code);\n    77   \tproperty__write_all(packet, properties, true);\n    80   \treturn packet__queue(context, packet);\n    81   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    32   \tmosquitto_property *connack_props = NULL;\n    33   \tuint32_t remaining_length;\n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    43   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->address, ack, reason_code);\n    44   \t}\n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    51   \t\t\tif(rc){\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    58   \t\t\tif(rc){\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    65   \t\t\tif(rc){\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    71   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_MAXIMUM_QOS, context->listener->max_qos);\n    72   \t\t\tif(rc){\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    78   \t\tremaining_length += property__get_remaining_length(connack_props);\n    79   \t}\n    81   \tif(packet__check_oversize(context, remaining_length)){\n    83   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    84   \t}\n    92   \tpacket->command = CMD_CONNACK;\n    93   \tpacket->remaining_length = remaining_length;\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    105  \t}\n    108  \treturn packet__queue(context, packet);\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    42   \tassert(mosq);\n    45   \tif(mosq->bridge){\n    46   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Bridge %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    47   \t}else\n    56   \tassert(mosq);\n    60   \tpacket->command = CMD_DISCONNECT;\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    62   \t\tpacket->remaining_length = 1;\n    63   \t\tif(properties){\n    64   \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    65   \t\t}\n    66   \t}else{\n    67   \t\tpacket->remaining_length = 0;\n    68   \t}\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    80   \t}\n    82   \treturn packet__queue(mosq, packet);\n    83   }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    126  \tassert(mosq);\n    130  \tpacket->command = command;\n    131  \tif(dup){\n    132  \t\tpacket->command |= 8;\n    133  \t}\n    134  \tpacket->remaining_length = 2;\n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    137  \t\tif(reason_code != 0 || properties){\n    138  \t\t\tpacket->remaining_length += 1;\n    139  \t\t}\n    140  \n    141  \t\tif(properties){\n    142  \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    143  \t\t}\n    144  \t}\n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tif(reason_code != 0 || properties){\n    156  \t\t\tpacket__write_byte(packet, reason_code);\n    157  \t\t}\n    158  \t\tif(properties){\n    159  \t\t\tproperty__write_all(packet, properties, true);\n    160  \t\t}\n    161  \t}\n    163  \treturn packet__queue(mosq, packet);\n    164  }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    117  \treturn send__command_with_mid(mosq, CMD_PUBREL|2, mid, false, 0, properties);\n    118  }\nFunction: send__publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:42\n    42   int send__publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    43   {\n    47   \tint i;\n    49   \tbool match;\n    51   \tchar *mapped_topic = NULL;\n    55   \tassert(mosq);\n    60   \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    63   \tif(!mosq->retain_available){\n    65   \t}\n    68   \tif(mosq->listener && mosq->listener->mount_point){\n    69   \t\tlen = strlen(mosq->listener->mount_point);\n    70   \t\tif(len < strlen(topic)){\n    71   \t\t\ttopic += len;\n    72   \t\t}else{\n    74   \t\t\treturn MOSQ_ERR_SUCCESS;\n    75   \t\t}\n    76   \t}\n    78   \tif(mosq->bridge && mosq->bridge->topics && mosq->bridge->topic_remapping){\n    79   \t\tfor(i=0; i<mosq->bridge->topic_count; i++){\n    80   \t\t\tcur_topic = &mosq->bridge->topics[i];\n    81   \t\t\tif((cur_topic->direction == bd_both || cur_topic->direction == bd_out)\n    82   \t\t\t\t\t&& (cur_topic->remote_prefix || cur_topic->local_prefix)){\n    85   \t\t\t\trc = mosquitto_topic_matches_sub(cur_topic->local_topic, topic, &match);\n    86   \t\t\t\tif(rc){\n    87   \t\t\t\t\treturn rc;\n    88   \t\t\t\t}\n    89   \t\t\t\tif(match){\n    90   \t\t\t\t\tmapped_topic = mosquitto__strdup(topic);\n    91   \t\t\t\t\tif(!mapped_topic) return MOSQ_ERR_NOMEM;\n    92   \t\t\t\t\tif(cur_topic->local_prefix){\n    94   \t\t\t\t\t\tif(!strncmp(cur_topic->local_prefix, mapped_topic, strlen(cur_topic->local_prefix))){\n    95   \t\t\t\t\t\t\ttopic_temp = mosquitto__strdup(mapped_topic+strlen(cur_topic->local_prefix));\n    96   \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    97   \t\t\t\t\t\t\tif(!topic_temp){\n    98   \t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    99   \t\t\t\t\t\t\t}\n    101  \t\t\t\t\t\t}\n    102  \t\t\t\t\t}\n    104  \t\t\t\t\tif(cur_topic->remote_prefix){\n    106  \t\t\t\t\t\tlen = strlen(mapped_topic) + strlen(cur_topic->remote_prefix)+1;\n    107  \t\t\t\t\t\ttopic_temp = mosquitto__malloc(len+1);\n    108  \t\t\t\t\t\tif(!topic_temp){\n    109  \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    110  \t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    111  \t\t\t\t\t\t}\n    112  \t\t\t\t\t\tsnprintf(topic_temp, len, \"%s%s\", cur_topic->remote_prefix, mapped_topic);\n    113  \t\t\t\t\t\ttopic_temp[len] = '\\0';\n    114  \t\t\t\t\t\tmosquitto__free(mapped_topic);\n    116  \t\t\t\t\t}\n    117  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, mapped_topic, (long)payloadlen);\n    119  \t\t\t\t\trc =  send__real_publish(mosq, mid, mapped_topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    120  \t\t\t\t\tmosquitto__free(mapped_topic);\n    121  \t\t\t\t\treturn rc;\n    122  \t\t\t\t}\n    123  \t\t\t}\n    124  \t\t}\n    125  \t}\n    127  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, topic, (long)payloadlen);\n    133  \treturn send__real_publish(mosq, mid, topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    134  }\nFunction: send__real_publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:137\n    137  int send__real_publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    138  {\n    140  \tunsigned int packetlen;\n    141  \tunsigned int proplen = 0, varbytes;\n    143  \tmosquitto_property expiry_prop;\n    145  \tassert(mosq);\n    147  \tif(topic){\n    148  \t\tpacketlen = 2+(unsigned int)strlen(topic) + payloadlen;\n    149  \t}else{\n    150  \t\tpacketlen = 2 + payloadlen;\n    151  \t}\n    152  \tif(qos > 0) packetlen += 2; /* For message id */\n    153  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tproplen += property__get_length_all(cmsg_props);\n    156  \t\tproplen += property__get_length_all(store_props);\n    157  \t\tif(expiry_interval > 0){\n    163  \t\t\tproplen += property__get_length_all(&expiry_prop);\n    164  \t\t}\n    166  \t\tvarbytes = packet__varint_bytes(proplen);\n    172  \t\t}else{\n    173  \t\t\tpacketlen += proplen + varbytes;\n    174  \t\t}\n    175  \t}\n    176  \tif(packet__check_oversize(mosq, packetlen)){\n    178  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Dropping too large outgoing PUBLISH for %s (%d bytes)\", SAFE_PRINT(mosq->id), packetlen);\n    182  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    183  \t}\n    189  \tpacket->command = (uint8_t)(CMD_PUBLISH | (uint8_t)((dup&0x1)<<3) | (uint8_t)(qos<<1) | retain);\n    190  \tpacket->remaining_length = packetlen;\n    206  \tif(mosq->protocol == mosq_p_mqtt5){\n    213  \t}\n    220  \treturn packet__queue(mosq, packet);\n    221  }\nFunction: set_session_expiry_time\nPath: /root/projects/mosquitto/src/session_expiry.c:46\n    46   static void set_session_expiry_time(struct mosquitto *context)\n    47   {\n    50   \tif(db.config->persistent_client_expiration == 0){\n    52   \t\tcontext->session_expiry_time += context->session_expiry_interval;\n    53   \t}else{\n    55   \t\tif(db.config->persistent_client_expiration < context->session_expiry_interval){\n    58   \t\t}else{\n    60   \t\t\tcontext->session_expiry_time += context->session_expiry_interval;\n    61   \t\t}\n    62   \t}\n    63   }\nFunction: session_expiry__remove\nPath: /root/projects/mosquitto/src/session_expiry.c:121\n    121  void session_expiry__remove(struct mosquitto *context)\n    122  {\n    123  \tif(context->expiry_list_item){\n    124  \t\tDL_DELETE(expiry_list, context->expiry_list_item);\n    125  \t\tmosquitto__free(context->expiry_list_item);\n    126  \t\tcontext->expiry_list_item = NULL;\n    127  \t}\n    128  }\nFunction: mosquitto_acl_check\nPath: /root/projects/mosquitto/src/security.c:679\n    679  int mosquitto_acl_check(struct mosquitto *context, const char *topic, uint32_t payloadlen, void* payload, uint8_t qos, bool retain, int access)\n    680  {\n    681  \tint rc;\n    682  \tint i;\n    683  \tstruct mosquitto__security_options *opts;\n    684  \tstruct mosquitto_acl_msg msg;\n    685  \tstruct mosquitto__callback *cb_base;\n    686  \tstruct mosquitto_evt_acl_check event_data;\n    688  \tif(!context->id){\n    689  \t\treturn MOSQ_ERR_ACL_DENIED;\n    690  \t}\n    691  \tif(context->bridge){\n    692  \t\treturn MOSQ_ERR_SUCCESS;\n    693  \t}\n    703  \tif(db.config->per_listener_settings){\n    704  \t\tif(context->listener){\n    705  \t\t\topts = &context->listener->security_options;\n    706  \t\t}else{\n    707  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    708  \t\t}\n    709  \t}else{\n    710  \t\topts = &db.config->security_options;\n    711  \t}\n    720  \tDL_FOREACH(opts->plugin_callbacks.acl_check, cb_base){\n    724  \t\tevent_data.client = context;\n    732  \t\trc = cb_base->cb(MOSQ_EVT_ACL_CHECK, &event_data, cb_base->userdata);\n    733  \t\tif(rc != MOSQ_ERR_PLUGIN_DEFER){\n    738  \tfor(i=0; i<opts->auth_plugin_config_count; i++){\n    739  \t\tif(opts->auth_plugin_configs[i].plugin.version < 5){\n    740  \t\t\trc = acl__check_single(&opts->auth_plugin_configs[i], context, &msg, access);\n    741  \t\t\tif(rc != MOSQ_ERR_PLUGIN_DEFER){\n    742  \t\t\t\treturn rc;\n    743  \t\t\t}\n    744  \t\t}\n    745  \t}\n    749  \tif(rc == MOSQ_ERR_PLUGIN_DEFER){\n    751  \t}\n    753  }\nFunction: sub__remove_shared_leaf\nPath: /root/projects/mosquitto/src/subs.c:190\n    190  static void sub__remove_shared_leaf(struct mosquitto__subhier *subhier, struct mosquitto__subshared *shared, struct mosquitto__subleaf *leaf)\n    191  {\n    192  \tDL_DELETE(shared->subs, leaf);\n    193  \tif(shared->subs == NULL){\n    194  \t\tHASH_DELETE(hh, subhier->shared, shared);\n    195  \t\tmosquitto__free(shared->name);\n    196  \t\tmosquitto__free(shared);\n    197  \t}\n    199  }\nFunction: sub__messages_queue\nPath: /root/projects/mosquitto/src/subs.c:659\n    659  int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n    660  {\n    661  \tint rc = MOSQ_ERR_SUCCESS, rc2;\n    662  \tint rc_normal = MOSQ_ERR_NO_SUBSCRIBERS, rc_shared = MOSQ_ERR_NO_SUBSCRIBERS;\n    663  \tstruct mosquitto__subhier *subhier;\n    664  \tchar **split_topics = NULL;\n    677  \tHASH_FIND(hh, db.normal_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    678  \tif(subhier){\n    679  \t\trc_normal = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    680  \t\tif(rc_normal > 0){\n    682  \t\t\tgoto end;\n    683  \t\t}\n    684  \t}\n    686  \tHASH_FIND(hh, db.shared_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    687  \tif(subhier){\n    688  \t\trc_shared = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    689  \t\tif(rc_shared > 0){\n    691  \t\t\tgoto end;\n    692  \t\t}\n    693  \t}\n    695  \tif(rc_normal == MOSQ_ERR_NO_SUBSCRIBERS && rc_shared == MOSQ_ERR_NO_SUBSCRIBERS){\n    697  \t}\n    711  }\nFunction: sub__search\nPath: /root/projects/mosquitto/src/subs.c:479\n    479  static int sub__search(struct mosquitto__subhier *subhier, char **split_topics, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    480  {\n    482  \tstruct mosquitto__subhier *branch;\n    486  \tif(split_topics && split_topics[0]){\n    488  \t\tHASH_FIND(hh, subhier->children, split_topics[0], strlen(split_topics[0]), branch);\n    490  \t\tif(branch){\n    491  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    492  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    494  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    495  \t\t\t\treturn rc;\n    496  \t\t\t}\n    497  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    498  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    499  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    501  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    502  \t\t\t\t\treturn rc;\n    503  \t\t\t\t}\n    504  \t\t\t}\n    505  \t\t}\n    508  \t\tHASH_FIND(hh, subhier->children, \"+\", 1, branch);\n    510  \t\tif(branch){\n    511  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    512  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    514  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    515  \t\t\t\treturn rc;\n    516  \t\t\t}\n    517  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    518  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    519  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    521  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    522  \t\t\t\t\treturn rc;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}\n    526  \t}\n    529  \tHASH_FIND(hh, subhier->children, \"#\", 1, branch);\n    530  \tif(branch && !branch->children){\n    535  \t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    536  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    538  \t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    539  \t\t\treturn rc;\n    540  \t\t}\n    541  \t}\n    548  }\nFunction: subs__process\nPath: /root/projects/mosquitto/src/subs.c:129\n    129  static int subs__process(struct mosquitto__subhier *hier, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    130  {\n    133  \tstruct mosquitto__subleaf *leaf;\n    135  \trc = subs__shared_process(hier, topic, qos, retain, stored);\n    137  \tleaf = hier->subs;\n    138  \twhile(source_id && leaf){\n    139  \t\tif(!leaf->context->id || (leaf->no_local && !strcmp(leaf->context->id, source_id))){\n    140  \t\t\tleaf = leaf->next;\n    142  \t\t}\n    147  \t\tleaf = leaf->next;\n    148  \t}\n    149  \tif(hier->subs || hier->shared){\n    150  \t\treturn rc;\n    151  \t}else{\n    152  \t\treturn MOSQ_ERR_NO_SUBSCRIBERS;\n    153  \t}\n    154  }\nFunction: subs__send\nPath: /root/projects/mosquitto/src/subs.c:63\n    63   static int subs__send(struct mosquitto__subleaf *leaf, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    64   {\n    65   \tbool client_retain;\n    66   \tuint16_t mid;\n    67   \tuint8_t client_qos, msg_qos;\n    68   \tmosquitto_property *properties = NULL;\n    72   \trc2 = mosquitto_acl_check(leaf->context, topic, stored->payloadlen, stored->payload, stored->qos, stored->retain, MOSQ_ACL_READ);\n    73   \tif(rc2 == MOSQ_ERR_ACL_DENIED){\n    74   \t\treturn MOSQ_ERR_SUCCESS;\n    75   \t}else if(rc2 == MOSQ_ERR_SUCCESS){\n    76   \t\tclient_qos = leaf->qos;\n    87   \t\tif(msg_qos){\n    88   \t\t\tmid = mosquitto__mid_generate(leaf->context);\n    89   \t\t}else{\n    92   \t\tif(leaf->retain_as_published){\n    93   \t\t\tclient_retain = retain;\n    94   \t\t}else{\n    97   \t\tif(leaf->identifier){\n    98   \t\t\tmosquitto_property_add_varint(&properties, MQTT_PROP_SUBSCRIPTION_IDENTIFIER, leaf->identifier);\n    99   \t\t}\n    100  \t\tif(db__message_insert(leaf->context, mid, mosq_md_out, msg_qos, client_retain, stored, properties, true) == 1){\n    101  \t\t\treturn 1;\n    102  \t\t}\n    103  \t}else{\n    104  \t\treturn 1; /* Application error */\n    105  \t}\n    107  }\nFunction: sub__clean_session\nPath: /root/projects/mosquitto/src/subs.c:746\n    746  int sub__clean_session(struct mosquitto *context)\n    747  {\n    748  \tint i;\n    749  \tstruct mosquitto__subleaf *leaf;\n    750  \tstruct mosquitto__subhier *hier;\n    752  \tfor(i=0; i<context->sub_count; i++){\n    753  \t\tif(context->subs[i] == NULL){\n    755  \t\t}\n    757  \t\thier = context->subs[i]->hier;\n    759  \t\tif(context->subs[i]->shared){\n    760  \t\t\tleaf = context->subs[i]->shared->subs;\n    761  \t\t\twhile(leaf){\n    762  \t\t\t\tif(leaf->context==context){\n    766  \t\t\t\t\tsub__remove_shared_leaf(context->subs[i]->hier, context->subs[i]->shared, leaf);\n    768  \t\t\t\t}\n    769  \t\t\t\tleaf = leaf->next;\n    770  \t\t\t}\n    771  \t\t}else{\n    772  \t\t\tleaf = hier->subs;\n    773  \t\t\twhile(leaf){\n    774  \t\t\t\tif(leaf->context==context){\n    778  \t\t\t\t\tDL_DELETE(hier->subs, leaf);\n    779  \t\t\t\t\tmosquitto__free(leaf);\n    781  \t\t\t\t}\n    782  \t\t\t\tleaf = leaf->next;\n    783  \t\t\t}\n    784  \t\t}\n    785  \t\tmosquitto__free(context->subs[i]);\n    786  \t\tcontext->subs[i] = NULL;\n    788  \t\tif(hier->subs == NULL\n    789  \t\t\t\t&& hier->children == NULL\n    790  \t\t\t\t&& hier->shared == NULL\n    791  \t\t\t\t&& hier->parent){\n    794  \t\t\t\thier = tmp_remove_subs(hier);\n    795  \t\t\t}while(hier);\n    796  \t\t}\n    797  \t}\n    798  \tmosquitto__free(context->subs);\n    799  \tcontext->subs = NULL;\n    800  \tcontext->sub_count = 0;\n    803  }\nFunction: tmp_remove_subs\nPath: /root/projects/mosquitto/src/subs.c:715\n    715  static struct mosquitto__subhier *tmp_remove_subs(struct mosquitto__subhier *sub)\n    716  {\n    719  \tif(!sub || !sub->parent){\n    720  \t\treturn NULL;\n    721  \t}\n    723  \tif(sub->children || sub->subs){\n    724  \t\treturn NULL;\n    725  \t}\n    727  \tparent = sub->parent;\n    728  \tHASH_DELETE(hh, parent->children, sub);\n    729  \tmosquitto__free(sub->topic);\n    730  \tmosquitto__free(sub);\n    732  \tif(parent->subs == NULL\n    733  \t\t\t&& parent->children == NULL\n    734  \t\t\t&& parent->shared == NULL\n    735  \t\t\t&& parent->parent){\n    737  \t\treturn parent;\n    738  \t}else{\n    739  \t\treturn NULL;\n    740  \t}\n    741  }\nFunction: mosquitto_validate_utf8\nPath: /root/projects/mosquitto/src/../lib/utf8_mosq.c:24\n    24   int mosquitto_validate_utf8(const char *str, int len)\n    25   {\n    26   \tint i;\n    27   \tint j;\n    28   \tint codelen;\n    29   \tint codepoint;\n    32   \tif(!str) return MOSQ_ERR_INVAL;\n    33   \tif(len < 0 || len > 65536) return MOSQ_ERR_INVAL;\n    35   \tfor(i=0; i<len; i++){\n    36   \t\tif(ustr[i] == 0){\n    37   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    38   \t\t}else if(ustr[i] <= 0x7f){\n    40   \t\t\tcodepoint = ustr[i];\n    41   \t\t}else if((ustr[i] & 0xE0) == 0xC0){\n    43   \t\t\tif(ustr[i] == 0xC0 || ustr[i] == 0xC1){\n    45   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    46   \t\t\t}\n    48   \t\t\tcodepoint = (ustr[i] & 0x1F);\n    49   \t\t}else if((ustr[i] & 0xF0) == 0xE0){\n    52   \t\t\tcodepoint = (ustr[i] & 0x0F);\n    53   \t\t}else if((ustr[i] & 0xF8) == 0xF0){\n    55   \t\t\tif(ustr[i] > 0xF4){\n    57   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    58   \t\t\t}\n    60   \t\t\tcodepoint = (ustr[i] & 0x07);\n    61   \t\t}else{\n    63   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    64   \t\t}\n    67   \t\tif(i == len-codelen+1){\n    69   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    70   \t\t}\n    71   \t\tfor(j=0; j<codelen-1; j++){\n    72   \t\t\tif((ustr[++i] & 0xC0) != 0x80){\n    74   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    75   \t\t\t}\n    76   \t\t\tcodepoint = (codepoint<<6) | (ustr[i] & 0x3F);\n    77   \t\t}\n    80   \t\tif(codepoint >= 0xD800 && codepoint <= 0xDFFF){\n    81   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    82   \t\t}\n    88   \t\t *\t return MOSQ_ERR_MALFORMED_UTF8;\n    91   \t\tif(codelen == 3 && codepoint < 0x0800){\n    92   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    93   \t\t}else if(codelen == 4 && (codepoint < 0x10000 || codepoint > 0x10FFFF)){\n    94   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    95   \t\t}\n    98   \t\tif(codepoint >= 0xFDD0 && codepoint <= 0xFDEF){\n    99   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    100  \t\t}\n    101  \t\tif((codepoint & 0xFFFF) == 0xFFFE || (codepoint & 0xFFFF) == 0xFFFF){\n    102  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    103  \t\t}\n    105  \t\tif(codepoint <= 0x001F || (codepoint >= 0x007F && codepoint <= 0x009F)){\n    106  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    107  \t\t}\n    108  \t}\n    110  }\nFunction: mosquitto__get_state\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:295\n    295  enum mosquitto_client_state mosquitto__get_state(struct mosquitto *mosq)\n    300  \tstate = mosq->state;\n    303  \treturn state;\n    304  }\nFunction: util__increment_receive_quota\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:215\n    215  void util__increment_receive_quota(struct mosquitto *mosq)\n    216  {\n    217  \tif(mosq->msgs_in.inflight_quota < mosq->msgs_in.inflight_maximum){\n    218  \t\tmosq->msgs_in.inflight_quota++;\n    219  \t}\n    220  }\nFunction: mosquitto__set_state\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:281\n    281  int mosquitto__set_state(struct mosquitto *mosq, enum mosquitto_client_state state)\n    282  {\n    285  \tif(mosq->state != mosq_cs_disused)\n    287  \t{\n    288  \t\tmosq->state = state;\n    289  \t}\n    293  }\nFunction: mosquitto_topic_matches_sub\nPath: /root/projects/mosquitto/src/../lib/util_topic.c:192\n    192  int mosquitto_topic_matches_sub(const char *sub, const char *topic, bool *result)\n    193  {\n    194  \tsize_t spos;\n    199  \tif(!sub || !topic || sub[0] == 0 || topic[0] == 0){\n    200  \t\treturn MOSQ_ERR_INVAL;\n    201  \t}\n    203  \tif((sub[0] == '$' && topic[0] != '$')\n    204  \t\t\t|| (topic[0] == '$' && sub[0] != '$')){\n    206  \t\treturn MOSQ_ERR_SUCCESS;\n    207  \t}\n    211  \twhile(sub[0] != 0){\n    212  \t\tif(topic[0] == '+' || topic[0] == '#'){\n    213  \t\t\treturn MOSQ_ERR_INVAL;\n    214  \t\t}\n    215  \t\tif(sub[0] != topic[0] || topic[0] == 0){ /* Check for wildcard matches */\n    216  \t\t\tif(sub[0] == '+'){\n    218  \t\t\t\tif(spos > 0 && sub[-1] != '/'){\n    219  \t\t\t\t\treturn MOSQ_ERR_INVAL;\n    220  \t\t\t\t}\n    222  \t\t\t\tif(sub[1] != 0 && sub[1] != '/'){\n    223  \t\t\t\t\treturn MOSQ_ERR_INVAL;\n    224  \t\t\t\t}\n    225  \t\t\t\tspos++;\n    226  \t\t\t\tsub++;\n    227  \t\t\t\twhile(topic[0] != 0 && topic[0] != '/'){\n    228  \t\t\t\t\tif(topic[0] == '+' || topic[0] == '#'){\n    229  \t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n    230  \t\t\t\t\t}\n    231  \t\t\t\t\ttopic++;\n    232  \t\t\t\t}\n    233  \t\t\t\tif(topic[0] == 0 && sub[0] == 0){\n    235  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    236  \t\t\t\t}\n    237  \t\t\t}else if(sub[0] == '#'){\n    239  \t\t\t\tif(spos > 0 && sub[-1] != '/'){\n    240  \t\t\t\t\treturn MOSQ_ERR_INVAL;\n    241  \t\t\t\t}\n    243  \t\t\t\tif(sub[1] != 0){\n    244  \t\t\t\t\treturn MOSQ_ERR_INVAL;\n    245  \t\t\t\t}else{\n    246  \t\t\t\t\twhile(topic[0] != 0){\n    247  \t\t\t\t\t\tif(topic[0] == '+' || topic[0] == '#'){\n    248  \t\t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n    249  \t\t\t\t\t\t}\n    250  \t\t\t\t\t\ttopic++;\n    251  \t\t\t\t\t}\n    253  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    254  \t\t\t\t}\n    255  \t\t\t}else{\n    257  \t\t\t\tif(topic[0] == 0\n    258  \t\t\t\t\t\t&& spos > 0\n    259  \t\t\t\t\t\t&& sub[-1] == '+'\n    260  \t\t\t\t\t\t&& sub[0] == '/'\n    261  \t\t\t\t\t\t&& sub[1] == '#')\n    262  \t\t\t\t{\n    264  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    265  \t\t\t\t}\n    268  \t\t\t\twhile(sub[0] != 0){\n    269  \t\t\t\t\tif(sub[0] == '#' && sub[1] != 0){\n    270  \t\t\t\t\t\treturn MOSQ_ERR_INVAL;\n    271  \t\t\t\t\t}\n    273  \t\t\t\t\tsub++;\n    274  \t\t\t\t}\n    277  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    278  \t\t\t}\n    279  \t\t}else{\n    281  \t\t\tif(topic[1] == 0){\n    283  \t\t\t\tif(sub[1] == '/'\n    284  \t\t\t\t\t\t&& sub[2] == '#'\n    285  \t\t\t\t\t\t&& sub[3] == 0){\n    287  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    288  \t\t\t\t}\n    289  \t\t\t}\n    290  \t\t\tspos++;\n    291  \t\t\tsub++;\n    292  \t\t\ttopic++;\n    293  \t\t\tif(sub[0] == 0 && topic[0] == 0){\n    295  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    296  \t\t\t}else if(topic[0] == 0 && sub[0] == '+' && sub[1] == 0){\n    297  \t\t\t\tif(spos > 0 && sub[-1] != '/'){\n    298  \t\t\t\t\treturn MOSQ_ERR_INVAL;\n    299  \t\t\t\t}\n    301  \t\t\t\tsub++;\n    303  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    304  \t\t\t}\n    305  \t\t}\n    306  \t}\n    307  \tif((topic[0] != 0 || sub[0] != 0)){\n    309  \t}\n    310  \twhile(topic[0] != 0){\n    311  \t\tif(topic[0] == '+' || topic[0] == '#'){\n    312  \t\t\treturn MOSQ_ERR_INVAL;\n    313  \t\t}\n    314  \t\ttopic++;\n    315  \t}\n    318  }\nFunction: will_delay__add\nPath: /root/projects/mosquitto/src/will_delay.c:39\n    39   int will_delay__add(struct mosquitto *context)\n    40   {\n    43   \tif(context->will_delay_entry){\n    44   \t\treturn MOSQ_ERR_SUCCESS;\n    45   \t}\n    50   \titem->context = context;\n    51   \tcontext->will_delay_entry = item;\n    52   \titem->context->will_delay_time = db.now_real_s + item->context->will_delay_interval;\n    54   \tDL_INSERT_INORDER(delay_list, item, will_delay__cmp);\n    57   }\nFunction: will_delay__remove\nPath: /root/projects/mosquitto/src/will_delay.c:99\n    99   void will_delay__remove(struct mosquitto *mosq)\n    100  {\n    101  \tif(mosq->will_delay_entry != NULL){\n    102  \t\tDL_DELETE(delay_list, mosq->will_delay_entry);\n    103  \t\tmosquitto__free(mosq->will_delay_entry);\n    104  \t\tmosq->will_delay_entry = NULL;\n    105  \t}\n    106  }\nFunction: will__clear\nPath: /root/projects/mosquitto/src/../lib/will_mosq.c:111\n    111  int will__clear(struct mosquitto *mosq)\n    112  {\n    113  \tif(!mosq->will) return MOSQ_ERR_SUCCESS;\n    115  \tmosquitto__free(mosq->will->msg.topic);\n    116  \tmosq->will->msg.topic = NULL;\n    118  \tmosquitto__free(mosq->will->msg.payload);\n    119  \tmosq->will->msg.payload = NULL;\n    121  \tmosquitto_property_free_all(&mosq->will->properties);\n    123  \tmosquitto__free(mosq->will);\n    124  \tmosq->will = NULL;\n    125  \tmosq->will_delay_interval = 0;\n    128  }\n",
    "If a Server does not support QoS 1 or QoS 2 PUBLISH packets, the Server MUST send a Maximum QoS in the CONNACK packet specifying the highest QoS it supports [MQTT-3.2.2-9].": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    191  \n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    199  \n    200  \t\t\t/* Unexpected disconnect, queue the client will. */\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    220  \n    221  \tplugin__handle_disconnect(context, -1);\n    222  \n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    225  #ifdef WITH_BRIDGE\n    226  \tif(context->bridge == NULL)\n    227  \t/* Outgoing bridge connection never expire */\n    228  #endif\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    231  \t\t\t/* Client session is due to be expired now */\n    232  \t\t\tif(context->will_delay_interval == 0){\n    233  \t\t\t\t/* This will be done later, after the will is published for delay>0. */\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__write_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:197\n    197  void packet__write_uint32(struct mosquitto__packet *packet, uint32_t word)\n    198  {\n    199  \tpacket__write_byte(packet, (uint8_t)((word & 0xFF000000) >> 24));\n    200  \tpacket__write_byte(packet, (uint8_t)((word & 0x00FF0000) >> 16));\n    201  \tpacket__write_byte(packet, (uint8_t)((word & 0x0000FF00) >> 8));\n    202  \tpacket__write_byte(packet, (uint8_t)((word & 0x000000FF)));\n    203  }\nFunction: packet__write_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:239\n    239  int packet__write_varint(struct mosquitto__packet *packet, uint32_t word)\n    240  {\n    241  \tuint8_t byte;\n    242  \tint count = 0;\n    243  \n    244  \tdo{\n    245  \t\tbyte = (uint8_t)(word % 128);\n    246  \t\tword = word / 128;\n    247  \t\t/* If there are more digits to encode, set the top bit of this digit */\n    248  \t\tif(word > 0){\n    249  \t\t\tbyte = byte | 0x80;\n    250  \t\t}\n    251  \t\tpacket__write_byte(packet, byte);\n    252  \t\tcount++;\n    253  \t}while(word > 0 && count < 5);\n    254  \n    255  \tif(count == 5){\n    256  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    257  \t}\n    258  \treturn MOSQ_ERR_SUCCESS;\n    259  }\nFunction: packet__varint_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:262\n    262  unsigned int packet__varint_bytes(uint32_t word)\n    263  {\n    264  \tif(word < 128){\n    265  \t\treturn 1;\n    266  \t}else if(word < 16384){\n    267  \t\treturn 2;\n    268  \t}else if(word < 2097152){\n    269  \t\treturn 3;\n    270  \t}else if(word < 268435456){\n    271  \t\treturn 4;\n    272  \t}else{\n    273  \t\treturn 5;\n    274  \t}\n    275  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    54   \tint i;\n    55   \n    56   \tassert(packet);\n    57   \n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    61   \tdo{\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    64   \t\t/* If there are more digits to encode, set the top bit of this digit */\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    73   #ifdef WITH_WEBSOCKETS\n    74   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length + LWS_PRE);\n    75   #else\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    77   #endif\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    79   \n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    85   \n    86   \treturn MOSQ_ERR_SUCCESS;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    92   \n    93   \t/* Free data and reset values */\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    144  #ifndef WITH_BROKER\n    145  \tchar sockpair_data = 0;\n    146  #endif\n    147  \tassert(mosq);\n    148  \tassert(packet);\n    149  \n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    152  \n    153  \tpacket->next = NULL;\n    154  \tCOMPAT_pthread_mutex_lock(&mosq->out_packet_mutex);\n    155  \n    156  #ifdef WITH_BROKER\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    158  \t\tmosquitto__free(packet);\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    162  \t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    165  \t\tG_MSGS_DROPPED_INC();\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    168  #endif\n    169  \n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    177  \tCOMPAT_pthread_mutex_unlock(&mosq->out_packet_mutex);\n    178  #ifdef WITH_BROKER\n    179  #  ifdef WITH_WEBSOCKETS\n    180  \tif(mosq->wsi){\n    181  \t\tlws_callback_on_writable(mosq->wsi);\n    182  \t\treturn MOSQ_ERR_SUCCESS;\n    183  \t}else{\n    184  \t\treturn packet__write(mosq);\n    185  \t}\n    186  #  else\n    187  \treturn packet__write(mosq);\n    188  #  endif\n    189  #else\n    190  \n    191  \t/* Write a single byte to sockpairW (connected to sockpairR) to break out\n    192  \t * of select() if in threaded mode. */\n    193  \tif(mosq->sockpairW != INVALID_SOCKET){\n    194  #ifndef WIN32\n    195  \t\tif(write(mosq->sockpairW, &sockpair_data, 1)){\n    196  \t\t}\n    197  #else\n    198  \t\tsend(mosq->sockpairW, &sockpair_data, 1, 0);\n    199  #endif\n    200  \t}\n    201  \n    202  \tif(mosq->in_callback == false && mosq->threaded == mosq_ts_none){\n    203  \t\treturn packet__write(mosq);\n    204  \t}else{\n    205  \t\treturn MOSQ_ERR_SUCCESS;\n    206  \t}\n    207  #endif\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    228  \tssize_t write_length;\n    229  \tstruct mosquitto__packet *packet;\n    230  \tenum mosquitto_client_state state;\n    231  \n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    234  \n    235  \tCOMPAT_pthread_mutex_lock(&mosq->current_out_packet_mutex);\n    236  \tCOMPAT_pthread_mutex_lock(&mosq->out_packet_mutex);\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    245  \tCOMPAT_pthread_mutex_unlock(&mosq->out_packet_mutex);\n    246  \n    247  #ifdef WITH_BROKER\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    251  #endif\n    252  \n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    255  \t\tCOMPAT_pthread_mutex_unlock(&mosq->current_out_packet_mutex);\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    258  \n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    261  \n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    269  #ifdef WIN32\n    270  \t\t\t\terrno = WSAGetLastError();\n    271  #endif\n    272  \t\t\t\tif(errno == EAGAIN || errno == COMPAT_EWOULDBLOCK\n    273  #ifdef WIN32\n    274  \t\t\t\t\t\t|| errno == WSAENOTCONN\n    275  #endif\n    276  \t\t\t\t\t\t){\n    277  \t\t\t\t\tCOMPAT_pthread_mutex_unlock(&mosq->current_out_packet_mutex);\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    280  \t\t\t\t\tCOMPAT_pthread_mutex_unlock(&mosq->current_out_packet_mutex);\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    294  \n    295  \t\tG_MSGS_SENT_INC(1);\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    297  \t\t\tG_PUB_MSGS_SENT_INC(1);\n    298  #ifndef WITH_BROKER\n    299  \t\t\tCOMPAT_pthread_mutex_lock(&mosq->callback_mutex);\n    300  \t\t\tif(mosq->on_publish){\n    301  \t\t\t\t/* This is a QoS=0 message */\n    302  \t\t\t\tmosq->in_callback = true;\n    303  \t\t\t\tmosq->on_publish(mosq, mosq->userdata, packet->mid);\n    304  \t\t\t\tmosq->in_callback = false;\n    305  \t\t\t}\n    306  \t\t\tif(mosq->on_publish_v5){\n    307  \t\t\t\t/* This is a QoS=0 message */\n    308  \t\t\t\tmosq->in_callback = true;\n    309  \t\t\t\tmosq->on_publish_v5(mosq, mosq->userdata, packet->mid, 0, NULL);\n    310  \t\t\t\tmosq->in_callback = false;\n    311  \t\t\t}\n    312  \t\t\tCOMPAT_pthread_mutex_unlock(&mosq->callback_mutex);\n    313  \t\t}else if(((packet->command)&0xF0) == CMD_DISCONNECT){\n    314  \t\t\tdo_client_disconnect(mosq, MOSQ_ERR_SUCCESS, NULL);\n    315  \t\t\tpacket__cleanup(packet);\n    316  \t\t\tmosquitto__free(packet);\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    318  #endif\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    320  \t\t\tG_PUB_MSGS_SENT_INC(1);\n    321  \t\t}\n    322  \n    323  \t\t/* Free data and reset values */\n    324  \t\tCOMPAT_pthread_mutex_lock(&mosq->out_packet_mutex);\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    333  \t\tCOMPAT_pthread_mutex_unlock(&mosq->out_packet_mutex);\n    334  \n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    337  \n    338  #ifdef WITH_BROKER\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    340  #else\n    341  \t\tCOMPAT_pthread_mutex_lock(&mosq->msgtime_mutex);\n    342  \t\tmosq->next_msg_out = mosquitto_time() + mosq->keepalive;\n    343  \t\tCOMPAT_pthread_mutex_unlock(&mosq->msgtime_mutex);\n    344  #endif\n    345  \t}\n    346  #ifdef WITH_BROKER\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    350  #endif\n    351  \tCOMPAT_pthread_mutex_unlock(&mosq->current_out_packet_mutex);\n    352  \treturn MOSQ_ERR_SUCCESS;\n    353  }\nFunction: packet__check_oversize\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:211\n    211  int packet__check_oversize(struct mosquitto *mosq, uint32_t remaining_length)\n    212  {\n    213  \tuint32_t len;\n    214  \n    215  \tif(mosq->maximum_packet_size == 0) return MOSQ_ERR_SUCCESS;\n    216  \n    217  \tlen = remaining_length + packet__varint_bytes(remaining_length);\n    218  \tif(len > mosq->maximum_packet_size){\n    219  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    220  \t}else{\n    221  \t\treturn MOSQ_ERR_SUCCESS;\n    222  \t}\n    223  }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    155  \tint rc;\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    158  \n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    161  \n    162  \t*properties = NULL;\n    163  \n    164  \t/* The order of properties must be preserved for some types, so keep the\n    165  \t * same order for all */\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    172  \n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    175  \t\t\tmosquitto__free(p);\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    179  \n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    185  \t\ttail = p;\n    186  \n    187  \t}\n    188  \n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    194  \treturn MOSQ_ERR_SUCCESS;\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    252  \n    253  \tif(!property) return;\n    254  \n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__read\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:35\n    35   static int property__read(struct mosquitto__packet *packet, uint32_t *len, mosquitto_property *property)\n    36   {\n    37   \tint rc;\n    38   \tuint32_t property_identifier;\n    39   \tuint8_t byte;\n    40   \tuint8_t byte_count;\n    41   \tuint16_t uint16;\n    42   \tuint32_t uint32;\n    43   \tuint32_t varint;\n    44   \tchar *str1, *str2;\n    45   \tuint16_t slen1, slen2;\n    46   \n    47   \tif(!property) return MOSQ_ERR_INVAL;\n    48   \n    49   \trc = packet__read_varint(packet, &property_identifier, NULL);\n    50   \tif(rc){\n    51   \t\treturn rc;\n    52   \t}\n    53   \t*len -= 1;\n    54   \n    55   \tmemset(property, 0, sizeof(mosquitto_property));\n    56   \n    57   \tproperty->identifier = (int32_t)property_identifier;\n    58   \n    59   \tswitch(property_identifier){\n    60   \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    61   \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    62   \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    63   \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    64   \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    65   \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    66   \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    67   \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    68   \t\t\trc = packet__read_byte(packet, &byte);\n    69   \t\t\tif(rc) return rc;\n    70   \t\t\t*len -= 1; /* byte */\n    71   \t\t\tproperty->value.i8 = byte;\n    72   \t\t\tbreak;\n    73   \n    74   \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    75   \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    76   \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    77   \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    78   \t\t\trc = packet__read_uint16(packet, &uint16);\n    79   \t\t\tif(rc) return rc;\n    80   \t\t\t*len -= 2; /* uint16 */\n    81   \t\t\tproperty->value.i16 = uint16;\n    82   \t\t\tbreak;\n    83   \n    84   \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    85   \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    86   \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    87   \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    88   \t\t\trc = packet__read_uint32(packet, &uint32);\n    89   \t\t\tif(rc) return rc;\n    90   \t\t\t*len -= 4; /* uint32 */\n    91   \t\t\tproperty->value.i32 = uint32;\n    92   \t\t\tbreak;\n    93   \n    94   \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    95   \t\t\trc = packet__read_varint(packet, &varint, &byte_count);\n    96   \t\t\tif(rc) return rc;\n    97   \t\t\t*len -= byte_count;\n    98   \t\t\tproperty->value.varint = varint;\n    99   \t\t\tbreak;\n    100  \n    101  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    102  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    103  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    104  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    105  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    106  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    107  \t\tcase MQTT_PROP_REASON_STRING:\n    108  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    109  \t\t\tif(rc) return rc;\n    110  \t\t\t*len = (*len) - 2 - slen1; /* uint16, string len */\n    111  \t\t\tproperty->value.s.v = str1;\n    112  \t\t\tproperty->value.s.len = slen1;\n    113  \t\t\tbreak;\n    114  \n    115  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    116  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    117  \t\t\trc = packet__read_binary(packet, (uint8_t **)&str1, &slen1);\n    118  \t\t\tif(rc) return rc;\n    119  \t\t\t*len = (*len) - 2 - slen1; /* uint16, binary len */\n    120  \t\t\tproperty->value.bin.v = str1;\n    121  \t\t\tproperty->value.bin.len = slen1;\n    122  \t\t\tbreak;\n    123  \n    124  \t\tcase MQTT_PROP_USER_PROPERTY:\n    125  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    126  \t\t\tif(rc) return rc;\n    127  \t\t\t*len = (*len) - 2 - slen1; /* uint16, string len */\n    128  \n    129  \t\t\trc = packet__read_string(packet, &str2, &slen2);\n    130  \t\t\tif(rc){\n    131  \t\t\t\tmosquitto__free(str1);\n    132  \t\t\t\treturn rc;\n    133  \t\t\t}\n    134  \t\t\t*len = (*len) - 2 - slen2; /* uint16, string len */\n    135  \n    136  \t\t\tproperty->name.v = str1;\n    137  \t\t\tproperty->name.len = slen1;\n    138  \t\t\tproperty->value.s.v = str2;\n    139  \t\t\tproperty->value.s.len = slen2;\n    140  \t\t\tbreak;\n    141  \n    142  \t\tdefault:\n    143  #ifdef WITH_BROKER\n    144  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property_identifier);\n    145  #endif\n    146  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    147  \t}\n    148  \n    149  \treturn MOSQ_ERR_SUCCESS;\n    150  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    933  \tint rc;\n    934  \n    935  \tp = properties;\n    936  \n    937  \twhile(p){\n    938  \t\t/* Validity checks */\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    947  \n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    957  \n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    966  \n    967  \t\t/* Check for properties on incorrect commands */\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    970  \n    971  \t\t/* Check for duplicates */\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    981  \n    982  \t\tp = p->next;\n    983  \t}\n    984  \n    985  \treturn MOSQ_ERR_SUCCESS;\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    462  \n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    468  \n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    474  \n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    481  \n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    494  \n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    500  \n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    507  \n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    513  \n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    519  \n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    527  \n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    533  \n    534  \t\tcase MQTT_PROP_USER_PROPERTY:\n    535  \t\t\tbreak;\n    536  \n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    540  \treturn MOSQ_ERR_SUCCESS;\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    201  \n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    212  \n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    217  \n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    222  \n    223  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    224  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    225  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    226  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    227  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    228  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    229  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    230  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    231  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    232  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    233  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    234  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    235  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    236  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    237  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    238  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    239  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    240  \t\t\t/* Nothing to free */\n    241  \t\t\tbreak;\n    242  \t}\n    243  \n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: property__write_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:429\n    429  int property__write_all(struct mosquitto__packet *packet, const mosquitto_property *properties, bool write_len)\n    430  {\n    431  \tint rc;\n    432  \tconst mosquitto_property *p;\n    433  \n    434  \tif(write_len){\n    435  \t\trc = packet__write_varint(packet, property__get_length_all(properties));\n    436  \t\tif(rc) return rc;\n    437  \t}\n    438  \n    439  \tp = properties;\n    440  \twhile(p){\n    441  \t\trc = property__write(packet, p);\n    442  \t\tif(rc) return rc;\n    443  \t\tp = p->next;\n    444  \t}\n    445  \n    446  \treturn MOSQ_ERR_SUCCESS;\n    447  }\nFunction: property__write\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:361\n    361  static int property__write(struct mosquitto__packet *packet, const mosquitto_property *property)\n    362  {\n    363  \tint rc;\n    364  \n    365  \trc = packet__write_varint(packet, (uint32_t)property->identifier);\n    366  \tif(rc) return rc;\n    367  \n    368  \tswitch(property->identifier){\n    369  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    370  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    371  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    372  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    373  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    374  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    375  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    376  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    377  \t\t\tpacket__write_byte(packet, property->value.i8);\n    378  \t\t\tbreak;\n    379  \n    380  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    381  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    382  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    383  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    384  \t\t\tpacket__write_uint16(packet, property->value.i16);\n    385  \t\t\tbreak;\n    386  \n    387  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    388  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    389  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    390  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    391  \t\t\tpacket__write_uint32(packet, property->value.i32);\n    392  \t\t\tbreak;\n    393  \n    394  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    395  \t\t\treturn packet__write_varint(packet, property->value.varint);\n    396  \n    397  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    398  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    399  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    400  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    401  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    402  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    403  \t\tcase MQTT_PROP_REASON_STRING:\n    404  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    405  \t\t\tbreak;\n    406  \n    407  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    408  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    409  \t\t\tpacket__write_uint16(packet, property->value.bin.len);\n    410  \t\t\tpacket__write_bytes(packet, property->value.bin.v, property->value.bin.len);\n    411  \t\t\tbreak;\n    412  \n    413  \t\tcase MQTT_PROP_USER_PROPERTY:\n    414  \t\t\tpacket__write_string(packet, property->name.v, property->name.len);\n    415  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    416  \t\t\tbreak;\n    417  \n    418  \t\tdefault:\n    419  #ifdef WITH_BROKER\n    420  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property->identifier);\n    421  #endif\n    422  \t\t\treturn MOSQ_ERR_INVAL;\n    423  \t}\n    424  \n    425  \treturn MOSQ_ERR_SUCCESS;\n    426  }\nFunction: mosquitto_property_add_byte\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:716\n    716  int mosquitto_property_add_byte(mosquitto_property **proplist, int identifier, uint8_t value)\n    717  {\n    718  \tmosquitto_property *prop;\n    719  \n    720  \tif(!proplist) return MOSQ_ERR_INVAL;\n    721  \tif(identifier != MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    722  \t\t\t&& identifier != MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    723  \t\t\t&& identifier != MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    724  \t\t\t&& identifier != MQTT_PROP_MAXIMUM_QOS\n    725  \t\t\t&& identifier != MQTT_PROP_RETAIN_AVAILABLE\n    726  \t\t\t&& identifier != MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    727  \t\t\t&& identifier != MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    728  \t\t\t&& identifier != MQTT_PROP_SHARED_SUB_AVAILABLE){\n    729  \t\treturn MOSQ_ERR_INVAL;\n    730  \t}\n    731  \n    732  \tprop = mosquitto__calloc(1, sizeof(mosquitto_property));\n    733  \tif(!prop) return MOSQ_ERR_NOMEM;\n    734  \n    735  \tprop->client_generated = true;\n    736  \tprop->identifier = identifier;\n    737  \tprop->value.i8 = value;\n    738  \n    739  \tproperty__add(proplist, prop);\n    740  \treturn MOSQ_ERR_SUCCESS;\n    741  }\nFunction: db__expire_all_messages\nPath: /root/projects/mosquitto/src/database.c:1053\n    1053 void db__expire_all_messages(struct mosquitto *context)\n    1054 {\n    1055 \tstruct mosquitto_client_msg *msg, *tmp;\n    1056 \n    1057 \tDL_FOREACH_SAFE(context->msgs_out.inflight, msg, tmp){\n    1058 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1059 \t\t\tif(msg->qos > 0){\n    1060 \t\t\t\tutil__increment_send_quota(context);\n    1061 \t\t\t}\n    1062 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1063 \t\t}\n    1064 \t}\n    1065 \tDL_FOREACH_SAFE(context->msgs_out.queued, msg, tmp){\n    1066 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1067 \t\t\tdb__message_remove_from_queued(&context->msgs_out, msg);\n    1068 \t\t}\n    1069 \t}\n    1070 \tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n    1071 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1072 \t\t\tif(msg->qos > 0){\n    1073 \t\t\t\tutil__increment_receive_quota(context);\n    1074 \t\t\t}\n    1075 \t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n    1076 \t\t}\n    1077 \t}\n    1078 \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n    1079 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1080 \t\t\tdb__message_remove_from_queued(&context->msgs_in, msg);\n    1081 \t\t}\n    1082 \t}\n    1083 }\nFunction: db__message_remove_from_queued\nPath: /root/projects/mosquitto/src/database.c:364\n    364  static void db__message_remove_from_queued(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    365  {\n    366  \tif(!msg_data || !item){\n    367  \t\treturn;\n    368  \t}\n    369  \n    370  \tDL_DELETE(msg_data->queued, item);\n    371  \tif(item->store){\n    372  \t\tdb__msg_store_ref_dec(&item->store);\n    373  \t}\n    374  \n    375  \tmosquitto_property_free_all(&item->properties);\n    376  \tmosquitto__free(item);\n    377  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1183 \tstruct mosquitto_client_msg *tail, *tmp;\n    1184 \tint rc;\n    1185 \n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1189 \n    1190 \tDL_FOREACH_SAFE(context->msgs_out.inflight, tail, tmp){\n    1191 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1192 \t\tif(rc) return rc;\n    1193 \t}\n    1194 \treturn MOSQ_ERR_SUCCESS;\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    115  \tint i;\n    116  \tint rc;\n    117  \tint in_quota, out_quota;\n    118  \tuint16_t in_maximum, out_maximum;\n    119  \n    120  \t/* Find if this client already has an entry. This must be done *after* any security checks. */\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    123  \t\t/* Found a matching client */\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    125  \t\t\t/* Client is reconnecting after a disconnect */\n    126  \t\t\t/* FIXME - does anything need to be done here? */\n    127  \t\t}else{\n    128  \t\t\t/* Client is already connected, disconnect old version. This is\n    129  \t\t\t * done in context__cleanup() below. */\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    134  \n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    139  \n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    142  \n    143  \t\t\t\tin_quota = context->msgs_in.inflight_quota;\n    144  \t\t\t\tout_quota = context->msgs_out.inflight_quota;\n    145  \t\t\t\tin_maximum = context->msgs_in.inflight_maximum;\n    146  \t\t\t\tout_maximum = context->msgs_out.inflight_maximum;\n    147  \n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    150  \n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    153  \n    154  \t\t\t\tcontext->msgs_in.inflight_quota = in_quota;\n    155  \t\t\t\tcontext->msgs_out.inflight_quota = out_quota;\n    156  \t\t\t\tcontext->msgs_in.inflight_maximum = in_maximum;\n    157  \t\t\t\tcontext->msgs_out.inflight_maximum = out_maximum;\n    158  \n    159  \t\t\t\tdb__message_reconnect_reset(context);\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    166  \n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    176  \n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    189  \n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    197  \n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    200  \n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    204  \n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    208  \n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    214  \n    215  \trc = acl__find_acls(context);\n    216  \tif(rc){\n    217  \t\tfree(auth_data_out);\n    218  \t\treturn rc;\n    219  \t}\n    220  \n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    239  \n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    245  \n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    248  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"No will message specified.\");\n    249  \t\t}\n    250  \t}\n    251  \n    252  \tcontext->ping_t = 0;\n    253  \tcontext->is_dropping = false;\n    254  \n    255  \tconnection_check_acl(context, &context->msgs_in.inflight);\n    256  \tconnection_check_acl(context, &context->msgs_in.queued);\n    257  \tconnection_check_acl(context, &context->msgs_out.inflight);\n    258  \tconnection_check_acl(context, &context->msgs_out.queued);\n    259  \n    260  \tcontext__add_to_by_id(context);\n    261  \n    262  #ifdef WITH_PERSISTENCE\n    263  \tif(!context->clean_start){\n    264  \t\tdb.persistence_changes++;\n    265  \t}\n    266  #endif\n    267  \tcontext->max_qos = context->listener->max_qos;\n    268  \n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    271  \n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    275  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    280  \t\t\trc = MOSQ_ERR_INVAL;\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    284  \n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    288  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    294  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    300  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    303  \n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    306  \t\t\t\t\trc = MOSQ_ERR_NOMEM;\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    312  \tfree(auth_data_out);\n    313  \tauth_data_out = NULL;\n    314  \n    315  \tkeepalive__add(context);\n    316  \n    317  \tmosquitto__set_state(context, mosq_cs_active);\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    319  \tmosquitto_property_free_all(&connack_props);\n    320  \tif(rc) return rc;\n    321  \tdb__expire_all_messages(context);\n    322  \trc = db__message_write_queued_out(context);\n    323  \tif(rc) return rc;\n    324  \trc = db__message_write_inflight_out_all(context);\n    325  \treturn rc;\n    326  error:\n    327  \tfree(auth_data_out);\n    328  \tmosquitto_property_free_all(&connack_props);\n    329  \treturn rc;\n    330  }\nFunction: connection_check_acl\nPath: /root/projects/mosquitto/src/handle_connect.c:86\n    86   static void connection_check_acl(struct mosquitto *context, struct mosquitto_client_msg **head)\n    87   {\n    88   \tstruct mosquitto_client_msg *msg_tail, *tmp;\n    89   \tint access;\n    90   \n    91   \tDL_FOREACH_SAFE((*head), msg_tail, tmp){\n    92   \t\tif(msg_tail->direction == mosq_md_out){\n    93   \t\t\taccess = MOSQ_ACL_READ;\n    94   \t\t}else{\n    95   \t\t\taccess = MOSQ_ACL_WRITE;\n    96   \t\t}\n    97   \t\tif(mosquitto_acl_check(context, msg_tail->store->topic,\n    98   \t\t\t\t\t\t\t   msg_tail->store->payloadlen, msg_tail->store->payload,\n    99   \t\t\t\t\t\t\t   msg_tail->store->qos, msg_tail->store->retain, access) != MOSQ_ERR_SUCCESS){\n    100  \n    101  \t\t\tDL_DELETE((*head), msg_tail);\n    102  \t\t\tdb__msg_store_ref_dec(&msg_tail->store);\n    103  \t\t\tmosquitto_property_free_all(&msg_tail->properties);\n    104  \t\t\tmosquitto__free(msg_tail);\n    105  \t\t}\n    106  \t}\n    107  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    247  \n    248  \tmosquitto__set_state(context, mosq_cs_disused);\n    249  \n    250  \tif(context->id){\n    251  \t\tcontext__remove_from_by_id(context);\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    255  \n    256  \tcontext->for_free_next = db.ll_for_free;\n    257  \tdb.ll_for_free = context;\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    296  \t\tcontext->in_by_id = true;\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    269  \tint i;\n    270  \n    271  \tmosquitto__free(store->source_id);\n    272  \tmosquitto__free(store->source_username);\n    273  \tif(store->dest_ids){\n    274  \t\tfor(i=0; i<store->dest_id_count; i++){\n    275  \t\t\tmosquitto__free(store->dest_ids[i]);\n    276  \t\t}\n    277  \t\tmosquitto__free(store->dest_ids);\n    278  \t}\n    279  \tmosquitto__free(store->topic);\n    280  \tmosquitto_property_free_all(&store->properties);\n    281  \tmosquitto__free(store->payload);\n    282  \tmosquitto__free(store);\n    283  }\nFunction: db__message_remove_from_inflight\nPath: /root/projects/mosquitto/src/database.c:347\n    347  static void db__message_remove_from_inflight(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    348  {\n    349  \tif(!msg_data || !item){\n    350  \t\treturn;\n    351  \t}\n    352  \n    353  \tDL_DELETE(msg_data->inflight, item);\n    354  \tif(item->store){\n    355  \t\tdb__msg_remove_from_inflight_stats(msg_data, item);\n    356  \t\tdb__msg_store_ref_dec(&item->store);\n    357  \t}\n    358  \n    359  \tmosquitto_property_free_all(&item->properties);\n    360  \tmosquitto__free(item);\n    361  }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1088 \tmosquitto_property *cmsg_props = NULL, *store_props = NULL;\n    1089 \tint rc;\n    1090 \tuint16_t mid;\n    1091 \tint retries;\n    1092 \tint retain;\n    1093 \tconst char *topic;\n    1094 \tuint8_t qos;\n    1095 \tuint32_t payloadlen;\n    1096 \tconst void *payload;\n    1097 \tuint32_t expiry_interval;\n    1098 \n    1099 \texpiry_interval = 0;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1102 \t\t\t/* Message is expired, must not send. */\n    1103 \t\t\tif(msg->direction == mosq_md_out && msg->qos > 0){\n    1104 \t\t\t\tutil__increment_send_quota(context);\n    1105 \t\t\t}\n    1106 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1121 \n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1126 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1131 \n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1135 \t\t\t\tmsg->timestamp = db.now_s;\n    1136 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1137 \t\t\t\tmsg->state = mosq_ms_wait_for_puback;\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1139 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1144 \n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1148 \t\t\t\tmsg->timestamp = db.now_s;\n    1149 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1150 \t\t\t\tmsg->state = mosq_ms_wait_for_pubrec;\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1152 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1157 \n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1159 \t\t\trc = send__pubrel(context, mid, NULL);\n    1160 \t\t\tif(!rc){\n    1161 \t\t\t\tmsg->state = mosq_ms_wait_for_pubcomp;\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1166 \n    1167 \t\tcase mosq_ms_invalid:\n    1168 \t\tcase mosq_ms_send_pubrec:\n    1169 \t\tcase mosq_ms_resend_pubcomp:\n    1170 \t\tcase mosq_ms_wait_for_puback:\n    1171 \t\tcase mosq_ms_wait_for_pubrec:\n    1172 \t\tcase mosq_ms_wait_for_pubrel:\n    1173 \t\tcase mosq_ms_wait_for_pubcomp:\n    1174 \t\tcase mosq_ms_queued:\n    1175 \t\t\tbreak;\n    1176 \t}\n    1177 \treturn MOSQ_ERR_SUCCESS;\n    1178 }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    448  \tstruct mosquitto_client_msg *msg;\n    449  \tstruct mosquitto_msg_data *msg_data;\n    450  \tenum mosquitto_msg_state state = mosq_ms_invalid;\n    451  \tint rc = 0;\n    452  \tint i;\n    453  \tchar **dest_ids;\n    454  \n    455  \tassert(stored);\n    456  \tif(!context) return MOSQ_ERR_INVAL;\n    457  \tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n    458  \n    459  \tif(dir == mosq_md_out){\n    460  \t\tmsg_data = &context->msgs_out;\n    461  \t}else{\n    462  \t\tmsg_data = &context->msgs_in;\n    463  \t}\n    464  \n    465  \t/* Check whether we've already sent this message to this client\n    466  \t * for outgoing messages only.\n    467  \t * If retain==true then this is a stale retained message and so should be\n    468  \t * sent regardless. FIXME - this does mean retained messages will received\n    469  \t * multiple times for overlapping subscriptions, although this is only the\n    470  \t * case for SUBSCRIPTION with multiple subs in so is a minor concern.\n    471  \t */\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    475  \n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    478  \t\t\t\t/* We have already sent this message to this client. */\n    479  \t\t\t\tmosquitto_property_free_all(&properties);\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    484  \tif(context->sock == INVALID_SOCKET){\n    485  \t\t/* Client is not connected only queue messages with QoS>0. */\n    486  \t\tif(qos == 0 && !db.config->queue_qos0_messages){\n    487  \t\t\tif(!context->bridge){\n    488  \t\t\t\tmosquitto_property_free_all(&properties);\n    489  \t\t\t\treturn 2;\n    490  \t\t\t}else{\n    491  \t\t\t\tif(context->bridge->start_type != bst_lazy){\n    492  \t\t\t\t\tmosquitto_property_free_all(&properties);\n    493  \t\t\t\t\treturn 2;\n    494  \t\t\t\t}\n    495  \t\t\t}\n    496  \t\t}\n    497  \t\tif(context->bridge && context->bridge->clean_start_local == true){\n    498  \t\t\tmosquitto_property_free_all(&properties);\n    499  \t\t\treturn 2;\n    500  \t\t}\n    501  \t}\n    502  \n    503  \tif(context->sock != INVALID_SOCKET){\n    504  \t\tif(db__ready_for_flight(context, dir, qos)){\n    505  \t\t\tif(dir == mosq_md_out){\n    506  \t\t\t\tswitch(qos){\n    507  \t\t\t\t\tcase 0:\n    508  \t\t\t\t\t\tstate = mosq_ms_publish_qos0;\n    509  \t\t\t\t\t\tbreak;\n    510  \t\t\t\t\tcase 1:\n    511  \t\t\t\t\t\tstate = mosq_ms_publish_qos1;\n    512  \t\t\t\t\t\tbreak;\n    513  \t\t\t\t\tcase 2:\n    514  \t\t\t\t\t\tstate = mosq_ms_publish_qos2;\n    515  \t\t\t\t\t\tbreak;\n    516  \t\t\t\t}\n    517  \t\t\t}else{\n    518  \t\t\t\tif(qos == 2){\n    519  \t\t\t\t\tstate = mosq_ms_wait_for_pubrel;\n    520  \t\t\t\t}else{\n    521  \t\t\t\t\tmosquitto_property_free_all(&properties);\n    522  \t\t\t\t\treturn 1;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n    526  \t\t\tstate = mosq_ms_queued;\n    527  \t\t\trc = 2;\n    528  \t\t}else{\n    529  \t\t\t/* Dropping message due to full queue. */\n    530  \t\t\tif(context->is_dropping == false){\n    531  \t\t\t\tcontext->is_dropping = true;\n    532  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    533  \t\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n    534  \t\t\t\t\t\tcontext->id);\n    535  \t\t\t}\n    536  \t\t\tG_MSGS_DROPPED_INC();\n    537  \t\t\tmosquitto_property_free_all(&properties);\n    538  \t\t\treturn 2;\n    539  \t\t}\n    540  \t}else{\n    541  \t\tif (db__ready_for_queue(context, qos, msg_data)){\n    542  \t\t\tstate = mosq_ms_queued;\n    543  \t\t}else{\n    544  \t\t\tG_MSGS_DROPPED_INC();\n    545  \t\t\tif(context->is_dropping == false){\n    546  \t\t\t\tcontext->is_dropping = true;\n    547  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    548  \t\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n    549  \t\t\t\t\t\tcontext->id);\n    550  \t\t\t}\n    551  \t\t\tmosquitto_property_free_all(&properties);\n    552  \t\t\treturn 2;\n    553  \t\t}\n    554  \t}\n    555  \tassert(state != mosq_ms_invalid);\n    556  \n    557  #ifdef WITH_PERSISTENCE\n    558  \tif(state == mosq_ms_queued){\n    559  \t\tdb.persistence_changes++;\n    560  \t}\n    561  #endif\n    562  \n    563  \tmsg = mosquitto__calloc(1, sizeof(struct mosquitto_client_msg));\n    564  \tif(!msg) return MOSQ_ERR_NOMEM;\n    565  \tmsg->prev = NULL;\n    566  \tmsg->next = NULL;\n    567  \tmsg->store = stored;\n    568  \tdb__msg_store_ref_inc(msg->store);\n    569  \tmsg->mid = mid;\n    570  \tmsg->timestamp = db.now_s;\n    571  \tmsg->direction = dir;\n    572  \tmsg->state = state;\n    573  \tmsg->dup = false;\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    577  \t\tmsg->qos = qos;\n    578  \t}\n    579  \tmsg->retain = retain;\n    580  \tmsg->properties = properties;\n    581  \n    582  \tif(state == mosq_ms_queued){\n    583  \t\tDL_APPEND(msg_data->queued, msg);\n    584  \t\tdb__msg_add_to_queued_stats(msg_data, msg);\n    585  \t}else{\n    586  \t\tDL_APPEND(msg_data->inflight, msg);\n    587  \t\tdb__msg_add_to_inflight_stats(msg_data, msg);\n    588  \t}\n    589  \n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    591  \t\t/* Record which client ids this message has been sent to so we can avoid duplicates.\n    592  \t\t * Outgoing messages only.\n    593  \t\t * If retain==true then this is a stale retained message and so should be\n    594  \t\t * sent regardless. FIXME - this does mean retained messages will received\n    595  \t\t * multiple times for overlapping subscriptions, although this is only the\n    596  \t\t * case for SUBSCRIPTION with multiple subs in so is a minor concern.\n    597  \t\t */\n    598  \t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n    599  \t\tif(dest_ids){\n    600  \t\t\tstored->dest_ids = dest_ids;\n    601  \t\t\tstored->dest_id_count++;\n    602  \t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t}\n    609  \t}\n    610  #ifdef WITH_BRIDGE\n    611  \tif(context->bridge && context->bridge->start_type == bst_lazy\n    612  \t\t\t&& context->sock == INVALID_SOCKET\n    613  \t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n    614  \n    615  \t\tcontext->bridge->lazy_reconnect = true;\n    616  \t}\n    617  #endif\n    618  \n    619  \tif(dir == mosq_md_out && msg->qos > 0 && state != mosq_ms_queued){\n    620  \t\tutil__decrement_send_quota(context);\n    621  \t}else if(dir == mosq_md_in && msg->qos > 0 && state != mosq_ms_queued){\n    622  \t\tutil__decrement_receive_quota(context);\n    623  \t}\n    624  \n    625  \tif(dir == mosq_md_out && update){\n    626  \t\trc = db__message_write_inflight_out_latest(context);\n    627  \t\tif(rc) return rc;\n    628  \t\trc = db__message_write_queued_out(context);\n    629  \t\tif(rc) return rc;\n    630  \t}\n    631  \n    632  \treturn rc;\n    633  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    704  \tstruct mosquitto_msg_store *stored;\n    705  \tconst char *source_id;\n    706  \tenum mosquitto_msg_origin origin;\n    707  \n    708  \tif(!topic) return MOSQ_ERR_INVAL;\n    709  \n    710  \tstored = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    711  \tif(stored == NULL) return MOSQ_ERR_NOMEM;\n    712  \n    713  \tstored->topic = mosquitto__strdup(topic);\n    714  \tif(stored->topic == NULL){\n    715  \t\tdb__msg_store_free(stored);\n    716  \t\treturn MOSQ_ERR_INVAL;\n    717  \t}\n    718  \n    719  \tstored->qos = qos;\n    720  \tif(db.config->retain_available == false){\n    721  \t\tstored->retain = 0;\n    722  \t}else{\n    723  \t\tstored->retain = retain;\n    724  \t}\n    725  \n    726  \tstored->payloadlen = payloadlen;\n    727  \tif(payloadlen > 0){\n    728  \t\tstored->payload = mosquitto__malloc(stored->payloadlen+1);\n    729  \t\tif(stored->payload == NULL){\n    730  \t\t\tdb__msg_store_free(stored);\n    731  \t\t\treturn MOSQ_ERR_NOMEM;\n    732  \t\t}\n    733  \t\t/* Ensure payload is always zero terminated, this is the reason for the extra byte above */\n    734  \t\t((uint8_t *)stored->payload)[stored->payloadlen] = 0;\n    735  \t\tmemcpy(stored->payload, payload, stored->payloadlen);\n    736  \t}\n    737  \n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    741  \t\tsource_id = \"\";\n    742  \t}\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    745  \t\t*properties = NULL;\n    746  \t}\n    747  \n    748  \tif(context){\n    749  \t\torigin = mosq_mo_client;\n    750  \t}else{\n    751  \t\torigin = mosq_mo_broker;\n    752  \t}\n    753  \tif(db__message_store(context, stored, message_expiry_interval, 0, origin)) return 1;\n    754  \n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    761  \tassert(stored);\n    762  \n    763  \tif(source && source->id){\n    764  \t\tstored->source_id = mosquitto__strdup(source->id);\n    765  \t}else{\n    766  \t\tstored->source_id = mosquitto__strdup(\"\");\n    767  \t}\n    768  \tif(!stored->source_id){\n    769  \t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n    770  \t\tdb__msg_store_free(stored);\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    773  \n    774  \tif(source && source->username){\n    775  \t\tstored->source_username = mosquitto__strdup(source->username);\n    776  \t\tif(!stored->source_username){\n    777  \t\t\tdb__msg_store_free(stored);\n    778  \t\t\treturn MOSQ_ERR_NOMEM;\n    779  \t\t}\n    780  \t}\n    781  \tif(source){\n    782  \t\tstored->source_listener = source->listener;\n    783  \t}\n    784  \tstored->mid = 0;\n    785  \tstored->origin = origin;\n    786  \tif(message_expiry_interval > 0){\n    787  \t\tstored->message_expiry_time = db.now_real_s + message_expiry_interval;\n    788  \t}else{\n    789  \t\tstored->message_expiry_time = 0;\n    790  \t}\n    791  \n    792  \tstored->dest_ids = NULL;\n    793  \tstored->dest_id_count = 0;\n    794  \tdb.msg_store_count++;\n    795  \tdb.msg_store_bytes += stored->payloadlen;\n    796  \n    797  \tif(!store_id){\n    798  \t\tstored->db_id = ++db.last_db_id;\n    799  \t}else{\n    800  \t\tstored->db_id = store_id;\n    801  \t}\n    802  \n    803  \tdb__msg_store_add(stored);\n    804  \n    805  \treturn MOSQ_ERR_SUCCESS;\n    806  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    435  \tuint8_t will, will_retain, will_qos, clean_start;\n    436  \tuint8_t username_flag, password_flag;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    445  \tbool allow_zero_length_clientid;\n    446  #ifdef WITH_TLS\n    447  \tint i;\n    448  \tX509 *client_cert = NULL;\n    449  \tX509_NAME *name;\n    450  \tX509_NAME_ENTRY *name_entry;\n    451  \tASN1_STRING *name_asn1 = NULL;\n    452  \tBIO *subject_bio;\n    453  \tchar *data_start;\n    454  \tlong name_length;\n    455  \tchar *subject;\n    456  #endif\n    457  \n    458  \tG_CONNECTION_COUNT_INC();\n    459  \n    460  \tif(!context->listener){\n    461  \t\treturn MOSQ_ERR_INVAL;\n    462  \t}\n    463  \n    464  \t/* Don't accept multiple CONNECT commands. */\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    467  \t\trc = MOSQ_ERR_PROTOCOL;\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    470  \n    471  \t/* Read protocol name as length then bytes rather than with read_string\n    472  \t * because the length is fixed and we can check that. Removes the need\n    473  \t * for another malloc as well. */\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    475  \t\trc = MOSQ_ERR_PROTOCOL;\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    479  \t\trc = MOSQ_ERR_PROTOCOL;\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    483  \t\trc = MOSQ_ERR_PROTOCOL;\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    487  \n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    489  \t\trc = MOSQ_ERR_PROTOCOL;\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    499  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    502  \t\tcontext->protocol = mosq_p_mqtt31;\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    504  \t\t\tcontext->is_bridge = true;\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    508  \t\t\tcontext->protocol = mosq_p_mqtt311;\n    509  \n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    511  \t\t\t\tcontext->is_bridge = true;\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    514  \t\t\tcontext->protocol = mosq_p_mqtt5;\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    521  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    525  \t\t\t/* Reserved flags not set to 0, must disconnect. */\n    526  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    534  \t\trc = MOSQ_ERR_PROTOCOL;\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    540  \n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    542  \t\trc = MOSQ_ERR_PROTOCOL;\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    547  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    551  \n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    553  \t/* session_expiry_interval will be overriden if the properties are read later */\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    555  \t\t/* v3* has clean_start == false mean the session never expires */\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    563  \t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid Will QoS in CONNECT from %s.\",\n    564  \t\t\t\tcontext->address);\n    565  \t\trc = MOSQ_ERR_PROTOCOL;\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    571  \n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    576  \t\trc = MOSQ_ERR_NOT_SUPPORTED;\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    579  \n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    581  \t\trc = MOSQ_ERR_PROTOCOL;\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    584  \n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    590  \n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    595  \t\trc = MOSQ_ERR_NOT_SUPPORTED;\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    598  \n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    602  \n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    604  \n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    606  \t\trc = MOSQ_ERR_PROTOCOL;\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    609  \n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    613  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    618  \n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    630  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    639  \t\t\t\t\trc = MOSQ_ERR_NOMEM;\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    646  \n    647  \t/* clientid_prefixes check */\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    655  \t\t\trc = MOSQ_ERR_AUTH;\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    659  \n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    666  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    671  \n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    675  \t\t\trc = MOSQ_ERR_NOMEM;\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    679  \t\t\t\t/* Username flag given, but no username. Ignore. */\n    680  \t\t\t\tusername_flag = 0;\n    681  \t\t\t}else{\n    682  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    689  \t\t\t\t/* username_flag == 0 && password_flag == 1 is forbidden */\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    691  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    699  \t\t\trc = MOSQ_ERR_NOMEM;\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    703  \t\t\t\t/* Password flag given, but no password. Ignore. */\n    704  \t\t\t}else{\n    705  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    710  \n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    712  \t\t/* Surplus data at end of packet, this must be an error. */\n    713  \t\trc = MOSQ_ERR_PROTOCOL;\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    716  \n    717  \t/* Once context->id is set, if we return from this function with an error\n    718  \t * we must make sure that context->id is freed and set to NULL, so that the\n    719  \t * client isn't erroneously removed from the by_id hash table. */\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    722  \n    723  #ifdef WITH_TLS\n    724  \tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    725  \t\t/* Don't need the username or password if provided */\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    730  \n    731  \t\tif(!context->ssl){\n    732  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    734  \t\t\t}else{\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    736  \t\t\t}\n    737  \t\t\trc = MOSQ_ERR_AUTH;\n    738  \t\t\tgoto handle_connect_error;\n    739  \t\t}\n    740  #ifdef FINAL_WITH_TLS_PSK\n    741  \t\tif(context->listener->psk_hint){\n    742  \t\t\t/* Client should have provided an identity to get this far. */\n    743  \t\t\tif(!context->username){\n    744  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    746  \t\t\t\t}else{\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    748  \t\t\t\t}\n    749  \t\t\t\trc = MOSQ_ERR_AUTH;\n    750  \t\t\t\tgoto handle_connect_error;\n    751  \t\t\t}\n    752  \t\t}else{\n    753  #endif /* FINAL_WITH_TLS_PSK */\n    754  \t\t\tclient_cert = SSL_get_peer_certificate(context->ssl);\n    755  \t\t\tif(!client_cert){\n    756  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    758  \t\t\t\t}else{\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    760  \t\t\t\t}\n    761  \t\t\t\trc = MOSQ_ERR_AUTH;\n    762  \t\t\t\tgoto handle_connect_error;\n    763  \t\t\t}\n    764  \t\t\tname = X509_get_subject_name(client_cert);\n    765  \t\t\tif(!name){\n    766  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    768  \t\t\t\t}else{\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    770  \t\t\t\t}\n    771  \t\t\t\trc = MOSQ_ERR_AUTH;\n    772  \t\t\t\tgoto handle_connect_error;\n    773  \t\t\t}\n    774  \t\t\tif (context->listener->use_identity_as_username) { /* use_identity_as_username */\n    775  \t\t\t\ti = X509_NAME_get_index_by_NID(name, NID_commonName, -1);\n    776  \t\t\t\tif(i == -1){\n    777  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    779  \t\t\t\t\t}else{\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    781  \t\t\t\t\t}\n    782  \t\t\t\t\trc = MOSQ_ERR_AUTH;\n    783  \t\t\t\t\tgoto handle_connect_error;\n    784  \t\t\t\t}\n    785  \t\t\t\tname_entry = X509_NAME_get_entry(name, i);\n    786  \t\t\t\tif(name_entry){\n    787  \t\t\t\t\tname_asn1 = X509_NAME_ENTRY_get_data(name_entry);\n    788  \t\t\t\t\tif (name_asn1 == NULL) {\n    789  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    791  \t\t\t\t\t\t}else{\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    793  \t\t\t\t\t\t}\n    794  \t\t\t\t\t\trc = MOSQ_ERR_AUTH;\n    795  \t\t\t\t\t\tgoto handle_connect_error;\n    796  \t\t\t\t\t}\n    797  \t\t\t\t\tconst char *new_username;\n    798  #if OPENSSL_VERSION_NUMBER < 0x10100000L\n    799  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_data(name_asn1);\n    800  #else\n    801  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_get0_data(name_asn1);\n    802  #endif\n    803  \t\t\t\t\tif(mosquitto_validate_utf8(new_username, (int)strlen(new_username))){\n    804  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    806  \t\t\t\t\t\t}else{\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    808  \t\t\t\t\t\t}\n    809  \t\t\t\t\t\tX509_free(client_cert);\n    810  \t\t\t\t\t\treturn MOSQ_ERR_AUTH;\n    811  \t\t\t\t\t}\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    814  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    816  \t\t\t\t\t\t}else{\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    818  \t\t\t\t\t\t}\n    819  \t\t\t\t\t\trc = MOSQ_ERR_NOMEM;\n    820  \t\t\t\t\t\tgoto handle_connect_error;\n    821  \t\t\t\t\t}\n    822  \t\t\t\t\t/* Make sure there isn't an embedded NUL character in the CN */\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    824  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    826  \t\t\t\t\t\t}else{\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    828  \t\t\t\t\t\t}\n    829  \t\t\t\t\t\trc = MOSQ_ERR_AUTH;\n    830  \t\t\t\t\t\tgoto handle_connect_error;\n    831  \t\t\t\t\t}\n    832  \t\t\t\t}\n    833  \t\t\t} else { /* use_subject_as_username */\n    834  \t\t\t\tsubject_bio = BIO_new(BIO_s_mem());\n    835  \t\t\t\tX509_NAME_print_ex(subject_bio, X509_get_subject_name(client_cert), 0, XN_FLAG_RFC2253);\n    836  \t\t\t\tdata_start = NULL;\n    837  \t\t\t\tname_length = BIO_get_mem_data(subject_bio, &data_start);\n    838  \t\t\t\tsubject = mosquitto__malloc(sizeof(char)*(size_t)(name_length+1));\n    839  \t\t\t\tif(!subject){\n    840  \t\t\t\t\tBIO_free(subject_bio);\n    841  \t\t\t\t\trc = MOSQ_ERR_NOMEM;\n    842  \t\t\t\t\tgoto handle_connect_error;\n    843  \t\t\t\t}\n    844  \t\t\t\tmemcpy(subject, data_start, (size_t)name_length);\n    845  \t\t\t\tsubject[name_length] = '\\0';\n    846  \t\t\t\tBIO_free(subject_bio);\n    847  \t\t\t\tcontext->username = subject;\n    848  \t\t\t}\n    849  \t\t\tif(!context->username){\n    850  \t\t\t\trc = MOSQ_ERR_AUTH;\n    851  \t\t\t\tgoto handle_connect_error;\n    852  \t\t\t}\n    853  \t\t\tX509_free(client_cert);\n    854  \t\t\tclient_cert = NULL;\n    855  #ifdef FINAL_WITH_TLS_PSK\n    856  \t\t}\n    857  #endif /* FINAL_WITH_TLS_PSK */\n    858  \t}else\n    859  #endif /* WITH_TLS */\n    860  \t{\n    861  \t\t/* FIXME - these ensure the mosquitto_client_id() and\n    862  \t\t * mosquitto_client_username() functions work, but is hacky */\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    867  \t}\n    868  \n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    874  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    883  \t\t\trc = MOSQ_ERR_AUTH;\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    890  \n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    893  \t\tmosquitto__free(auth_data);\n    894  \t\tauth_data = NULL;\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    898  \t\t\tmosquitto__set_state(context, mosq_cs_authenticating);\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    900  \t\t\tfree(auth_data_out);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    903  \t\t\tfree(auth_data_out);\n    904  \t\t\tauth_data_out = NULL;\n    905  \t\t\twill__clear(context);\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    912  \t\t\t\t/* Client has requested extended authentication, but we don't support it. */\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    924  #ifdef WITH_TLS\n    925  \t\tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    926  \t\t\t/* Authentication assumed to be cleared */\n    927  \t\t}else\n    928  #endif\n    929  \t\t{\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    932  \t\t\t\tcase MOSQ_ERR_SUCCESS:\n    933  \t\t\t\t\tbreak;\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    940  \t\t\t\t\trc = MOSQ_ERR_AUTH;\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    944  \t\t\t\t\trc = MOSQ_ERR_UNKNOWN;\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    948  \t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    951  \n    952  \n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    955  \tmosquitto__free(auth_data);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    972  #ifdef WITH_TLS\n    973  \tif(client_cert) X509_free(client_cert);\n    974  #endif\n    975  \t/* We return an error here which means the client is freed later on. */\n    976  \tcontext->clean_start = true;\n    977  \tcontext->session_expiry_interval = 0;\n    978  \tcontext->will_delay_interval = 0;\n    979  \treturn rc;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    53   \tchar *client_id;\n    54   \tuint8_t rnd[16];\n    55   \tint i;\n    56   \tint pos;\n    57   \n    58   \tif(util__random_bytes(rnd, 16)) return NULL;\n    59   \n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    61   \n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    69   \n    70   \tpos = 0;\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    80   \n    81   \treturn client_id;\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    335  \tint rc = MOSQ_ERR_SUCCESS;\n    336  \tsize_t slen;\n    337  \tuint16_t tlen;\n    338  \tstruct mosquitto_message_all *will_struct = NULL;\n    339  \tchar *will_topic_mount = NULL;\n    340  \tuint16_t payloadlen;\n    341  \tmosquitto_property *properties = NULL;\n    342  \n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    344  \tif(!will_struct){\n    345  \t\trc = MOSQ_ERR_NOMEM;\n    346  \t\tgoto error_cleanup;\n    347  \t}\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    349  \t\trc = property__read_all(CMD_WILL, &context->in_packet, &properties);\n    350  \t\tif(rc) goto error_cleanup;\n    351  \n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    353  \t\tmosquitto_property_free_all(&properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    356  \trc = packet__read_string(&context->in_packet, &will_struct->msg.topic, &tlen);\n    357  \tif(rc) goto error_cleanup;\n    358  \tif(!tlen){\n    359  \t\trc = MOSQ_ERR_PROTOCOL;\n    360  \t\tgoto error_cleanup;\n    361  \t}\n    362  \n    363  \tif(context->listener->mount_point){\n    364  \t\tslen = strlen(context->listener->mount_point) + strlen(will_struct->msg.topic) + 1;\n    365  \t\twill_topic_mount = mosquitto__malloc(slen+1);\n    366  \t\tif(!will_topic_mount){\n    367  \t\t\trc = MOSQ_ERR_NOMEM;\n    368  \t\t\tgoto error_cleanup;\n    369  \t\t}\n    370  \n    371  \t\tsnprintf(will_topic_mount, slen, \"%s%s\", context->listener->mount_point, will_struct->msg.topic);\n    372  \t\twill_topic_mount[slen] = '\\0';\n    373  \n    374  \t\tmosquitto__free(will_struct->msg.topic);\n    375  \t\twill_struct->msg.topic = will_topic_mount;\n    376  \t}\n    377  \n    378  \tif(!strncmp(will_struct->msg.topic, \"$CONTROL/\", strlen(\"$CONTROL/\"))){\n    379  \t\trc = MOSQ_ERR_ACL_DENIED;\n    380  \t\tgoto error_cleanup;\n    381  \t}\n    382  \trc = mosquitto_pub_topic_check(will_struct->msg.topic);\n    383  \tif(rc) goto error_cleanup;\n    384  \n    385  \trc = packet__read_uint16(&context->in_packet, &payloadlen);\n    386  \tif(rc) goto error_cleanup;\n    387  \n    388  \twill_struct->msg.payloadlen = payloadlen;\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    391  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Client %s connected with too large Will payload\", client_id);\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    393  \t\t\t\tsend__connack(context, 0, MQTT_RC_PACKET_TOO_LARGE, NULL);\n    394  \t\t\t}else{\n    395  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    396  \t\t\t}\n    397  \t\t\trc = MOSQ_ERR_PAYLOAD_SIZE;\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    400  \t\twill_struct->msg.payload = mosquitto__malloc((size_t)will_struct->msg.payloadlen);\n    401  \t\tif(!will_struct->msg.payload){\n    402  \t\t\trc = MOSQ_ERR_NOMEM;\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    405  \n    406  \t\trc = packet__read_bytes(&context->in_packet, will_struct->msg.payload, (uint32_t)will_struct->msg.payloadlen);\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    409  \n    410  \twill_struct->msg.qos = will_qos;\n    411  \twill_struct->msg.retain = will_retain;\n    412  \n    413  \t*will = will_struct;\n    414  \treturn MOSQ_ERR_SUCCESS;\n    415  \n    416  error_cleanup:\n    417  \tif(will_struct){\n    418  \t\tmosquitto__free(will_struct->msg.topic);\n    419  \t\tmosquitto__free(will_struct->msg.payload);\n    420  \t\tmosquitto_property_free_all(&will_struct->properties);\n    421  \t\tmosquitto__free(will_struct);\n    422  \t}\n    423  \treturn rc;\n    424  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    51   \tassert(packet);\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    53   \n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    56   \n    57   \treturn MOSQ_ERR_SUCCESS;\n    58   }\nFunction: packet__write_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:61\n    61   void packet__write_byte(struct mosquitto__packet *packet, uint8_t byte)\n    62   {\n    63   \tassert(packet);\n    64   \tassert(packet->pos+1 <= packet->packet_length);\n    65   \n    66   \tpacket->payload[packet->pos] = byte;\n    67   \tpacket->pos++;\n    68   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    73   \tassert(packet);\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    75   \n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    78   \n    79   \treturn MOSQ_ERR_SUCCESS;\n    80   }\nFunction: packet__write_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:83\n    83   void packet__write_bytes(struct mosquitto__packet *packet, const void *bytes, uint32_t count)\n    84   {\n    85   \tassert(packet);\n    86   \tassert(packet->pos+count <= packet->packet_length);\n    87   \n    88   \tif(count > 0){\n    89   \t\tmemcpy(&(packet->payload[packet->pos]), bytes, count);\n    90   \t\tpacket->pos += count;\n    91   \t}\n    92   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    98   \tint rc;\n    99   \n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    103  \n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    106  \t\t*length = 0;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    109  \n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    111  \n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    120  \n    121  \t*length = slen;\n    122  \treturn MOSQ_ERR_SUCCESS;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    155  \tuint8_t msb, lsb;\n    156  \n    157  \tassert(packet);\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    159  \n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    164  \n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    166  \n    167  \treturn MOSQ_ERR_SUCCESS;\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    128  \tint rc;\n    129  \n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    133  \n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    140  \n    141  \treturn MOSQ_ERR_SUCCESS;\n    142  }\nFunction: packet__write_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:145\n    145  void packet__write_string(struct mosquitto__packet *packet, const char *str, uint16_t length)\n    146  {\n    147  \tassert(packet);\n    148  \tpacket__write_uint16(packet, length);\n    149  \tpacket__write_bytes(packet, str, length);\n    150  }\nFunction: packet__write_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:171\n    171  void packet__write_uint16(struct mosquitto__packet *packet, uint16_t word)\n    172  {\n    173  \tpacket__write_byte(packet, MOSQ_MSB(word));\n    174  \tpacket__write_byte(packet, MOSQ_LSB(word));\n    175  }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    280  #ifdef WITH_WEBSOCKETS\n    281  \tbool is_duplicate = false;\n    282  #endif\n    283  \n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    287  #ifdef WITH_WEBSOCKETS\n    288  \tif(context->wsi){\n    289  \t\tif(context->state == mosq_cs_duplicate){\n    290  \t\t\tis_duplicate = true;\n    291  \t\t}\n    292  \n    293  \t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    294  \t\t\tmosquitto__set_state(context, mosq_cs_disconnect_ws);\n    295  \t\t}\n    296  \t\tif(context->wsi){\n    297  \t\t\tlws_callback_on_writable(context->wsi);\n    298  \t\t}\n    299  \t\tif(context->sock != INVALID_SOCKET){\n    300  \t\t\tHASH_DELETE(hh_sock, db.contexts_by_sock, context);\n    301  \t\t\tmux__delete(context);\n    302  \t\t\tcontext->sock = INVALID_SOCKET;\n    303  \t\t}\n    304  \t\tif(is_duplicate){\n    305  \t\t\t/* This occurs if another client is taking over the same client id.\n    306  \t\t\t * It is important to remove this from the by_id hash here, so it\n    307  \t\t\t * doesn't leave us with multiple clients in the hash with the same\n    308  \t\t\t * id. Websockets doesn't actually close the connection here,\n    309  \t\t\t * unlike for normal clients, which means there is extra time when\n    310  \t\t\t * there could be two clients with the same id in the hash. */\n    311  \t\t\tcontext__remove_from_by_id(context);\n    312  \t\t}\n    313  \t}else\n    314  #endif\n    315  \t{\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    320  \t\t\t\tid = \"<unknown>\";\n    321  \t\t\t}\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    324  \t\t\t\t\tcase MOSQ_ERR_SUCCESS:\n    325  \t\t\t\t\t\tbreak;\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    371  \t\tmux__delete(context);\n    372  \t\tcontext__disconnect(context);\n    373  \t}\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    52   \tvoid *mem;\n    53   #ifdef REAL_WITH_MEMORY_TRACKING\n    54   \tif(mem_limit && memcount + size > mem_limit){\n    55   \t\treturn NULL;\n    56   \t}\n    57   #endif\n    58   \tmem = calloc(nmemb, size);\n    59   \n    60   #ifdef REAL_WITH_MEMORY_TRACKING\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    63   \t\tif(memcount > max_memcount){\n    64   \t\t\tmax_memcount = memcount;\n    65   \t\t}\n    66   \t}\n    67   #endif\n    68   \n    69   \treturn mem;\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    74   #ifdef REAL_WITH_MEMORY_TRACKING\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    79   #endif\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto__malloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:83\n    83   void *mosquitto__malloc(size_t size)\n    84   {\n    85   \tvoid *mem;\n    86   \n    87   #ifdef REAL_WITH_MEMORY_TRACKING\n    88   \tif(mem_limit && memcount + size > mem_limit){\n    89   \t\treturn NULL;\n    90   \t}\n    91   #endif\n    92   \n    93   \tmem = malloc(size);\n    94   \n    95   #ifdef REAL_WITH_MEMORY_TRACKING\n    96   \tif(mem){\n    97   \t\tmemcount += malloc_usable_size(mem);\n    98   \t\tif(memcount > max_memcount){\n    99   \t\t\tmax_memcount = memcount;\n    100  \t\t}\n    101  \t}\n    102  #endif\n    103  \n    104  \treturn mem;\n    105  }\nFunction: mosquitto__realloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:119\n    119  void *mosquitto__realloc(void *ptr, size_t size)\n    120  {\n    121  \tvoid *mem;\n    122  #ifdef REAL_WITH_MEMORY_TRACKING\n    123  \tif(mem_limit && memcount + size > mem_limit){\n    124  \t\treturn NULL;\n    125  \t}\n    126  \tif(ptr){\n    127  \t\tmemcount -= malloc_usable_size(ptr);\n    128  \t}\n    129  #endif\n    130  \tmem = realloc(ptr, size);\n    131  \n    132  #ifdef REAL_WITH_MEMORY_TRACKING\n    133  \tif(mem){\n    134  \t\tmemcount += malloc_usable_size(mem);\n    135  \t\tif(memcount > max_memcount){\n    136  \t\t\tmax_memcount = memcount;\n    137  \t\t}\n    138  \t}\n    139  #endif\n    140  \n    141  \treturn mem;\n    142  }\nFunction: mosquitto__strdup\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:144\n    144  char *mosquitto__strdup(const char *s)\n    145  {\n    146  \tchar *str;\n    147  #ifdef REAL_WITH_MEMORY_TRACKING\n    148  \tif(mem_limit && memcount + strlen(s) > mem_limit){\n    149  \t\treturn NULL;\n    150  \t}\n    151  #endif\n    152  \tstr = strdup(s);\n    153  \n    154  #ifdef REAL_WITH_MEMORY_TRACKING\n    155  \tif(str){\n    156  \t\tmemcount += malloc_usable_size(str);\n    157  \t\tif(memcount > max_memcount){\n    158  \t\t\tmax_memcount = memcount;\n    159  \t\t}\n    160  \t}\n    161  #endif\n    162  \n    163  \treturn str;\n    164  }\nFunction: mosquitto_free\nPath: /root/projects/mosquitto/src/memory_public.c:27\n    27   void mosquitto_free(void *mem)\n    28   {\n    29   \tmosquitto__free(mem);\n    30   }\nFunction: mosquitto_malloc\nPath: /root/projects/mosquitto/src/memory_public.c:32\n    32   void *mosquitto_malloc(size_t size)\n    33   {\n    34   \treturn mosquitto__malloc(size);\n    35   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    30   \tstruct mosquitto__packet *packet = NULL;\n    31   \tint rc;\n    32   \tmosquitto_property *connack_props = NULL;\n    33   \tuint32_t remaining_length;\n    34   \n    35   \trc = mosquitto_property_copy_all(&connack_props, properties);\n    36   \tif(rc){\n    37   \t\treturn rc;\n    38   \t}\n    39   \n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    43   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->address, ack, reason_code);\n    44   \t}\n    45   \n    46   \tremaining_length = 2;\n    47   \n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    50   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_RETAIN_AVAILABLE, 0);\n    51   \t\t\tif(rc){\n    52   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    57   \t\t\trc = mosquitto_property_add_int32(&connack_props, MQTT_PROP_MAXIMUM_PACKET_SIZE, db.config->max_packet_size);\n    58   \t\t\tif(rc){\n    59   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    64   \t\t\trc = mosquitto_property_add_int16(&connack_props, MQTT_PROP_RECEIVE_MAXIMUM, db.config->max_inflight_messages);\n    65   \t\t\tif(rc){\n    66   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    71   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_MAXIMUM_QOS, context->listener->max_qos);\n    72   \t\t\tif(rc){\n    73   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    77   \n    78   \t\tremaining_length += property__get_remaining_length(connack_props);\n    79   \t}\n    80   \n    81   \tif(packet__check_oversize(context, remaining_length)){\n    82   \t\tmosquitto_property_free_all(&connack_props);\n    83   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    84   \t}\n    85   \n    86   \tpacket = mosquitto__calloc(1, sizeof(struct mosquitto__packet));\n    87   \tif(!packet){\n    88   \t\tmosquitto_property_free_all(&connack_props);\n    89   \t\treturn MOSQ_ERR_NOMEM;\n    90   \t}\n    91   \n    92   \tpacket->command = CMD_CONNACK;\n    93   \tpacket->remaining_length = remaining_length;\n    94   \n    95   \trc = packet__alloc(packet);\n    96   \tif(rc){\n    97   \t\tmosquitto_property_free_all(&connack_props);\n    98   \t\tmosquitto__free(packet);\n    99   \t\treturn rc;\n    100  \t}\n    101  \tpacket__write_byte(packet, ack);\n    102  \tpacket__write_byte(packet, reason_code);\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    104  \t\tproperty__write_all(packet, connack_props, true);\n    105  \t}\n    106  \tmosquitto_property_free_all(&connack_props);\n    107  \n    108  \treturn packet__queue(context, packet);\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    39   \tstruct mosquitto__packet *packet = NULL;\n    40   \tint rc;\n    41   \n    42   \tassert(mosq);\n    43   #ifdef WITH_BROKER\n    44   #  ifdef WITH_BRIDGE\n    45   \tif(mosq->bridge){\n    46   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Bridge %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    47   \t}else\n    48   #  else\n    49   \t{\n    50   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Sending DISCONNECT to %s (rc%d)\", SAFE_PRINT(mosq->id), reason_code);\n    51   \t}\n    52   #  endif\n    53   #else\n    54   \tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Client %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    55   #endif\n    56   \tassert(mosq);\n    57   \tpacket = mosquitto__calloc(1, sizeof(struct mosquitto__packet));\n    58   \tif(!packet) return MOSQ_ERR_NOMEM;\n    59   \n    60   \tpacket->command = CMD_DISCONNECT;\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    62   \t\tpacket->remaining_length = 1;\n    63   \t\tif(properties){\n    64   \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    65   \t\t}\n    66   \t}else{\n    67   \t\tpacket->remaining_length = 0;\n    68   \t}\n    69   \n    70   \trc = packet__alloc(packet);\n    71   \tif(rc){\n    72   \t\tmosquitto__free(packet);\n    73   \t\treturn rc;\n    74   \t}\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    76   \t\tpacket__write_byte(packet, reason_code);\n    77   \t\tif(properties){\n    78   \t\t\tproperty__write_all(packet, properties, true);\n    79   \t\t}\n    80   \t}\n    81   \n    82   \treturn packet__queue(mosq, packet);\n    83   }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    123  \tstruct mosquitto__packet *packet = NULL;\n    124  \tint rc;\n    125  \n    126  \tassert(mosq);\n    127  \tpacket = mosquitto__calloc(1, sizeof(struct mosquitto__packet));\n    128  \tif(!packet) return MOSQ_ERR_NOMEM;\n    129  \n    130  \tpacket->command = command;\n    131  \tif(dup){\n    132  \t\tpacket->command |= 8;\n    133  \t}\n    134  \tpacket->remaining_length = 2;\n    135  \n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    137  \t\tif(reason_code != 0 || properties){\n    138  \t\t\tpacket->remaining_length += 1;\n    139  \t\t}\n    140  \n    141  \t\tif(properties){\n    142  \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    143  \t\t}\n    144  \t}\n    145  \n    146  \trc = packet__alloc(packet);\n    147  \tif(rc){\n    148  \t\tmosquitto__free(packet);\n    149  \t\treturn rc;\n    150  \t}\n    151  \n    152  \tpacket__write_uint16(packet, mid);\n    153  \n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tif(reason_code != 0 || properties){\n    156  \t\t\tpacket__write_byte(packet, reason_code);\n    157  \t\t}\n    158  \t\tif(properties){\n    159  \t\t\tproperty__write_all(packet, properties, true);\n    160  \t\t}\n    161  \t}\n    162  \n    163  \treturn packet__queue(mosq, packet);\n    164  }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    110  {\n    111  #ifdef WITH_BROKER\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    113  #else\n    114  \tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Client %s sending PUBREL (m%d)\", SAFE_PRINT(mosq->id), mid);\n    115  #endif\n    116  \t/* We don't use Reason String or User Property yet. */\n    117  \treturn send__command_with_mid(mosq, CMD_PUBREL|2, mid, false, 0, properties);\n    118  }\nFunction: session_expiry__remove\nPath: /root/projects/mosquitto/src/session_expiry.c:121\n    121  void session_expiry__remove(struct mosquitto *context)\n    122  {\n    123  \tif(context->expiry_list_item){\n    124  \t\tDL_DELETE(expiry_list, context->expiry_list_item);\n    125  \t\tmosquitto__free(context->expiry_list_item);\n    126  \t\tcontext->expiry_list_item = NULL;\n    127  \t}\n    128  }\nFunction: sub__remove_shared_leaf\nPath: /root/projects/mosquitto/src/subs.c:190\n    190  static void sub__remove_shared_leaf(struct mosquitto__subhier *subhier, struct mosquitto__subshared *shared, struct mosquitto__subleaf *leaf)\n    191  {\n    192  \tDL_DELETE(shared->subs, leaf);\n    193  \tif(shared->subs == NULL){\n    194  \t\tHASH_DELETE(hh, subhier->shared, shared);\n    195  \t\tmosquitto__free(shared->name);\n    196  \t\tmosquitto__free(shared);\n    197  \t}\n    198  \tmosquitto__free(leaf);\n    199  }\nFunction: sub__messages_queue\nPath: /root/projects/mosquitto/src/subs.c:659\n    659  int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n    660  {\n    661  \tint rc = MOSQ_ERR_SUCCESS, rc2;\n    662  \tint rc_normal = MOSQ_ERR_NO_SUBSCRIBERS, rc_shared = MOSQ_ERR_NO_SUBSCRIBERS;\n    663  \tstruct mosquitto__subhier *subhier;\n    664  \tchar **split_topics = NULL;\n    665  \tchar *local_topic = NULL;\n    666  \n    667  \tassert(topic);\n    668  \n    669  \tif(sub__topic_tokenise(topic, &local_topic, &split_topics, NULL)) return 1;\n    670  \n    671  \t/* Protect this message until we have sent it to all\n    672  \tclients - this is required because websockets client calls\n    673  \tdb__message_write(), which could remove the message if ref_count==0.\n    674  \t*/\n    675  \tdb__msg_store_ref_inc(*stored);\n    676  \n    677  \tHASH_FIND(hh, db.normal_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    678  \tif(subhier){\n    679  \t\trc_normal = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    680  \t\tif(rc_normal > 0){\n    681  \t\t\trc = rc_normal;\n    682  \t\t\tgoto end;\n    683  \t\t}\n    684  \t}\n    685  \n    686  \tHASH_FIND(hh, db.shared_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    687  \tif(subhier){\n    688  \t\trc_shared = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    689  \t\tif(rc_shared > 0){\n    690  \t\t\trc = rc_shared;\n    691  \t\t\tgoto end;\n    692  \t\t}\n    693  \t}\n    694  \n    695  \tif(rc_normal == MOSQ_ERR_NO_SUBSCRIBERS && rc_shared == MOSQ_ERR_NO_SUBSCRIBERS){\n    696  \t\trc = MOSQ_ERR_NO_SUBSCRIBERS;\n    697  \t}\n    698  \n    699  \tif(retain){\n    700  \t\trc2 = retain__store(topic, *stored, split_topics);\n    701  \t\tif(rc2) rc = rc2;\n    702  \t}\n    703  \n    704  end:\n    705  \tmosquitto__free(split_topics);\n    706  \tmosquitto__free(local_topic);\n    707  \t/* Remove our reference and free if needed. */\n    708  \tdb__msg_store_ref_dec(stored);\n    709  \n    710  \treturn rc;\n    711  }\nFunction: sub__search\nPath: /root/projects/mosquitto/src/subs.c:479\n    479  static int sub__search(struct mosquitto__subhier *subhier, char **split_topics, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    480  {\n    481  \t/* FIXME - need to take into account source_id if the client is a bridge */\n    482  \tstruct mosquitto__subhier *branch;\n    483  \tint rc;\n    484  \tbool have_subscribers = false;\n    485  \n    486  \tif(split_topics && split_topics[0]){\n    487  \t\t/* Check for literal match */\n    488  \t\tHASH_FIND(hh, subhier->children, split_topics[0], strlen(split_topics[0]), branch);\n    489  \n    490  \t\tif(branch){\n    491  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    492  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    493  \t\t\t\thave_subscribers = true;\n    494  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    495  \t\t\t\treturn rc;\n    496  \t\t\t}\n    497  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    498  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    499  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    500  \t\t\t\t\thave_subscribers = true;\n    501  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    502  \t\t\t\t\treturn rc;\n    503  \t\t\t\t}\n    504  \t\t\t}\n    505  \t\t}\n    506  \n    507  \t\t/* Check for + match */\n    508  \t\tHASH_FIND(hh, subhier->children, \"+\", 1, branch);\n    509  \n    510  \t\tif(branch){\n    511  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    512  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    513  \t\t\t\thave_subscribers = true;\n    514  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    515  \t\t\t\treturn rc;\n    516  \t\t\t}\n    517  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    518  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    519  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    520  \t\t\t\t\thave_subscribers = true;\n    521  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    522  \t\t\t\t\treturn rc;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}\n    526  \t}\n    527  \n    528  \t/* Check for # match */\n    529  \tHASH_FIND(hh, subhier->children, \"#\", 1, branch);\n    530  \tif(branch && !branch->children){\n    531  \t\t/* The topic matches due to a # wildcard - process the\n    532  \t\t * subscriptions but *don't* return. Although this branch has ended\n    533  \t\t * there may still be other subscriptions to deal with.\n    534  \t\t */\n    535  \t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    536  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    537  \t\t\thave_subscribers = true;\n    538  \t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    539  \t\t\treturn rc;\n    540  \t\t}\n    541  \t}\n    542  \n    543  \tif(have_subscribers){\n    544  \t\treturn MOSQ_ERR_SUCCESS;\n    545  \t}else{\n    546  \t\treturn MOSQ_ERR_NO_SUBSCRIBERS;\n    547  \t}\n    548  }\nFunction: subs__process\nPath: /root/projects/mosquitto/src/subs.c:129\n    129  static int subs__process(struct mosquitto__subhier *hier, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    130  {\n    131  \tint rc = 0;\n    132  \tint rc2;\n    133  \tstruct mosquitto__subleaf *leaf;\n    134  \n    135  \trc = subs__shared_process(hier, topic, qos, retain, stored);\n    136  \n    137  \tleaf = hier->subs;\n    138  \twhile(source_id && leaf){\n    139  \t\tif(!leaf->context->id || (leaf->no_local && !strcmp(leaf->context->id, source_id))){\n    140  \t\t\tleaf = leaf->next;\n    141  \t\t\tcontinue;\n    142  \t\t}\n    143  \t\trc2 = subs__send(leaf, topic, qos, retain, stored);\n    144  \t\tif(rc2){\n    145  \t\t\trc = 1;\n    146  \t\t}\n    147  \t\tleaf = leaf->next;\n    148  \t}\n    149  \tif(hier->subs || hier->shared){\n    150  \t\treturn rc;\n    151  \t}else{\n    152  \t\treturn MOSQ_ERR_NO_SUBSCRIBERS;\n    153  \t}\n    154  }\nFunction: subs__send\nPath: /root/projects/mosquitto/src/subs.c:63\n    63   static int subs__send(struct mosquitto__subleaf *leaf, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    64   {\n    65   \tbool client_retain;\n    66   \tuint16_t mid;\n    67   \tuint8_t client_qos, msg_qos;\n    68   \tmosquitto_property *properties = NULL;\n    69   \tint rc2;\n    70   \n    71   \t/* Check for ACL topic access. */\n    72   \trc2 = mosquitto_acl_check(leaf->context, topic, stored->payloadlen, stored->payload, stored->qos, stored->retain, MOSQ_ACL_READ);\n    73   \tif(rc2 == MOSQ_ERR_ACL_DENIED){\n    74   \t\treturn MOSQ_ERR_SUCCESS;\n    75   \t}else if(rc2 == MOSQ_ERR_SUCCESS){\n    76   \t\tclient_qos = leaf->qos;\n    77   \n    78   \t\tif(db.config->upgrade_outgoing_qos){\n    79   \t\t\tmsg_qos = client_qos;\n    80   \t\t}else{\n    81   \t\t\tif(qos > client_qos){\n    82   \t\t\t\tmsg_qos = client_qos;\n    83   \t\t\t}else{\n    84   \t\t\t\tmsg_qos = qos;\n    85   \t\t\t}\n    86   \t\t}\n    87   \t\tif(msg_qos){\n    88   \t\t\tmid = mosquitto__mid_generate(leaf->context);\n    89   \t\t}else{\n    90   \t\t\tmid = 0;\n    91   \t\t}\n    92   \t\tif(leaf->retain_as_published){\n    93   \t\t\tclient_retain = retain;\n    94   \t\t}else{\n    95   \t\t\tclient_retain = false;\n    96   \t\t}\n    97   \t\tif(leaf->identifier){\n    98   \t\t\tmosquitto_property_add_varint(&properties, MQTT_PROP_SUBSCRIPTION_IDENTIFIER, leaf->identifier);\n    99   \t\t}\n    100  \t\tif(db__message_insert(leaf->context, mid, mosq_md_out, msg_qos, client_retain, stored, properties, true) == 1){\n    101  \t\t\treturn 1;\n    102  \t\t}\n    103  \t}else{\n    104  \t\treturn 1; /* Application error */\n    105  \t}\n    106  \treturn 0;\n    107  }\nFunction: sub__clean_session\nPath: /root/projects/mosquitto/src/subs.c:746\n    746  int sub__clean_session(struct mosquitto *context)\n    747  {\n    748  \tint i;\n    749  \tstruct mosquitto__subleaf *leaf;\n    750  \tstruct mosquitto__subhier *hier;\n    751  \n    752  \tfor(i=0; i<context->sub_count; i++){\n    753  \t\tif(context->subs[i] == NULL){\n    754  \t\t\tcontinue;\n    755  \t\t}\n    756  \n    757  \t\thier = context->subs[i]->hier;\n    758  \n    759  \t\tif(context->subs[i]->shared){\n    760  \t\t\tleaf = context->subs[i]->shared->subs;\n    761  \t\t\twhile(leaf){\n    762  \t\t\t\tif(leaf->context==context){\n    763  #ifdef WITH_SYS_TREE\n    764  \t\t\t\t\tdb.shared_subscription_count--;\n    765  #endif\n    766  \t\t\t\t\tsub__remove_shared_leaf(context->subs[i]->hier, context->subs[i]->shared, leaf);\n    767  \t\t\t\t\tbreak;\n    768  \t\t\t\t}\n    769  \t\t\t\tleaf = leaf->next;\n    770  \t\t\t}\n    771  \t\t}else{\n    772  \t\t\tleaf = hier->subs;\n    773  \t\t\twhile(leaf){\n    774  \t\t\t\tif(leaf->context==context){\n    775  #ifdef WITH_SYS_TREE\n    776  \t\t\t\t\tdb.subscription_count--;\n    777  #endif\n    778  \t\t\t\t\tDL_DELETE(hier->subs, leaf);\n    779  \t\t\t\t\tmosquitto__free(leaf);\n    780  \t\t\t\t\tbreak;\n    781  \t\t\t\t}\n    782  \t\t\t\tleaf = leaf->next;\n    783  \t\t\t}\n    784  \t\t}\n    785  \t\tmosquitto__free(context->subs[i]);\n    786  \t\tcontext->subs[i] = NULL;\n    787  \n    788  \t\tif(hier->subs == NULL\n    789  \t\t\t\t&& hier->children == NULL\n    790  \t\t\t\t&& hier->shared == NULL\n    791  \t\t\t\t&& hier->parent){\n    792  \n    793  \t\t\tdo{\n    794  \t\t\t\thier = tmp_remove_subs(hier);\n    795  \t\t\t}while(hier);\n    796  \t\t}\n    797  \t}\n    798  \tmosquitto__free(context->subs);\n    799  \tcontext->subs = NULL;\n    800  \tcontext->sub_count = 0;\n    801  \n    802  \treturn MOSQ_ERR_SUCCESS;\n    803  }\nFunction: tmp_remove_subs\nPath: /root/projects/mosquitto/src/subs.c:715\n    715  static struct mosquitto__subhier *tmp_remove_subs(struct mosquitto__subhier *sub)\n    716  {\n    717  \tstruct mosquitto__subhier *parent;\n    718  \n    719  \tif(!sub || !sub->parent){\n    720  \t\treturn NULL;\n    721  \t}\n    722  \n    723  \tif(sub->children || sub->subs){\n    724  \t\treturn NULL;\n    725  \t}\n    726  \n    727  \tparent = sub->parent;\n    728  \tHASH_DELETE(hh, parent->children, sub);\n    729  \tmosquitto__free(sub->topic);\n    730  \tmosquitto__free(sub);\n    731  \n    732  \tif(parent->subs == NULL\n    733  \t\t\t&& parent->children == NULL\n    734  \t\t\t&& parent->shared == NULL\n    735  \t\t\t&& parent->parent){\n    736  \n    737  \t\treturn parent;\n    738  \t}else{\n    739  \t\treturn NULL;\n    740  \t}\n    741  }\nFunction: sub__topic_tokenise\nPath: /root/projects/mosquitto/src/topic_tok.c:58\n    58   int sub__topic_tokenise(const char *subtopic, char **local_sub, char ***topics, const char **sharename)\n    59   {\n    60   \tchar *saveptr = NULL;\n    61   \tchar *token;\n    62   \tint count;\n    63   \tint topic_index = 0;\n    64   \tint i;\n    65   \tsize_t len;\n    66   \n    67   \tlen = strlen(subtopic);\n    68   \tif(len == 0){\n    69   \t\treturn MOSQ_ERR_INVAL;\n    70   \t}\n    71   \n    72   \t*local_sub = mosquitto__strdup(subtopic);\n    73   \tif((*local_sub) == NULL) return MOSQ_ERR_NOMEM;\n    74   \n    75   \tcount = 0;\n    76   \tsaveptr = *local_sub;\n    77   \twhile(saveptr){\n    78   \t\tsaveptr = strchr(&saveptr[1], '/');\n    79   \t\tcount++;\n    80   \t}\n    81   \t*topics = mosquitto__calloc((size_t)(count+3) /* 3=$shared,sharename,NULL */, sizeof(char *));\n    82   \tif((*topics) == NULL){\n    83   \t\tmosquitto__free(*local_sub);\n    84   \t\treturn MOSQ_ERR_NOMEM;\n    85   \t}\n    86   \n    87   \tif((*local_sub)[0] != '$'){\n    88   \t\t(*topics)[topic_index] = \"\";\n    89   \t\ttopic_index++;\n    90   \t}\n    91   \n    92   \ttoken = strtok_hier((*local_sub), &saveptr);\n    93   \twhile(token){\n    94   \t\t(*topics)[topic_index] = token;\n    95   \t\ttopic_index++;\n    96   \t\ttoken = strtok_hier(NULL, &saveptr);\n    97   \t}\n    98   \n    99   \tif(!strcmp((*topics)[0], \"$share\")){\n    100  \t\tif(count < 3 || (count == 3 && strlen((*topics)[2]) == 0)){\n    101  \t\t\tmosquitto__free(*local_sub);\n    102  \t\t\tmosquitto__free(*topics);\n    103  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    104  \t\t}\n    105  \n    106  \t\tif(sharename){\n    107  \t\t\t(*sharename) = (*topics)[1];\n    108  \t\t}\n    109  \n    110  \t\tfor(i=1; i<count-1; i++){\n    111  \t\t\t(*topics)[i] = (*topics)[i+1];\n    112  \t\t}\n    113  \t\t(*topics)[0] = \"\";\n    114  \t\t(*topics)[count-1] = NULL;\n    115  \t}\n    116  \treturn MOSQ_ERR_SUCCESS;\n    117  }\nFunction: will_delay__remove\nPath: /root/projects/mosquitto/src/will_delay.c:99\n    99   void will_delay__remove(struct mosquitto *mosq)\n    100  {\n    101  \tif(mosq->will_delay_entry != NULL){\n    102  \t\tDL_DELETE(delay_list, mosq->will_delay_entry);\n    103  \t\tmosquitto__free(mosq->will_delay_entry);\n    104  \t\tmosq->will_delay_entry = NULL;\n    105  \t}\n    106  }\nFunction: will__clear\nPath: /root/projects/mosquitto/src/../lib/will_mosq.c:111\n    111  int will__clear(struct mosquitto *mosq)\n    112  {\n    113  \tif(!mosq->will) return MOSQ_ERR_SUCCESS;\n    114  \n    115  \tmosquitto__free(mosq->will->msg.topic);\n    116  \tmosq->will->msg.topic = NULL;\n    117  \n    118  \tmosquitto__free(mosq->will->msg.payload);\n    119  \tmosq->will->msg.payload = NULL;\n    120  \n    121  \tmosquitto_property_free_all(&mosq->will->properties);\n    122  \n    123  \tmosquitto__free(mosq->will);\n    124  \tmosq->will = NULL;\n    125  \tmosq->will_delay_interval = 0;\n    126  \n    127  \treturn MOSQ_ERR_SUCCESS;\n    128  }\n",
    "If a Server receives a CONNECT packet containing a Will Message with the Will Retain set to 1, and the Server does not support retained messages, the Server MUST reject the connection request.": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    221  \tplugin__handle_disconnect(context, -1);\n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    226  \tif(context->bridge == NULL)\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    232  \t\t\tif(context->will_delay_interval == 0){\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__read_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:178\n    178  int packet__read_uint32(struct mosquitto__packet *packet, uint32_t *word)\n    179  {\n    180  \tuint32_t val = 0;\n    181  \tint i;\n    183  \tassert(packet);\n    184  \tif(packet->pos+4 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    186  \tfor(i=0; i<4; i++){\n    187  \t\tval = (val << 8) + packet->payload[packet->pos];\n    188  \t\tpacket->pos++;\n    189  \t}\n    191  \t*word = val;\n    194  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    147  \tassert(mosq);\n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    153  \tpacket->next = NULL;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    187  \treturn packet__write(mosq);\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    353  }\nFunction: packet__check_oversize\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:211\n    211  int packet__check_oversize(struct mosquitto *mosq, uint32_t remaining_length)\n    212  {\n    215  \tif(mosq->maximum_packet_size == 0) return MOSQ_ERR_SUCCESS;\n    217  \tlen = remaining_length + packet__varint_bytes(remaining_length);\n    218  \tif(len > mosq->maximum_packet_size){\n    219  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    220  \t}else{\n    221  \t\treturn MOSQ_ERR_SUCCESS;\n    222  \t}\n    223  }\nFunction: property__process_connect\nPath: /root/projects/mosquitto/src/property_broker.c:30\n    30   int property__process_connect(struct mosquitto *context, mosquitto_property **props)\n    31   {\n    32   \tmosquitto_property *p;\n    34   \tp = *props;\n    36   \twhile(p){\n    37   \t\tif(p->identifier == MQTT_PROP_SESSION_EXPIRY_INTERVAL){\n    38   \t\t\tcontext->session_expiry_interval = p->value.i32;\n    39   \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM){\n    40   \t\t\tif(p->value.i16 == 0){\n    41   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    42   \t\t\t}\n    44   \t\t\tcontext->msgs_out.inflight_maximum = p->value.i16;\n    45   \t\t\tcontext->msgs_out.inflight_quota = context->msgs_out.inflight_maximum;\n    46   \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    47   \t\t\tif(p->value.i32 == 0){\n    48   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    49   \t\t\t}\n    50   \t\t\tcontext->maximum_packet_size = p->value.i32;\n    51   \t\t}\n    52   \t\tp = p->next;\n    53   \t}\n    56   }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__read\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:35\n    35   static int property__read(struct mosquitto__packet *packet, uint32_t *len, mosquitto_property *property)\n    36   {\n    38   \tuint32_t property_identifier;\n    39   \tuint8_t byte;\n    40   \tuint8_t byte_count;\n    41   \tuint16_t uint16;\n    42   \tuint32_t uint32;\n    43   \tuint32_t varint;\n    44   \tchar *str1, *str2;\n    45   \tuint16_t slen1, slen2;\n    47   \tif(!property) return MOSQ_ERR_INVAL;\n    49   \trc = packet__read_varint(packet, &property_identifier, NULL);\n    50   \tif(rc){\n    51   \t\treturn rc;\n    52   \t}\n    55   \tmemset(property, 0, sizeof(mosquitto_property));\n    57   \tproperty->identifier = (int32_t)property_identifier;\n    59   \tswitch(property_identifier){\n    60   \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    61   \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    62   \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    63   \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    64   \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    65   \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    66   \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    67   \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    68   \t\t\trc = packet__read_byte(packet, &byte);\n    69   \t\t\tif(rc) return rc;\n    71   \t\t\tproperty->value.i8 = byte;\n    72   \t\t\tbreak;\n    74   \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    75   \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    76   \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    77   \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    78   \t\t\trc = packet__read_uint16(packet, &uint16);\n    79   \t\t\tif(rc) return rc;\n    81   \t\t\tproperty->value.i16 = uint16;\n    82   \t\t\tbreak;\n    84   \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    85   \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    86   \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    87   \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    88   \t\t\trc = packet__read_uint32(packet, &uint32);\n    89   \t\t\tif(rc) return rc;\n    91   \t\t\tproperty->value.i32 = uint32;\n    92   \t\t\tbreak;\n    94   \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    95   \t\t\trc = packet__read_varint(packet, &varint, &byte_count);\n    96   \t\t\tif(rc) return rc;\n    98   \t\t\tproperty->value.varint = varint;\n    99   \t\t\tbreak;\n    101  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    102  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    103  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    104  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    105  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    106  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    107  \t\tcase MQTT_PROP_REASON_STRING:\n    108  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    109  \t\t\tif(rc) return rc;\n    111  \t\t\tproperty->value.s.v = str1;\n    112  \t\t\tproperty->value.s.len = slen1;\n    113  \t\t\tbreak;\n    115  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    116  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    117  \t\t\trc = packet__read_binary(packet, (uint8_t **)&str1, &slen1);\n    118  \t\t\tif(rc) return rc;\n    120  \t\t\tproperty->value.bin.v = str1;\n    121  \t\t\tproperty->value.bin.len = slen1;\n    122  \t\t\tbreak;\n    124  \t\tcase MQTT_PROP_USER_PROPERTY:\n    125  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    126  \t\t\tif(rc) return rc;\n    129  \t\t\trc = packet__read_string(packet, &str2, &slen2);\n    130  \t\t\tif(rc){\n    131  \t\t\t\tmosquitto__free(str1);\n    132  \t\t\t\treturn rc;\n    133  \t\t\t}\n    136  \t\t\tproperty->name.v = str1;\n    137  \t\t\tproperty->name.len = slen1;\n    138  \t\t\tproperty->value.s.v = str2;\n    139  \t\t\tproperty->value.s.len = slen2;\n    140  \t\t\tbreak;\n    142  \t\tdefault:\n    144  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property_identifier);\n    146  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    147  \t}\n    150  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: mosquitto_property_add_byte\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:716\n    716  int mosquitto_property_add_byte(mosquitto_property **proplist, int identifier, uint8_t value)\n    717  {\n    721  \tif(identifier != MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    722  \t\t\t&& identifier != MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    723  \t\t\t&& identifier != MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    724  \t\t\t&& identifier != MQTT_PROP_MAXIMUM_QOS\n    725  \t\t\t&& identifier != MQTT_PROP_RETAIN_AVAILABLE\n    726  \t\t\t&& identifier != MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    727  \t\t\t&& identifier != MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    728  \t\t\t&& identifier != MQTT_PROP_SHARED_SUB_AVAILABLE){\n    729  \t\treturn MOSQ_ERR_INVAL;\n    730  \t}\n    736  \tprop->identifier = identifier;\n    737  \tprop->value.i8 = value;\n    739  \tproperty__add(proplist, prop);\n    741  }\nFunction: db__expire_all_messages\nPath: /root/projects/mosquitto/src/database.c:1053\n    1053 void db__expire_all_messages(struct mosquitto *context)\n    1055 \tstruct mosquitto_client_msg *msg, *tmp;\n    1057 \tDL_FOREACH_SAFE(context->msgs_out.inflight, msg, tmp){\n    1058 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1059 \t\t\tif(msg->qos > 0){\n    1060 \t\t\t\tutil__increment_send_quota(context);\n    1062 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1065 \tDL_FOREACH_SAFE(context->msgs_out.queued, msg, tmp){\n    1066 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1067 \t\t\tdb__message_remove_from_queued(&context->msgs_out, msg);\n    1070 \tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n    1071 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1072 \t\t\tif(msg->qos > 0){\n    1073 \t\t\t\tutil__increment_receive_quota(context);\n    1075 \t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n    1078 \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n    1079 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1080 \t\t\tdb__message_remove_from_queued(&context->msgs_in, msg);\n    1083 }\nFunction: db__message_remove_from_queued\nPath: /root/projects/mosquitto/src/database.c:364\n    364  static void db__message_remove_from_queued(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    365  {\n    366  \tif(!msg_data || !item){\n    367  \t\treturn;\n    368  \t}\n    370  \tDL_DELETE(msg_data->queued, item);\n    377  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1183 \tstruct mosquitto_client_msg *tail, *tmp;\n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1190 \tDL_FOREACH_SAFE(context->msgs_out.inflight, tail, tmp){\n    1191 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1192 \t\tif(rc) return rc;\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    143  \t\t\t\tin_quota = context->msgs_in.inflight_quota;\n    144  \t\t\t\tout_quota = context->msgs_out.inflight_quota;\n    145  \t\t\t\tin_maximum = context->msgs_in.inflight_maximum;\n    146  \t\t\t\tout_maximum = context->msgs_out.inflight_maximum;\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    154  \t\t\t\tcontext->msgs_in.inflight_quota = in_quota;\n    155  \t\t\t\tcontext->msgs_out.inflight_quota = out_quota;\n    156  \t\t\t\tcontext->msgs_in.inflight_maximum = in_maximum;\n    157  \t\t\t\tcontext->msgs_out.inflight_maximum = out_maximum;\n    159  \t\t\t\tdb__message_reconnect_reset(context);\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    215  \trc = acl__find_acls(context);\n    216  \tif(rc){\n    218  \t\treturn rc;\n    219  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    250  \t}\n    252  \tcontext->ping_t = 0;\n    253  \tcontext->is_dropping = false;\n    255  \tconnection_check_acl(context, &context->msgs_in.inflight);\n    256  \tconnection_check_acl(context, &context->msgs_in.queued);\n    257  \tconnection_check_acl(context, &context->msgs_out.inflight);\n    258  \tconnection_check_acl(context, &context->msgs_out.queued);\n    260  \tcontext__add_to_by_id(context);\n    263  \tif(!context->clean_start){\n    267  \tcontext->max_qos = context->listener->max_qos;\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    315  \tkeepalive__add(context);\n    317  \tmosquitto__set_state(context, mosq_cs_active);\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    320  \tif(rc) return rc;\n    321  \tdb__expire_all_messages(context);\n    322  \trc = db__message_write_queued_out(context);\n    323  \tif(rc) return rc;\n    324  \trc = db__message_write_inflight_out_all(context);\n    330  }\nFunction: connection_check_acl\nPath: /root/projects/mosquitto/src/handle_connect.c:86\n    86   static void connection_check_acl(struct mosquitto *context, struct mosquitto_client_msg **head)\n    97   \t\tif(mosquitto_acl_check(context, msg_tail->store->topic,\n    99   \t\t\t\t\t\t\t   msg_tail->store->qos, msg_tail->store->retain, access) != MOSQ_ERR_SUCCESS){\n    101  \t\t\tDL_DELETE((*head), msg_tail);\n    107  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    248  \tmosquitto__set_state(context, mosq_cs_disused);\n    250  \tif(context->id){\n    251  \t\tcontext__remove_from_by_id(context);\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    256  \tcontext->for_free_next = db.ll_for_free;\n    257  \tdb.ll_for_free = context;\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    296  \t\tcontext->in_by_id = true;\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__msg_add_to_queued_stats\nPath: /root/projects/mosquitto/src/database.c:162\n    162  void db__msg_add_to_queued_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    163  {\n    164  \tmsg_data->queued_count++;\n    165  \tmsg_data->queued_bytes += msg->store->payloadlen;\n    166  \tif(msg->qos != 0){\n    167  \t\tmsg_data->queued_count12++;\n    168  \t\tmsg_data->queued_bytes12 += msg->store->payloadlen;\n    169  \t}\n    170  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    271  \tmosquitto__free(store->source_id);\n    272  \tmosquitto__free(store->source_username);\n    283  }\nFunction: db__message_remove_from_inflight\nPath: /root/projects/mosquitto/src/database.c:347\n    347  static void db__message_remove_from_inflight(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    348  {\n    349  \tif(!msg_data || !item){\n    350  \t\treturn;\n    351  \t}\n    353  \tDL_DELETE(msg_data->inflight, item);\n    354  \tif(item->store){\n    355  \t\tdb__msg_remove_from_inflight_stats(msg_data, item);\n    357  \t}\n    361  }\nFunction: db__message_write_inflight_out_latest\nPath: /root/projects/mosquitto/src/database.c:1198\n    1198 int db__message_write_inflight_out_latest(struct mosquitto *context)\n    1199 {\n    1200 \tstruct mosquitto_client_msg *tail, *next;\n    1203 \tif(context->state != mosq_cs_active\n    1204 \t\t\t|| context->sock == INVALID_SOCKET\n    1205 \t\t\t|| context->msgs_out.inflight == NULL){\n    1207 \t\treturn MOSQ_ERR_SUCCESS;\n    1208 \t}\n    1210 \tif(context->msgs_out.inflight->prev == context->msgs_out.inflight){\n    1212 \t\treturn db__message_write_inflight_out_single(context, context->msgs_out.inflight);\n    1213 \t}\n    1217 \ttail = context->msgs_out.inflight->prev;\n    1218 \twhile(tail != context->msgs_out.inflight &&\n    1219 \t\t\t(tail->state == mosq_ms_publish_qos0\n    1220 \t\t\t || tail->state == mosq_ms_publish_qos1\n    1221 \t\t\t || tail->state == mosq_ms_publish_qos2)){\n    1223 \t\ttail = tail->prev;\n    1224 \t}\n    1229 \tif(tail != context->msgs_out.inflight){\n    1230 \t\ttail = tail->next;\n    1231 \t}\n    1233 \twhile(tail){\n    1234 \t\tnext = tail->next;\n    1235 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1236 \t\tif(rc) return rc;\n    1238 \t}\n    1240 }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1097 \tuint32_t expiry_interval;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1103 \t\t\tif(msg->direction == mosq_md_out && msg->qos > 0){\n    1104 \t\t\t\tutil__increment_send_quota(context);\n    1105 \t\t\t}\n    1106 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1126 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1135 \t\t\t\tmsg->timestamp = db.now_s;\n    1136 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1137 \t\t\t\tmsg->state = mosq_ms_wait_for_puback;\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1139 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1148 \t\t\t\tmsg->timestamp = db.now_s;\n    1149 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1150 \t\t\t\tmsg->state = mosq_ms_wait_for_pubrec;\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1152 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1159 \t\t\trc = send__pubrel(context, mid, NULL);\n    1160 \t\t\tif(!rc){\n    1161 \t\t\t\tmsg->state = mosq_ms_wait_for_pubcomp;\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1176 \t}\n    1178 }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    449  \tstruct mosquitto_msg_data *msg_data;\n    450  \tenum mosquitto_msg_state state = mosq_ms_invalid;\n    452  \tint i;\n    457  \tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n    459  \tif(dir == mosq_md_out){\n    460  \t\tmsg_data = &context->msgs_out;\n    461  \t}else{\n    462  \t\tmsg_data = &context->msgs_in;\n    463  \t}\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    484  \tif(context->sock == INVALID_SOCKET){\n    486  \t\tif(qos == 0 && !db.config->queue_qos0_messages){\n    487  \t\t\tif(!context->bridge){\n    489  \t\t\t\treturn 2;\n    490  \t\t\t}else{\n    491  \t\t\t\tif(context->bridge->start_type != bst_lazy){\n    493  \t\t\t\t\treturn 2;\n    494  \t\t\t\t}\n    495  \t\t\t}\n    496  \t\t}\n    497  \t\tif(context->bridge && context->bridge->clean_start_local == true){\n    499  \t\t\treturn 2;\n    500  \t\t}\n    501  \t}\n    503  \tif(context->sock != INVALID_SOCKET){\n    504  \t\tif(db__ready_for_flight(context, dir, qos)){\n    517  \t\t\t}else{\n    520  \t\t\t\t}else{\n    522  \t\t\t\t\treturn 1;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n    528  \t\t}else{\n    530  \t\t\tif(context->is_dropping == false){\n    531  \t\t\t\tcontext->is_dropping = true;\n    532  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    534  \t\t\t\t\t\tcontext->id);\n    535  \t\t\t}\n    538  \t\t\treturn 2;\n    539  \t\t}\n    540  \t}else{\n    541  \t\tif (db__ready_for_queue(context, qos, msg_data)){\n    543  \t\t}else{\n    545  \t\t\tif(context->is_dropping == false){\n    546  \t\t\t\tcontext->is_dropping = true;\n    547  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    549  \t\t\t\t\t\tcontext->id);\n    550  \t\t\t}\n    552  \t\t\treturn 2;\n    553  \t\t}\n    554  \t}\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    582  \tif(state == mosq_ms_queued){\n    583  \t\tDL_APPEND(msg_data->queued, msg);\n    585  \t}else{\n    586  \t\tDL_APPEND(msg_data->inflight, msg);\n    588  \t}\n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    598  \t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n    599  \t\tif(dest_ids){\n    602  \t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t}\n    609  \t}\n    611  \tif(context->bridge && context->bridge->start_type == bst_lazy\n    612  \t\t\t&& context->sock == INVALID_SOCKET\n    613  \t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n    616  \t}\n    633  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    704  \tstruct mosquitto_msg_store *stored;\n    705  \tconst char *source_id;\n    706  \tenum mosquitto_msg_origin origin;\n    710  \tstored = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    711  \tif(stored == NULL) return MOSQ_ERR_NOMEM;\n    713  \tstored->topic = mosquitto__strdup(topic);\n    714  \tif(stored->topic == NULL){\n    715  \t\tdb__msg_store_free(stored);\n    716  \t\treturn MOSQ_ERR_INVAL;\n    717  \t}\n    719  \tstored->qos = qos;\n    720  \tif(db.config->retain_available == false){\n    721  \t\tstored->retain = 0;\n    722  \t}else{\n    723  \t\tstored->retain = retain;\n    724  \t}\n    726  \tstored->payloadlen = payloadlen;\n    727  \tif(payloadlen > 0){\n    728  \t\tstored->payload = mosquitto__malloc(stored->payloadlen+1);\n    729  \t\tif(stored->payload == NULL){\n    730  \t\t\tdb__msg_store_free(stored);\n    731  \t\t\treturn MOSQ_ERR_NOMEM;\n    732  \t\t}\n    734  \t\t((uint8_t *)stored->payload)[stored->payloadlen] = 0;\n    735  \t\tmemcpy(stored->payload, payload, stored->payloadlen);\n    736  \t}\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    746  \t}\n    748  \tif(context){\n    750  \t}else{\n    753  \tif(db__message_store(context, stored, message_expiry_interval, 0, origin)) return 1;\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    763  \tif(source && source->id){\n    764  \t\tstored->source_id = mosquitto__strdup(source->id);\n    765  \t}else{\n    766  \t\tstored->source_id = mosquitto__strdup(\"\");\n    767  \t}\n    768  \tif(!stored->source_id){\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    774  \tif(source && source->username){\n    775  \t\tstored->source_username = mosquitto__strdup(source->username);\n    776  \t\tif(!stored->source_username){\n    778  \t\t\treturn MOSQ_ERR_NOMEM;\n    779  \t\t}\n    780  \t}\n    781  \tif(source){\n    782  \t\tstored->source_listener = source->listener;\n    783  \t}\n    806  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    448  \tX509 *client_cert = NULL;\n    460  \tif(!context->listener){\n    461  \t\treturn MOSQ_ERR_INVAL;\n    462  \t}\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    502  \t\tcontext->protocol = mosq_p_mqtt31;\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    504  \t\t\tcontext->is_bridge = true;\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    508  \t\t\tcontext->protocol = mosq_p_mqtt311;\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    511  \t\t\t\tcontext->is_bridge = true;\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    514  \t\t\tcontext->protocol = mosq_p_mqtt5;\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    563  \t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid Will QoS in CONNECT from %s.\",\n    564  \t\t\t\tcontext->address);\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    576  \t\trc = MOSQ_ERR_NOT_SUPPORTED;\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    724  \tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    731  \t\tif(!context->ssl){\n    732  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    741  \t\tif(context->listener->psk_hint){\n    743  \t\t\tif(!context->username){\n    744  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    754  \t\t\tclient_cert = SSL_get_peer_certificate(context->ssl);\n    755  \t\t\tif(!client_cert){\n    756  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    764  \t\t\tname = X509_get_subject_name(client_cert);\n    765  \t\t\tif(!name){\n    766  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    774  \t\t\tif (context->listener->use_identity_as_username) { /* use_identity_as_username */\n    775  \t\t\t\ti = X509_NAME_get_index_by_NID(name, NID_commonName, -1);\n    776  \t\t\t\tif(i == -1){\n    777  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    785  \t\t\t\tname_entry = X509_NAME_get_entry(name, i);\n    786  \t\t\t\tif(name_entry){\n    787  \t\t\t\t\tname_asn1 = X509_NAME_ENTRY_get_data(name_entry);\n    788  \t\t\t\t\tif (name_asn1 == NULL) {\n    789  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    801  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_get0_data(name_asn1);\n    803  \t\t\t\t\tif(mosquitto_validate_utf8(new_username, (int)strlen(new_username))){\n    804  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    809  \t\t\t\t\t\tX509_free(client_cert);\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    814  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    824  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    835  \t\t\t\tX509_NAME_print_ex(subject_bio, X509_get_subject_name(client_cert), 0, XN_FLAG_RFC2253);\n    847  \t\t\t\tcontext->username = subject;\n    849  \t\t\tif(!context->username){\n    853  \t\t\tX509_free(client_cert);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    898  \t\t\tmosquitto__set_state(context, mosq_cs_authenticating);\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    905  \t\t\twill__clear(context);\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    925  \t\tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    973  \tif(client_cert) X509_free(client_cert);\n    976  \tcontext->clean_start = true;\n    977  \tcontext->session_expiry_interval = 0;\n    978  \tcontext->will_delay_interval = 0;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    55   \tint i;\n    56   \tint pos;\n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    349  \t\trc = property__read_all(CMD_WILL, &context->in_packet, &properties);\n    350  \t\tif(rc) goto error_cleanup;\n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    356  \trc = packet__read_string(&context->in_packet, &will_struct->msg.topic, &tlen);\n    363  \tif(context->listener->mount_point){\n    364  \t\tslen = strlen(context->listener->mount_point) + strlen(will_struct->msg.topic) + 1;\n    366  \t\tif(!will_topic_mount){\n    368  \t\t\tgoto error_cleanup;\n    369  \t\t}\n    371  \t\tsnprintf(will_topic_mount, slen, \"%s%s\", context->listener->mount_point, will_struct->msg.topic);\n    374  \t\tmosquitto__free(will_struct->msg.topic);\n    375  \t\twill_struct->msg.topic = will_topic_mount;\n    376  \t}\n    378  \tif(!strncmp(will_struct->msg.topic, \"$CONTROL/\", strlen(\"$CONTROL/\"))){\n    380  \t\tgoto error_cleanup;\n    381  \t}\n    382  \trc = mosquitto_pub_topic_check(will_struct->msg.topic);\n    385  \trc = packet__read_uint16(&context->in_packet, &payloadlen);\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    393  \t\t\t\tsend__connack(context, 0, MQTT_RC_PACKET_TOO_LARGE, NULL);\n    394  \t\t\t}else{\n    395  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    396  \t\t\t}\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    400  \t\twill_struct->msg.payload = mosquitto__malloc((size_t)will_struct->msg.payloadlen);\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    406  \t\trc = packet__read_bytes(&context->in_packet, will_struct->msg.payload, (uint32_t)will_struct->msg.payloadlen);\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    411  \twill_struct->msg.retain = will_retain;\n    416  error_cleanup:\n    417  \tif(will_struct){\n    418  \t\tmosquitto__free(will_struct->msg.topic);\n    419  \t\tmosquitto__free(will_struct->msg.payload);\n    422  \t}\n    424  }\nFunction: net__handle_ssl\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:938\n    938  static int net__handle_ssl(struct mosquitto* mosq, int ret)\n    939  {\n    942  \terr = SSL_get_error(mosq->ssl, ret);\n    943  \tif (err == SSL_ERROR_WANT_READ) {\n    946  \t}\n    947  \telse if (err == SSL_ERROR_WANT_WRITE) {\n    950  \t\tmux__add_out(mosq);\n    955  \t}\n    956  \telse {\n    957  \t\tnet__print_ssl_error(mosq);\n    959  \t}\n    966  }\nFunction: net__write\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:996\n    996  ssize_t net__write(struct mosquitto *mosq, const void *buf, size_t count)\n    997  {\n    999  \tint ret;\n    1001 \tassert(mosq);\n    1005 \tif(mosq->ssl){\n    1007 \t\tmosq->want_write = false;\n    1008 \t\tret = SSL_write(mosq->ssl, buf, (int)count);\n    1009 \t\tif(ret < 0){\n    1010 \t\t\tret = net__handle_ssl(mosq, ret);\n    1011 \t\t}\n    1012 \t\treturn (ssize_t )ret;\n    1013 \t}else{\n    1017 \treturn send(mosq->sock, buf, count, MSG_NOSIGNAL);\n    1020 \t}\n    1022 }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    51   \tassert(packet);\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    73   \tassert(packet);\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    157  \tassert(packet);\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    371  \t\tmux__delete(context);\n    372  \t\tcontext__disconnect(context);\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto__malloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:83\n    83   void *mosquitto__malloc(size_t size)\n    84   {\n    88   \tif(mem_limit && memcount + size > mem_limit){\n    89   \t\treturn NULL;\n    90   \t}\n    93   \tmem = malloc(size);\n    96   \tif(mem){\n    97   \t\tmemcount += malloc_usable_size(mem);\n    101  \t}\n    105  }\nFunction: mosquitto__strdup\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:144\n    144  char *mosquitto__strdup(const char *s)\n    145  {\n    148  \tif(mem_limit && memcount + strlen(s) > mem_limit){\n    149  \t\treturn NULL;\n    150  \t}\n    152  \tstr = strdup(s);\n    155  \tif(str){\n    156  \t\tmemcount += malloc_usable_size(str);\n    160  \t}\n    164  }\nFunction: mosquitto_free\nPath: /root/projects/mosquitto/src/memory_public.c:27\n    27   void mosquitto_free(void *mem)\n    29   \tmosquitto__free(mem);\n    30   }\nFunction: mosquitto_malloc\nPath: /root/projects/mosquitto/src/memory_public.c:32\n    32   void *mosquitto_malloc(size_t size)\n    34   \treturn mosquitto__malloc(size);\n    35   }\nFunction: mux__add_out\nPath: /root/projects/mosquitto/src/mux.c:31\n    31   int mux__add_out(struct mosquitto *context)\n    34   \treturn mux_epoll__add_out(context);\n    38   }\nFunction: mux__remove_out\nPath: /root/projects/mosquitto/src/mux.c:41\n    41   int mux__remove_out(struct mosquitto *context)\n    44   \treturn mux_epoll__remove_out(context);\n    48   }\nFunction: mux__delete\nPath: /root/projects/mosquitto/src/mux.c:61\n    61   int mux__delete(struct mosquitto *context)\n    64   \treturn mux_epoll__delete(context);\n    68   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    32   \tmosquitto_property *connack_props = NULL;\n    33   \tuint32_t remaining_length;\n    35   \trc = mosquitto_property_copy_all(&connack_props, properties);\n    36   \tif(rc){\n    37   \t\treturn rc;\n    38   \t}\n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    43   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->address, ack, reason_code);\n    44   \t}\n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    50   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_RETAIN_AVAILABLE, 0);\n    51   \t\t\tif(rc){\n    52   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    57   \t\t\trc = mosquitto_property_add_int32(&connack_props, MQTT_PROP_MAXIMUM_PACKET_SIZE, db.config->max_packet_size);\n    58   \t\t\tif(rc){\n    59   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    64   \t\t\trc = mosquitto_property_add_int16(&connack_props, MQTT_PROP_RECEIVE_MAXIMUM, db.config->max_inflight_messages);\n    65   \t\t\tif(rc){\n    66   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    71   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_MAXIMUM_QOS, context->listener->max_qos);\n    72   \t\t\tif(rc){\n    73   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    78   \t\tremaining_length += property__get_remaining_length(connack_props);\n    79   \t}\n    81   \tif(packet__check_oversize(context, remaining_length)){\n    82   \t\tmosquitto_property_free_all(&connack_props);\n    83   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    84   \t}\n    87   \tif(!packet){\n    88   \t\tmosquitto_property_free_all(&connack_props);\n    89   \t\treturn MOSQ_ERR_NOMEM;\n    90   \t}\n    92   \tpacket->command = CMD_CONNACK;\n    93   \tpacket->remaining_length = remaining_length;\n    96   \tif(rc){\n    97   \t\tmosquitto_property_free_all(&connack_props);\n    99   \t\treturn rc;\n    100  \t}\n    102  \tpacket__write_byte(packet, reason_code);\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    104  \t\tproperty__write_all(packet, connack_props, true);\n    105  \t}\n    106  \tmosquitto_property_free_all(&connack_props);\n    108  \treturn packet__queue(context, packet);\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    42   \tassert(mosq);\n    45   \tif(mosq->bridge){\n    46   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Bridge %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    47   \t}else\n    56   \tassert(mosq);\n    60   \tpacket->command = CMD_DISCONNECT;\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    62   \t\tpacket->remaining_length = 1;\n    63   \t\tif(properties){\n    64   \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    65   \t\t}\n    66   \t}else{\n    67   \t\tpacket->remaining_length = 0;\n    68   \t}\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    76   \t\tpacket__write_byte(packet, reason_code);\n    80   \t}\n    82   \treturn packet__queue(mosq, packet);\n    83   }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    126  \tassert(mosq);\n    130  \tpacket->command = command;\n    131  \tif(dup){\n    132  \t\tpacket->command |= 8;\n    133  \t}\n    134  \tpacket->remaining_length = 2;\n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    137  \t\tif(reason_code != 0 || properties){\n    138  \t\t\tpacket->remaining_length += 1;\n    139  \t\t}\n    141  \t\tif(properties){\n    142  \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    143  \t\t}\n    144  \t}\n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tif(reason_code != 0 || properties){\n    156  \t\t\tpacket__write_byte(packet, reason_code);\n    157  \t\t}\n    161  \t}\n    163  \treturn packet__queue(mosq, packet);\n    164  }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    117  \treturn send__command_with_mid(mosq, CMD_PUBREL|2, mid, false, 0, properties);\n    118  }\nFunction: session_expiry__remove\nPath: /root/projects/mosquitto/src/session_expiry.c:121\n    121  void session_expiry__remove(struct mosquitto *context)\n    122  {\n    123  \tif(context->expiry_list_item){\n    124  \t\tDL_DELETE(expiry_list, context->expiry_list_item);\n    125  \t\tmosquitto__free(context->expiry_list_item);\n    126  \t\tcontext->expiry_list_item = NULL;\n    127  \t}\n    128  }\nFunction: acl__check_single\nPath: /root/projects/mosquitto/src/security.c:602\n    602  static int acl__check_single(struct mosquitto__auth_plugin_config *auth_plugin, struct mosquitto *context, struct mosquitto_acl_msg *msg, int access)\n    603  {\n    607  \tusername = mosquitto_client_username(context);\n    608  \tif(auth_plugin->deny_special_chars == true){\n    615  \t\tif(username && strpbrk(username, \"+#\")){\n    616  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous username \\\"%s\\\"\", username);\n    617  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    618  \t\t}\n    619  \t\tif(context->id && strpbrk(context->id, \"+#\")){\n    620  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous client id \\\"%s\\\"\", context->id);\n    621  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    622  \t\t}\n    623  \t}\n    625  \tif(auth_plugin->plugin.version == 4){\n    626  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    627  \t\t\treturn MOSQ_ERR_SUCCESS;\n    628  \t\t}\n    629  \t\treturn auth_plugin->plugin.acl_check_v4(auth_plugin->plugin.user_data, access, context, msg);\n    630  \t}else if(auth_plugin->plugin.version == 3){\n    631  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    632  \t\t\treturn MOSQ_ERR_SUCCESS;\n    633  \t\t}\n    634  \t\treturn auth_plugin->plugin.acl_check_v3(auth_plugin->plugin.user_data, access, context, msg);\n    635  \t}else if(auth_plugin->plugin.version == 2){\n    636  \t\tif(access == MOSQ_ACL_SUBSCRIBE || access == MOSQ_ACL_UNSUBSCRIBE){\n    637  \t\t\treturn MOSQ_ERR_SUCCESS;\n    638  \t\t}\n    639  \t\treturn auth_plugin->plugin.acl_check_v2(auth_plugin->plugin.user_data, context->id, username, topic, access);\n    640  \t}else{\n    641  \t\treturn MOSQ_ERR_INVAL;\n    642  \t}\n    643  }\nFunction: sub__remove_shared_leaf\nPath: /root/projects/mosquitto/src/subs.c:190\n    190  static void sub__remove_shared_leaf(struct mosquitto__subhier *subhier, struct mosquitto__subshared *shared, struct mosquitto__subleaf *leaf)\n    191  {\n    192  \tDL_DELETE(shared->subs, leaf);\n    193  \tif(shared->subs == NULL){\n    194  \t\tHASH_DELETE(hh, subhier->shared, shared);\n    195  \t\tmosquitto__free(shared->name);\n    196  \t\tmosquitto__free(shared);\n    197  \t}\n    199  }\nFunction: sub__messages_queue\nPath: /root/projects/mosquitto/src/subs.c:659\n    659  int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n    660  {\n    661  \tint rc = MOSQ_ERR_SUCCESS, rc2;\n    662  \tint rc_normal = MOSQ_ERR_NO_SUBSCRIBERS, rc_shared = MOSQ_ERR_NO_SUBSCRIBERS;\n    663  \tstruct mosquitto__subhier *subhier;\n    664  \tchar **split_topics = NULL;\n    677  \tHASH_FIND(hh, db.normal_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    678  \tif(subhier){\n    679  \t\trc_normal = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    680  \t\tif(rc_normal > 0){\n    682  \t\t\tgoto end;\n    683  \t\t}\n    684  \t}\n    686  \tHASH_FIND(hh, db.shared_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    687  \tif(subhier){\n    688  \t\trc_shared = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    689  \t\tif(rc_shared > 0){\n    691  \t\t\tgoto end;\n    692  \t\t}\n    693  \t}\n    695  \tif(rc_normal == MOSQ_ERR_NO_SUBSCRIBERS && rc_shared == MOSQ_ERR_NO_SUBSCRIBERS){\n    697  \t}\n    711  }\nFunction: sub__search\nPath: /root/projects/mosquitto/src/subs.c:479\n    479  static int sub__search(struct mosquitto__subhier *subhier, char **split_topics, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    480  {\n    482  \tstruct mosquitto__subhier *branch;\n    486  \tif(split_topics && split_topics[0]){\n    488  \t\tHASH_FIND(hh, subhier->children, split_topics[0], strlen(split_topics[0]), branch);\n    490  \t\tif(branch){\n    491  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    492  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    494  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    495  \t\t\t\treturn rc;\n    496  \t\t\t}\n    497  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    498  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    499  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    501  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    502  \t\t\t\t\treturn rc;\n    503  \t\t\t\t}\n    504  \t\t\t}\n    505  \t\t}\n    508  \t\tHASH_FIND(hh, subhier->children, \"+\", 1, branch);\n    510  \t\tif(branch){\n    511  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    512  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    514  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    515  \t\t\t\treturn rc;\n    516  \t\t\t}\n    517  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    518  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    519  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    521  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    522  \t\t\t\t\treturn rc;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}\n    526  \t}\n    529  \tHASH_FIND(hh, subhier->children, \"#\", 1, branch);\n    530  \tif(branch && !branch->children){\n    535  \t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    536  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    538  \t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    539  \t\t\treturn rc;\n    540  \t\t}\n    541  \t}\n    548  }\nFunction: subs__process\nPath: /root/projects/mosquitto/src/subs.c:129\n    129  static int subs__process(struct mosquitto__subhier *hier, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    130  {\n    133  \tstruct mosquitto__subleaf *leaf;\n    135  \trc = subs__shared_process(hier, topic, qos, retain, stored);\n    137  \tleaf = hier->subs;\n    138  \twhile(source_id && leaf){\n    139  \t\tif(!leaf->context->id || (leaf->no_local && !strcmp(leaf->context->id, source_id))){\n    140  \t\t\tleaf = leaf->next;\n    142  \t\t}\n    147  \t\tleaf = leaf->next;\n    148  \t}\n    149  \tif(hier->subs || hier->shared){\n    150  \t\treturn rc;\n    151  \t}else{\n    152  \t\treturn MOSQ_ERR_NO_SUBSCRIBERS;\n    153  \t}\n    154  }\nFunction: subs__send\nPath: /root/projects/mosquitto/src/subs.c:63\n    63   static int subs__send(struct mosquitto__subleaf *leaf, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    64   {\n    65   \tbool client_retain;\n    66   \tuint16_t mid;\n    67   \tuint8_t client_qos, msg_qos;\n    68   \tmosquitto_property *properties = NULL;\n    72   \trc2 = mosquitto_acl_check(leaf->context, topic, stored->payloadlen, stored->payload, stored->qos, stored->retain, MOSQ_ACL_READ);\n    73   \tif(rc2 == MOSQ_ERR_ACL_DENIED){\n    74   \t\treturn MOSQ_ERR_SUCCESS;\n    75   \t}else if(rc2 == MOSQ_ERR_SUCCESS){\n    76   \t\tclient_qos = leaf->qos;\n    87   \t\tif(msg_qos){\n    88   \t\t\tmid = mosquitto__mid_generate(leaf->context);\n    89   \t\t}else{\n    92   \t\tif(leaf->retain_as_published){\n    93   \t\t\tclient_retain = retain;\n    94   \t\t}else{\n    97   \t\tif(leaf->identifier){\n    98   \t\t\tmosquitto_property_add_varint(&properties, MQTT_PROP_SUBSCRIPTION_IDENTIFIER, leaf->identifier);\n    99   \t\t}\n    100  \t\tif(db__message_insert(leaf->context, mid, mosq_md_out, msg_qos, client_retain, stored, properties, true) == 1){\n    101  \t\t\treturn 1;\n    102  \t\t}\n    103  \t}else{\n    104  \t\treturn 1; /* Application error */\n    105  \t}\n    107  }\nFunction: sub__clean_session\nPath: /root/projects/mosquitto/src/subs.c:746\n    746  int sub__clean_session(struct mosquitto *context)\n    747  {\n    748  \tint i;\n    749  \tstruct mosquitto__subleaf *leaf;\n    750  \tstruct mosquitto__subhier *hier;\n    752  \tfor(i=0; i<context->sub_count; i++){\n    753  \t\tif(context->subs[i] == NULL){\n    755  \t\t}\n    757  \t\thier = context->subs[i]->hier;\n    759  \t\tif(context->subs[i]->shared){\n    760  \t\t\tleaf = context->subs[i]->shared->subs;\n    761  \t\t\twhile(leaf){\n    762  \t\t\t\tif(leaf->context==context){\n    766  \t\t\t\t\tsub__remove_shared_leaf(context->subs[i]->hier, context->subs[i]->shared, leaf);\n    768  \t\t\t\t}\n    769  \t\t\t\tleaf = leaf->next;\n    770  \t\t\t}\n    771  \t\t}else{\n    772  \t\t\tleaf = hier->subs;\n    773  \t\t\twhile(leaf){\n    774  \t\t\t\tif(leaf->context==context){\n    778  \t\t\t\t\tDL_DELETE(hier->subs, leaf);\n    779  \t\t\t\t\tmosquitto__free(leaf);\n    781  \t\t\t\t}\n    782  \t\t\t\tleaf = leaf->next;\n    783  \t\t\t}\n    784  \t\t}\n    785  \t\tmosquitto__free(context->subs[i]);\n    786  \t\tcontext->subs[i] = NULL;\n    788  \t\tif(hier->subs == NULL\n    789  \t\t\t\t&& hier->children == NULL\n    790  \t\t\t\t&& hier->shared == NULL\n    791  \t\t\t\t&& hier->parent){\n    794  \t\t\t\thier = tmp_remove_subs(hier);\n    795  \t\t\t}while(hier);\n    796  \t\t}\n    797  \t}\n    798  \tmosquitto__free(context->subs);\n    799  \tcontext->subs = NULL;\n    800  \tcontext->sub_count = 0;\n    803  }\nFunction: tmp_remove_subs\nPath: /root/projects/mosquitto/src/subs.c:715\n    715  static struct mosquitto__subhier *tmp_remove_subs(struct mosquitto__subhier *sub)\n    716  {\n    719  \tif(!sub || !sub->parent){\n    720  \t\treturn NULL;\n    721  \t}\n    723  \tif(sub->children || sub->subs){\n    724  \t\treturn NULL;\n    725  \t}\n    727  \tparent = sub->parent;\n    728  \tHASH_DELETE(hh, parent->children, sub);\n    729  \tmosquitto__free(sub->topic);\n    730  \tmosquitto__free(sub);\n    732  \tif(parent->subs == NULL\n    733  \t\t\t&& parent->children == NULL\n    734  \t\t\t&& parent->shared == NULL\n    735  \t\t\t&& parent->parent){\n    737  \t\treturn parent;\n    738  \t}else{\n    739  \t\treturn NULL;\n    740  \t}\n    741  }\nFunction: util__increment_send_quota\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:222\n    222  void util__increment_send_quota(struct mosquitto *mosq)\n    223  {\n    224  \tif(mosq->msgs_out.inflight_quota < mosq->msgs_out.inflight_maximum){\n    225  \t\tmosq->msgs_out.inflight_quota++;\n    226  \t}\n    227  }\nFunction: will_delay__remove\nPath: /root/projects/mosquitto/src/will_delay.c:99\n    99   void will_delay__remove(struct mosquitto *mosq)\n    100  {\n    101  \tif(mosq->will_delay_entry != NULL){\n    102  \t\tDL_DELETE(delay_list, mosq->will_delay_entry);\n    103  \t\tmosquitto__free(mosq->will_delay_entry);\n    104  \t\tmosq->will_delay_entry = NULL;\n    105  \t}\n    106  }\nFunction: will__clear\nPath: /root/projects/mosquitto/src/../lib/will_mosq.c:111\n    111  int will__clear(struct mosquitto *mosq)\n    112  {\n    113  \tif(!mosq->will) return MOSQ_ERR_SUCCESS;\n    115  \tmosquitto__free(mosq->will->msg.topic);\n    116  \tmosq->will->msg.topic = NULL;\n    118  \tmosquitto__free(mosq->will->msg.payload);\n    119  \tmosq->will->msg.payload = NULL;\n    121  \tmosquitto_property_free_all(&mosq->will->properties);\n    123  \tmosquitto__free(mosq->will);\n    124  \tmosq->will = NULL;\n    125  \tmosq->will_delay_interval = 0;\n    128  }\n",
    "If a Server receives a CONNECT packet containing a Will QoS that exceeds the Server's capabilities, the Server SHOULD use a CONNACK packet with Reason Code 0x9B (QoS not supported) as described in section 4.13 Handling errors, and MUST close the Network Connection [MQTT-3.2.2-12].": "Function: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    94   \tpacket->command = 0;\n    97   \tpacket->remaining_length = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    150  \tpacket->pos = 0;\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    345  \t}\n    353  }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    205  \t\tfound_context->clean_start = true;\n    213  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    247  \t\t} else {\n    250  \t}\n    263  \tif(!context->clean_start){\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    320  \tif(rc) return rc;\n    330  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    557  \t}else{\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    595  \t\trc = MOSQ_ERR_NOT_SUPPORTED;\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    976  \tcontext->clean_start = true;\n    980  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\n",
    "If a Server receives a CONNECT packet containing a Will QoS that exceeds the Server's capabilities, the Server MUST reject the connection.": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    221  \tplugin__handle_disconnect(context, -1);\n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    226  \tif(context->bridge == NULL)\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    232  \t\t\tif(context->will_delay_interval == 0){\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    147  \tassert(mosq);\n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    153  \tpacket->next = NULL;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    187  \treturn packet__write(mosq);\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    353  }\nFunction: property__process_connect\nPath: /root/projects/mosquitto/src/property_broker.c:30\n    30   int property__process_connect(struct mosquitto *context, mosquitto_property **props)\n    31   {\n    32   \tmosquitto_property *p;\n    34   \tp = *props;\n    36   \twhile(p){\n    37   \t\tif(p->identifier == MQTT_PROP_SESSION_EXPIRY_INTERVAL){\n    38   \t\t\tcontext->session_expiry_interval = p->value.i32;\n    39   \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM){\n    40   \t\t\tif(p->value.i16 == 0){\n    41   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    42   \t\t\t}\n    44   \t\t\tcontext->msgs_out.inflight_maximum = p->value.i16;\n    45   \t\t\tcontext->msgs_out.inflight_quota = context->msgs_out.inflight_maximum;\n    46   \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    47   \t\t\tif(p->value.i32 == 0){\n    48   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    49   \t\t\t}\n    50   \t\t\tcontext->maximum_packet_size = p->value.i32;\n    51   \t\t}\n    52   \t\tp = p->next;\n    53   \t}\n    56   }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: db__expire_all_messages\nPath: /root/projects/mosquitto/src/database.c:1053\n    1053 void db__expire_all_messages(struct mosquitto *context)\n    1055 \tstruct mosquitto_client_msg *msg, *tmp;\n    1057 \tDL_FOREACH_SAFE(context->msgs_out.inflight, msg, tmp){\n    1058 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1059 \t\t\tif(msg->qos > 0){\n    1060 \t\t\t\tutil__increment_send_quota(context);\n    1062 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1065 \tDL_FOREACH_SAFE(context->msgs_out.queued, msg, tmp){\n    1066 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1067 \t\t\tdb__message_remove_from_queued(&context->msgs_out, msg);\n    1070 \tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n    1071 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1072 \t\t\tif(msg->qos > 0){\n    1073 \t\t\t\tutil__increment_receive_quota(context);\n    1075 \t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n    1078 \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n    1079 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1080 \t\t\tdb__message_remove_from_queued(&context->msgs_in, msg);\n    1083 }\nFunction: db__message_remove_from_queued\nPath: /root/projects/mosquitto/src/database.c:364\n    364  static void db__message_remove_from_queued(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    365  {\n    366  \tif(!msg_data || !item){\n    367  \t\treturn;\n    368  \t}\n    370  \tDL_DELETE(msg_data->queued, item);\n    377  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1183 \tstruct mosquitto_client_msg *tail, *tmp;\n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1190 \tDL_FOREACH_SAFE(context->msgs_out.inflight, tail, tmp){\n    1191 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1192 \t\tif(rc) return rc;\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    143  \t\t\t\tin_quota = context->msgs_in.inflight_quota;\n    144  \t\t\t\tout_quota = context->msgs_out.inflight_quota;\n    145  \t\t\t\tin_maximum = context->msgs_in.inflight_maximum;\n    146  \t\t\t\tout_maximum = context->msgs_out.inflight_maximum;\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    154  \t\t\t\tcontext->msgs_in.inflight_quota = in_quota;\n    155  \t\t\t\tcontext->msgs_out.inflight_quota = out_quota;\n    156  \t\t\t\tcontext->msgs_in.inflight_maximum = in_maximum;\n    157  \t\t\t\tcontext->msgs_out.inflight_maximum = out_maximum;\n    159  \t\t\t\tdb__message_reconnect_reset(context);\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    215  \trc = acl__find_acls(context);\n    216  \tif(rc){\n    218  \t\treturn rc;\n    219  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    250  \t}\n    252  \tcontext->ping_t = 0;\n    253  \tcontext->is_dropping = false;\n    255  \tconnection_check_acl(context, &context->msgs_in.inflight);\n    256  \tconnection_check_acl(context, &context->msgs_in.queued);\n    257  \tconnection_check_acl(context, &context->msgs_out.inflight);\n    258  \tconnection_check_acl(context, &context->msgs_out.queued);\n    260  \tcontext__add_to_by_id(context);\n    263  \tif(!context->clean_start){\n    267  \tcontext->max_qos = context->listener->max_qos;\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    315  \tkeepalive__add(context);\n    317  \tmosquitto__set_state(context, mosq_cs_active);\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    320  \tif(rc) return rc;\n    321  \tdb__expire_all_messages(context);\n    322  \trc = db__message_write_queued_out(context);\n    323  \tif(rc) return rc;\n    324  \trc = db__message_write_inflight_out_all(context);\n    330  }\nFunction: connection_check_acl\nPath: /root/projects/mosquitto/src/handle_connect.c:86\n    86   static void connection_check_acl(struct mosquitto *context, struct mosquitto_client_msg **head)\n    97   \t\tif(mosquitto_acl_check(context, msg_tail->store->topic,\n    99   \t\t\t\t\t\t\t   msg_tail->store->qos, msg_tail->store->retain, access) != MOSQ_ERR_SUCCESS){\n    101  \t\t\tDL_DELETE((*head), msg_tail);\n    107  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    248  \tmosquitto__set_state(context, mosq_cs_disused);\n    250  \tif(context->id){\n    251  \t\tcontext__remove_from_by_id(context);\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    256  \tcontext->for_free_next = db.ll_for_free;\n    257  \tdb.ll_for_free = context;\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    296  \t\tcontext->in_by_id = true;\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__msg_add_to_inflight_stats\nPath: /root/projects/mosquitto/src/database.c:141\n    141  void db__msg_add_to_inflight_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    142  {\n    143  \tmsg_data->inflight_count++;\n    144  \tmsg_data->inflight_bytes += msg->store->payloadlen;\n    145  \tif(msg->qos != 0){\n    146  \t\tmsg_data->inflight_count12++;\n    147  \t\tmsg_data->inflight_bytes12 += msg->store->payloadlen;\n    148  \t}\n    149  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    271  \tmosquitto__free(store->source_id);\n    272  \tmosquitto__free(store->source_username);\n    283  }\nFunction: db__msg_remove_from_queued_stats\nPath: /root/projects/mosquitto/src/database.c:172\n    172  static void db__msg_remove_from_queued_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    173  {\n    174  \tmsg_data->queued_count--;\n    175  \tmsg_data->queued_bytes -= msg->store->payloadlen;\n    176  \tif(msg->qos != 0){\n    177  \t\tmsg_data->queued_count12--;\n    178  \t\tmsg_data->queued_bytes12 -= msg->store->payloadlen;\n    179  \t}\n    180  }\nFunction: db__message_remove_from_inflight\nPath: /root/projects/mosquitto/src/database.c:347\n    347  static void db__message_remove_from_inflight(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    348  {\n    349  \tif(!msg_data || !item){\n    350  \t\treturn;\n    351  \t}\n    353  \tDL_DELETE(msg_data->inflight, item);\n    354  \tif(item->store){\n    355  \t\tdb__msg_remove_from_inflight_stats(msg_data, item);\n    357  \t}\n    361  }\nFunction: db__message_write_inflight_out_latest\nPath: /root/projects/mosquitto/src/database.c:1198\n    1198 int db__message_write_inflight_out_latest(struct mosquitto *context)\n    1199 {\n    1200 \tstruct mosquitto_client_msg *tail, *next;\n    1203 \tif(context->state != mosq_cs_active\n    1204 \t\t\t|| context->sock == INVALID_SOCKET\n    1205 \t\t\t|| context->msgs_out.inflight == NULL){\n    1207 \t\treturn MOSQ_ERR_SUCCESS;\n    1208 \t}\n    1210 \tif(context->msgs_out.inflight->prev == context->msgs_out.inflight){\n    1212 \t\treturn db__message_write_inflight_out_single(context, context->msgs_out.inflight);\n    1213 \t}\n    1217 \ttail = context->msgs_out.inflight->prev;\n    1218 \twhile(tail != context->msgs_out.inflight &&\n    1219 \t\t\t(tail->state == mosq_ms_publish_qos0\n    1220 \t\t\t || tail->state == mosq_ms_publish_qos1\n    1221 \t\t\t || tail->state == mosq_ms_publish_qos2)){\n    1223 \t\ttail = tail->prev;\n    1224 \t}\n    1229 \tif(tail != context->msgs_out.inflight){\n    1230 \t\ttail = tail->next;\n    1231 \t}\n    1233 \twhile(tail){\n    1234 \t\tnext = tail->next;\n    1235 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1236 \t\tif(rc) return rc;\n    1238 \t}\n    1240 }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1097 \tuint32_t expiry_interval;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1103 \t\t\tif(msg->direction == mosq_md_out && msg->qos > 0){\n    1104 \t\t\t\tutil__increment_send_quota(context);\n    1105 \t\t\t}\n    1106 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1126 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1135 \t\t\t\tmsg->timestamp = db.now_s;\n    1136 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1137 \t\t\t\tmsg->state = mosq_ms_wait_for_puback;\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1139 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1148 \t\t\t\tmsg->timestamp = db.now_s;\n    1149 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1150 \t\t\t\tmsg->state = mosq_ms_wait_for_pubrec;\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1152 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1159 \t\t\trc = send__pubrel(context, mid, NULL);\n    1160 \t\t\tif(!rc){\n    1161 \t\t\t\tmsg->state = mosq_ms_wait_for_pubcomp;\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1176 \t}\n    1178 }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    449  \tstruct mosquitto_msg_data *msg_data;\n    450  \tenum mosquitto_msg_state state = mosq_ms_invalid;\n    452  \tint i;\n    457  \tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n    459  \tif(dir == mosq_md_out){\n    460  \t\tmsg_data = &context->msgs_out;\n    461  \t}else{\n    462  \t\tmsg_data = &context->msgs_in;\n    463  \t}\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    484  \tif(context->sock == INVALID_SOCKET){\n    486  \t\tif(qos == 0 && !db.config->queue_qos0_messages){\n    487  \t\t\tif(!context->bridge){\n    489  \t\t\t\treturn 2;\n    490  \t\t\t}else{\n    491  \t\t\t\tif(context->bridge->start_type != bst_lazy){\n    493  \t\t\t\t\treturn 2;\n    494  \t\t\t\t}\n    495  \t\t\t}\n    496  \t\t}\n    497  \t\tif(context->bridge && context->bridge->clean_start_local == true){\n    499  \t\t\treturn 2;\n    500  \t\t}\n    501  \t}\n    503  \tif(context->sock != INVALID_SOCKET){\n    504  \t\tif(db__ready_for_flight(context, dir, qos)){\n    517  \t\t\t}else{\n    520  \t\t\t\t}else{\n    522  \t\t\t\t\treturn 1;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n    528  \t\t}else{\n    530  \t\t\tif(context->is_dropping == false){\n    531  \t\t\t\tcontext->is_dropping = true;\n    532  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    534  \t\t\t\t\t\tcontext->id);\n    535  \t\t\t}\n    538  \t\t\treturn 2;\n    539  \t\t}\n    540  \t}else{\n    541  \t\tif (db__ready_for_queue(context, qos, msg_data)){\n    543  \t\t}else{\n    545  \t\t\tif(context->is_dropping == false){\n    546  \t\t\t\tcontext->is_dropping = true;\n    547  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    549  \t\t\t\t\t\tcontext->id);\n    550  \t\t\t}\n    552  \t\t\treturn 2;\n    553  \t\t}\n    554  \t}\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    577  \t\tmsg->qos = qos;\n    578  \t}\n    582  \tif(state == mosq_ms_queued){\n    583  \t\tDL_APPEND(msg_data->queued, msg);\n    585  \t}else{\n    586  \t\tDL_APPEND(msg_data->inflight, msg);\n    588  \t}\n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    598  \t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n    599  \t\tif(dest_ids){\n    602  \t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t}\n    609  \t}\n    611  \tif(context->bridge && context->bridge->start_type == bst_lazy\n    612  \t\t\t&& context->sock == INVALID_SOCKET\n    613  \t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n    616  \t}\n    633  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    704  \tstruct mosquitto_msg_store *stored;\n    705  \tconst char *source_id;\n    706  \tenum mosquitto_msg_origin origin;\n    710  \tstored = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    711  \tif(stored == NULL) return MOSQ_ERR_NOMEM;\n    713  \tstored->topic = mosquitto__strdup(topic);\n    714  \tif(stored->topic == NULL){\n    715  \t\tdb__msg_store_free(stored);\n    716  \t\treturn MOSQ_ERR_INVAL;\n    717  \t}\n    719  \tstored->qos = qos;\n    720  \tif(db.config->retain_available == false){\n    721  \t\tstored->retain = 0;\n    722  \t}else{\n    723  \t\tstored->retain = retain;\n    724  \t}\n    726  \tstored->payloadlen = payloadlen;\n    727  \tif(payloadlen > 0){\n    728  \t\tstored->payload = mosquitto__malloc(stored->payloadlen+1);\n    729  \t\tif(stored->payload == NULL){\n    730  \t\t\tdb__msg_store_free(stored);\n    731  \t\t\treturn MOSQ_ERR_NOMEM;\n    732  \t\t}\n    734  \t\t((uint8_t *)stored->payload)[stored->payloadlen] = 0;\n    735  \t\tmemcpy(stored->payload, payload, stored->payloadlen);\n    736  \t}\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    746  \t}\n    748  \tif(context){\n    750  \t}else{\n    753  \tif(db__message_store(context, stored, message_expiry_interval, 0, origin)) return 1;\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    763  \tif(source && source->id){\n    764  \t\tstored->source_id = mosquitto__strdup(source->id);\n    765  \t}else{\n    766  \t\tstored->source_id = mosquitto__strdup(\"\");\n    767  \t}\n    768  \tif(!stored->source_id){\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    774  \tif(source && source->username){\n    775  \t\tstored->source_username = mosquitto__strdup(source->username);\n    776  \t\tif(!stored->source_username){\n    778  \t\t\treturn MOSQ_ERR_NOMEM;\n    779  \t\t}\n    780  \t}\n    781  \tif(source){\n    782  \t\tstored->source_listener = source->listener;\n    783  \t}\n    806  }\nFunction: net__socket_close\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:205\n    205  int net__socket_close(struct mosquitto *mosq)\n    206  {\n    207  \tint rc = 0;\n    209  \tstruct mosquitto *mosq_found;\n    212  \tassert(mosq);\n    218  \t\tif(mosq->ssl){\n    219  \t\t\tif(!SSL_in_init(mosq->ssl)){\n    220  \t\t\t\tSSL_shutdown(mosq->ssl);\n    221  \t\t\t}\n    222  \t\t\tSSL_free(mosq->ssl);\n    223  \t\t\tmosq->ssl = NULL;\n    224  \t\t}\n    238  \t\tif(mosq->sock != INVALID_SOCKET){\n    240  \t\t\tHASH_FIND(hh_sock, db.contexts_by_sock, &mosq->sock, sizeof(mosq->sock), mosq_found);\n    241  \t\t\tif(mosq_found){\n    242  \t\t\t\tHASH_DELETE(hh_sock, db.contexts_by_sock, mosq_found);\n    243  \t\t\t}\n    245  \t\t\trc = COMPAT_CLOSE(mosq->sock);\n    246  \t\t\tmosq->sock = INVALID_SOCKET;\n    247  \t\t}\n    251  \tif(mosq->listener){\n    252  \t\tmosq->listener->client_count--;\n    253  \t\tmosq->listener = NULL;\n    254  \t}\n    257  \treturn rc;\n    258  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    448  \tX509 *client_cert = NULL;\n    460  \tif(!context->listener){\n    461  \t\treturn MOSQ_ERR_INVAL;\n    462  \t}\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    502  \t\tcontext->protocol = mosq_p_mqtt31;\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    504  \t\t\tcontext->is_bridge = true;\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    508  \t\t\tcontext->protocol = mosq_p_mqtt311;\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    511  \t\t\t\tcontext->is_bridge = true;\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    514  \t\t\tcontext->protocol = mosq_p_mqtt5;\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    563  \t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid Will QoS in CONNECT from %s.\",\n    564  \t\t\t\tcontext->address);\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    595  \t\trc = MOSQ_ERR_NOT_SUPPORTED;\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    724  \tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    731  \t\tif(!context->ssl){\n    732  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    741  \t\tif(context->listener->psk_hint){\n    743  \t\t\tif(!context->username){\n    744  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    754  \t\t\tclient_cert = SSL_get_peer_certificate(context->ssl);\n    755  \t\t\tif(!client_cert){\n    756  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    764  \t\t\tname = X509_get_subject_name(client_cert);\n    765  \t\t\tif(!name){\n    766  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    774  \t\t\tif (context->listener->use_identity_as_username) { /* use_identity_as_username */\n    775  \t\t\t\ti = X509_NAME_get_index_by_NID(name, NID_commonName, -1);\n    776  \t\t\t\tif(i == -1){\n    777  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    785  \t\t\t\tname_entry = X509_NAME_get_entry(name, i);\n    786  \t\t\t\tif(name_entry){\n    787  \t\t\t\t\tname_asn1 = X509_NAME_ENTRY_get_data(name_entry);\n    788  \t\t\t\t\tif (name_asn1 == NULL) {\n    789  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    801  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_get0_data(name_asn1);\n    803  \t\t\t\t\tif(mosquitto_validate_utf8(new_username, (int)strlen(new_username))){\n    804  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    809  \t\t\t\t\t\tX509_free(client_cert);\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    814  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    824  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    835  \t\t\t\tX509_NAME_print_ex(subject_bio, X509_get_subject_name(client_cert), 0, XN_FLAG_RFC2253);\n    847  \t\t\t\tcontext->username = subject;\n    849  \t\t\tif(!context->username){\n    853  \t\t\tX509_free(client_cert);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    898  \t\t\tmosquitto__set_state(context, mosq_cs_authenticating);\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    905  \t\t\twill__clear(context);\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    925  \t\tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    973  \tif(client_cert) X509_free(client_cert);\n    976  \tcontext->clean_start = true;\n    977  \tcontext->session_expiry_interval = 0;\n    978  \tcontext->will_delay_interval = 0;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    55   \tint i;\n    56   \tint pos;\n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    350  \t\tif(rc) goto error_cleanup;\n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    356  \trc = packet__read_string(&context->in_packet, &will_struct->msg.topic, &tlen);\n    363  \tif(context->listener->mount_point){\n    364  \t\tslen = strlen(context->listener->mount_point) + strlen(will_struct->msg.topic) + 1;\n    366  \t\tif(!will_topic_mount){\n    368  \t\t\tgoto error_cleanup;\n    369  \t\t}\n    371  \t\tsnprintf(will_topic_mount, slen, \"%s%s\", context->listener->mount_point, will_struct->msg.topic);\n    374  \t\tmosquitto__free(will_struct->msg.topic);\n    375  \t\twill_struct->msg.topic = will_topic_mount;\n    376  \t}\n    378  \tif(!strncmp(will_struct->msg.topic, \"$CONTROL/\", strlen(\"$CONTROL/\"))){\n    380  \t\tgoto error_cleanup;\n    381  \t}\n    382  \trc = mosquitto_pub_topic_check(will_struct->msg.topic);\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    393  \t\t\t\tsend__connack(context, 0, MQTT_RC_PACKET_TOO_LARGE, NULL);\n    394  \t\t\t}else{\n    395  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    396  \t\t\t}\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    400  \t\twill_struct->msg.payload = mosquitto__malloc((size_t)will_struct->msg.payloadlen);\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    406  \t\trc = packet__read_bytes(&context->in_packet, will_struct->msg.payload, (uint32_t)will_struct->msg.payloadlen);\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    410  \twill_struct->msg.qos = will_qos;\n    413  \t*will = will_struct;\n    416  error_cleanup:\n    417  \tif(will_struct){\n    418  \t\tmosquitto__free(will_struct->msg.topic);\n    419  \t\tmosquitto__free(will_struct->msg.payload);\n    422  \t}\n    424  }\nFunction: net__handle_ssl\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:938\n    938  static int net__handle_ssl(struct mosquitto* mosq, int ret)\n    939  {\n    942  \terr = SSL_get_error(mosq->ssl, ret);\n    943  \tif (err == SSL_ERROR_WANT_READ) {\n    946  \t}\n    947  \telse if (err == SSL_ERROR_WANT_WRITE) {\n    950  \t\tmux__add_out(mosq);\n    955  \t}\n    956  \telse {\n    957  \t\tnet__print_ssl_error(mosq);\n    959  \t}\n    966  }\nFunction: net__write\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:996\n    996  ssize_t net__write(struct mosquitto *mosq, const void *buf, size_t count)\n    997  {\n    999  \tint ret;\n    1001 \tassert(mosq);\n    1005 \tif(mosq->ssl){\n    1007 \t\tmosq->want_write = false;\n    1008 \t\tret = SSL_write(mosq->ssl, buf, (int)count);\n    1009 \t\tif(ret < 0){\n    1010 \t\t\tret = net__handle_ssl(mosq, ret);\n    1011 \t\t}\n    1012 \t\treturn (ssize_t )ret;\n    1013 \t}else{\n    1017 \treturn send(mosq->sock, buf, count, MSG_NOSIGNAL);\n    1020 \t}\n    1022 }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    51   \tassert(packet);\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__write_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:61\n    61   void packet__write_byte(struct mosquitto__packet *packet, uint8_t byte)\n    64   \tassert(packet->pos+1 <= packet->packet_length);\n    66   \tpacket->payload[packet->pos] = byte;\n    67   \tpacket->pos++;\n    68   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    73   \tassert(packet);\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__write_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:83\n    83   void packet__write_bytes(struct mosquitto__packet *packet, const void *bytes, uint32_t count)\n    84   {\n    86   \tassert(packet->pos+count <= packet->packet_length);\n    88   \tif(count > 0){\n    89   \t\tmemcpy(&(packet->payload[packet->pos]), bytes, count);\n    90   \t\tpacket->pos += count;\n    91   \t}\n    92   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    157  \tassert(packet);\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    371  \t\tmux__delete(context);\n    372  \t\tcontext__disconnect(context);\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto__malloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:83\n    83   void *mosquitto__malloc(size_t size)\n    84   {\n    88   \tif(mem_limit && memcount + size > mem_limit){\n    89   \t\treturn NULL;\n    90   \t}\n    93   \tmem = malloc(size);\n    96   \tif(mem){\n    97   \t\tmemcount += malloc_usable_size(mem);\n    101  \t}\n    105  }\nFunction: mosquitto__strdup\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:144\n    144  char *mosquitto__strdup(const char *s)\n    145  {\n    148  \tif(mem_limit && memcount + strlen(s) > mem_limit){\n    149  \t\treturn NULL;\n    150  \t}\n    152  \tstr = strdup(s);\n    155  \tif(str){\n    156  \t\tmemcount += malloc_usable_size(str);\n    160  \t}\n    164  }\nFunction: mosquitto_free\nPath: /root/projects/mosquitto/src/memory_public.c:27\n    27   void mosquitto_free(void *mem)\n    29   \tmosquitto__free(mem);\n    30   }\nFunction: mosquitto_malloc\nPath: /root/projects/mosquitto/src/memory_public.c:32\n    32   void *mosquitto_malloc(size_t size)\n    34   \treturn mosquitto__malloc(size);\n    35   }\nFunction: mux__add_out\nPath: /root/projects/mosquitto/src/mux.c:31\n    31   int mux__add_out(struct mosquitto *context)\n    34   \treturn mux_epoll__add_out(context);\n    38   }\nFunction: mux__remove_out\nPath: /root/projects/mosquitto/src/mux.c:41\n    41   int mux__remove_out(struct mosquitto *context)\n    44   \treturn mux_epoll__remove_out(context);\n    48   }\nFunction: mux__delete\nPath: /root/projects/mosquitto/src/mux.c:61\n    61   int mux__delete(struct mosquitto *context)\n    64   \treturn mux_epoll__delete(context);\n    68   }\nFunction: mux_epoll__add_out\nPath: /root/projects/mosquitto/src/mux_epoll.c:108\n    108  int mux_epoll__add_out(struct mosquitto *context)\n    109  {\n    110  \tstruct epoll_event ev;\n    112  \tif(!(context->events & EPOLLOUT)) {\n    114  \t\tev.data.ptr = context;\n    116  \t\tif(epoll_ctl(db.epollfd, EPOLL_CTL_ADD, context->sock, &ev) == -1) {\n    117  \t\t\tif((errno != EEXIST)||(epoll_ctl(db.epollfd, EPOLL_CTL_MOD, context->sock, &ev) == -1)) {\n    119  \t\t\t}\n    120  \t\t}\n    121  \t\tcontext->events = EPOLLIN | EPOLLOUT;\n    122  \t}\n    124  }\nFunction: mux_epoll__remove_out\nPath: /root/projects/mosquitto/src/mux_epoll.c:127\n    127  int mux_epoll__remove_out(struct mosquitto *context)\n    128  {\n    129  \tstruct epoll_event ev;\n    131  \tif(context->events & EPOLLOUT) {\n    133  \t\tev.data.ptr = context;\n    135  \t\tif(epoll_ctl(db.epollfd, EPOLL_CTL_ADD, context->sock, &ev) == -1) {\n    136  \t\t\tif((errno != EEXIST)||(epoll_ctl(db.epollfd, EPOLL_CTL_MOD, context->sock, &ev) == -1)) {\n    138  \t\t\t}\n    139  \t\t}\n    140  \t\tcontext->events = EPOLLIN;\n    141  \t}\n    143  }\nFunction: mux_epoll__delete\nPath: /root/projects/mosquitto/src/mux_epoll.c:163\n    163  int mux_epoll__delete(struct mosquitto *context)\n    164  {\n    165  \tstruct epoll_event ev;\n    168  \tif(context->sock != INVALID_SOCKET){\n    169  \t\tif(epoll_ctl(db.epollfd, EPOLL_CTL_DEL, context->sock, &ev) == -1){\n    170  \t\t\treturn 1;\n    171  \t\t}\n    172  \t}\n    174  }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    32   \tmosquitto_property *connack_props = NULL;\n    33   \tuint32_t remaining_length;\n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    43   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->address, ack, reason_code);\n    44   \t}\n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    51   \t\t\tif(rc){\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    58   \t\t\tif(rc){\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    65   \t\t\tif(rc){\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    71   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_MAXIMUM_QOS, context->listener->max_qos);\n    72   \t\t\tif(rc){\n    73   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    78   \t\tremaining_length += property__get_remaining_length(connack_props);\n    79   \t}\n    81   \tif(packet__check_oversize(context, remaining_length)){\n    83   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    84   \t}\n    92   \tpacket->command = CMD_CONNACK;\n    93   \tpacket->remaining_length = remaining_length;\n    102  \tpacket__write_byte(packet, reason_code);\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    105  \t}\n    108  \treturn packet__queue(context, packet);\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    42   \tassert(mosq);\n    45   \tif(mosq->bridge){\n    46   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Bridge %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    47   \t}else\n    56   \tassert(mosq);\n    60   \tpacket->command = CMD_DISCONNECT;\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    62   \t\tpacket->remaining_length = 1;\n    63   \t\tif(properties){\n    64   \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    65   \t\t}\n    66   \t}else{\n    67   \t\tpacket->remaining_length = 0;\n    68   \t}\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    80   \t}\n    82   \treturn packet__queue(mosq, packet);\n    83   }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    126  \tassert(mosq);\n    130  \tpacket->command = command;\n    131  \tif(dup){\n    132  \t\tpacket->command |= 8;\n    133  \t}\n    134  \tpacket->remaining_length = 2;\n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    137  \t\tif(reason_code != 0 || properties){\n    138  \t\t\tpacket->remaining_length += 1;\n    139  \t\t}\n    141  \t\tif(properties){\n    142  \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    143  \t\t}\n    144  \t}\n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    161  \t}\n    163  \treturn packet__queue(mosq, packet);\n    164  }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    117  \treturn send__command_with_mid(mosq, CMD_PUBREL|2, mid, false, 0, properties);\n    118  }\nFunction: set_session_expiry_time\nPath: /root/projects/mosquitto/src/session_expiry.c:46\n    46   static void set_session_expiry_time(struct mosquitto *context)\n    47   {\n    50   \tif(db.config->persistent_client_expiration == 0){\n    52   \t\tcontext->session_expiry_time += context->session_expiry_interval;\n    53   \t}else{\n    55   \t\tif(db.config->persistent_client_expiration < context->session_expiry_interval){\n    58   \t\t}else{\n    60   \t\t\tcontext->session_expiry_time += context->session_expiry_interval;\n    61   \t\t}\n    62   \t}\n    63   }\nFunction: session_expiry__remove\nPath: /root/projects/mosquitto/src/session_expiry.c:121\n    121  void session_expiry__remove(struct mosquitto *context)\n    122  {\n    123  \tif(context->expiry_list_item){\n    124  \t\tDL_DELETE(expiry_list, context->expiry_list_item);\n    125  \t\tmosquitto__free(context->expiry_list_item);\n    126  \t\tcontext->expiry_list_item = NULL;\n    127  \t}\n    128  }\nFunction: mosquitto_acl_check\nPath: /root/projects/mosquitto/src/security.c:679\n    679  int mosquitto_acl_check(struct mosquitto *context, const char *topic, uint32_t payloadlen, void* payload, uint8_t qos, bool retain, int access)\n    680  {\n    681  \tint rc;\n    682  \tint i;\n    683  \tstruct mosquitto__security_options *opts;\n    684  \tstruct mosquitto_acl_msg msg;\n    685  \tstruct mosquitto__callback *cb_base;\n    686  \tstruct mosquitto_evt_acl_check event_data;\n    688  \tif(!context->id){\n    689  \t\treturn MOSQ_ERR_ACL_DENIED;\n    690  \t}\n    691  \tif(context->bridge){\n    692  \t\treturn MOSQ_ERR_SUCCESS;\n    693  \t}\n    703  \tif(db.config->per_listener_settings){\n    704  \t\tif(context->listener){\n    705  \t\t\topts = &context->listener->security_options;\n    706  \t\t}else{\n    707  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    708  \t\t}\n    709  \t}else{\n    710  \t\topts = &db.config->security_options;\n    711  \t}\n    720  \tDL_FOREACH(opts->plugin_callbacks.acl_check, cb_base){\n    724  \t\tevent_data.client = context;\n    732  \t\trc = cb_base->cb(MOSQ_EVT_ACL_CHECK, &event_data, cb_base->userdata);\n    733  \t\tif(rc != MOSQ_ERR_PLUGIN_DEFER){\n    738  \tfor(i=0; i<opts->auth_plugin_config_count; i++){\n    739  \t\tif(opts->auth_plugin_configs[i].plugin.version < 5){\n    740  \t\t\trc = acl__check_single(&opts->auth_plugin_configs[i], context, &msg, access);\n    741  \t\t\tif(rc != MOSQ_ERR_PLUGIN_DEFER){\n    742  \t\t\t\treturn rc;\n    743  \t\t\t}\n    744  \t\t}\n    745  \t}\n    749  \tif(rc == MOSQ_ERR_PLUGIN_DEFER){\n    751  \t}\n    753  }\nFunction: sub__remove_shared_leaf\nPath: /root/projects/mosquitto/src/subs.c:190\n    190  static void sub__remove_shared_leaf(struct mosquitto__subhier *subhier, struct mosquitto__subshared *shared, struct mosquitto__subleaf *leaf)\n    191  {\n    192  \tDL_DELETE(shared->subs, leaf);\n    193  \tif(shared->subs == NULL){\n    194  \t\tHASH_DELETE(hh, subhier->shared, shared);\n    195  \t\tmosquitto__free(shared->name);\n    196  \t\tmosquitto__free(shared);\n    197  \t}\n    199  }\nFunction: sub__messages_queue\nPath: /root/projects/mosquitto/src/subs.c:659\n    659  int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n    660  {\n    661  \tint rc = MOSQ_ERR_SUCCESS, rc2;\n    662  \tint rc_normal = MOSQ_ERR_NO_SUBSCRIBERS, rc_shared = MOSQ_ERR_NO_SUBSCRIBERS;\n    663  \tstruct mosquitto__subhier *subhier;\n    664  \tchar **split_topics = NULL;\n    677  \tHASH_FIND(hh, db.normal_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    678  \tif(subhier){\n    679  \t\trc_normal = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    680  \t\tif(rc_normal > 0){\n    682  \t\t\tgoto end;\n    683  \t\t}\n    684  \t}\n    686  \tHASH_FIND(hh, db.shared_subs, split_topics[0], strlen(split_topics[0]), subhier);\n    687  \tif(subhier){\n    688  \t\trc_shared = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n    689  \t\tif(rc_shared > 0){\n    691  \t\t\tgoto end;\n    692  \t\t}\n    693  \t}\n    695  \tif(rc_normal == MOSQ_ERR_NO_SUBSCRIBERS && rc_shared == MOSQ_ERR_NO_SUBSCRIBERS){\n    697  \t}\n    711  }\nFunction: sub__search\nPath: /root/projects/mosquitto/src/subs.c:479\n    479  static int sub__search(struct mosquitto__subhier *subhier, char **split_topics, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    480  {\n    482  \tstruct mosquitto__subhier *branch;\n    486  \tif(split_topics && split_topics[0]){\n    488  \t\tHASH_FIND(hh, subhier->children, split_topics[0], strlen(split_topics[0]), branch);\n    490  \t\tif(branch){\n    491  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    492  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    494  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    495  \t\t\t\treturn rc;\n    496  \t\t\t}\n    497  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    498  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    499  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    501  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    502  \t\t\t\t\treturn rc;\n    503  \t\t\t\t}\n    504  \t\t\t}\n    505  \t\t}\n    508  \t\tHASH_FIND(hh, subhier->children, \"+\", 1, branch);\n    510  \t\tif(branch){\n    511  \t\t\trc = sub__search(branch, &(split_topics[1]), source_id, topic, qos, retain, stored);\n    512  \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    514  \t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    515  \t\t\t\treturn rc;\n    516  \t\t\t}\n    517  \t\t\tif(split_topics[1] == NULL){ /* End of list */\n    518  \t\t\t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    519  \t\t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    521  \t\t\t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    522  \t\t\t\t\treturn rc;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}\n    526  \t}\n    529  \tHASH_FIND(hh, subhier->children, \"#\", 1, branch);\n    530  \tif(branch && !branch->children){\n    535  \t\trc = subs__process(branch, source_id, topic, qos, retain, stored);\n    536  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    538  \t\t}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){\n    539  \t\t\treturn rc;\n    540  \t\t}\n    541  \t}\n    548  }\nFunction: subs__process\nPath: /root/projects/mosquitto/src/subs.c:129\n    129  static int subs__process(struct mosquitto__subhier *hier, const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    130  {\n    133  \tstruct mosquitto__subleaf *leaf;\n    135  \trc = subs__shared_process(hier, topic, qos, retain, stored);\n    137  \tleaf = hier->subs;\n    138  \twhile(source_id && leaf){\n    139  \t\tif(!leaf->context->id || (leaf->no_local && !strcmp(leaf->context->id, source_id))){\n    140  \t\t\tleaf = leaf->next;\n    142  \t\t}\n    147  \t\tleaf = leaf->next;\n    148  \t}\n    149  \tif(hier->subs || hier->shared){\n    150  \t\treturn rc;\n    151  \t}else{\n    152  \t\treturn MOSQ_ERR_NO_SUBSCRIBERS;\n    153  \t}\n    154  }\nFunction: subs__send\nPath: /root/projects/mosquitto/src/subs.c:63\n    63   static int subs__send(struct mosquitto__subleaf *leaf, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store *stored)\n    64   {\n    65   \tbool client_retain;\n    66   \tuint16_t mid;\n    67   \tuint8_t client_qos, msg_qos;\n    68   \tmosquitto_property *properties = NULL;\n    72   \trc2 = mosquitto_acl_check(leaf->context, topic, stored->payloadlen, stored->payload, stored->qos, stored->retain, MOSQ_ACL_READ);\n    73   \tif(rc2 == MOSQ_ERR_ACL_DENIED){\n    74   \t\treturn MOSQ_ERR_SUCCESS;\n    75   \t}else if(rc2 == MOSQ_ERR_SUCCESS){\n    76   \t\tclient_qos = leaf->qos;\n    87   \t\tif(msg_qos){\n    88   \t\t\tmid = mosquitto__mid_generate(leaf->context);\n    89   \t\t}else{\n    92   \t\tif(leaf->retain_as_published){\n    93   \t\t\tclient_retain = retain;\n    94   \t\t}else{\n    97   \t\tif(leaf->identifier){\n    98   \t\t\tmosquitto_property_add_varint(&properties, MQTT_PROP_SUBSCRIPTION_IDENTIFIER, leaf->identifier);\n    99   \t\t}\n    100  \t\tif(db__message_insert(leaf->context, mid, mosq_md_out, msg_qos, client_retain, stored, properties, true) == 1){\n    101  \t\t\treturn 1;\n    102  \t\t}\n    103  \t}else{\n    104  \t\treturn 1; /* Application error */\n    105  \t}\n    107  }\nFunction: sub__clean_session\nPath: /root/projects/mosquitto/src/subs.c:746\n    746  int sub__clean_session(struct mosquitto *context)\n    747  {\n    748  \tint i;\n    749  \tstruct mosquitto__subleaf *leaf;\n    750  \tstruct mosquitto__subhier *hier;\n    752  \tfor(i=0; i<context->sub_count; i++){\n    753  \t\tif(context->subs[i] == NULL){\n    755  \t\t}\n    757  \t\thier = context->subs[i]->hier;\n    759  \t\tif(context->subs[i]->shared){\n    760  \t\t\tleaf = context->subs[i]->shared->subs;\n    761  \t\t\twhile(leaf){\n    762  \t\t\t\tif(leaf->context==context){\n    766  \t\t\t\t\tsub__remove_shared_leaf(context->subs[i]->hier, context->subs[i]->shared, leaf);\n    768  \t\t\t\t}\n    769  \t\t\t\tleaf = leaf->next;\n    770  \t\t\t}\n    771  \t\t}else{\n    772  \t\t\tleaf = hier->subs;\n    773  \t\t\twhile(leaf){\n    774  \t\t\t\tif(leaf->context==context){\n    778  \t\t\t\t\tDL_DELETE(hier->subs, leaf);\n    779  \t\t\t\t\tmosquitto__free(leaf);\n    781  \t\t\t\t}\n    782  \t\t\t\tleaf = leaf->next;\n    783  \t\t\t}\n    784  \t\t}\n    785  \t\tmosquitto__free(context->subs[i]);\n    786  \t\tcontext->subs[i] = NULL;\n    788  \t\tif(hier->subs == NULL\n    789  \t\t\t\t&& hier->children == NULL\n    790  \t\t\t\t&& hier->shared == NULL\n    791  \t\t\t\t&& hier->parent){\n    794  \t\t\t\thier = tmp_remove_subs(hier);\n    795  \t\t\t}while(hier);\n    796  \t\t}\n    797  \t}\n    798  \tmosquitto__free(context->subs);\n    799  \tcontext->subs = NULL;\n    800  \tcontext->sub_count = 0;\n    803  }\nFunction: tmp_remove_subs\nPath: /root/projects/mosquitto/src/subs.c:715\n    715  static struct mosquitto__subhier *tmp_remove_subs(struct mosquitto__subhier *sub)\n    716  {\n    719  \tif(!sub || !sub->parent){\n    720  \t\treturn NULL;\n    721  \t}\n    723  \tif(sub->children || sub->subs){\n    724  \t\treturn NULL;\n    725  \t}\n    727  \tparent = sub->parent;\n    728  \tHASH_DELETE(hh, parent->children, sub);\n    729  \tmosquitto__free(sub->topic);\n    730  \tmosquitto__free(sub);\n    732  \tif(parent->subs == NULL\n    733  \t\t\t&& parent->children == NULL\n    734  \t\t\t&& parent->shared == NULL\n    735  \t\t\t&& parent->parent){\n    737  \t\treturn parent;\n    738  \t}else{\n    739  \t\treturn NULL;\n    740  \t}\n    741  }\nFunction: mosquitto_validate_utf8\nPath: /root/projects/mosquitto/src/../lib/utf8_mosq.c:24\n    24   int mosquitto_validate_utf8(const char *str, int len)\n    25   {\n    26   \tint i;\n    27   \tint j;\n    28   \tint codelen;\n    29   \tint codepoint;\n    32   \tif(!str) return MOSQ_ERR_INVAL;\n    35   \tfor(i=0; i<len; i++){\n    36   \t\tif(ustr[i] == 0){\n    37   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    38   \t\t}else if(ustr[i] <= 0x7f){\n    40   \t\t\tcodepoint = ustr[i];\n    41   \t\t}else if((ustr[i] & 0xE0) == 0xC0){\n    43   \t\t\tif(ustr[i] == 0xC0 || ustr[i] == 0xC1){\n    45   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    46   \t\t\t}\n    48   \t\t\tcodepoint = (ustr[i] & 0x1F);\n    49   \t\t}else if((ustr[i] & 0xF0) == 0xE0){\n    52   \t\t\tcodepoint = (ustr[i] & 0x0F);\n    53   \t\t}else if((ustr[i] & 0xF8) == 0xF0){\n    55   \t\t\tif(ustr[i] > 0xF4){\n    57   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    58   \t\t\t}\n    60   \t\t\tcodepoint = (ustr[i] & 0x07);\n    61   \t\t}else{\n    63   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    64   \t\t}\n    67   \t\tif(i == len-codelen+1){\n    69   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    70   \t\t}\n    71   \t\tfor(j=0; j<codelen-1; j++){\n    72   \t\t\tif((ustr[++i] & 0xC0) != 0x80){\n    74   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    75   \t\t\t}\n    76   \t\t\tcodepoint = (codepoint<<6) | (ustr[i] & 0x3F);\n    77   \t\t}\n    80   \t\tif(codepoint >= 0xD800 && codepoint <= 0xDFFF){\n    81   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    82   \t\t}\n    88   \t\t *\t return MOSQ_ERR_MALFORMED_UTF8;\n    91   \t\tif(codelen == 3 && codepoint < 0x0800){\n    92   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    93   \t\t}else if(codelen == 4 && (codepoint < 0x10000 || codepoint > 0x10FFFF)){\n    94   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    95   \t\t}\n    98   \t\tif(codepoint >= 0xFDD0 && codepoint <= 0xFDEF){\n    99   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    100  \t\t}\n    101  \t\tif((codepoint & 0xFFFF) == 0xFFFE || (codepoint & 0xFFFF) == 0xFFFF){\n    102  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    103  \t\t}\n    105  \t\tif(codepoint <= 0x001F || (codepoint >= 0x007F && codepoint <= 0x009F)){\n    106  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    107  \t\t}\n    108  \t}\n    110  }\nFunction: mosquitto__get_state\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:295\n    295  enum mosquitto_client_state mosquitto__get_state(struct mosquitto *mosq)\n    300  \tstate = mosq->state;\n    303  \treturn state;\n    304  }\nFunction: util__increment_receive_quota\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:215\n    215  void util__increment_receive_quota(struct mosquitto *mosq)\n    216  {\n    217  \tif(mosq->msgs_in.inflight_quota < mosq->msgs_in.inflight_maximum){\n    218  \t\tmosq->msgs_in.inflight_quota++;\n    219  \t}\n    220  }\nFunction: mosquitto__set_state\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:281\n    281  int mosquitto__set_state(struct mosquitto *mosq, enum mosquitto_client_state state)\n    282  {\n    285  \tif(mosq->state != mosq_cs_disused)\n    287  \t{\n    288  \t\tmosq->state = state;\n    289  \t}\n    293  }\nFunction: mosquitto_pub_topic_check\nPath: /root/projects/mosquitto/src/../lib/util_topic.c:50\n    50   int mosquitto_pub_topic_check(const char *str)\n    51   {\n    57   \tif(str == NULL){\n    58   \t\treturn MOSQ_ERR_INVAL;\n    59   \t}\n    61   \twhile(str && str[0]){\n    62   \t\tif(str[0] == '+' || str[0] == '#'){\n    63   \t\t\treturn MOSQ_ERR_INVAL;\n    64   \t\t}\n    66   \t\telse if(str[0] == '/'){\n    68   \t\t}\n    71   \t\tstr = &str[1];\n    72   \t}\n    79   }\nFunction: will_delay__remove\nPath: /root/projects/mosquitto/src/will_delay.c:99\n    99   void will_delay__remove(struct mosquitto *mosq)\n    100  {\n    101  \tif(mosq->will_delay_entry != NULL){\n    102  \t\tDL_DELETE(delay_list, mosq->will_delay_entry);\n    103  \t\tmosquitto__free(mosq->will_delay_entry);\n    104  \t\tmosq->will_delay_entry = NULL;\n    105  \t}\n    106  }\nFunction: will__clear\nPath: /root/projects/mosquitto/src/../lib/will_mosq.c:111\n    111  int will__clear(struct mosquitto *mosq)\n    112  {\n    113  \tif(!mosq->will) return MOSQ_ERR_SUCCESS;\n    115  \tmosquitto__free(mosq->will->msg.topic);\n    116  \tmosq->will->msg.topic = NULL;\n    118  \tmosquitto__free(mosq->will->msg.payload);\n    119  \tmosq->will->msg.payload = NULL;\n    121  \tmosquitto_property_free_all(&mosq->will->properties);\n    123  \tmosquitto__free(mosq->will);\n    124  \tmosq->will = NULL;\n    125  \tmosq->will_delay_interval = 0;\n    128  }\n",
    "Including Request Problem Information more than once, or having a value other than 0 or 1, is a Protocol Error.": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n ",
    "If a Server receives a CONNECT packet containing a Will Message with the Will Retain set to 1 and the Server does not support retained messages, the Server SHOULD send CONNACK with Reason Code 0x9A (Retain not supported) and then MUST close the Network Connection [MQTT-3.2.2-13].": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    212  }\nFunction: packet__read_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:178\n    178  int packet__read_uint32(struct mosquitto__packet *packet, uint32_t *word)\n    179  {\n    180  \tuint32_t val = 0;\n    181  \tint i;\n    184  \tif(packet->pos+4 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    186  \tfor(i=0; i<4; i++){\n    187  \t\tval = (val << 8) + packet->payload[packet->pos];\n    188  \t\tpacket->pos++;\n    189  \t}\n    191  \t*word = val;\n    194  }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    94   \tpacket->command = 0;\n    97   \tpacket->remaining_length = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    150  \tpacket->pos = 0;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    345  \t}\n    353  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    250  \t}\n    263  \tif(!context->clean_start){\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    319  \tmosquitto_property_free_all(&connack_props);\n    320  \tif(rc) return rc;\n    326  error:\n    328  \tmosquitto_property_free_all(&connack_props);\n    330  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    250  \tif(context->id){\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    258  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    705  \tconst char *source_id;\n    720  \tif(db.config->retain_available == false){\n    721  \t\tstored->retain = 0;\n    722  \t}else{\n    723  \t\tstored->retain = retain;\n    724  \t}\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    557  \t}else{\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    576  \t\trc = MOSQ_ERR_NOT_SUPPORTED;\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    976  \tcontext->clean_start = true;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    55   \tint i;\n    56   \tint pos;\n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    393  \t\t\t\tsend__connack(context, 0, MQTT_RC_PACKET_TOO_LARGE, NULL);\n    394  \t\t\t}else{\n    395  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    396  \t\t\t}\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    413  \t*will = will_struct;\n    424  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    73   \tassert(packet);\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    106  \t\t*length = 0;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    33   \tuint32_t remaining_length;\n    36   \tif(rc){\n    37   \t\treturn rc;\n    38   \t}\n    39   \n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    43   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->address, ack, reason_code);\n    44   \t}\n    45   \n    46   \tremaining_length = 2;\n    47   \n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    50   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_RETAIN_AVAILABLE, 0);\n    51   \t\t\tif(rc){\n    52   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    57   \t\t\trc = mosquitto_property_add_int32(&connack_props, MQTT_PROP_MAXIMUM_PACKET_SIZE, db.config->max_packet_size);\n    58   \t\t\tif(rc){\n    59   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    64   \t\t\trc = mosquitto_property_add_int16(&connack_props, MQTT_PROP_RECEIVE_MAXIMUM, db.config->max_inflight_messages);\n    65   \t\t\tif(rc){\n    66   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    71   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_MAXIMUM_QOS, context->listener->max_qos);\n    72   \t\t\tif(rc){\n    73   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    77   \n    78   \t\tremaining_length += property__get_remaining_length(connack_props);\n    79   \t}\n    80   \n    81   \tif(packet__check_oversize(context, remaining_length)){\n    82   \t\tmosquitto_property_free_all(&connack_props);\n    83   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    84   \t}\n    85   \n    86   \tpacket = mosquitto__calloc(1, sizeof(struct mosquitto__packet));\n    87   \tif(!packet){\n    88   \t\tmosquitto_property_free_all(&connack_props);\n    89   \t\treturn MOSQ_ERR_NOMEM;\n    90   \t}\n    91   \n    92   \tpacket->command = CMD_CONNACK;\n    93   \tpacket->remaining_length = remaining_length;\n    94   \n    95   \trc = packet__alloc(packet);\n    96   \tif(rc){\n    97   \t\tmosquitto_property_free_all(&connack_props);\n    98   \t\tmosquitto__free(packet);\n    99   \t\treturn rc;\n    100  \t}\n    101  \tpacket__write_byte(packet, ack);\n    102  \tpacket__write_byte(packet, reason_code);\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    104  \t\tproperty__write_all(packet, connack_props, true);\n    105  \t}\n    106  \tmosquitto_property_free_all(&connack_props);\n    107  \n    108  \treturn packet__queue(context, packet);\n    109  }\n    110  \n    111  \n    112  \n    113  \n    114  \n    115  \n    116  \n    117  \n    118  \n    119  \n    120  \n    121  \n    122  \n    123  \n    124  \n    125  \n    126  \n    127  \n    128  \n    129  \n    131  \n    132  \n    133  \n    134  \n    135  \n    136  \n    137  \n    138  \n    139  \n    140  \n    141  \n    142  \n    143  \n    144  \n    145  \n    146  \n    147  \n    148  \n    149  \n    150  \n    151  \n    152  \n    154  \n    156  \n    157  \n    158  \n    159  \n    160  \n    161  \n    162  \n    163  \n    165  \n    166  \n    167  \n    168  \n    169  \n    170  \n    171  \n    172  \n    173  \n    174  \n    175  \n    176  \n    177  \n    178  \n    179  \n    180  \n    181  \n    182  \n    183  \n    184  \n    185  \n    186  \n    187  \n    188  \n    189  \n    190  \n    191  \n    192  \n    193  \n    194  \n    195  \n    196  \n    197  \n    198  \n    199  \n    200  \n    201  \n    202  \n    203  \n    205  \n    206  \n    207  \n    208  \n    209  \n    210  \n    211  \n    212  \n    213  \n    214  \n    215  \n    216  \n    217  \n    218  \n    219  \n    220  \n    221  \n    222  \n    223  \n    224  \n    225  \n    226  \n    227  \n    228  \n    229  \n    230  \n    231  \n    232  \n    233  \n    234  \n    235  \n    236  \n    237  \n    238  \n    239  \n    240  \n    241  \n    242  \n    243  \n    245  \n    246  \n    247  \n    248  \n    250  \n    251  \n    252  \n    255  \n    256  \n    257  \n    258  \n    259  \n    260  \n    262  \n    263  \n    265  \n    266  \n    267  \n    268  \n    269  \n    270  \n    271  \n    273  \n    274  \n    275  \n    276  \n    277  \n    278  \n    279  \n    282  \n    283  \n    286  \n    287  \n    288  \n    289  \n    290  \n    291  \n    292  \n    293  \n    294  \n    295  \n    296  \n    297  \n    298  \n    301  \n    302  \n    304  \n    306  \n    307  \n    309  \n    311  \n    312  \n    313  \n    314  \n    315  \n    316  \n    317  \n    318  \n    319  \n    320  \n    322  \n    323  \n    325  \n    326  \n    327  \n    328  \n    330  \n    331  \n    332  \n    333  \n    334  \n    335  \n    336  \n    337  \n    338  \n    339  \n    340  \n    341  \n    342  \n    343  \n    344  \n    345  \n    347  \n    348  \n    350  \n    351  \n    354  \n    356  \n    357  \n    359  \n    360  \n    362  \n    363  \n    364  \n    365  \n    366  \n    367  \n    368  \n    369  \n    370  \n    371  \n    372  \n    373  \n    377  \n    379  \n    385  \n    390  \n    391  \n    393  \n    396  \n    397  \n    398  \n    400  \n    401  \n    403  \n    404  \n    406  \n    407  \n    408  \n    409  \n    410  \n    411  \n    412  \n    413  \n    414  \n    415  \n    418  \n    419  \n    420  \n    421  \n    423  \n    424  \n    426  \n    429  \n    431  \n    432  \n    435  \n    436  \n    437  \n    438  \n    441  \n    442  \n    443  \n    444  \n    445  \n    446  \n    447  \n    448  \n    449  \n    450  \n    451  \n    452  \n    453  \n    454  \n    455  \n    456  \n    459  \n    460  \n    464  \n    465  \n    466  \n    467  \n    468  \n    469  \n    470  \n    471  \n    472  \n    474  \n    475  \n    477  \n    478  \n    479  \n    482  \n    483  \n    484  \n    486  \n    488  \n    489  \n    490  \n    491  \n    492  \n    493  \n    494  \n    495  \n    496  \n    497  \n    498  \n    499  \n    500  \n    501  \n    503  \n    504  \n    506  \n    508  \n    510  \n    511  \n    512  \n    513  \n    514  \n    515  \n    516  \n    518  \n    519  \n    521  \n    524  \n    526  \n    527  \n    529  \n    530  \n    532  \n    534  \n    535  \n    536  \n    537  \n    538  \n    541  \n    542  \n    544  \n    545  \n    546  \n    547  \n    548  \n    549  \n    552  \n    554  \n    555  \n    557  \n    558  \n    561  \n    564  \n    565  \n    567  \n    568  \n    571  \n    572  \n    576  \n    579  \n    581  \n    582  \n    583  \n    584  \n    586  \n    587  \n    588  \n    592  \n    594  \n    599  \n    600  \n    602  \n    603  \n    604  \n    606  \n    611  \n    612  \n    613  \n    615  \n    616  \n    619  \n    620  \n    621  \n    624  \n    625  \n    630  \n    633  \n    635  \n    637  \n    640  \n    641  \n    642  \n    644  \n    645  \n    646  \n    647  \n    648  \n    650  \n    651  \n    652  \n    654  \n    655  \n    656  \n    658  \n    659  \n    661  \n    662  \n    663  \n    664  \n    665  \n    666  \n    667  \n    668  \n    669  \n    670  \n    674  \n    677  \n    681  \n    682  \n    684  \n    685  \n    686  \n    687  \n    688  \n    689  \n    691  \n    705  \n    706  \n    713  \n    715  \n    717  \n    719  \n    720  \n    721  \n    723  \n    724  \n    726  \n    728  \n    729  \n    732  \n    733  \n    734  \n    737  \n    749  \n    752  \n    753  \n    755  \n    757  \n    760  \n    761  \n    762  \n    766  \n    768  \n    769  \n    773  \n    774  \n    775  \n    778  \n    779  \n    780  \n    781  \n    789  \n    790  \n    797  \n    798  \n    800  \n    801  \n    802  \n    803  \n    804  \n    806  \n    808  \n    809  \n    811  \n    812  \n    813  \n    814  \n    816  \n    817  \n    818  \n    819  \n    820  \n    822  \n    824  \n    826  \n    829  \n    831  \n    833  \n    835  \n    839  \n    843  \n    852  \n    854  \n    855  \n    856  \n    858  \n    860  \n    861  \n    862  \n    863  \n    866  \n    867  \n    868  \n    869  \n    872  \n    873  \n    875  \n    876  \n    877  \n    880  \n    881  \n    884  \n    885  \n    886  \n    887  \n    894  \n    895  \n    898  \n    900  \n    901  \n    904  \n    906  \n    907  \n    908  \n    909  \n    911  \n    912  \n    913  \n    915  \n    916  \n    919  \n    920  \n    921  \n    923  \n    933  \n    941  \n    943  \n    946  \n    949  \n    953  \n    954  \n    958  \n    959  \n    960  \n    961  \n    962  \n    963  \n    965  \n    966  \n    967  \n    978  \n    979  \n    980  \n    986  \n    987  \n    1002 \n    1005 \n    1006 \n    1008 \n    1010 \n    1016 \n    1018 \n    1020 \n    1021 \n    1023 \n    1039 \n    1049 \n    1050 \n    1055 \n    1056 \n    1057 \n    1058 \n    1060 \n    1062 \n    1066 \n    1071 \n    1075 \n    1076 \n    1077 \n    1079 \n    1090 \n    1091 \n    1092 \n    1093 \n    1097 \n    1100 \n    1101 \n    1109 \n    1115 \n    1117 \n    1118 \n    1120 \n    1122 \n    1123 \n    1124 \n    1125 \n    1129 \n    1130 \n    1133 \n    1134 \n    1136 \n    1138 \n    1139 \n    1140 \n    1141 \n    1146 \n    1147 \n    1149 \n    1150 \n    1151 \n    1153 \n    1154 \n    1158 \n    1160 \n    1161 \n    1168 \n    1169 \n    1170 \n    1171 \n    1173 \n    1174 \n    1175 \n    1177 \n    1178 \n    1179 \n    1180 \n    1182 \n    1185 \n    1186 \n    1187 \n    1188 \n    1190 \n    1193 \n    1194 \n    1195 \n    1196 \n    1197 \n    1199 \n    1205 \n    1207 \n    1208 \n    1210 \n    1214 \n    1215 \n    1217 \n    1220 \n    1221 \n    1223 \n    1229 \n    1231 \n    1235 \n    1237 \n    1239 \n    1240 \n    1242 \n    1245 \n    1252 \n    1253 \n    1254 \n    1257 \n    1262 \n    1263 \n    1265 \n    1266 \n    1267 \n    1275 \n    1276 \n    1277 \n    1278 \n    1279 \n    1280 \n    1281 \n    1284 \n    1285 \n    1286 \n    1287 \n    1290 \n    1291 \n    1300 \n    1313 \n    1314 \n    1315 \n    1321 \n    1370 \n    1557 \n    1579 \n    1618 \n    1620 \n    1622 \n    1624 \n    1626 \n    1628 \n    1630 \n    1632 \n    1634 \n    1640 \n    1660 \n    1709 \n    1827 \n    1905 \n    1971 \n    1997 \n    2044 \n    2068 \n    2079 \n    2107 \nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    45   \tif(mosq->bridge){\n    46   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Bridge %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    47   \t}else\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    66   \t}else{\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    76   \t\tpacket__write_byte(packet, reason_code);\n    80   \t}\n    83   }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    118  }\nFunction: acl__check_single\nPath: /root/projects/mosquitto/src/security.c:602\n    602  static int acl__check_single(struct mosquitto__auth_plugin_config *auth_plugin, struct mosquitto *context, struct mosquitto_acl_msg *msg, int access)\n    603  {\n    608  \tif(auth_plugin->deny_special_chars == true){\n    615  \t\tif(username && strpbrk(username, \"+#\")){\n    617  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    618  \t\t}\n    619  \t\tif(context->id && strpbrk(context->id, \"+#\")){\n    620  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous client id \\\"%s\\\"\", context->id);\n    621  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    622  \t\t}\n    623  \t}\n    625  \tif(auth_plugin->plugin.version == 4){\n    626  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    627  \t\t\treturn MOSQ_ERR_SUCCESS;\n    628  \t\t}\n    629  \t\treturn auth_plugin->plugin.acl_check_v4(auth_plugin->plugin.user_data, access, context, msg);\n    630  \t}else if(auth_plugin->plugin.version == 3){\n    631  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    632  \t\t\treturn MOSQ_ERR_SUCCESS;\n    633  \t\t}\n    634  \t\treturn auth_plugin->plugin.acl_check_v3(auth_plugin->plugin.user_data, access, context, msg);\n    635  \t}else if(auth_plugin->plugin.version == 2){\n    636  \t\tif(access == MOSQ_ACL_SUBSCRIBE || access == MOSQ_ACL_UNSUBSCRIBE){\n    637  \t\t\treturn MOSQ_ERR_SUCCESS;\n    638  \t\t}\n    639  \t\treturn auth_plugin->plugin.acl_check_v2(auth_plugin->plugin.user_data, context->id, username, topic, access);\n    640  \t}else{\n    641  \t\treturn MOSQ_ERR_INVAL;\n    642  \t}\n    643  }\nFunction: mosquitto_validate_utf8\nPath: /root/projects/mosquitto/src/../lib/utf8_mosq.c:24\n    24   int mosquitto_validate_utf8(const char *str, int len)\n    25   {\n    26   \tint i;\n    28   \tint codelen;\n    29   \tint codepoint;\n    33   \tif(len < 0 || len > 65536) return MOSQ_ERR_INVAL;\n    35   \tfor(i=0; i<len; i++){\n    36   \t\tif(ustr[i] == 0){\n    37   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    38   \t\t}else if(ustr[i] <= 0x7f){\n    40   \t\t\tcodepoint = ustr[i];\n    41   \t\t}else if((ustr[i] & 0xE0) == 0xC0){\n    43   \t\t\tif(ustr[i] == 0xC0 || ustr[i] == 0xC1){\n    45   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    46   \t\t\t}\n    48   \t\t\tcodepoint = (ustr[i] & 0x1F);\n    49   \t\t}else if((ustr[i] & 0xF0) == 0xE0){\n    52   \t\t\tcodepoint = (ustr[i] & 0x0F);\n    53   \t\t}else if((ustr[i] & 0xF8) == 0xF0){\n    55   \t\t\tif(ustr[i] > 0xF4){\n    57   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    58   \t\t\t}\n    60   \t\t\tcodepoint = (ustr[i] & 0x07);\n    61   \t\t}else{\n    63   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    64   \t\t}\n    67   \t\tif(i == len-codelen+1){\n    69   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    70   \t\t}\n    71   \t\tfor(j=0; j<codelen-1; j++){\n    72   \t\t\tif((ustr[++i] & 0xC0) != 0x80){\n    74   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    75   \t\t\t}\n    76   \t\t\tcodepoint = (codepoint<<6) | (ustr[i] & 0x3F);\n    77   \t\t}\n    80   \t\tif(codepoint >= 0xD800 && codepoint <= 0xDFFF){\n    81   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    82   \t\t}\n    88   \t\t *\t return MOSQ_ERR_MALFORMED_UTF8;\n    91   \t\tif(codelen == 3 && codepoint < 0x0800){\n    92   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    93   \t\t}else if(codelen == 4 && (codepoint < 0x10000 || codepoint > 0x10FFFF)){\n    94   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    95   \t\t}\n    98   \t\tif(codepoint >= 0xFDD0 && codepoint <= 0xFDEF){\n    99   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    100  \t\t}\n    101  \t\tif((codepoint & 0xFFFF) == 0xFFFE || (codepoint & 0xFFFF) == 0xFFFF){\n    102  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    103  \t\t}\n    105  \t\tif(codepoint <= 0x001F || (codepoint >= 0x007F && codepoint <= 0x009F)){\n    106  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    107  \t\t}\n    108  \t}\n    110  }\nFunction: mosquitto__get_state\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:295\n    295  enum mosquitto_client_state mosquitto__get_state(struct mosquitto *mosq)\n    300  \tstate = mosq->state;\n    303  \treturn state;\n    304  }\nFunction: mosquitto__set_state\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:281\n    281  int mosquitto__set_state(struct mosquitto *mosq, enum mosquitto_client_state state)\n    282  {\n    285  \tif(mosq->state != mosq_cs_disused)\n    287  \t{\n    288  \t\tmosq->state = state;\n    289  \t}\n    293  }\nFunction: will__clear\nPath: /root/projects/mosquitto/src/../lib/will_mosq.c:111\n    111  int will__clear(struct mosquitto *mosq)\n    112  {\n    113  \tif(!mosq->will) return MOSQ_ERR_SUCCESS;\n    115  \tmosquitto__free(mosq->will->msg.topic);\n    116  \tmosq->will->msg.topic = NULL;\n    118  \tmosquitto__free(mosq->will->msg.payload);\n    119  \tmosq->will->msg.payload = NULL;\n    121  \tmosquitto_property_free_all(&mosq->will->properties);\n    123  \tmosquitto__free(mosq->will);\n    124  \tmosq->will = NULL;\n    128  }\n",
    "If the Client connects using a zero length Client Identifier, the Server MUST respond with a CONNACK containing a new Assigned Client Identifier not used by any other Session currently in the Server.": "Function: context__remove_from_by_id\nPath: /root/projects/mosquitto/src/context.c:302\n    302  void context__remove_from_by_id(struct mosquitto *context)\n    303  {\n    304  \tstruct mosquitto *context_found;\n    306  \tif(context->in_by_id == true && context->id){\n    307  \t\tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), context_found);\n    308  \t\tif(context_found){\n    309  \t\t\tHASH_DELETE(hh_id, db.contexts_by_id, context_found);\n    310  \t\t}\n    312  \t}\n    313  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    150  \tpacket->pos = 0;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    345  \t}\n    353  }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    250  \t}\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    294  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    319  \tmosquitto_property_free_all(&connack_props);\n    320  \tif(rc) return rc;\n    326  error:\n    328  \tmosquitto_property_free_all(&connack_props);\n    330  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    250  \tif(context->id){\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    205  \tsubhier = sub__add_hier_entry(NULL, &db.shared_subs, \"\", 0);\n    206  \tif(!subhier) return MOSQ_ERR_NOMEM;\n    208  \tsubhier = sub__add_hier_entry(NULL, &db.normal_subs, \"\", 0);\n    209  \tif(!subhier) return MOSQ_ERR_NOMEM;\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    705  \tconst char *source_id;\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    745  \t\t*properties = NULL;\n    746  \t}\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\n    766  \t\tstored->source_id = mosquitto__strdup(\"\");\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    557  \t}else{\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    613  \t\t\trc = MOSQ_ERR_PROTOCOL;\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    618  \n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    630  \t\t\t\trc = MOSQ_ERR_PROTOCOL;\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    639  \t\t\t\t\trc = MOSQ_ERR_NOMEM;\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    53   \tchar *client_id;\n    54   \tuint8_t rnd[16];\n    55   \tint i;\n    56   \tint pos;\n    57   \n    58   \tif(util__random_bytes(rnd, 16)) return NULL;\n    59   \n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    61   \n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    69   \n    70   \tpos = 0;\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    80   \n    81   \treturn client_id;\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    335  \tint rc = MOSQ_ERR_SUCCESS;\n    341  \tmosquitto_property *properties = NULL;\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    349  \t\trc = property__read_all(CMD_WILL, &context->in_packet, &properties);\n    350  \t\tif(rc) goto error_cleanup;\n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    353  \t\tmosquitto_property_free_all(&properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    391  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Client %s connected with too large Will payload\", client_id);\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    393  \t\t\t\tsend__connack(context, 0, MQTT_RC_PACKET_TOO_LARGE, NULL);\n    394  \t\t\t}else{\n    395  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    396  \t\t\t}\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    424  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    73   \tassert(packet);\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    106  \t\t*length = 0;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    32   \tmosquitto_property *connack_props = NULL;\n    33   \tuint32_t remaining_length;\n    35   \trc = mosquitto_property_copy_all(&connack_props, properties);\n    36   \tif(rc){\n    37   \t\treturn rc;\n    38   \t}\n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    50   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_RETAIN_AVAILABLE, 0);\n    51   \t\t\tif(rc){\n    52   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    57   \t\t\trc = mosquitto_property_add_int32(&connack_props, MQTT_PROP_MAXIMUM_PACKET_SIZE, db.config->max_packet_size);\n    58   \t\t\tif(rc){\n    59   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    64   \t\t\trc = mosquitto_property_add_int16(&connack_props, MQTT_PROP_RECEIVE_MAXIMUM, db.config->max_inflight_messages);\n    65   \t\t\tif(rc){\n    66   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    71   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_MAXIMUM_QOS, context->listener->max_qos);\n    72   \t\t\tif(rc){\n    73   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    78   \t\tremaining_length += property__get_remaining_length(connack_props);\n    79   \t}\n    81   \tif(packet__check_oversize(context, remaining_length)){\n    82   \t\tmosquitto_property_free_all(&connack_props);\n    83   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    84   \t}\n    87   \tif(!packet){\n    88   \t\tmosquitto_property_free_all(&connack_props);\n    89   \t\treturn MOSQ_ERR_NOMEM;\n    90   \t}\n    93   \tpacket->remaining_length = remaining_length;\n    96   \tif(rc){\n    97   \t\tmosquitto_property_free_all(&connack_props);\n    99   \t\treturn rc;\n    100  \t}\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    104  \t\tproperty__write_all(packet, connack_props, true);\n    105  \t}\n    106  \tmosquitto_property_free_all(&connack_props);\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    45   \tif(mosq->bridge){\n    46   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Bridge %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    47   \t}else\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    63   \t\tif(properties){\n    64   \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    65   \t\t}\n    66   \t}else{\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    77   \t\tif(properties){\n    78   \t\t\tproperty__write_all(packet, properties, true);\n    79   \t\t}\n    80   \t}\n    83   }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    117  \treturn send__command_with_mid(mosq, CMD_PUBREL|2, mid, false, 0, properties);\n    118  }\n",
    "The Server MUST NOT send the Reason String if the Reason String would increase the size of the CONNACK packet beyond the Maximum Packet Size specified by the Client.": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    221  \tplugin__handle_disconnect(context, -1);\n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    226  \tif(context->bridge == NULL)\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    232  \t\t\tif(context->will_delay_interval == 0){\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__read_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:178\n    178  int packet__read_uint32(struct mosquitto__packet *packet, uint32_t *word)\n    179  {\n    180  \tuint32_t val = 0;\n    181  \tint i;\n    183  \tassert(packet);\n    184  \tif(packet->pos+4 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    186  \tfor(i=0; i<4; i++){\n    187  \t\tval = (val << 8) + packet->payload[packet->pos];\n    188  \t\tpacket->pos++;\n    189  \t}\n    191  \t*word = val;\n    194  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    147  \tassert(mosq);\n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    153  \tpacket->next = NULL;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    187  \treturn packet__write(mosq);\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    353  }\nFunction: packet__check_oversize\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:211\n    211  int packet__check_oversize(struct mosquitto *mosq, uint32_t remaining_length)\n    212  {\n    213  \tuint32_t len;\n    214  \n    215  \tif(mosq->maximum_packet_size == 0) return MOSQ_ERR_SUCCESS;\n    216  \n    217  \tlen = remaining_length + packet__varint_bytes(remaining_length);\n    218  \tif(len > mosq->maximum_packet_size){\n    219  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    220  \t}else{\n    221  \t\treturn MOSQ_ERR_SUCCESS;\n    222  \t}\n    223  }\nFunction: property__process_connect\nPath: /root/projects/mosquitto/src/property_broker.c:30\n    30   int property__process_connect(struct mosquitto *context, mosquitto_property **props)\n    31   {\n    32   \tmosquitto_property *p;\n    34   \tp = *props;\n    36   \twhile(p){\n    37   \t\tif(p->identifier == MQTT_PROP_SESSION_EXPIRY_INTERVAL){\n    38   \t\t\tcontext->session_expiry_interval = p->value.i32;\n    39   \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM){\n    40   \t\t\tif(p->value.i16 == 0){\n    41   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    42   \t\t\t}\n    44   \t\t\tcontext->msgs_out.inflight_maximum = p->value.i16;\n    45   \t\t\tcontext->msgs_out.inflight_quota = context->msgs_out.inflight_maximum;\n    46   \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    47   \t\t\tif(p->value.i32 == 0){\n    48   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    49   \t\t\t}\n    50   \t\t\tcontext->maximum_packet_size = p->value.i32;\n    51   \t\t}\n    52   \t\tp = p->next;\n    53   \t}\n    56   }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__read\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:35\n    35   static int property__read(struct mosquitto__packet *packet, uint32_t *len, mosquitto_property *property)\n    36   {\n    38   \tuint32_t property_identifier;\n    39   \tuint8_t byte;\n    40   \tuint8_t byte_count;\n    41   \tuint16_t uint16;\n    42   \tuint32_t uint32;\n    43   \tuint32_t varint;\n    44   \tchar *str1, *str2;\n    45   \tuint16_t slen1, slen2;\n    47   \tif(!property) return MOSQ_ERR_INVAL;\n    49   \trc = packet__read_varint(packet, &property_identifier, NULL);\n    50   \tif(rc){\n    51   \t\treturn rc;\n    52   \t}\n    55   \tmemset(property, 0, sizeof(mosquitto_property));\n    57   \tproperty->identifier = (int32_t)property_identifier;\n    59   \tswitch(property_identifier){\n    60   \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    61   \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    62   \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    63   \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    64   \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    65   \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    66   \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    67   \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    68   \t\t\trc = packet__read_byte(packet, &byte);\n    69   \t\t\tif(rc) return rc;\n    71   \t\t\tproperty->value.i8 = byte;\n    72   \t\t\tbreak;\n    74   \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    75   \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    76   \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    77   \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    78   \t\t\trc = packet__read_uint16(packet, &uint16);\n    79   \t\t\tif(rc) return rc;\n    81   \t\t\tproperty->value.i16 = uint16;\n    82   \t\t\tbreak;\n    84   \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    85   \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    86   \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    87   \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    88   \t\t\trc = packet__read_uint32(packet, &uint32);\n    89   \t\t\tif(rc) return rc;\n    91   \t\t\tproperty->value.i32 = uint32;\n    92   \t\t\tbreak;\n    94   \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    95   \t\t\trc = packet__read_varint(packet, &varint, &byte_count);\n    96   \t\t\tif(rc) return rc;\n    98   \t\t\tproperty->value.varint = varint;\n    99   \t\t\tbreak;\n    101  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    102  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    103  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    104  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    105  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    106  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    107  \t\tcase MQTT_PROP_REASON_STRING:\n    108  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    109  \t\t\tif(rc) return rc;\n    110  \t\t\t*len = (*len) - 2 - slen1; /* uint16, string len */\n    111  \t\t\tproperty->value.s.v = str1;\n    112  \t\t\tproperty->value.s.len = slen1;\n    113  \t\t\tbreak;\n    115  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    116  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    117  \t\t\trc = packet__read_binary(packet, (uint8_t **)&str1, &slen1);\n    118  \t\t\tif(rc) return rc;\n    119  \t\t\t*len = (*len) - 2 - slen1; /* uint16, binary len */\n    120  \t\t\tproperty->value.bin.v = str1;\n    121  \t\t\tproperty->value.bin.len = slen1;\n    122  \t\t\tbreak;\n    124  \t\tcase MQTT_PROP_USER_PROPERTY:\n    125  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    126  \t\t\tif(rc) return rc;\n    127  \t\t\t*len = (*len) - 2 - slen1; /* uint16, string len */\n    129  \t\t\trc = packet__read_string(packet, &str2, &slen2);\n    130  \t\t\tif(rc){\n    131  \t\t\t\tmosquitto__free(str1);\n    132  \t\t\t\treturn rc;\n    133  \t\t\t}\n    136  \t\t\tproperty->name.v = str1;\n    137  \t\t\tproperty->name.len = slen1;\n    138  \t\t\tproperty->value.s.v = str2;\n    139  \t\t\tproperty->value.s.len = slen2;\n    140  \t\t\tbreak;\n    142  \t\tdefault:\n    144  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property_identifier);\n    146  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    147  \t}\n    150  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: property__write_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:429\n    429  int property__write_all(struct mosquitto__packet *packet, const mosquitto_property *properties, bool write_len)\n    430  {\n    432  \tconst mosquitto_property *p;\n    440  \twhile(p){\n    441  \t\trc = property__write(packet, p);\n    442  \t\tif(rc) return rc;\n    443  \t\tp = p->next;\n    444  \t}\n    447  }\nFunction: property__write\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:361\n    361  static int property__write(struct mosquitto__packet *packet, const mosquitto_property *property)\n    362  {\n    365  \trc = packet__write_varint(packet, (uint32_t)property->identifier);\n    366  \tif(rc) return rc;\n    368  \tswitch(property->identifier){\n    394  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    395  \t\t\treturn packet__write_varint(packet, property->value.varint);\n    397  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    398  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    399  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    400  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    401  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    402  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    403  \t\tcase MQTT_PROP_REASON_STRING:\n    404  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    405  \t\t\tbreak;\n    407  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    408  \t\tcase ",
    "The Server MUST NOT send the User Property if the User Property would increase the size of the CONNACK packet beyond the Maximum Packet Size specified by the Client [MQTT-3.2.2-20].": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    221  \tplugin__handle_disconnect(context, -1);\n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    226  \tif(context->bridge == NULL)\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    232  \t\t\tif(context->will_delay_interval == 0){\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__read_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:178\n    178  int packet__read_uint32(struct mosquitto__packet *packet, uint32_t *word)\n    179  {\n    180  \tuint32_t val = 0;\n    181  \tint i;\n    183  \tassert(packet);\n    184  \tif(packet->pos+4 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    186  \tfor(i=0; i<4; i++){\n    187  \t\tval = (val << 8) + packet->payload[packet->pos];\n    188  \t\tpacket->pos++;\n    189  \t}\n    191  \t*word = val;\n    194  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    147  \tassert(mosq);\n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    153  \tpacket->next = NULL;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    187  \treturn packet__write(mosq);\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    353  }\nFunction: packet__check_oversize\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:211\n    211  int packet__check_oversize(struct mosquitto *mosq, uint32_t remaining_length)\n    212  {\n    213  \tuint32_t len;\n    214  \n    215  \tif(mosq->maximum_packet_size == 0) return MOSQ_ERR_SUCCESS;\n    216  \n    217  \tlen = remaining_length + packet__varint_bytes(remaining_length);\n    218  \tif(len > mosq->maximum_packet_size){\n    219  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    220  \t}else{\n    221  \t\treturn MOSQ_ERR_SUCCESS;\n    222  \t}\n    223  }\nFunction: property__process_connect\nPath: /root/projects/mosquitto/src/property_broker.c:30\n    30   int property__process_connect(struct mosquitto *context, mosquitto_property **props)\n    31   {\n    32   \tmosquitto_property *p;\n    34   \tp = *props;\n    36   \twhile(p){\n    37   \t\tif(p->identifier == MQTT_PROP_SESSION_EXPIRY_INTERVAL){\n    38   \t\t\tcontext->session_expiry_interval = p->value.i32;\n    39   \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM){\n    40   \t\t\tif(p->value.i16 == 0){\n    41   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    42   \t\t\t}\n    44   \t\t\tcontext->msgs_out.inflight_maximum = p->value.i16;\n    45   \t\t\tcontext->msgs_out.inflight_quota = context->msgs_out.inflight_maximum;\n    46   \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    47   \t\t\tif(p->value.i32 == 0){\n    48   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    49   \t\t\t}\n    50   \t\t\tcontext->maximum_packet_size = p->value.i32;\n    51   \t\t}\n    52   \t\tp = p->next;\n    53   \t}\n    56   }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__read\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:35\n    35   static int property__read(struct mosquitto__packet *packet, uint32_t *len, mosquitto_property *property)\n    36   {\n    38   \tuint32_t property_identifier;\n    39   \tuint8_t byte;\n    40   \tuint8_t byte_count;\n    41   \tuint16_t uint16;\n    42   \tuint32_t uint32;\n    43   \tuint32_t varint;\n    44   \tchar *str1, *str2;\n    45   \tuint16_t slen1, slen2;\n    47   \tif(!property) return MOSQ_ERR_INVAL;\n    49   \trc = packet__read_varint(packet, &property_identifier, NULL);\n    50   \tif(rc){\n    51   \t\treturn rc;\n    52   \t}\n    55   \tmemset(property, 0, sizeof(mosquitto_property));\n    57   \tproperty->identifier = (int32_t)property_identifier;\n    59   \tswitch(property_identifier){\n    60   \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    61   \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    62   \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    63   \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    64   \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    65   \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    66   \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    67   \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    68   \t\t\trc = packet__read_byte(packet, &byte);\n    69   \t\t\tif(rc) return rc;\n    71   \t\t\tproperty->value.i8 = byte;\n    72   \t\t\tbreak;\n    74   \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    75   \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    76   \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    77   \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    78   \t\t\trc = packet__read_uint16(packet, &uint16);\n    79   \t\t\tif(rc) return rc;\n    81   \t\t\tproperty->value.i16 = uint16;\n    82   \t\t\tbreak;\n    84   \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    85   \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    86   \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    87   \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    88   \t\t\trc = packet__read_uint32(packet, &uint32);\n    89   \t\t\tif(rc) return rc;\n    91   \t\t\tproperty->value.i32 = uint32;\n    92   \t\t\tbreak;\n    94   \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    95   \t\t\trc = packet__read_varint(packet, &varint, &byte_count);\n    96   \t\t\tif(rc) return rc;\n    98   \t\t\tproperty->value.varint = varint;\n    99   \t\t\tbreak;\n    101  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    102  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    103  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    104  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    105  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    106  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    107  \t\tcase MQTT_PROP_REASON_STRING:\n    108  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    109  \t\t\tif(rc) return rc;\n    110  \t\t\t*len = (*len) - 2 - slen1; /* uint16, string len */\n    111  \t\t\tproperty->value.s.v = str1;\n    112  \t\t\tproperty->value.s.len = slen1;\n    113  \t\t\tbreak;\n    115  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    116  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    117  \t\t\trc = packet__read_binary(packet, (uint8_t **)&str1, &slen1);\n    118  \t\t\tif(rc) return rc;\n    119  \t\t\t*len = (*len) - 2 - slen1; /* uint16, binary len */\n    120  \t\t\tproperty->value.bin.v = str1;\n    121  \t\t\tproperty->value.bin.len = slen1;\n    122  \t\t\tbreak;\n    124  \t\tcase MQTT_PROP_USER_PROPERTY:\n    125  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    126  \t\t\tif(rc) return rc;\n    127  \t\t\t*len = (*len) - 2 - slen1; /* uint16, string len */\n    129  \t\t\trc = packet__read_string(packet, &str2, &slen2);\n    130  \t\t\tif(rc){\n    131  \t\t\t\tmosquitto__free(str1);\n    132  \t\t\t\treturn rc;\n    133  \t\t\t}\n    134  \t\t\t*len = (*len) - 2 - slen2; /* uint16, string len */\n    136  \t\t\tproperty->name.v = str1;\n    137  \t\t\tproperty->name.len = slen1;\n    138  \t\t\tproperty->value.s.v = str2;\n    139  \t\t\tproperty->value.s.len = slen2;\n    140  \t\t\tbreak;\n    142  \t\tdefault:\n    144  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property_identifier);\n    146  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    147  \t}\n    150  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: property__write_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:429\n    429  int property__write_all(struct mosquitto__packet *packet, const mosquitto_property *properties, bool write_len)\n    430  {\n    432  \tconst mosquitto_property *p;\n    434  \tif(write_len){\n    435  \t\trc = packet__write_varint(packet, property__get_length_all(properties));\n    436  \t\tif(rc) return rc;\n    437  \t}\n    440  \twhile(p){\n    441  \t\trc = property__write(packet, p);\n    442  \t\tif(rc) return rc;\n    443  \t\tp = p->next;\n    444  \t}\n    447  }\nFunction: property__write\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:361\n    361  static int property__write(struct mosquitto__packet *packet, const mosquitto_property *property)\n    362  {\n    365  \trc = packet__write_varint(packet, (uint32_t)property->identifier);\n    366  \tif(rc) return rc;\n    368  \tswitch(property->identifier){\n    369  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    370  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    371  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    372  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    373  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    374  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    375  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    376  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    377  \t\t\tpacket__write_byte(packet, property->value.i8);\n    378  \t\t\tbreak;\n    380  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    381  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    382  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    383  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    384  \t\t\tpacket__write_uint16(packet, property->value.i16);\n    385  \t\t\tbreak;\n    387  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    388  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    389  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    390  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    391  \t\t\tpacket__write_uint32(packet, property->value.i32);\n    392  \t\t\tbreak;\n    394  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    395  \t\t\treturn packet__write_varint(packet, property->value.varint);\n    397  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    398  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    399  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    400  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    401  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    402  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    403  \t\tcase MQTT_PROP_REASON_STRING:\n    404  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    405  \t\t\tbreak;\n    407  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    408  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    409  \t\t\tpacket__write_uint16(packet, property->value.bin.len);\n    410  \t\t\tpacket__write_bytes(packet, property->value.bin.v, property->value.bin.len);\n    411  \t\t\tbreak;\n    413  \t\tcase MQTT_PROP_USER_PROPERTY:\n    414  \t\t\tpacket__write_string(packet, property->name.v, property->name.len);\n    415  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    416  \t\t\tbreak;\n    418  \t\tdefault:\n    420  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property->identifier);\n    422  \t\t\treturn MOSQ_ERR_INVAL;\n    423  \t}\n    426  }\nFunction: db__expire_all_messages\nPath: /root/projects/mosquitto/src/database.c:1053\n    1053 void db__expire_all_messages(struct mosquitto *context)\n    1055 \tstruct mosquitto_client_msg *msg, *tmp;\n    1057 \tDL_FOREACH_SAFE(context->msgs_out.inflight, msg, tmp){\n    1058 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1059 \t\t\tif(msg->qos > 0){\n    1060 \t\t\t\tutil__increment_send_quota(context);\n    1062 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1065 \tDL_FOREACH_SAFE(context->msgs_out.queued, msg, tmp){\n    1066 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1067 \t\t\tdb__message_remove_from_queued(&context->msgs_out, msg);\n    1070 \tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n    1071 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1072 \t\t\tif(msg->qos > 0){\n    1073 \t\t\t\tutil__increment_receive_quota(context);\n    1075 \t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n    1078 \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n    1079 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1080 \t\t\tdb__message_remove_from_queued(&context->msgs_in, msg);\n    1083 }\nFunction: db__message_remove_from_queued\nPath: /root/projects/mosquitto/src/database.c:364\n    364  static void db__message_remove_from_queued(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    365  {\n    366  \tif(!msg_data || !item){\n    367  \t\treturn;\n    368  \t}\n    370  \tDL_DELETE(msg_data->queued, item);\n    375  \tmosquitto_property_free_all(&item->properties);\n    377  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1183 \tstruct mosquitto_client_msg *tail, *tmp;\n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1190 \tDL_FOREACH_SAFE(context->msgs_out.inflight, tail, tmp){\n    1191 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1192 \t\tif(rc) return rc;\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    143  \t\t\t\tin_quota = context->msgs_in.inflight_quota;\n    144  \t\t\t\tout_quota = context->msgs_out.inflight_quota;\n    145  \t\t\t\tin_maximum = context->msgs_in.inflight_maximum;\n    146  \t\t\t\tout_maximum = context->msgs_out.inflight_maximum;\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    154  \t\t\t\tcontext->msgs_in.inflight_quota = in_quota;\n    155  \t\t\t\tcontext->msgs_out.inflight_quota = out_quota;\n    156  \t\t\t\tcontext->msgs_in.inflight_maximum = in_maximum;\n    157  \t\t\t\tcontext->msgs_out.inflight_maximum = out_maximum;\n    159  \t\t\t\tdb__message_reconnect_reset(context);\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    215  \trc = acl__find_acls(context);\n    216  \tif(rc){\n    218  \t\treturn rc;\n    219  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    250  \t}\n    252  \tcontext->ping_t = 0;\n    253  \tcontext->is_dropping = false;\n    255  \tconnection_check_acl(context, &context->msgs_in.inflight);\n    256  \tconnection_check_acl(context, &context->msgs_in.queued);\n    257  \tconnection_check_acl(context, &context->msgs_out.inflight);\n    258  \tconnection_check_acl(context, &context->msgs_out.queued);\n    260  \tcontext__add_to_by_id(context);\n    263  \tif(!context->clean_start){\n    267  \tcontext->max_qos = context->listener->max_qos;\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    315  \tkeepalive__add(context);\n    317  \tmosquitto__set_state(context, mosq_cs_active);\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    319  \tmosquitto_property_free_all(&connack_props);\n    320  \tif(rc) return rc;\n    321  \tdb__expire_all_messages(context);\n    322  \trc = db__message_write_queued_out(context);\n    323  \tif(rc) return rc;\n    324  \trc = db__message_write_inflight_out_all(context);\n    326  error:\n    328  \tmosquitto_property_free_all(&connack_props);\n    330  }\nFunction: connection_check_acl\nPath: /root/projects/mosquitto/src/handle_connect.c:86\n    86   static void connection_check_acl(struct mosquitto *context, struct mosquitto_client_msg **head)\n    97   \t\tif(mosquitto_acl_check(context, msg_tail->store->topic,\n    99   \t\t\t\t\t\t\t   msg_tail->store->qos, msg_tail->store->retain, access) != MOSQ_ERR_SUCCESS){\n    101  \t\t\tDL_DELETE((*head), msg_tail);\n    103  \t\t\tmosquitto_property_free_all(&msg_tail->properties);\n    107  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    248  \tmosquitto__set_state(context, mosq_cs_disused);\n    250  \tif(context->id){\n    251  \t\tcontext__remove_from_by_id(context);\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    256  \tcontext->for_free_next = db.ll_for_free;\n    257  \tdb.ll_for_free = context;\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    296  \t\tcontext->in_by_id = true;\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__msg_add_to_queued_stats\nPath: /root/projects/mosquitto/src/database.c:162\n    162  void db__msg_add_to_queued_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    163  {\n    164  \tmsg_data->queued_count++;\n    165  \tmsg_data->queued_bytes += msg->store->payloadlen;\n    166  \tif(msg->qos != 0){\n    167  \t\tmsg_data->queued_count12++;\n    168  \t\tmsg_data->queued_bytes12 += msg->store->payloadlen;\n    169  \t}\n    170  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    271  \tmosquitto__free(store->source_id);\n    272  \tmosquitto__free(store->source_username);\n    280  \tmosquitto_property_free_all(&store->properties);\n    283  }\nFunction: db__message_remove_from_inflight\nPath: /root/projects/mosquitto/src/database.c:347\n    347  static void db__message_remove_from_inflight(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    348  {\n    349  \tif(!msg_data || !item){\n    350  \t\treturn;\n    351  \t}\n    353  \tDL_DELETE(msg_data->inflight, item);\n    354  \tif(item->store){\n    355  \t\tdb__msg_remove_from_inflight_stats(msg_data, item);\n    357  \t}\n    359  \tmosquitto_property_free_all(&item->properties);\n    361  }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1097 \tuint32_t expiry_interval;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1103 \t\t\tif(msg->direction == mosq_md_out && msg->qos > 0){\n    1104 \t\t\t\tutil__increment_send_quota(context);\n    1105 \t\t\t}\n    1106 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1126 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1135 \t\t\t\tmsg->timestamp = db.now_s;\n    1136 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1137 \t\t\t\tmsg->state = mosq_ms_wait_for_puback;\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1139 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1148 \t\t\t\tmsg->timestamp = db.now_s;\n    1149 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1150 \t\t\t\tmsg->state = mosq_ms_wait_for_pubrec;\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1152 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1159 \t\t\trc = send__pubrel(context, mid, NULL);\n    1160 \t\t\tif(!rc){\n    1161 \t\t\t\tmsg->state = mosq_ms_wait_for_pubcomp;\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1176 \t}\n    1178 }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    449  \tstruct mosquitto_msg_data *msg_data;\n    450  \tenum mosquitto_msg_state state = mosq_ms_invalid;\n    452  \tint i;\n    457  \tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n    459  \tif(dir == mosq_md_out){\n    460  \t\tmsg_data = &context->msgs_out;\n    461  \t}else{\n    462  \t\tmsg_data = &context->msgs_in;\n    463  \t}\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    484  \tif(context->sock == INVALID_SOCKET){\n    486  \t\tif(qos == 0 && !db.config->queue_qos0_messages){\n    487  \t\t\tif(!context->bridge){\n    489  \t\t\t\treturn 2;\n    490  \t\t\t}else{\n    491  \t\t\t\tif(context->bridge->start_type != bst_lazy){\n    493  \t\t\t\t\treturn 2;\n    494  \t\t\t\t}\n    495  \t\t\t}\n    496  \t\t}\n    497  \t\tif(context->bridge && context->bridge->clean_start_local == true){\n    499  \t\t\treturn 2;\n    500  \t\t}\n    501  \t}\n    503  \tif(context->sock != INVALID_SOCKET){\n    504  \t\tif(db__ready_for_flight(context, dir, qos)){\n    517  \t\t\t}else{\n    520  \t\t\t\t}else{\n    522  \t\t\t\t\treturn 1;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n    528  \t\t}else{\n    530  \t\t\tif(context->is_dropping == false){\n    531  \t\t\t\tcontext->is_dropping = true;\n    532  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    534  \t\t\t\t\t\tcontext->id);\n    535  \t\t\t}\n    538  \t\t\treturn 2;\n    539  \t\t}\n    540  \t}else{\n    541  \t\tif (db__ready_for_queue(context, qos, msg_data)){\n    543  \t\t}else{\n    545  \t\t\tif(context->is_dropping == false){\n    546  \t\t\t\tcontext->is_dropping = true;\n    547  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    549  \t\t\t\t\t\tcontext->id);\n    550  \t\t\t}\n    552  \t\t\treturn 2;\n    553  \t\t}\n    554  \t}\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    582  \tif(state == mosq_ms_queued){\n    583  \t\tDL_APPEND(msg_data->queued, msg);\n    585  \t}else{\n    586  \t\tDL_APPEND(msg_data->inflight, msg);\n    588  \t}\n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    598  \t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n    599  \t\tif(dest_ids){\n    602  \t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t}\n    609  \t}\n    611  \tif(context->bridge && context->bridge->start_type == bst_lazy\n    612  \t\t\t&& context->sock == INVALID_SOCKET\n    613  \t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n    616  \t}\n    633  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    704  \tstruct mosquitto_msg_store *stored;\n    705  \tconst char *source_id;\n    706  \tenum mosquitto_msg_origin origin;\n    710  \tstored = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    711  \tif(stored == NULL) return MOSQ_ERR_NOMEM;\n    713  \tstored->topic = mosquitto__strdup(topic);\n    714  \tif(stored->topic == NULL){\n    715  \t\tdb__msg_store_free(stored);\n    716  \t\treturn MOSQ_ERR_INVAL;\n    717  \t}\n    719  \tstored->qos = qos;\n    720  \tif(db.config->retain_available == false){\n    721  \t\tstored->retain = 0;\n    722  \t}else{\n    723  \t\tstored->retain = retain;\n    724  \t}\n    726  \tstored->payloadlen = payloadlen;\n    727  \tif(payloadlen > 0){\n    728  \t\tstored->payload = mosquitto__malloc(stored->payloadlen+1);\n    729  \t\tif(stored->payload == NULL){\n    730  \t\t\tdb__msg_store_free(stored);\n    731  \t\t\treturn MOSQ_ERR_NOMEM;\n    732  \t\t}\n    734  \t\t((uint8_t *)stored->payload)[stored->payloadlen] = 0;\n    735  \t\tmemcpy(stored->payload, payload, stored->payloadlen);\n    736  \t}\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    745  \t\t*properties = NULL;\n    746  \t}\n    748  \tif(context){\n    750  \t}else{\n    753  \tif(db__message_store(context, stored, message_expiry_interval, 0, origin)) return 1;\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    763  \tif(source && source->id){\n    764  \t\tstored->source_id = mosquitto__strdup(source->id);\n    765  \t}else{\n    766  \t\tstored->source_id = mosquitto__strdup(\"\");\n    767  \t}\n    768  \tif(!stored->source_id){\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    774  \tif(source && source->username){\n    775  \t\tstored->source_username = mosquitto__strdup(source->username);\n    776  \t\tif(!stored->source_username){\n    778  \t\t\treturn MOSQ_ERR_NOMEM;\n    779  \t\t}\n    780  \t}\n    781  \tif(source){\n    782  \t\tstored->source_listener = source->listener;\n    783  \t}\n    806  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    448  \tX509 *client_cert = NULL;\n    460  \tif(!context->listener){\n    461  \t\treturn MOSQ_ERR_INVAL;\n    462  \t}\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    502  \t\tcontext->protocol = mosq_p_mqtt31;\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    504  \t\t\tcontext->is_bridge = true;\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    508  \t\t\tcontext->protocol = mosq_p_mqtt311;\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    511  \t\t\t\tcontext->is_bridge = true;\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    514  \t\t\tcontext->protocol = mosq_p_mqtt5;\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    563  \t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid Will QoS in CONNECT from %s.\",\n    564  \t\t\t\tcontext->address);\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    724  \tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    731  \t\tif(!context->ssl){\n    732  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    741  \t\tif(context->listener->psk_hint){\n    743  \t\t\tif(!context->username){\n    744  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    754  \t\t\tclient_cert = SSL_get_peer_certificate(context->ssl);\n    755  \t\t\tif(!client_cert){\n    756  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    764  \t\t\tname = X509_get_subject_name(client_cert);\n    765  \t\t\tif(!name){\n    766  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    774  \t\t\tif (context->listener->use_identity_as_username) { /* use_identity_as_username */\n    775  \t\t\t\ti = X509_NAME_get_index_by_NID(name, NID_commonName, -1);\n    776  \t\t\t\tif(i == -1){\n    777  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    785  \t\t\t\tname_entry = X509_NAME_get_entry(name, i);\n    786  \t\t\t\tif(name_entry){\n    787  \t\t\t\t\tname_asn1 = X509_NAME_ENTRY_get_data(name_entry);\n    788  \t\t\t\t\tif (name_asn1 == NULL) {\n    789  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    801  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_get0_data(name_asn1);\n    803  \t\t\t\t\tif(mosquitto_validate_utf8(new_username, (int)strlen(new_username))){\n    804  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    809  \t\t\t\t\t\tX509_free(client_cert);\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    814  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    824  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    835  \t\t\t\tX509_NAME_print_ex(subject_bio, X509_get_subject_name(client_cert), 0, XN_FLAG_RFC2253);\n    847  \t\t\t\tcontext->username = subject;\n    849  \t\t\tif(!context->username){\n    853  \t\t\tX509_free(client_cert);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    898  \t\t\tmosquitto__set_state(context, mosq_cs_authenticating);\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    905  \t\t\twill__clear(context);\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    925  \t\tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    973  \tif(client_cert) X509_free(client_cert);\n    976  \tcontext->clean_start = true;\n    977  \tcontext->session_expiry_interval = 0;\n    978  \tcontext->will_delay_interval = 0;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    55   \tint i;\n    56   \tint pos;\n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    335  \tint rc = MOSQ_ERR_SUCCESS;\n    337  \tuint16_t tlen;\n    340  \tuint16_t payloadlen;\n    341  \tmosquitto_property *properties = NULL;\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    349  \t\trc = property__read_all(CMD_WILL, &context->in_packet, &properties);\n    350  \t\tif(rc) goto error_cleanup;\n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    353  \t\tmosquitto_property_free_all(&properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    356  \trc = packet__read_string(&context->in_packet, &will_struct->msg.topic, &tlen);\n    357  \tif(rc) goto error_cleanup;\n    363  \tif(context->listener->mount_point){\n    364  \t\tslen = strlen(context->listener->mount_point) + strlen(will_struct->msg.topic) + 1;\n    365  \t\twill_topic_mount = mosquitto__malloc(slen+1);\n    366  \t\tif(!will_topic_mount){\n    368  \t\t\tgoto error_cleanup;\n    369  \t\t}\n    371  \t\tsnprintf(will_topic_mount, slen, \"%s%s\", context->listener->mount_point, will_struct->msg.topic);\n    372  \t\twill_topic_mount[slen] = '\\0';\n    374  \t\tmosquitto__free(will_struct->msg.topic);\n    375  \t\twill_struct->msg.topic = will_topic_mount;\n    376  \t}\n    378  \tif(!strncmp(will_struct->msg.topic, \"$CONTROL/\", strlen(\"$CONTROL/\"))){\n    380  \t\tgoto error_cleanup;\n    381  \t}\n    382  \trc = mosquitto_pub_topic_check(will_struct->msg.topic);\n    385  \trc = packet__read_uint16(&context->in_packet, &payloadlen);\n    386  \tif(rc) goto error_cleanup;\n    388  \twill_struct->msg.payloadlen = payloadlen;\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    393  \t\t\t\tsend__connack(context, 0, MQTT_RC_PACKET_TOO_LARGE, NULL);\n    394  \t\t\t}else{\n    395  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    396  \t\t\t}\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    400  \t\twill_struct->msg.payload = mosquitto__malloc((size_t)will_struct->msg.payloadlen);\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    406  \t\trc = packet__read_bytes(&context->in_packet, will_struct->msg.payload, (uint32_t)will_struct->msg.payloadlen);\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    416  error_cleanup:\n    417  \tif(will_struct){\n    418  \t\tmosquitto__free(will_struct->msg.topic);\n    419  \t\tmosquitto__free(will_struct->msg.payload);\n    422  \t}\n    424  }\nFunction: net__write\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:996\n    996  ssize_t net__write(struct mosquitto *mosq, const void *buf, size_t count)\n    997  {\n    999  \tint ret;\n    1001 \tassert(mosq);\n    1005 \tif(mosq->ssl){\n    1007 \t\tmosq->want_write = false;\n    1008 \t\tret = SSL_write(mosq->ssl, buf, (int)count);\n    1009 \t\tif(ret < 0){\n    1010 \t\t\tret = net__handle_ssl(mosq, ret);\n    1011 \t\t}\n    1012 \t\treturn (ssize_t )ret;\n    1013 \t}else{\n    1017 \treturn send(mosq->sock, buf, count, MSG_NOSIGNAL);\n    1020 \t}\n    1022 }\nFunction: packet__write_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:61\n    61   void packet__write_byte(struct mosquitto__packet *packet, uint8_t byte)\n    64   \tassert(packet->pos+1 <= packet->packet_length);\n    66   \tpacket->payload[packet->pos] = byte;\n    67   \tpacket->pos++;\n    68   }\nFunction: packet__write_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:83\n    83   void packet__write_bytes(struct mosquitto__packet *packet, const void *bytes, uint32_t count)\n    84   {\n    86   \tassert(packet->pos+count <= packet->packet_length);\n    88   \tif(count > 0){\n    89   \t\tmemcpy(&(packet->payload[packet->pos]), bytes, count);\n    90   \t\tpacket->pos += count;\n    91   \t}\n    92   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    371  \t\tmux__delete(context);\n    372  \t\tcontext__disconnect(context);\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto__malloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:83\n    83   void *mosquitto__malloc(size_t size)\n    84   {\n    88   \tif(mem_limit && memcount + size > mem_limit){\n    89   \t\treturn NULL;\n    90   \t}\n    93   \tmem = malloc(size);\n    96   \tif(mem){\n    97   \t\tmemcount += malloc_usable_size(mem);\n    101  \t}\n    105  }\nFunction: mosquitto__strdup\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:144\n    144  char *mosquitto__strdup(const char *s)\n    145  {\n    148  \tif(mem_limit && memcount + strlen(s) > mem_limit){\n    149  \t\treturn NULL;\n    150  \t}\n    152  \tstr = strdup(s);\n    155  \tif(str){\n    156  \t\tmemcount += malloc_usable_size(str);\n    160  \t}\n    164  }\nFunction: mosquitto_free\nPath: /root/projects/mosquitto/src/memory_public.c:27\n    27   void mosquitto_free(void *mem)\n    29   \tmosquitto__free(mem);\n    30   }\nFunction: mosquitto_malloc\nPath: /root/projects/mosquitto/src/memory_public.c:32\n    32   void *mosquitto_malloc(size_t size)\n    34   \treturn mosquitto__malloc(size);\n    35   }\nFunction: mux_epoll__add_out\nPath: /root/projects/mosquitto/src/mux_epoll.c:108\n    108  int mux_epoll__add_out(struct mosquitto *context)\n    109  {\n    110  \tstruct epoll_event ev;\n    112  \tif(!(context->events & EPOLLOUT)) {\n    114  \t\tev.data.ptr = context;\n    116  \t\tif(epoll_ctl(db.epollfd, EPOLL_CTL_ADD, context->sock, &ev) == -1) {\n    117  \t\t\tif((errno != EEXIST)||(epoll_ctl(db.epollfd, EPOLL_CTL_MOD, context->sock, &ev) == -1)) {\n    119  \t\t\t}\n    120  \t\t}\n    121  \t\tcontext->events = EPOLLIN | EPOLLOUT;\n    122  \t}\n    124  }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    32   \tmosquitto_property *connack_props = NULL;\n    33   \tuint32_t remaining_length;\n    35   \trc = mosquitto_property_copy_all(&connack_props, properties);\n    36   \tif(rc){\n    37   \t\treturn rc;\n    38   \t}\n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    43   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->address, ack, reason_code);\n    44   \t}\n    48   \tif(context->protocol == mosq_p_mqtt5){\n    49   \t\tif(reason_code < 128 && db.config->retain_available == false){\n    50   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_RETAIN_AVAILABLE, 0);\n    51   \t\t\tif(rc){\n    52   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    53   \t\t\t\treturn rc;\n    54   \t\t\t}\n    55   \t\t}\n    56   \t\tif(reason_code < 128 && db.config->max_packet_size > 0){\n    57   \t\t\trc = mosquitto_property_add_int32(&connack_props, MQTT_PROP_MAXIMUM_PACKET_SIZE, db.config->max_packet_size);\n    58   \t\t\tif(rc){\n    59   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    60   \t\t\t\treturn rc;\n    61   \t\t\t}\n    62   \t\t}\n    63   \t\tif(reason_code < 128 && db.config->max_inflight_messages > 0){\n    64   \t\t\trc = mosquitto_property_add_int16(&connack_props, MQTT_PROP_RECEIVE_MAXIMUM, db.config->max_inflight_messages);\n    65   \t\t\tif(rc){\n    66   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    67   \t\t\t\treturn rc;\n    68   \t\t\t}\n    69   \t\t}\n    70   \t\tif(context->listener->max_qos != 2){\n    71   \t\t\trc = mosquitto_property_add_byte(&connack_props, MQTT_PROP_MAXIMUM_QOS, context->listener->max_qos);\n    72   \t\t\tif(rc){\n    73   \t\t\t\tmosquitto_property_free_all(&connack_props);\n    74   \t\t\t\treturn rc;\n    75   \t\t\t}\n    76   \t\t}\n    78   \t\tremaining_length += property__get_remaining_length(connack_props);\n    79   \t}\n    81   \tif(packet__check_oversize(context, remaining_length)){\n    82   \t\tmosquitto_property_free_all(&connack_props);\n    83   \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    84   \t}\n    87   \tif(!packet){\n    88   \t\tmosquitto_property_free_all(&connack_props);\n    89   \t\treturn MOSQ_ERR_NOMEM;\n    90   \t}\n    92   \tpacket->command = CMD_CONNACK;\n    93   \tpacket->remaining_length = remaining_length;\n    96   \tif(rc){\n    97   \t\tmosquitto_property_free_all(&connack_props);\n    99   \t\treturn rc;\n    100  \t}\n    103  \tif(context->protocol == mosq_p_mqtt5){\n    104  \t\tproperty__write_all(packet, connack_props, true);\n    105  \t}\n    106  \tmosquitto_property_free_all(&connack_props);\n    108  \treturn packet__queue(context, packet);\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    42   \tassert(mosq);\n    45   \tif(mosq->bridge){\n    46   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Bridge %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    47   \t}else\n    56   \tassert(mosq);\n    60   \tpacket->command = CMD_DISCONNECT;\n    61   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    62   \t\tpacket->remaining_length = 1;\n    63   \t\tif(properties){\n    64   \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    65   \t\t}\n    66   \t}else{\n    67   \t\tpacket->remaining_length = 0;\n    68   \t}\n    75   \tif(mosq->protocol == mosq_p_mqtt5 && (reason_code != 0 || properties)){\n    77   \t\tif(properties){\n    78   \t\t\tproperty__write_all(packet, properties, true);\n    79   \t\t}\n    80   \t}\n    82   \treturn packet__queue(mosq, packet);\n    83   }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    126  \tassert(mosq);\n    130  \tpacket->command = command;\n    131  \tif(dup){\n    132  \t\tpacket->command |= 8;\n    133  \t}\n    134  \tpacket->remaining_length = 2;\n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    137  \t\tif(reason_code != 0 || properties){\n    138  \t\t\tpacket->remaining_length += 1;\n    139  \t\t}\n    140  \n    141  \t\tif(properties){\n    142  \t\t\tpacket->remaining_length += property__get_remaining_length(properties);\n    143  \t\t}\n    144  \t}\n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tif(reason_code != 0 || properties){\n    156  \t\t\tpacket__write_byte(packet, reason_code);\n    157  \t\t}\n    158  \t\tif(properties){\n    159  \t\t\tproperty__write_all(packet, properties, true);\n    160  \t\t}\n    161  \t}\n    163  \treturn packet__queue(mosq, packet);\n    164  }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    117  \treturn send__command_with_mid(mosq, CMD_PUBREL|2, mid, false, 0, properties);\n    118  }\nFunction: session_expiry__remove\nPath: /root/projects/mosquitto/src/session_expiry.c:121\n    121  void session_expiry__remove(struct mosquitto *context)\n    122  {\n    123  \tif(context->expiry_list_item){\n    124  \t\tDL_DELETE(expiry_list, context->expiry_list_item);\n    125  \t\tmosquitto__free(context->expiry_list_item);\n    126  \t\tcontext->expiry_list_item = NULL;\n    127  \t}\n    128  }\nFunction: acl__check_single\nPath: /root/projects/mosquitto/src/security.c:602\n    602  static int acl__check_single(struct mosquitto__auth_plugin_config *auth_plugin, struct mosquitto *context, struct mosquitto_acl_msg *msg, int access)\n    603  {\n    607  \tusername = mosquitto_client_username(context);\n    608  \tif(auth_plugin->deny_special_chars == true){\n    615  \t\tif(username && strpbrk(username, \"+#\")){\n    616  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous username \\\"%s\\\"\", username);\n    617  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    618  \t\t}\n    619  \t\tif(context->id && strpbrk(context->id, \"+#\")){\n    620  \t\t\tlog__",
    "If the Server does not send the Server Keep Alive, the Server MUST use the Keep Alive value set by the Client on CONNECT [MQTT-3.2.2-22].": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    189  \t\t\treturn;\n    190  \t\t}\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    212  }\nFunction: packet__read_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:178\n    178  int packet__read_uint32(struct mosquitto__packet *packet, uint32_t *word)\n    179  {\n    180  \tuint32_t val = 0;\n    181  \tint i;\n    184  \tif(packet->pos+4 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    186  \tfor(i=0; i<4; i++){\n    187  \t\tval = (val << 8) + packet->payload[packet->pos];\n    188  \t\tpacket->pos++;\n    189  \t}\n    191  \t*word = val;\n    194  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    94   \tpacket->command = 0;\n    97   \tpacket->remaining_length = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    150  \tpacket->pos = 0;\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    353  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    113  \tmosquitto_property *connack_props = NULL;\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    250  \t}\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    271  \n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    275  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    280  \t\t\trc = MOSQ_ERR_INVAL;\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    319  \tmosquitto_property_free_all(&connack_props);\n    320  \tif(rc) return rc;\n    326  error:\n    328  \tmosquitto_property_free_all(&connack_props);\n    330  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    258  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    465  \tif(context->state != mosq_cs_new){\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    557  \t}else{\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    581  \t\trc = MOSQ_ERR_PROTOCOL;\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    980  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    284  \tif(context->state == mosq_cs_disconnected){\n    285  \t\treturn;\n    286  \t}\n    316  \t\tif(db.config->connection_messages == true){\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    363  \t\t\t}else{\n    370  \t\t}\n    374  }\nFunction: mosquitto__get_state\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:295\n    295  enum mosquitto_client_state mosquitto__get_state(struct mosquitto *mosq)\n    300  \tstate = mosq->state;\n    303  \treturn state;\n    304  }\nFunction: mosquitto__set_state\nPath: /root/projects/mosquitto/src/../lib/util_mosq.c:281\n    281  int mosquitto__set_state(struct mosquitto *mosq, enum mosquitto_client_state state)\n    282  {\n    285  \tif(mosq->state != mosq_cs_disused)\n    287  \t{\n    288  \t\tmosq->state = state;\n    289  \t}\n    293  }\n",
    "If the Server accepts a connection with Clean Start set to 1, the Server MUST set Session Present to 0 in the CONNACK packet and MUST set a 0x00 (Success) Reason Code in the CONNACK packet.": "Function: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    205  \t\tfound_context->clean_start = true;\n    213  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    247  \t\t} else {\n    250  \t}\n    263  \tif(!context->clean_start){\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    319  \tmosquitto_property_free_all(&connack_props);\n    320  \tif(rc) return rc;\n    326  error:\n    328  \tmosquitto_property_free_all(&connack_props);\n    330  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    553  \t/* session_expiry_interval will be overriden if the properties are read later */\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    555  \t\t/* v3* has clean_start == false mean the session never expires */\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    976  \tcontext->clean_start = true;\n    980  }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    392  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    393  \t\t\t\tsend__connack(context, 0, MQTT_RC_PACKET_TOO_LARGE, NULL);\n    394  \t\t\t}else{\n    395  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    396  \t\t\t}\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    410  \twill_struct->msg.qos = will_qos;\n    424  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    54   \t*byte = packet->payload[packet->pos];\n    58   }\n",
    "The Server MUST NOT send the Reason String if the Reason String would increase the size of the UNSUBACK packet beyond the Maximum Packet Size specified by the Client.": "Function: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    980  }\n",
    "If the Server does not support the Authentication Method supplied by the Client, the Server MAY send a CONNACK with a Reason Code of 0x8C (Bad authentication method) or 0x87 (Not Authorized) and MUST close the Network Connection.": "Function: plugin__handle_disconnect\nPath: /root/projects/mosquitto/src/plugin.c:106\n    106  void plugin__handle_disconnect(struct mosquitto *context, int reason)\n    107  {\n    109  \tstruct mosquitto__callback *cb_base;\n    110  \tstruct mosquitto__security_options *opts;\n    112  \tif(db.config->per_listener_settings){\n    113  \t\tif(context->listener == NULL){\n    115  \t\t}\n    116  \t\topts = &context->listener->security_options;\n    117  \t}else{\n    122  \tevent_data.client = context;\n    123  \tevent_data.reason = reason;\n    124  \tDL_FOREACH(opts->plugin_callbacks.disconnect, cb_base){\n    125  \t\tcb_base->cb(MOSQ_EVT_DISCONNECT, &event_data, cb_base->userdata);\n    127  }\nFunction: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    221  \tplugin__handle_disconnect(context, -1);\n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    226  \tif(context->bridge == NULL)\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    232  \t\t\tif(context->will_delay_interval == 0){\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__read_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:178\n    178  int packet__read_uint32(struct mosquitto__packet *packet, uint32_t *word)\n    179  {\n    180  \tuint32_t val = 0;\n    181  \tint i;\n    183  \tassert(packet);\n    184  \tif(packet->pos+4 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    186  \tfor(i=0; i<4; i++){\n    187  \t\tval = (val << 8) + packet->payload[packet->pos];\n    188  \t\tpacket->pos++;\n    189  \t}\n    191  \t*word = val;\n    194  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    147  \tassert(mosq);\n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    153  \tpacket->next = NULL;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    187  \treturn packet__write(mosq);\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    353  }\nFunction: packet__check_oversize\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:211\n    211  int packet__check_oversize(struct mosquitto *mosq, uint32_t remaining_length)\n    212  {\n    215  \tif(mosq->maximum_packet_size == 0) return MOSQ_ERR_SUCCESS;\n    217  \tlen = remaining_length + packet__varint_bytes(remaining_length);\n    218  \tif(len > mosq->maximum_packet_size){\n    219  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    220  \t}else{\n    221  \t\treturn MOSQ_ERR_SUCCESS;\n    222  \t}\n    223  }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__read\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:35\n    35   static int property__read(struct mosquitto__packet *packet, uint32_t *len, mosquitto_property *property)\n    36   {\n    38   \tuint32_t property_identifier;\n    39   \tuint8_t byte;\n    40   \tuint8_t byte_count;\n    41   \tuint16_t uint16;\n    42   \tuint32_t uint32;\n    43   \tuint32_t varint;\n    44   \tchar *str1, *str2;\n    45   \tuint16_t slen1, slen2;\n    47   \tif(!property) return MOSQ_ERR_INVAL;\n    49   \trc = packet__read_varint(packet, &property_identifier, NULL);\n    50   \tif(rc){\n    51   \t\treturn rc;\n    52   \t}\n    55   \tmemset(property, 0, sizeof(mosquitto_property));\n    57   \tproperty->identifier = (int32_t)property_identifier;\n    59   \tswitch(property_identifier){\n    60   \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    61   \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    62   \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    63   \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    64   \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    65   \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    66   \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    67   \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    68   \t\t\trc = packet__read_byte(packet, &byte);\n    69   \t\t\tif(rc) return rc;\n    71   \t\t\tproperty->value.i8 = byte;\n    72   \t\t\tbreak;\n    74   \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    75   \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    76   \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    77   \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    78   \t\t\trc = packet__read_uint16(packet, &uint16);\n    79   \t\t\tif(rc) return rc;\n    81   \t\t\tproperty->value.i16 = uint16;\n    82   \t\t\tbreak;\n    84   \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    85   \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    86   \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    87   \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    88   \t\t\trc = packet__read_uint32(packet, &uint32);\n    89   \t\t\tif(rc) return rc;\n    91   \t\t\tproperty->value.i32 = uint32;\n    92   \t\t\tbreak;\n    94   \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    95   \t\t\trc = packet__read_varint(packet, &varint, &byte_count);\n    96   \t\t\tif(rc) return rc;\n    98   \t\t\tproperty->value.varint = varint;\n    99   \t\t\tbreak;\n    101  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    102  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    103  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    104  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    105  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    106  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    107  \t\tcase MQTT_PROP_REASON_STRING:\n    108  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    109  \t\t\tif(rc) return rc;\n    111  \t\t\tproperty->value.s.v = str1;\n    112  \t\t\tproperty->value.s.len = slen1;\n    113  \t\t\tbreak;\n    115  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    116  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    117  \t\t\trc = packet__read_binary(packet, (uint8_t **)&str1, &slen1);\n    118  \t\t\tif(rc) return rc;\n    120  \t\t\tproperty->value.bin.v = str1;\n    121  \t\t\tproperty->value.bin.len = slen1;\n    122  \t\t\tbreak;\n    124  \t\tcase MQTT_PROP_USER_PROPERTY:\n    125  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    126  \t\t\tif(rc) return rc;\n    129  \t\t\trc = packet__read_string(packet, &str2, &slen2);\n    130  \t\t\tif(rc){\n    131  \t\t\t\tmosquitto__free(str1);\n    132  \t\t\t\treturn rc;\n    133  \t\t\t}\n    136  \t\t\tproperty->name.v = str1;\n    137  \t\t\tproperty->name.len = slen1;\n    138  \t\t\tproperty->value.s.v = str2;\n    139  \t\t\tproperty->value.s.len = slen2;\n    140  \t\t\tbreak;\n    142  \t\tdefault:\n    144  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property_identifier);\n    146  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    147  \t}\n    150  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOA",
    "If the Client does not include an Authentication Method in the CONNECT packet, the Server MUST NOT send an AUTH packet and MUST NOT include an Authentication Method in the CONNACK packet [MQTT-4.12.0-6].": "Function: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    221  \tplugin__handle_disconnect(context, -1);\n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    226  \tif(context->bridge == NULL)\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    232  \t\t\tif(context->will_delay_interval == 0){\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__read_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:178\n    178  int packet__read_uint32(struct mosquitto__packet *packet, uint32_t *word)\n    179  {\n    180  \tuint32_t val = 0;\n    181  \tint i;\n    183  \tassert(packet);\n    184  \tif(packet->pos+4 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    186  \tfor(i=0; i<4; i++){\n    187  \t\tval = (val << 8) + packet->payload[packet->pos];\n    188  \t\tpacket->pos++;\n    189  \t}\n    191  \t*word = val;\n    194  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    52   \tuint8_t remaining_bytes[5], byte;\n    53   \tuint32_t remaining_length;\n    58   \tremaining_length = packet->remaining_length;\n    59   \tpacket->payload = NULL;\n    60   \tpacket->remaining_count = 0;\n    62   \t\tbyte = remaining_length % 128;\n    63   \t\tremaining_length = remaining_length / 128;\n    65   \t\tif(remaining_length > 0){\n    66   \t\t\tbyte = byte | 0x80;\n    67   \t\t}\n    68   \t\tremaining_bytes[packet->remaining_count] = byte;\n    69   \t\tpacket->remaining_count++;\n    70   \t}while(remaining_length > 0 && packet->remaining_count < 5);\n    71   \tif(packet->remaining_count == 5) return MOSQ_ERR_PAYLOAD_SIZE;\n    72   \tpacket->packet_length = packet->remaining_length + 1 + (uint8_t)packet->remaining_count;\n    76   \tpacket->payload = mosquitto__malloc(sizeof(uint8_t)*packet->packet_length);\n    78   \tif(!packet->payload) return MOSQ_ERR_NOMEM;\n    80   \tpacket->payload[0] = packet->command;\n    81   \tfor(i=0; i<packet->remaining_count; i++){\n    82   \t\tpacket->payload[i+1] = remaining_bytes[i];\n    83   \t}\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    91   \tif(!packet) return;\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    96   \tpacket->remaining_mult = 1;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    147  \tassert(mosq);\n    150  \tpacket->pos = 0;\n    151  \tpacket->to_process = packet->packet_length;\n    153  \tpacket->next = NULL;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    160  \t\t\tmosq->is_dropping = true;\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    170  \tif(mosq->out_packet){\n    171  \t\tmosq->out_packet_last->next = packet;\n    172  \t}else{\n    173  \t\tmosq->out_packet = packet;\n    174  \t}\n    175  \tmosq->out_packet_last = packet;\n    176  \tmosq->out_packet_count++;\n    187  \treturn packet__write(mosq);\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    232  \tif(!mosq) return MOSQ_ERR_INVAL;\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    238  \t\tmosq->current_out_packet = mosq->out_packet;\n    239  \t\tmosq->out_packet = mosq->out_packet->next;\n    240  \t\tif(!mosq->out_packet){\n    241  \t\t\tmosq->out_packet_last = NULL;\n    242  \t\t}\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    248  \tif(mosq->current_out_packet){\n    249  \t   mux__add_out(mosq);\n    250  \t}\n    253  \tstate = mosquitto__get_state(mosq);\n    254  \tif(state == mosq_cs_connect_pending){\n    256  \t\treturn MOSQ_ERR_SUCCESS;\n    257  \t}\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    325  \t\tmosq->current_out_packet = mosq->out_packet;\n    326  \t\tif(mosq->out_packet){\n    327  \t\t\tmosq->out_packet = mosq->out_packet->next;\n    328  \t\t\tif(!mosq->out_packet){\n    329  \t\t\t\tmosq->out_packet_last = NULL;\n    330  \t\t\t}\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    335  \t\tpacket__cleanup(packet);\n    336  \t\tmosquitto__free(packet);\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    347  \tif (mosq->current_out_packet == NULL) {\n    348  \t\tmux__remove_out(mosq);\n    349  \t}\n    353  }\nFunction: packet__check_oversize\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:211\n    211  int packet__check_oversize(struct mosquitto *mosq, uint32_t remaining_length)\n    212  {\n    215  \tif(mosq->maximum_packet_size == 0) return MOSQ_ERR_SUCCESS;\n    217  \tlen = remaining_length + packet__varint_bytes(remaining_length);\n    218  \tif(len > mosq->maximum_packet_size){\n    219  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    220  \t}else{\n    221  \t\treturn MOSQ_ERR_SUCCESS;\n    222  \t}\n    223  }\nFunction: property__process_connect\nPath: /root/projects/mosquitto/src/property_broker.c:30\n    30   int property__process_connect(struct mosquitto *context, mosquitto_property **props)\n    31   {\n    32   \tmosquitto_property *p;\n    34   \tp = *props;\n    36   \twhile(p){\n    37   \t\tif(p->identifier == MQTT_PROP_SESSION_EXPIRY_INTERVAL){\n    38   \t\t\tcontext->session_expiry_interval = p->value.i32;\n    39   \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM){\n    40   \t\t\tif(p->value.i16 == 0){\n    41   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    42   \t\t\t}\n    44   \t\t\tcontext->msgs_out.inflight_maximum = p->value.i16;\n    45   \t\t\tcontext->msgs_out.inflight_quota = context->msgs_out.inflight_maximum;\n    46   \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    47   \t\t\tif(p->value.i32 == 0){\n    48   \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    49   \t\t\t}\n    50   \t\t\tcontext->maximum_packet_size = p->value.i32;\n    51   \t\t}\n    52   \t\tp = p->next;\n    53   \t}\n    56   }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__read\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:35\n    35   static int property__read(struct mosquitto__packet *packet, uint32_t *len, mosquitto_property *property)\n    36   {\n    38   \tuint32_t property_identifier;\n    39   \tuint8_t byte;\n    40   \tuint8_t byte_count;\n    41   \tuint16_t uint16;\n    42   \tuint32_t uint32;\n    43   \tuint32_t varint;\n    44   \tchar *str1, *str2;\n    45   \tuint16_t slen1, slen2;\n    47   \tif(!property) return MOSQ_ERR_INVAL;\n    49   \trc = packet__read_varint(packet, &property_identifier, NULL);\n    50   \tif(rc){\n    51   \t\treturn rc;\n    52   \t}\n    55   \tmemset(property, 0, sizeof(mosquitto_property));\n    57   \tproperty->identifier = (int32_t)property_identifier;\n    59   \tswitch(property_identifier){\n    60   \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    61   \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    62   \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    63   \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    64   \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    65   \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    66   \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    67   \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    68   \t\t\trc = packet__read_byte(packet, &byte);\n    69   \t\t\tif(rc) return rc;\n    71   \t\t\tproperty->value.i8 = byte;\n    72   \t\t\tbreak;\n    74   \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    75   \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    76   \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    77   \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    78   \t\t\trc = packet__read_uint16(packet, &uint16);\n    79   \t\t\tif(rc) return rc;\n    81   \t\t\tproperty->value.i16 = uint16;\n    82   \t\t\tbreak;\n    84   \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    85   \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    86   \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    87   \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    88   \t\t\trc = packet__read_uint32(packet, &uint32);\n    89   \t\t\tif(rc) return rc;\n    91   \t\t\tproperty->value.i32 = uint32;\n    92   \t\t\tbreak;\n    94   \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    95   \t\t\trc = packet__read_varint(packet, &varint, &byte_count);\n    96   \t\t\tif(rc) return rc;\n    98   \t\t\tproperty->value.varint = varint;\n    99   \t\t\tbreak;\n    101  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    102  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    103  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    104  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    105  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    106  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    107  \t\tcase MQTT_PROP_REASON_STRING:\n    108  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    109  \t\t\tif(rc) return rc;\n    110  \t\t\t*len = (*len) - 2 - slen1; /* uint16, string len */\n    111  \t\t\tproperty->value.s.v = str1;\n    112  \t\t\tproperty->value.s.len = slen1;\n    113  \t\t\tbreak;\n    115  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    116  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    117  \t\t\trc = packet__read_binary(packet, (uint8_t **)&str1, &slen1);\n    118  \t\t\tif(rc) return rc;\n    119  \t\t\t*len = (*len) - 2 - slen1; /* uint16, binary len */\n    120  \t\t\tproperty->value.bin.v = str1;\n    121  \t\t\tproperty->value.bin.len = slen1;\n    122  \t\t\tbreak;\n    124  \t\tcase MQTT_PROP_USER_PROPERTY:\n    125  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    126  \t\t\tif(rc) return rc;\n    127  \t\t\t*len = (*len) - 2 - slen1; /* uint16, string len */\n    129  \t\t\trc = packet__read_string(packet, &str2, &slen2);\n    130  \t\t\tif(rc){\n    131  \t\t\t\tmosquitto__free(str1);\n    132  \t\t\t\treturn rc;\n    133  \t\t\t}\n    136  \t\t\tproperty->name.v = str1;\n    137  \t\t\tproperty->name.len = slen1;\n    138  \t\t\tproperty->value.s.v = str2;\n    139  \t\t\tproperty->value.s.len = slen2;\n    140  \t\t\tbreak;\n    142  \t\tdefault:\n    144  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property_identifier);\n    146  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    147  \t}\n    150  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: property__write_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:429\n    429  int property__write_all(struct mosquitto__packet *packet, const mosquitto_property *properties, bool write_len)\n    430  {\n    432  \tconst mosquitto_property *p;\n    440  \twhile(p){\n    441  \t\trc = property__write(packet, p);\n    442  \t\tif(rc) return rc;\n    443  \t\tp = p->next;\n    444  \t}\n    447  }\nFunction: property__write\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:361\n    361  static int property__write(struct mosquitto__packet *packet, const mosquitto_property *property)\n    362  {\n    365  \trc = packet__write_varint(packet, (uint32_t)property->identifier);\n    366  \tif(rc) return rc;\n    368  \tswitch(property->identifier){\n    369  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    370  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    371  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    372  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    373  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    374  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    375  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    376  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    377  \t\t\tpacket__write_byte(packet, property->value.i8);\n    378  \t\t\tbreak;\n    380  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    381  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    382  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    383  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    384  \t\t\tpacket__write_uint16(packet, property->value.i16);\n    385  \t\t\tbreak;\n    387  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    388  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    389  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    390  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    391  \t\t\tpacket__write_uint32(packet, property->value.i32);\n    392  \t\t\tbreak;\n    394  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    395  \t\t\treturn packet__write_varint(packet, property->value.varint);\n    397  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    398  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    399  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    400  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    401  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    402  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    403  \t\tcase MQTT_PROP_REASON_STRING:\n    404  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    405  \t\t\tbreak;\n    407  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    408  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    409  \t\t\tpacket__write_uint16(packet, property->value.bin.len);\n    410  \t\t\tpacket__write_bytes(packet, property->value.bin.v, property->value.bin.len);\n    411  \t\t\tbreak;\n    413  \t\tcase MQTT_PROP_USER_PROPERTY:\n    414  \t\t\tpacket__write_string(packet, property->name.v, property->name.len);\n    415  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    416  \t\t\tbreak;\n    418  \t\tdefault:\n    420  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property->identifier);\n    422  \t\t\treturn MOSQ_ERR_INVAL;\n    423  \t}\n    426  }\nFunction: mosquitto_property_read_binary\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1106\n    1106 const mosquitto_property *mosquitto_property_read_binary(const mosquitto_property *proplist, int identifier, void **value, uint16_t *len, bool skip_first)\n    1107 {\n    1109 \tif(!proplist || (value && !len) || (!value && len)) return NULL;\n    1111 \tif(value) *value = NULL;\n    1113 \tp = property__get_property(proplist, identifier, skip_first);\n    1114 \tif(!p) return NULL;\n    1115 \tif(p->identifier != MQTT_PROP_CORRELATION_DATA\n    1116 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_DATA){\n    1118 \t\treturn NULL;\n    1119 \t}\n    1121 \tif(value){\n    1122 \t\t*len = p->value.bin.len;\n    1123 \t\t*value = calloc(1, *len + 1U);\n    1124 \t\tif(!(*value)) return NULL;\n    1126 \t\tmemcpy(*value, p->value.bin.v, *len);\n    1127 \t}\n    1130 }\nFunction: mosquitto_property_read_string\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:1133\n    1133 const mosquitto_property *mosquitto_property_read_string(const mosquitto_property *proplist, int identifier, char **value, bool skip_first)\n    1134 {\n    1136 \tif(!proplist) return NULL;\n    1138 \tp = property__get_property(proplist, identifier, skip_first);\n    1139 \tif(!p) return NULL;\n    1140 \tif(p->identifier != MQTT_PROP_CONTENT_TYPE\n    1141 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_TOPIC\n    1142 \t\t\t&& p->identifier != MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER\n    1143 \t\t\t&& p->identifier != MQTT_PROP_AUTHENTICATION_METHOD\n    1144 \t\t\t&& p->identifier != MQTT_PROP_RESPONSE_INFORMATION\n    1145 \t\t\t&& p->identifier != MQTT_PROP_SERVER_REFERENCE\n    1146 \t\t\t&& p->identifier != MQTT_PROP_REASON_STRING){\n    1148 \t\treturn NULL;\n    1149 \t}\n    1151 \tif(value){\n    1152 \t\t*value = calloc(1, (size_t)p->value.s.len+1);\n    1153 \t\tif(!(*value)) return NULL;\n    1155 \t\tmemcpy(*value, p->value.s.v, p->value.s.len);\n    1156 \t}\n    1159 }\nFunction: db__expire_all_messages\nPath: /root/projects/mosquitto/src/database.c:1053\n    1053 void db__expire_all_messages(struct mosquitto *context)\n    1055 \tstruct mosquitto_client_msg *msg, *tmp;\n    1057 \tDL_FOREACH_SAFE(context->msgs_out.inflight, msg, tmp){\n    1058 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1059 \t\t\tif(msg->qos > 0){\n    1060 \t\t\t\tutil__increment_send_quota(context);\n    1062 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1065 \tDL_FOREACH_SAFE(context->msgs_out.queued, msg, tmp){\n    1066 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1067 \t\t\tdb__message_remove_from_queued(&context->msgs_out, msg);\n    1070 \tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n    1071 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1072 \t\t\tif(msg->qos > 0){\n    1073 \t\t\t\tutil__increment_receive_quota(context);\n    1075 \t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n    1078 \tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n    1079 \t\tif(msg->store->message_expiry_time && db.now_real_s > msg->store->message_expiry_time){\n    1080 \t\t\tdb__message_remove_from_queued(&context->msgs_in, msg);\n    1083 }\nFunction: db__message_remove_from_queued\nPath: /root/projects/mosquitto/src/database.c:364\n    364  static void db__message_remove_from_queued(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    365  {\n    366  \tif(!msg_data || !item){\n    367  \t\treturn;\n    368  \t}\n    370  \tDL_DELETE(msg_data->queued, item);\n    375  \tmosquitto_property_free_all(&item->properties);\n    377  }\nFunction: db__message_write_inflight_out_all\nPath: /root/projects/mosquitto/src/database.c:1181\n    1181 int db__message_write_inflight_out_all(struct mosquitto *context)\n    1182 {\n    1183 \tstruct mosquitto_client_msg *tail, *tmp;\n    1186 \tif(context->state != mosq_cs_active || context->sock == INVALID_SOCKET){\n    1187 \t\treturn MOSQ_ERR_SUCCESS;\n    1188 \t}\n    1190 \tDL_FOREACH_SAFE(context->msgs_out.inflight, tail, tmp){\n    1191 \t\trc = db__message_write_inflight_out_single(context, tail);\n    1192 \t\tif(rc) return rc;\n    1195 }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    114  \tuint8_t connect_ack = 0;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    143  \t\t\t\tin_quota = context->msgs_in.inflight_quota;\n    144  \t\t\t\tout_quota = context->msgs_out.inflight_quota;\n    145  \t\t\t\tin_maximum = context->msgs_in.inflight_maximum;\n    146  \t\t\t\tout_maximum = context->msgs_out.inflight_maximum;\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    154  \t\t\t\tcontext->msgs_in.inflight_quota = in_quota;\n    155  \t\t\t\tcontext->msgs_out.inflight_quota = out_quota;\n    156  \t\t\t\tcontext->msgs_in.inflight_maximum = in_maximum;\n    157  \t\t\t\tcontext->msgs_out.inflight_maximum = out_maximum;\n    159  \t\t\t\tdb__message_reconnect_reset(context);\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    215  \trc = acl__find_acls(context);\n    216  \tif(rc){\n    218  \t\treturn rc;\n    219  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    240  \t\tif(context->will) {\n    241  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Will message specified (%ld bytes) (r%d, q%d).\",\n    242  \t\t\t\t\t(long)context->will->msg.payloadlen,\n    243  \t\t\t\t\tcontext->will->msg.retain,\n    244  \t\t\t\t\tcontext->will->msg.qos);\n    246  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s\", context->will->msg.topic);\n    247  \t\t} else {\n    250  \t}\n    252  \tcontext->ping_t = 0;\n    253  \tcontext->is_dropping = false;\n    255  \tconnection_check_acl(context, &context->msgs_in.inflight);\n    256  \tconnection_check_acl(context, &context->msgs_in.queued);\n    257  \tconnection_check_acl(context, &context->msgs_out.inflight);\n    258  \tconnection_check_acl(context, &context->msgs_out.queued);\n    260  \tcontext__add_to_by_id(context);\n    263  \tif(!context->clean_start){\n    267  \tcontext->max_qos = context->listener->max_qos;\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    279  \t\t\tsend__connack(context, connect_ack, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    300  \t\t\t\trc = MOSQ_ERR_NOMEM;\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    315  \tkeepalive__add(context);\n    317  \tmosquitto__set_state(context, mosq_cs_active);\n    318  \trc = send__connack(context, connect_ack, CONNACK_ACCEPTED, connack_props);\n    319  \tmosquitto_property_free_all(&connack_props);\n    320  \tif(rc) return rc;\n    321  \tdb__expire_all_messages(context);\n    322  \trc = db__message_write_queued_out(context);\n    323  \tif(rc) return rc;\n    324  \trc = db__message_write_inflight_out_all(context);\n    326  error:\n    328  \tmosquitto_property_free_all(&connack_props);\n    330  }\nFunction: connection_check_acl\nPath: /root/projects/mosquitto/src/handle_connect.c:86\n    86   static void connection_check_acl(struct mosquitto *context, struct mosquitto_client_msg **head)\n    97   \t\tif(mosquitto_acl_check(context, msg_tail->store->topic,\n    99   \t\t\t\t\t\t\t   msg_tail->store->qos, msg_tail->store->retain, access) != MOSQ_ERR_SUCCESS){\n    101  \t\t\tDL_DELETE((*head), msg_tail);\n    107  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    246  \tif(context->state == mosq_cs_disused) return;\n    248  \tmosquitto__set_state(context, mosq_cs_disused);\n    250  \tif(context->id){\n    251  \t\tcontext__remove_from_by_id(context);\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    256  \tcontext->for_free_next = db.ll_for_free;\n    257  \tdb.ll_for_free = context;\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    296  \t\tcontext->in_by_id = true;\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__msg_add_to_queued_stats\nPath: /root/projects/mosquitto/src/database.c:162\n    162  void db__msg_add_to_queued_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    163  {\n    164  \tmsg_data->queued_count++;\n    165  \tmsg_data->queued_bytes += msg->store->payloadlen;\n    166  \tif(msg->qos != 0){\n    167  \t\tmsg_data->queued_count12++;\n    168  \t\tmsg_data->queued_bytes12 += msg->store->payloadlen;\n    169  \t}\n    170  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    271  \tmosquitto__free(store->source_id);\n    272  \tmosquitto__free(store->source_username);\n    283  }\nFunction: db__message_remove_from_inflight\nPath: /root/projects/mosquitto/src/database.c:347\n    347  static void db__message_remove_from_inflight(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *item)\n    348  {\n    349  \tif(!msg_data || !item){\n    350  \t\treturn;\n    351  \t}\n    353  \tDL_DELETE(msg_data->inflight, item);\n    354  \tif(item->store){\n    355  \t\tdb__msg_remove_from_inflight_stats(msg_data, item);\n    357  \t}\n    359  \tmosquitto_property_free_all(&item->properties);\n    361  }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1097 \tuint32_t expiry_interval;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1103 \t\t\tif(msg->direction == mosq_md_out && msg->qos > 0){\n    1104 \t\t\t\tutil__increment_send_quota(context);\n    1105 \t\t\t}\n    1106 \t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1126 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1135 \t\t\t\tmsg->timestamp = db.now_s;\n    1136 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1137 \t\t\t\tmsg->state = mosq_ms_wait_for_puback;\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1139 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1148 \t\t\t\tmsg->timestamp = db.now_s;\n    1149 \t\t\t\tmsg->dup = 1; /* Any retry attempts are a duplicate. */\n    1150 \t\t\t\tmsg->state = mosq_ms_wait_for_pubrec;\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1152 \t\t\t\tdb__message_remove_from_inflight(&context->msgs_out, msg);\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1159 \t\t\trc = send__pubrel(context, mid, NULL);\n    1160 \t\t\tif(!rc){\n    1161 \t\t\t\tmsg->state = mosq_ms_wait_for_pubcomp;\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1176 \t}\n    1178 }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    449  \tstruct mosquitto_msg_data *msg_data;\n    450  \tenum mosquitto_msg_state state = mosq_ms_invalid;\n    452  \tint i;\n    457  \tif(!context->id) return MOSQ_ERR_SUCCESS; /* Protect against unlikely \"client is disconnected but not entirely freed\" scenario */\n    459  \tif(dir == mosq_md_out){\n    460  \t\tmsg_data = &context->msgs_out;\n    461  \t}else{\n    462  \t\tmsg_data = &context->msgs_in;\n    463  \t}\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    484  \tif(context->sock == INVALID_SOCKET){\n    486  \t\tif(qos == 0 && !db.config->queue_qos0_messages){\n    487  \t\t\tif(!context->bridge){\n    489  \t\t\t\treturn 2;\n    490  \t\t\t}else{\n    491  \t\t\t\tif(context->bridge->start_type != bst_lazy){\n    493  \t\t\t\t\treturn 2;\n    494  \t\t\t\t}\n    495  \t\t\t}\n    496  \t\t}\n    497  \t\tif(context->bridge && context->bridge->clean_start_local == true){\n    499  \t\t\treturn 2;\n    500  \t\t}\n    501  \t}\n    503  \tif(context->sock != INVALID_SOCKET){\n    504  \t\tif(db__ready_for_flight(context, dir, qos)){\n    517  \t\t\t}else{\n    520  \t\t\t\t}else{\n    522  \t\t\t\t\treturn 1;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n    528  \t\t}else{\n    530  \t\t\tif(context->is_dropping == false){\n    531  \t\t\t\tcontext->is_dropping = true;\n    532  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    534  \t\t\t\t\t\tcontext->id);\n    535  \t\t\t}\n    538  \t\t\treturn 2;\n    539  \t\t}\n    540  \t}else{\n    541  \t\tif (db__ready_for_queue(context, qos, msg_data)){\n    543  \t\t}else{\n    545  \t\t\tif(context->is_dropping == false){\n    546  \t\t\t\tcontext->is_dropping = true;\n    547  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    549  \t\t\t\t\t\tcontext->id);\n    550  \t\t\t}\n    552  \t\t\treturn 2;\n    553  \t\t}\n    554  \t}\n    574  \tif(qos > context->max_qos){\n    575  \t\tmsg->qos = context->max_qos;\n    576  \t}else{\n    582  \tif(state == mosq_ms_queued){\n    583  \t\tDL_APPEND(msg_data->queued, msg);\n    585  \t}else{\n    586  \t\tDL_APPEND(msg_data->inflight, msg);\n    588  \t}\n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    598  \t\tdest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1));\n    599  \t\tif(dest_ids){\n    602  \t\t\tstored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id);\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t}\n    609  \t}\n    611  \tif(context->bridge && context->bridge->start_type == bst_lazy\n    612  \t\t\t&& context->sock == INVALID_SOCKET\n    613  \t\t\t&& context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){\n    616  \t}\n    633  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    704  \tstruct mosquitto_msg_store *stored;\n    705  \tconst char *source_id;\n    706  \tenum mosquitto_msg_origin origin;\n    710  \tstored = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    711  \tif(stored == NULL) return MOSQ_ERR_NOMEM;\n    713  \tstored->topic = mosquitto__strdup(topic);\n    714  \tif(stored->topic == NULL){\n    715  \t\tdb__msg_store_free(stored);\n    716  \t\treturn MOSQ_ERR_INVAL;\n    717  \t}\n    719  \tstored->qos = qos;\n    720  \tif(db.config->retain_available == false){\n    721  \t\tstored->retain = 0;\n    722  \t}else{\n    723  \t\tstored->retain = retain;\n    724  \t}\n    726  \tstored->payloadlen = payloadlen;\n    727  \tif(payloadlen > 0){\n    728  \t\tstored->payload = mosquitto__malloc(stored->payloadlen+1);\n    729  \t\tif(stored->payload == NULL){\n    730  \t\t\tdb__msg_store_free(stored);\n    731  \t\t\treturn MOSQ_ERR_NOMEM;\n    732  \t\t}\n    734  \t\t((uint8_t *)stored->payload)[stored->payloadlen] = 0;\n    735  \t\tmemcpy(stored->payload, payload, stored->payloadlen);\n    736  \t}\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    743  \tif(properties){\n    744  \t\tstored->properties = *properties;\n    746  \t}\n    748  \tif(context){\n    750  \t}else{\n    753  \tif(db__message_store(context, stored, message_expiry_interval, 0, origin)) return 1;\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    763  \tif(source && source->id){\n    764  \t\tstored->source_id = mosquitto__strdup(source->id);\n    765  \t}else{\n    766  \t\tstored->source_id = mosquitto__strdup(\"\");\n    767  \t}\n    768  \tif(!stored->source_id){\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    774  \tif(source && source->username){\n    775  \t\tstored->source_username = mosquitto__strdup(source->username);\n    776  \t\tif(!stored->source_username){\n    778  \t\t\treturn MOSQ_ERR_NOMEM;\n    779  \t\t}\n    780  \t}\n    781  \tif(source){\n    782  \t\tstored->source_listener = source->listener;\n    783  \t}\n    806  }\nFunction: net__socket_close\nPath: /root/projects/mosquitto/src/../lib/net_mosq.c:205\n    205  int net__socket_close(struct mosquitto *mosq)\n    206  {\n    207  \tint rc = 0;\n    209  \tstruct mosquitto *mosq_found;\n    212  \tassert(mosq);\n    218  \t\tif(mosq->ssl){\n    219  \t\t\tif(!SSL_in_init(mosq->ssl)){\n    220  \t\t\t\tSSL_shutdown(mosq->ssl);\n    221  \t\t\t}\n    222  \t\t\tSSL_free(mosq->ssl);\n    223  \t\t\tmosq->ssl = NULL;\n    224  \t\t}\n    238  \t\tif(mosq->sock != INVALID_SOCKET){\n    240  \t\t\tHASH_FIND(hh_sock, db.contexts_by_sock, &mosq->sock, sizeof(mosq->sock), mosq_found);\n    241  \t\t\tif(mosq_found){\n    242  \t\t\t\tHASH_DELETE(hh_sock, db.contexts_by_sock, mosq_found);\n    243  \t\t\t}\n    245  \t\t\trc = COMPAT_CLOSE(mosq->sock);\n    246  \t\t\tmosq->sock = INVALID_SOCKET;\n    247  \t\t}\n    251  \tif(mosq->listener){\n    252  \t\tmosq->listener->client_count--;\n    253  \t\tmosq->listener = NULL;\n    254  \t}\n    257  \treturn rc;\n    258  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    440  \tmosquitto_property *properties = NULL;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    448  \tX509 *client_cert = NULL;\n    460  \tif(!context->listener){\n    461  \t\treturn MOSQ_ERR_INVAL;\n    462  \t}\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    502  \t\tcontext->protocol = mosq_p_mqtt31;\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    504  \t\t\tcontext->is_bridge = true;\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    508  \t\t\tcontext->protocol = mosq_p_mqtt311;\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    511  \t\t\t\tcontext->is_bridge = true;\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    514  \t\t\tcontext->protocol = mosq_p_mqtt5;\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    520  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    563  \t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid Will QoS in CONNECT from %s.\",\n    564  \t\t\t\tcontext->address);\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    574  \t\t\tsend__connack(context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    589  \tproperty__process_connect(context, &properties);\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    593  \t\t\tsend__connack(context, 0, MQTT_RC_QOS_NOT_SUPPORTED, NULL);\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    599  \tif(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){\n    600  \t\tmosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);\n    601  \t}\n    603  \tmosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    612  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    625  \t\t\t\tif(context->protocol == mosq_p_mqtt311){\n    626  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);\n    627  \t\t\t\t}else{\n    628  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_UNSPECIFIED, NULL);\n    629  \t\t\t\t}\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    642  \t\t\t\tcontext->assigned_id = true;\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    650  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    651  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    652  \t\t\t}else{\n    653  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    654  \t\t\t}\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    724  \tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    731  \t\tif(!context->ssl){\n    732  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    733  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    735  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    741  \t\tif(context->listener->psk_hint){\n    743  \t\t\tif(!context->username){\n    744  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    745  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    747  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    754  \t\t\tclient_cert = SSL_get_peer_certificate(context->ssl);\n    755  \t\t\tif(!client_cert){\n    756  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    757  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    759  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    764  \t\t\tname = X509_get_subject_name(client_cert);\n    765  \t\t\tif(!name){\n    766  \t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    767  \t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    769  \t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    774  \t\t\tif (context->listener->use_identity_as_username) { /* use_identity_as_username */\n    775  \t\t\t\ti = X509_NAME_get_index_by_NID(name, NID_commonName, -1);\n    776  \t\t\t\tif(i == -1){\n    777  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    778  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    780  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    785  \t\t\t\tname_entry = X509_NAME_get_entry(name, i);\n    786  \t\t\t\tif(name_entry){\n    787  \t\t\t\t\tname_asn1 = X509_NAME_ENTRY_get_data(name_entry);\n    788  \t\t\t\t\tif (name_asn1 == NULL) {\n    789  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    790  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    792  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    801  \t\t\t\t\tnew_username = (const char *) ASN1_STRING_get0_data(name_asn1);\n    803  \t\t\t\t\tif(mosquitto_validate_utf8(new_username, (int)strlen(new_username))){\n    804  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    805  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    807  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    809  \t\t\t\t\t\tX509_free(client_cert);\n    812  \t\t\t\t\tcontext->username = mosquitto__strdup(new_username);\n    813  \t\t\t\t\tif(!context->username){\n    814  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    815  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);\n    817  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);\n    823  \t\t\t\t\tif ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {\n    824  \t\t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    825  \t\t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);\n    827  \t\t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);\n    835  \t\t\t\tX509_NAME_print_ex(subject_bio, X509_get_subject_name(client_cert), 0, XN_FLAG_RFC2253);\n    847  \t\t\t\tcontext->username = subject;\n    849  \t\t\tif(!context->username){\n    853  \t\t\tX509_free(client_cert);\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    878  \t\t\tif(context->protocol == mosq_p_mqtt5){\n    879  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    880  \t\t\t}else{\n    881  \t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    882  \t\t\t}\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    888  \tcontext->will = will_struct;\n    889  \twill_struct = NULL;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    893  \t\tmosquitto__free(auth_data);\n    894  \t\tauth_data = NULL;\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    898  \t\t\tmosquitto__set_state(context, mosq_cs_authenticating);\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    900  \t\t\tfree(auth_data_out);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    903  \t\t\tfree(auth_data_out);\n    904  \t\t\tauth_data_out = NULL;\n    905  \t\t\twill__clear(context);\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    907  \t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    912  \t\t\t\t/* Client has requested extended authentication, but we don't support it. */\n    913  \t\t\t\tsend__connack(context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    924  #ifdef WITH_TLS\n    925  \t\tif(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){\n    926  \t\t\t/* Authentication assumed to be cleared */\n    927  \t\t}else\n    928  #endif\n    929  \t\t{\n    930  \t\t\trc = mosquitto_unpwd_check(context);\n    931  \t\t\tswitch(rc){\n    932  \t\t\t\tcase MOSQ_ERR_SUCCESS:\n    933  \t\t\t\t\tbreak;\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    935  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    936  \t\t\t\t\t\tsend__connack(context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);\n    937  \t\t\t\t\t}else{\n    938  \t\t\t\t\t\tsend__connack(context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);\n    939  \t\t\t\t\t}\n    940  \t\t\t\t\trc = MOSQ_ERR_AUTH;\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    944  \t\t\t\t\trc = MOSQ_ERR_UNKNOWN;\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    948  \t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    954  \tmosquitto_property_free_all(&properties);\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    959  \tif(will_struct){\n    960  \t\tmosquitto_property_free_all(&will_struct->properties);\n    961  \t\tmosquitto__free(will_struct->msg.payload);\n    962  \t\tmosquitto__free(will_struct->msg.topic);\n    963  \t\tmosquitto__free(will_struct);\n    964  \t}\n    965  \tif(context->will){\n    966  \t\tmosquitto_property_free_all(&context->will->properties);\n    967  \t\tmosquitto__free(context->will->msg.payload);\n    968  \t\tmosquitto__free(context->will->msg.topic);\n    969  \t\tmosquitto__free(context->will);\n    970  \t\tcontext->will = NULL;\n    971  \t}\n    973  \tif(client_cert) X509_free(client_cert);\n    976  \tcontext->clean_start = true;\n    977  \tcontext->session_expiry_interval = 0;\n    978  \tcontext->will_delay_interval = 0;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    55   \tint i;\n    56   \tint pos;\n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    335  \tint rc = MOSQ_ERR_SUCCESS;\n    337  \tuint16_t tlen;\n    340  \tuint16_t payloadlen;\n    341  \tmosquitto_property *properties = NULL;\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    348  \tif(context->protocol == PROTOCOL_VERSION_v5){\n    349  \t\trc = property__read_all(CMD_WILL, &context->in_packet, &properties);\n    350  \t\tif(rc) goto error_cleanup;\n    352  \t\trc = property__process_will(context, will_struct, &properties);\n    353  \t\tmosquitto_property_free_all(&properties);\n    354  \t\tif(rc) goto error_cleanup;\n    355  \t}\n    356  \trc = packet__read_string(&context->in_packet, &will_struct->msg.topic, &tlen);\n    357  \tif(rc) goto error_cleanup;\n    363  \tif(context->listener->mount_point){\n    364  \t\tslen = strlen(context->listener->mount_point) + strlen(will_struct->msg.topic) + 1;\n    365  \t\twill_topic_mount = mosquitto__malloc(slen+1);\n    366  \t\tif(!will_topic_mount){\n    368  \t",
    "On receipt of DISCONNECT with a Reason Code of 0x00 (Success) the Server MUST discard any Will Message associated with the current Connection without publishing the Will Message [MQTT-3.14.4-3].": "Function: plugin__handle_disconnect\nPath: /root/projects/mosquitto/src/plugin.c:106\n    106  void plugin__handle_disconnect(struct mosquitto *context, int reason)\n    107  {\n    108  \tstruct mosquitto_evt_disconnect event_data;\n    109  \tstruct mosquitto__callback *cb_base;\n    110  \tstruct mosquitto__security_options *opts;\n    111  \n    112  \tif(db.config->per_listener_settings){\n    113  \t\tif(context->listener == NULL){\n    114  \t\t\treturn;\n    115  \t\t}\n    116  \t\topts = &context->listener->security_options;\n    117  \t}else{\n    118  \t\topts = &db.config->security_options;\n    119  \t\tmemset(&event_data, 0, sizeof(event_data));\n    120  \t}\n    121  \n    122  \tevent_data.client = context;\n    123  \tevent_data.reason = reason;\n    124  \tDL_FOREACH(opts->plugin_callbacks.disconnect, cb_base){\n    125  \t\tcb_base->cb(MOSQ_EVT_DISCONNECT, &event_data, cb_base->userdata);\n    126  \t}\n    127  }\nFunction: context__send_will\nPath: /root/projects/mosquitto/src/context.c:184\n    184  void context__send_will(struct mosquitto *ctxt)\n    185  {\n    186  \tif(ctxt->state != mosq_cs_disconnecting && ctxt->will){\n    187  \t\tif(ctxt->will_delay_interval > 0){\n    188  \t\t\twill_delay__add(ctxt);\n    189  \t\t\treturn;\n    190  \t\t}\n    191  \n    192  \t\tif(mosquitto_acl_check(ctxt,\n    193  \t\t\t\t\tctxt->will->msg.topic,\n    194  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    195  \t\t\t\t\tctxt->will->msg.payload,\n    196  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    197  \t\t\t\t\tctxt->will->msg.retain,\n    198  \t\t\t\t\tMOSQ_ACL_WRITE) == MOSQ_ERR_SUCCESS){\n    199  \n    200  \t\t\t/* Unexpected disconnect, queue the client will. */\n    201  \t\t\tdb__messages_easy_queue(ctxt,\n    202  \t\t\t\t\tctxt->will->msg.topic,\n    203  \t\t\t\t\t(uint8_t)ctxt->will->msg.qos,\n    204  \t\t\t\t\t(uint32_t)ctxt->will->msg.payloadlen,\n    205  \t\t\t\t\tctxt->will->msg.payload,\n    206  \t\t\t\t\tctxt->will->msg.retain,\n    207  \t\t\t\t\tctxt->will->expiry_interval,\n    208  \t\t\t\t\t&ctxt->will->properties);\n    209  \t\t}\n    210  \t}\n    211  \twill__clear(ctxt);\n    212  }\nFunction: context__disconnect\nPath: /root/projects/mosquitto/src/context.c:215\n    215  void context__disconnect(struct mosquitto *context)\n    216  {\n    217  \tif(mosquitto__get_state(context) == mosq_cs_disconnected){\n    218  \t\treturn;\n    219  \t}\n    221  \tplugin__handle_disconnect(context, -1);\n    223  \tcontext__send_will(context);\n    224  \tnet__socket_close(context);\n    226  \tif(context->bridge == NULL)\n    229  \t{\n    230  \t\tif(context->session_expiry_interval == 0){\n    232  \t\t\tif(context->will_delay_interval == 0){\n    234  \t\t\t\tcontext__add_to_disused(context);\n    235  \t\t\t}\n    236  \t\t}else{\n    237  \t\t\tsession_expiry__add(context);\n    238  \t\t}\n    239  \t}\n    240  \tkeepalive__remove(context);\n    241  \tmosquitto__set_state(context, mosq_cs_disconnected);\n    242  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    94   \tpacket->command = 0;\n    97   \tpacket->remaining_length = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    150  \tpacket->pos = 0;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    233  \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    313  \t\t}else if(((packet->command)&0xF0) == CMD_DISCONNECT){\n    314  \t\t\tdo_client_disconnect(mosq, MOSQ_ERR_SUCCESS, NULL);\n    315  \t\t\tpacket__cleanup(packet);\n    316  \t\t\tmosquitto__free(packet);\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    345  \t}\n    353  }\nFunction: property__process_disconnect\nPath: /root/projects/mosquitto/src/property_broker.c:118\n    118  int property__process_disconnect(struct mosquitto *context, mosquitto_property **props)\n    119  {\n    120  \tmosquitto_property *p;\n    122  \tp = *props;\n    124  \twhile(p){\n    125  \t\tif(p->identifier == MQTT_PROP_SESSION_EXPIRY_INTERVAL){\n    126  \t\t\tif(context->session_expiry_interval == 0 && p->value.i32 != 0){\n    127  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    128  \t\t\t}\n    129  \t\t\tcontext->session_expiry_interval = p->value.i32;\n    130  \t\t}\n    131  \t\tp = p->next;\n    132  \t}\n    134  }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    2",
    "If the Server receives a SUBSCRIBE packet containing a Wildcard Subscription and the Server does not support Wildcard Subscriptions, receiving such a packet is a Protocol Error.": "Function: retain__queue\nPath: /root/projects/mosquitto/src/retain.c:278\n    278  int retain__queue(struct mosquitto *context, const char *sub, uint8_t sub_qos, uint32_t subscription_identifier)\n    279  {\n    280  \tstruct mosquitto__retainhier *retainhier;\n    281  \tchar *local_sub;\n    282  \tchar **split_topics;\n    286  \tassert(sub);\n    288  \tif(!strncmp(sub, \"$share/\", strlen(\"$share/\"))){\n    289  \t\treturn MOSQ_ERR_SUCCESS;\n    290  \t}\n    292  \trc = sub__topic_tokenise(sub, &local_sub, &split_topics, NULL);\n    293  \tif(rc) return rc;\n    295  \tHASH_FIND(hh, db.retains, split_topics[0], strlen(split_topics[0]), ",
    "If the Server receives a SUBSCRIBE packet containing a Subscription Identifier and the Server does not support Subscription Identifiers, this situation is a Protocol Error.": "Function: retain__queue\nPath: /root/projects/mosquitto/src/retain.c:278\n    278  int retain__queue(struct mosquitto *context, const char *sub, uint8_t sub_qos, uint32_t subscription_identifier)\n    279  {\n    280  \tstruct mosquitto__retainhier *retainhier;\n    282  \tchar **split_topics;\n    295  \tHASH_FIND(hh, db.retains, split_topics[0], strlen(split_topics[0]), retainhier);\n    297  \tif(retainhier){\n    298  \t\tretain__search(retainhier, split_topics, context, sub, sub_qos, subscription_identifier, 0);\n    299  \t}\n    304  }\nFunction: retain__search\nPath: /root/projects/mosquitto/src/retain.c:219\n    219  static int retain__search(struct mosquitto__retainhier *retainhier, char **split_topics, struct mosquitto *context, const char *sub, uint8_t sub_qos, uint32_t subscription_identifier, int level)\n    220  {\n    221  \tstruct mosquitto__retainhier *branch, *branch_tmp;\n    224  \tif(!strcmp(split_topics[0], \"#\") && split_topics[1] == NULL){\n    228  \t\t\t * this function and return to an",
    "In either case the multi-level wildcard character MUST be specified either on its own or following a topic level separator and MUST be the last character specified in the Topic Filter [MQTT-4.7.1-1].": "Function: retain__queue\nPath: /root/projects/mosquitto/src/retain.c:278\n    278  int retain__queue(struct mosquitto *context, const char *sub, uint8_t sub_qos, uint32_t subscription_identifier)\n    279  {\n    280  \tstruct mosquitto__retainhier *retainhier;\n    281  \tchar *local_s",
    "When the Server receives a SUBSCRIBE packet from a Client, the Server MUST respond with a SUBACK packet [MQTT-3.8.4-1].": "Function: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__alloc\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:50\n    50   int packet__alloc(struct mosquitto__packet *packet)\n    51   {\n    80   \tpacket->payload[0] = packet->command;\n    84   \tpacket->pos = 1U + (uint8_t)packet->remaining_count;\n    87   }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    94   \tpacket->command = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    150  \tpacket->pos = 0;\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    345  \t}\n    353  }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    633  }\nFunction: handle__subscribe\nPath: /root/projects/mosquitto/src/handle_subscribe.c:32\n    32   int handle__subscribe(struct mosquitto *context)\n    33   {\n    36   \tuint16_t mid;\n    37   \tchar *sub;\n    38   \tuint8_t subscription_options;\n    39   \tuint32_t subscription_identifier = 0;\n    40   \tuint8_t qos;\n    42   \tuint8_t *payload = NULL, *tmp_payload;\n    43   \tuint32_t payloadlen = 0;\n    48   \tbool allowed;\n    55   \tif(context->in_packet.command != (CMD_SUBSCRIBE|2)){\n    56   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    57   \t}\n    61   \tif(context->protocol != mosq_p_mqtt31){\n    62   \t\tif((context->in_packet.command&0x0F) != 0x02){\n    63   \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    64   \t\t}\n    65   \t}\n    66   \tif(packet__read_uint16(&context->in_packet, &mid)) return MOSQ_ERR_MALFORMED_PACKET;\n    67   \tif(mid == 0) return MOSQ_ERR_MALFORMED_PACKET;\n    69   \tif(context->protocol == mosq_p_mqtt5){\n    70   \t\trc = property__read_all(CMD_SUBSCRIBE, &context->in_packet, &properties);\n    71   \t\tif(rc){\n    74   \t\t\t * return codes so needs doc changes as well. */\n    75   \t\t\tif(rc == MOSQ_ERR_PROTOCOL){\n    76   \t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    77   \t\t\t}else{\n    78   \t\t\t\treturn rc;\n    79   \t\t\t}\n    80   \t\t}\n    83   \t\t\t\t\t&subscription_identifier, false)){\n    86   \t\t\tif(subscription_identifier == 0){\n    88   \t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    89   \t\t\t}\n    90   \t\t}\n    94   \t}\n    96   \twhile(context->in_packet.pos < context->in_packet.remaining_length){\n    97   \t\tsub = NULL;\n    98   \t\tif(packet__read_string(&context->in_packet, &sub, &slen)){\n    100  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    101  \t\t}\n    103  \t\tif(sub){\n    104  \t\t\tif(!slen){\n    108  \t\t\t\tmosquitto__free(sub);\n    110  \t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    111  \t\t\t}\n    112  \t\t\tif(mosquitto_sub_topic_check(sub)){\n    116  \t\t\t\tmosquitto__free(sub);\n    118  \t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    119  \t\t\t}\n    121  \t\t\tif(packet__read_byte(&context->in_packet, &subscription_options)){\n    122  \t\t\t\tmosquitto__free(sub);\n    124  \t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    125  \t\t\t}\n    126  \t\t\tif(context->protocol == mosq_p_mqtt31 || context->protocol == mosq_p_mqtt311){\n    127  \t\t\t\tqos = subscription_options;\n    131  \t\t\t}else{\n    132  \t\t\t\tqos = subscription_options & 0x03;\n    135  \t\t\t\tif((subscription_options & MQTT_SUB_OPT_NO_LOCAL) && !strncmp(sub, \"$share/\", 7)){\n    136  \t\t\t\t\tmosquitto__free(sub);\n    138  \t\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    139  \t\t\t\t}\n    141  \t\t\t\tif(retain_handling == 0x30 || (subscription_options & 0xC0) != 0){\n    142  \t\t\t\t\tmosquitto__free(sub);\n    144  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    145  \t\t\t\t}\n    146  \t\t\t}\n    147  \t\t\tif(qos > 2){\n    151  \t\t\t\tmosquitto__free(sub);\n    153  \t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    154  \t\t\t}\n    155  \t\t\tif(qos > context->max_qos){\n    156  \t\t\t\tqos = context->max_qos;\n    157  \t\t\t}\n    160  \t\t\tif(context->listener && context->listener->mount_point){\n    163  \t\t\t\tif(!sub_mount){\n    164  \t\t\t\t\tmosquitto__free(sub);\n    166  \t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    167  \t\t\t\t}\n    168  \t\t\t\tsnprintf(sub_mount, len, \"%s%s\", context->listener->mount_point, sub);\n    171  \t\t\t\tmosquitto__free(sub);\n    172  \t\t\t\tsub = sub_mount;\n    174  \t\t\t}\n    175  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s (QoS %d)\", sub, qos);\n    178  \t\t\trc2 = mosquitto_acl_check(context, sub, 0, NULL, qos, false, MOSQ_ACL_SUBSCRIBE);\n    179  \t\t\tswitch(rc2){\n    182  \t\t\t\tcase MOSQ_ERR_ACL_DENIED:\n    184  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    186  \t\t\t\t\t}else if(context->protocol == mosq_p_mqtt311){\n    188  \t\t\t\t\t}\n    189  \t\t\t\t\tbreak;\n    190  \t\t\t\tdefault:\n    191  \t\t\t\t\tmosquitto__free(sub);\n    192  \t\t\t\t\treturn rc2;\n    193  \t\t\t}\n    195  \t\t\tif(allowed){\n    196  \t\t\t\trc2 = sub__add(context, sub, qos, subscription_identifier, subscription_options);\n    197  \t\t\t\tif(rc2 > 0){\n    198  \t\t\t\t\tmosquitto__free(sub);\n    199  \t\t\t\t\treturn rc2;\n    200  \t\t\t\t}\n    201  \t\t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    202  \t\t\t\t\tif(rc2 == MOSQ_ERR_SUCCESS || rc2 == MOSQ_ERR_SUB_EXISTS){\n    203  \t\t\t\t\t\tif(retain__queue(context, sub, qos, 0)) rc = 1;\n    204  \t\t\t\t\t}\n    205  \t\t\t\t}else{\n    206  \t\t\t\t\tif((retain_handling == MQTT_SUB_OPT_SEND_RETAIN_ALWAYS)\n    207  \t\t\t\t\t\t\t|| (rc2 == MOSQ_ERR_SUCCESS && retain_handling == MQTT_SUB_OPT_SEND_RETAIN_NEW)){\n    209  \t\t\t\t\t\tif(retain__queue(context, sub, qos, subscription_identifier)) rc = 1;\n    210  \t\t\t\t\t}\n    211  \t\t\t\t}\n    213  \t\t\t\tlog__printf(NULL, MOSQ_LOG_SUBSCRIBE, \"%s %d %s\", context->id, qos, sub);\n    214  \t\t\t}\n    215  \t\t\tmosquitto__free(sub);\n    217  \t\t\ttmp_payload = mosquitto__realloc(payload, payloadlen + 1);\n    218  \t\t\tif(tmp_payload){\n    221  \t\t\t\tpayloadlen++;\n    222  \t\t\t}else{\n    225  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    226  \t\t\t}\n    227  \t\t}\n    228  \t}\n    230  \tif(context->protocol != mosq_p_mqtt31){\n    231  \t\tif(payloadlen == 0){\n    233  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    234  \t\t}\n    235  \t}\n    236  \tif(send__suback(context, mid, payloadlen, payload)) rc = 1;\n    251  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__write_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:61\n    61   void packet__write_byte(struct mosquitto__packet *packet, uint8_t byte)\n    63   \tassert(packet);\n    64   \tassert(packet->pos+1 <= packet->packet_length);\n    66   \tpacket->payload[packet->pos] = byte;\n    67   \tpacket->pos++;\n    68   }\nFunction: packet__write_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:83\n    83   void packet__write_bytes(struct mosquitto__packet *packet, const void *bytes, uint32_t count)\n    84   {\n    86   \tassert(packet->pos+count <= packet->packet_length);\n    88   \tif(count > 0){\n    89   \t\tmemcpy(&(packet->payload[packet->pos]), bytes, count);\n    90   \t\tpacket->pos += count;\n    91   \t}\n    92   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: packet__write_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:171\n    171  void packet__write_uint16(struct mosquitto__packet *packet, uint16_t word)\n    173  \tpacket__write_byte(packet, MOSQ_MSB(word));\n    174  \tpacket__write_byte(packet, MOSQ_LSB(word));\n    175  }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    144  \t}\n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    161  \t}\n    164  }\nFunction: send__suback\nPath: /root/projects/mosquitto/src/send_suback.c:29\n    29   int send__suback(struct mosquitto *context, uint16_t mid, uint32_t payloadlen, const void *payload)\n    30   {\n    31   \tstruct mosquitto__packet *packet = NULL;\n    32   \tint rc;\n    33   \tmosquitto_property *properties = NULL;\n    34   \n    35   \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending SUBACK to %s\", context->id);\n    36   \n    37   \tpacket = mosquitto__calloc(1, sizeof(struct mosquitto__packet));\n    38   \tif(!packet) return MOSQ_ERR_NOMEM;\n    39   \n    40   \tpacket->command = CMD_SUBACK;\n    41   \tpacket->remaining_length = 2+payloadlen;\n    42   \tif(context->protocol == mosq_p_mqtt5){\n    43   \t\tpacket->remaining_length += property__get_remaining_length(properties);\n    44   \t}\n    45   \trc = packet__alloc(packet);\n    46   \tif(rc){\n    47   \t\tmosquitto__free(packet);\n    48   \t\treturn rc;\n    49   \t}\n    50   \tpacket__write_uint16(packet, mid);\n    51   \n    52   \tif(context->protocol == mosq_p_mqtt5){\n    53   \t\t/* We don't use Reason String or User Property yet. */\n    54   \t\tproperty__write_all(packet, properties, true);\n    55   \t}\n    56   \n    57   \tif(payloadlen){\n    58   \t\tpacket__write_bytes(packet, payload, payloadlen);\n    59   \t}\n    60   \n    61   \treturn packet__queue(context, packet);\n    62   }\nFunction: sub__add_shared\nPath: /root/projects/mosquitto/src/subs.c:202\n    202  static int sub__add_shared(struct mosquitto *context, const char *sub, uint8_t qos, uint32_t identifier, int options, struct mosquitto__subhier *subhier, const char *sharename)\n    203  {\n    270  \tif(context->protocol == mosq_p_mqtt31 || context->protocol == mosq_p_mqtt5){\n    271  \t\treturn rc;\n    272  \t}else{\n    275  \t\treturn MOSQ_ERR_SUCCESS;\n    276  \t}\n    277  }\nFunction: sub__add_normal\nPath: /root/projects/mosquitto/src/subs.c:280\n    280  static int sub__add_normal(struct mosquitto *context, const char *sub, uint8_t qos, uint32_t identifier, int options, struct mosquitto__subhier *subhier)\n    281  {\n    325  \tif(context->protocol == mosq_p_mqtt31 || context->protocol == mosq_p_mqtt5){\n    326  \t\treturn rc;\n    327  \t}else{\n    330  \t\treturn MOSQ_ERR_SUCCESS;\n    331  \t}\n    332  }\n",
    "The ShareName MUST NOT contain the characters '/', '+' or '#', but MUST be followed by a '/' character. The '/' character MUST be followed by a Topic Filter [MQTT-4.8.2-2] as described in section 4.7.": "Function: retain__queue\nPath: /root/projects/mosquitto/src/retain.c:278\n    278  int retain__queue(struct mosquitto *context, const char *sub, uint8_t sub_qos, uint32_t subscription_identifier)\n    279  {\n    280  \tstruct mosquitto__retainhier *retainhier;\n    281  \tchar *local_sub;\n    282  \tchar **split_topics;\n    286  \tassert(sub);\n    288  \tif(!strncmp(sub, \"$share/\", strlen(\"$share/\"))){\n    289  \t\treturn MOSQ_ERR_SUCCESS;\n    290  \t}\n    292  \trc = sub__topic_tokenise(sub, &local_sub, &split_topics, NULL);\n    293  \tif(rc) return rc;\n    295  \tHASH_FIND(hh, db.retains, split_topics[0], strlen(split_topics[0]), retainhier);\n    297  \tif(retainhier){\n    298  \t\tretain__search(retainhier, split_topics, context, sub, sub_qos, subscription_identifier, 0);\n    299  \t}\n    300  \tmosquitto__free(local_sub);\n    304  }\nFunction: retain__search\nPath: /root/projects/mosquitto/src/retain.c:219\n    219  static int retain__search(struct mosquitto__retainhier *retainhier, char **split_topics, struct mosquitto *context, const char *sub, uint8_t sub_qos, uint32_t subscription_identifier, int level)\n    220  {\n    221  \tstruct mosquitto__retainhier *branch, *branch_tmp;\n    224  \tif(!strcmp(split_topics[0], \"#\") && split_topics[1] == NULL){\n    228  \t\t\t * this function and return to an earlier retain__search().\n    232  \t\t\t\tretain__process(branch, context, sub_qos, subscription_identifier);\n    235  \t\t\t\tretain__search(branch, split_topics, context, sub, sub_qos, subscription_identifier, level+1);\n    238  \t}else{\n    239  \t\tif(!strcmp(split_topics[0], \"+\")){\n    242  \t\t\t\t\tif(retain__search(branch, &(split_topics[1]), context, sub, sub_qos, subscription_identifier, level+1) == -1\n    243  \t\t\t\t\t\t\t|| (split_topics[1] != NULL && !strcmp(split_topics[1], \"#\") && level>0)){\n    255  \t\t}else{\n    256  \t\t\tHASH_FIND(hh, retainhier->children, split_topics[0], strlen(split_topics[0]), branch);\n    257  \t\t\tif(branch){\n    258  \t\t\t\tif(split_topics[1] != NULL){\n    259  \t\t\t\t\tif(retain__search(branch, &(split_topics[1]), context, sub, sub_qos, subscription_identifier, level+1) == -1\n    260  \t\t\t\t\t\t\t|| (split_topics[1] != NULL && !strcmp(split_topics[1], \"#\") && level>0)){\n    265  \t\t\t\t\t}\n    266  \t\t\t\t}else{\n    271  \t\t\t}\n    272  \t\t}\n    273  \t}\n    275  }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    94   \tpacket->command = 0;\n    102  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    345  \t}\n    353  }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    633  }\nFunction: handle__subscribe\nPath: /root/projects/mosquitto/src/handle_subscribe.c:32\n    32   int handle__subscribe(struct mosquitto *context)\n    33   {\n    36   \tuint16_t mid;\n    37   \tchar *sub;\n    38   \tuint8_t subscription_options;\n    39   \tuint32_t subscription_identifier = 0;\n    40   \tuint8_t qos;\n    41   \tuint8_t retain_handling = 0;\n    42   \tuint8_t *payload = NULL, *tmp_payload;\n    43   \tuint32_t payloadlen = 0;\n    45   \tuint16_t slen;\n    48   \tbool allowed;\n    55   \tif(context->in_packet.command != (CMD_SUBSCRIBE|2)){\n    56   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    57   \t}\n    61   \tif(context->protocol != mosq_p_mqtt31){\n    62   \t\tif((context->in_packet.command&0x0F) != 0x02){\n    63   \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    64   \t\t}\n    65   \t}\n    66   \tif(packet__read_uint16(&context->in_packet, &mid)) return MOSQ_ERR_MALFORMED_PACKET;\n    67   \tif(mid == 0) return MOSQ_ERR_MALFORMED_PACKET;\n    69   \tif(context->protocol == mosq_p_mqtt5){\n    71   \t\tif(rc){\n    74   \t\t\t * return codes so needs doc changes as well. */\n    75   \t\t\tif(rc == MOSQ_ERR_PROTOCOL){\n    76   \t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    77   \t\t\t}else{\n    78   \t\t\t\treturn rc;\n    79   \t\t\t}\n    80   \t\t}\n    82   \t\tif(mosquitto_property_read_varint(properties, MQTT_PROP_SUBSCRIPTION_IDENTIFIER,\n    83   \t\t\t\t\t&subscription_identifier, false)){\n    86   \t\t\tif(subscription_identifier == 0){\n    88   \t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    89   \t\t\t}\n    90   \t\t}\n    94   \t}\n    96   \twhile(context->in_packet.pos < context->in_packet.remaining_length){\n    97   \t\tsub = NULL;\n    98   \t\tif(packet__read_string(&context->in_packet, &sub, &slen)){\n    100  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    101  \t\t}\n    103  \t\tif(sub){\n    104  \t\t\tif(!slen){\n    108  \t\t\t\tmosquitto__free(sub);\n    110  \t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    111  \t\t\t}\n    112  \t\t\tif(mosquitto_sub_topic_check(sub)){\n    113  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO,\n    114  \t\t\t\t\t\t\"Invalid subscription string from %s, disconnecting.\",\n    115  \t\t\t\t\t\tcontext->address);\n    116  \t\t\t\tmosquitto__free(sub);\n    118  \t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    119  \t\t\t}\n    121  \t\t\tif(packet__read_byte(&context->in_packet, &subscription_options)){\n    122  \t\t\t\tmosquitto__free(sub);\n    124  \t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    125  \t\t\t}\n    126  \t\t\tif(context->protocol == mosq_p_mqtt31 || context->protocol == mosq_p_mqtt311){\n    127  \t\t\t\tqos = subscription_options;\n    128  \t\t\t\tif(context->is_bridge){\n    129  \t\t\t\t\tsubscription_options = MQTT_SUB_OPT_RETAIN_AS_PUBLISHED | MQTT_SUB_OPT_NO_LOCAL;\n    130  \t\t\t\t}\n    131  \t\t\t}else{\n    132  \t\t\t\tqos = subscription_options & 0x03;\n    133  \t\t\t\tsubscription_options &= 0xFC;\n    135  \t\t\t\tif((subscription_options & MQTT_SUB_OPT_NO_LOCAL) && !strncmp(sub, \"$share/\", 7)){\n    136  \t\t\t\t\tmosquitto__free(sub);\n    138  \t\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    139  \t\t\t\t}\n    140  \t\t\t\tretain_handling = (subscription_options & 0x30);\n    141  \t\t\t\tif(retain_handling == 0x30 || (subscription_options & 0xC0) != 0){\n    142  \t\t\t\t\tmosquitto__free(sub);\n    144  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    145  \t\t\t\t}\n    146  \t\t\t}\n    147  \t\t\tif(qos > 2){\n    151  \t\t\t\tmosquitto__free(sub);\n    153  \t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    154  \t\t\t}\n    155  \t\t\tif(qos > context->max_qos){\n    156  \t\t\t\tqos = context->max_qos;\n    157  \t\t\t}\n    160  \t\t\tif(context->listener && context->listener->mount_point){\n    161  \t\t\t\tlen = strlen(context->listener->mount_point) + slen + 1;\n    162  \t\t\t\tsub_mount = mosquitto__malloc(len+1);\n    163  \t\t\t\tif(!sub_mount){\n    164  \t\t\t\t\tmosquitto__free(sub);\n    166  \t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    167  \t\t\t\t}\n    168  \t\t\t\tsnprintf(sub_mount, len, \"%s%s\", context->listener->mount_point, sub);\n    169  \t\t\t\tsub_mount[len] = '\\0';\n    171  \t\t\t\tmosquitto__free(sub);\n    172  \t\t\t\tsub = sub_mount;\n    174  \t\t\t}\n    175  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"\\t%s (QoS %d)\", sub, qos);\n    178  \t\t\trc2 = mosquitto_acl_check(context, sub, 0, NULL, qos, false, MOSQ_ACL_SUBSCRIBE);\n    179  \t\t\tswitch(rc2){\n    182  \t\t\t\tcase MOSQ_ERR_ACL_DENIED:\n    184  \t\t\t\t\tif(context->protocol == mosq_p_mqtt5){\n    186  \t\t\t\t\t}else if(context->protocol == mosq_p_mqtt311){\n    188  \t\t\t\t\t}\n    189  \t\t\t\t\tbreak;\n    190  \t\t\t\tdefault:\n    191  \t\t\t\t\tmosquitto__free(sub);\n    192  \t\t\t\t\treturn rc2;\n    193  \t\t\t}\n    195  \t\t\tif(allowed){\n    196  \t\t\t\trc2 = sub__add(context, sub, qos, subscription_identifier, subscription_options);\n    197  \t\t\t\tif(rc2 > 0){\n    198  \t\t\t\t\tmosquitto__free(sub);\n    199  \t\t\t\t\treturn rc2;\n    200  \t\t\t\t}\n    201  \t\t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    202  \t\t\t\t\tif(rc2 == MOSQ_ERR_SUCCESS || rc2 == MOSQ_ERR_SUB_EXISTS){\n    203  \t\t\t\t\t\tif(retain__queue(context, sub, qos, 0)) rc = 1;\n    204  \t\t\t\t\t}\n    205  \t\t\t\t}else{\n    206  \t\t\t\t\tif((retain_handling == MQTT_SUB_OPT_SEND_RETAIN_ALWAYS)\n    207  \t\t\t\t\t\t\t|| (rc2 == MOSQ_ERR_SUCCESS && retain_handling == MQTT_SUB_OPT_SEND_RETAIN_NEW)){\n    209  \t\t\t\t\t\tif(retain__queue(context, sub, qos, subscription_identifier)) rc = 1;\n    210  \t\t\t\t\t}\n    211  \t\t\t\t}\n    213  \t\t\t\tlog__printf(NULL, MOSQ_LOG_SUBSCRIBE, \"%s %d %s\", context->id, qos, sub);\n    214  \t\t\t}\n    215  \t\t\tmosquitto__free(sub);\n    217  \t\t\ttmp_payload = mosquitto__realloc(payload, payloadlen + 1);\n    218  \t\t\tif(tmp_payload){\n    220  \t\t\t\tpayload[payloadlen] = qos;\n    221  \t\t\t\tpayloadlen++;\n    222  \t\t\t}else{\n    225  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    226  \t\t\t}\n    227  \t\t}\n    228  \t}\n    230  \tif(context->protocol != mosq_p_mqtt31){\n    231  \t\tif(payloadlen == 0){\n    233  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    234  \t\t}\n    235  \t}\n    236  \tif(send__suback(context, mid, payloadlen, payload)) rc = 1;\n    251  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    54   \t*byte = packet->payload[packet->pos];\n    58   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    106  \t\t*length = 0;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: mosquitto__malloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:83\n    83   void *mosquitto__malloc(size_t size)\n    84   {\n    88   \tif(mem_limit && memcount + size > mem_limit){\n    89   \t\treturn NULL;\n    90   \t}\n    93   \tmem = malloc(size);\n    96   \tif(mem){\n    97   \t\tmemcount += malloc_usable_size(mem);\n    101  \t}\n    105  }\nFunction: mosquitto__strdup\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:144\n    144  char *mosquitto__strdup(const char *s)\n    145  {\n    148  \tif(mem_limit && memcount + strlen(s) > mem_limit){\n    149  \t\treturn NULL;\n    150  \t}\n    152  \tstr = strdup(s);\n    155  \tif(str){\n    156  \t\tmemcount += malloc_usable_size(str);\n    160  \t}\n    164  }\nFunction: send__command_with_mid\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:121\n    121  int send__command_with_mid(struct mosquitto *mosq, uint8_t command, uint16_t mid, bool dup, uint8_t reason_code, const mosquitto_property *properties)\n    122  {\n    136  \tif(mosq->protocol == mosq_p_mqtt5){\n    144  \t}\n    154  \tif(mosq->protocol == mosq_p_mqtt5){\n    161  \t}\n    164  }\nFunction: send__real_publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:137\n    137  int send__real_publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    138  {\n    153  \tif(mosq->protocol == mosq_p_mqtt5){\n    175  \t}\n    206  \tif(mosq->protocol == mosq_p_mqtt5){\n    213  \t}\n    221  }\nFunction: send__suback\nPath: /root/projects/mosquitto/src/send_suback.c:29\n    29   int send__suback(struct mosquitto *context, uint16_t mid, uint32_t payloadlen, const void *payload)\n    30   {\n    42   \tif(context->protocol == mosq_p_mqtt5){\n    44   \t}\n    52   \tif(context->protocol == mosq_p_mqtt5){\n    55   \t}\n    62   }\nFunction: mosquitto_acl_check\nPath: /root/projects/mosquitto/src/security.c:679\n    679  int mosquitto_acl_check(struct mosquitto *context, const char *topic, uint32_t payloadlen, void* payload, uint8_t qos, bool retain, int access)\n    680  {\n    695  \trc = acl__check_dollar(topic, access);\n    696  \tif(rc) return rc;\n    714  \tmsg.topic = topic;\n    726  \t\tevent_data.topic = topic;\n    753  }\nFunction: acl__check_dollar\nPath: /root/projects/mosquitto/src/security.c:646\n    646  static int acl__check_dollar(const char *topic, int access)\n    647  {\n    649  \tbool match = false;\n    651  \tif(topic[0] != '$') return MOSQ_ERR_SUCCESS;\n    653  \tif(!strncmp(topic, \"$SYS\", 4)){\n    654  \t\tif(access == MOSQ_ACL_WRITE){\n    656  \t\t\trc = mosquitto_topic_matches_sub(\"$SYS/broker/connection/+/state\", topic, &match);\n    657  \t\t\tif(rc == MOSQ_ERR_SUCCESS && match == true){\n    658  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    659  \t\t\t}else{\n    660  \t\t\t\treturn MOSQ_ERR_ACL_DENIED;\n    661  \t\t\t}\n    662  \t\t}else{\n    663  \t\t\treturn MOSQ_ERR_SUCCESS;\n    664  \t\t}\n    665  \t}else if(!strncmp(topic, \"$share\", 6)){\n    667  \t\tif(access == MOSQ_ACL_SUBSCRIBE || access == MOSQ_ACL_UNSUBSCRIBE){\n    668  \t\t\treturn MOSQ_ERR_SUCCESS;\n    669  \t\t}else{\n    670  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    671  \t\t}\n    672  \t}else{\n    674  \t\treturn MOSQ_ERR_SUCCESS;\n    675  \t}\n    676  }\nFunction: acl__check_single\nPath: /root/projects/mosquitto/src/security.c:602\n    602  static int acl__check_single(struct mosquitto__auth_plugin_config *auth_plugin, struct mosquitto *context, struct mosquitto_acl_msg *msg, int access)\n    603  {\n    605  \tconst char *topic = msg->topic;\n    615  \t\tif(username && strpbrk(username, \"+#\")){\n    616  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous username \\\"%s\\\"\", username);\n    617  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    618  \t\t}\n    619  \t\tif(context->id && strpbrk(context->id, \"+#\")){\n    620  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"ACL denying access to client with dangerous client id \\\"%s\\\"\", context->id);\n    621  \t\t\treturn MOSQ_ERR_ACL_DENIED;\n    622  \t\t}\n    625  \tif(auth_plugin->plugin.version == 4){\n    626  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    627  \t\t\treturn MOSQ_ERR_SUCCESS;\n    628  \t\t}\n    629  \t\treturn auth_plugin->plugin.acl_check_v4(auth_plugin->plugin.user_data, access, context, msg);\n    630  \t}else if(auth_plugin->plugin.version == 3){\n    631  \t\tif(access == MOSQ_ACL_UNSUBSCRIBE){\n    632  \t\t\treturn MOSQ_ERR_SUCCESS;\n    633  \t\t}\n    634  \t\treturn auth_plugin->plugin.acl_check_v3(auth_plugin->plugin.user_data, access, context, msg);\n    635  \t}else if(auth_plugin->plugin.version == 2){\n    636  \t\tif(access == MOSQ_ACL_SUBSCRIBE || access == MOSQ_ACL_UNSUBSCRIBE){\n    637  \t\t\treturn MOSQ_ERR_SUCCESS;\n    638  \t\t}\n    639  \t\treturn auth_plugin->plugin.acl_check_v2(auth_plugin->plugin.user_data, context->id, username, topic, access);\n    640  \t}else{\n    641  \t\treturn MOSQ_ERR_INVAL;\n    642  \t}\n    643  }\nFunction: sub__add\nPath: /root/projects/mosquitto/src/subs.c:578\n    578  int sub__add(struct mosquitto *context, const char *sub, uint8_t qos, uint32_t identifier, int options)\n    579  {\n    581  \tstruct mosquitto__subhier *subhier;\n    582  \tconst char *sharename = NULL;\n    583  \tchar *local_sub;\n    584  \tchar **topics;\n    587  \tassert(sub);\n    589  \trc = sub__topic_tokenise(sub, &local_sub, &topics, &sharename);\n    590  \tif(rc) return rc;\n    592  \ttopiclen = strlen(topics[0]);\n    593  \tif(topiclen > UINT16_MAX){\n    594  \t\tmosquitto__free(local_sub);\n    596  \t\treturn MOSQ_ERR_INVAL;\n    597  \t}\n    599  \tif(sharename){\n    600  \t\tHASH_FIND(hh, db.shared_subs, topics[0], topiclen, subhier);\n    601  \t\tif(!subhier){\n    602  \t\t\tsubhier = sub__add_hier_entry(NULL, &db.shared_subs, topics[0], (uint16_t)topiclen);\n    603  \t\t\tif(!subhier){\n    604  \t\t\t\tmosquitto__free(local_sub);\n    606  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n    607  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t\t}\n    609  \t\t}\n    610  \t}else{\n    611  \t\tHASH_FIND(hh, db.normal_subs, topics[0], topiclen, subhier);\n    612  \t\tif(!subhier){\n    613  \t\t\tsubhier = sub__add_hier_entry(NULL, &db.normal_subs, topics[0], (uint16_t)topiclen);\n    614  \t\t\tif(!subhier){\n    615  \t\t\t\tmosquitto__free(local_sub);\n    617  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n    618  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    619  \t\t\t}\n    620  \t\t}\n    621  \t}\n    622  \trc = sub__add_context(context, sub, qos, identifier, options, subhier, topics, sharename);\n    624  \tmosquitto__free(local_sub);\n    628  }\nFunction: sub__add_context\nPath: /root/projects/mosquitto/src/subs.c:335\n    335  static int sub__add_context(struct mosquitto *context, const char *topic_filter, uint8_t qos, uint32_t identifier, int options, struct mosquitto__subhier *subhier, char *const *const topics, const char *sharename)\n    336  {\n    358  \tif(context && context->id){\n    359  \t\tif(sharename){\n    360  \t\t\treturn sub__add_shared(context, topic_filter, qos, identifier, options, subhier, sharename);\n    361  \t\t}else{\n    362  \t\t\treturn sub__add_normal(context, topic_filter, qos, identifier, options, subhier);\n    363  \t\t}\n    364  \t}else{\n    365  \t\treturn MOSQ_ERR_SUCCESS;\n    366  \t}\n    367  }\nFunction: sub__add_shared\nPath: /root/projects/mosquitto/src/subs.c:202\n    202  static int sub__add_shared(struct mosquitto *context, const char *sub, uint8_t qos, uint32_t identifier, int options, struct mosquitto__subhier *subhier, const char *sharename)\n    203  {\n    204  \tstruct mosquitto__subleaf *newleaf;\n    205  \tstruct mosquitto__subshared *shared = NULL;\n    212  \tslen = strlen(sharename);\n    214  \tHASH_FIND(hh, subhier->shared, sharename, slen, shared);\n    215  \tif(shared == NULL){\n    216  \t\tshared = mosquitto__calloc(1, sizeof(struct mosquitto__subshared));\n    217  \t\tif(!shared){\n    218  \t\t\treturn MOSQ_ERR_NOMEM;\n    219  \t\t}\n    221  \t\tif(shared->name == NULL){\n    223  \t\t\treturn MOSQ_ERR_NOMEM;\n    224  \t\t}\n    227  \t}\n    229  \trc = sub__add_leaf(context, qos, identifier, options, &shared->subs, &newleaf);\n    239  \tif(rc != MOSQ_ERR_SUB_EXISTS){\n    240  \t\tslen = strlen(sub);\n    241  \t\tcsub = mosquitto__calloc(1, sizeof(struct mosquitto__client_sub) + slen + 1);\n    242  \t\tif(csub == NULL) return MOSQ_ERR_NOMEM;\n    243  \t\tmemcpy(csub->topic_filter, sub, slen);\n    244  \t\tcsub->hier = subhier;\n    245  \t\tcsub->shared = shared;\n    247  \t\tfor(i=0; i<context->sub_count; i++){\n    248  \t\t\tif(!context->subs[i]){\n    249  \t\t\t\tcontext->subs[i] = csub;\n    251  \t\t\t}\n    252  \t\t}\n    253  \t\tif(i == context->sub_count){\n    254  \t\t\tsubs = mosquitto__realloc(context->subs, sizeof(struct mosquitto__client_sub *)*(size_t)(context->sub_count + 1));\n    255  \t\t\tif(!subs){\n    258  \t\t\t\tmosquitto__free(csub);\n    259  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    260  \t\t\t}\n    263  \t\t\tcontext->subs[context->sub_count-1] = csub;\n    264  \t\t}\n    268  \t}\n    270  \tif(context->protocol == mosq_p_mqtt31 || context->protocol == mosq_p_mqtt5){\n    271  \t\treturn rc;\n    272  \t}else{\n    275  \t\treturn MOSQ_ERR_SUCCESS;\n    276  \t}\n    277  }\nFunction: sub__topic_tokenise\nPath: /root/projects/mosquitto/src/topic_tok.c:58\n    58   int sub__topic_tokenise(const char *subtopic, char **local_sub, char ***topics, const char **sharename)\n    59   {\n    60   \tchar *saveptr = NULL;\n    61   \tchar *token;\n    62   \tint count;\n    67   \tlen = strlen(subtopic);\n    68   \tif(len == 0){\n    69   \t\treturn MOSQ_ERR_INVAL;\n    70   \t}\n    72   \t*local_sub = mosquitto__strdup(subtopic);\n    73   \tif((*local_sub) == NULL) return MOSQ_ERR_NOMEM;\n    76   \tsaveptr = *local_sub;\n    77   \twhile(saveptr){\n    78   \t\tsaveptr = strchr(&saveptr[1], '/');\n    79   \t\tcount++;\n    80   \t}\n    81   \t*topics = mosquitto__calloc((size_t)(count+3) /* 3=$shared,sharename,NULL */, sizeof(char *));\n    82   \tif((*topics) == NULL){\n    83   \t\tmosquitto__free(*local_sub);\n    84   \t\treturn MOSQ_ERR_NOMEM;\n    85   \t}\n    87   \tif((*local_sub)[0] != '$'){\n    88   \t\t(*topics)[topic_index] = \"\";\n    90   \t}\n    92   \ttoken = strtok_hier((*local_sub), &saveptr);\n    93   \twhile(token){\n    94   \t\t(*topics)[topic_index] = token;\n    96   \t\ttoken = strtok_hier(NULL, &saveptr);\n    97   \t}\n    99   \tif(!strcmp((*topics)[0], \"$share\")){\n    100  \t\tif(count < 3 || (count == 3 && strlen((*topics)[2]) == 0)){\n    101  \t\t\tmosquitto__free(*local_sub);\n    102  \t\t\tmosquitto__free(*topics);\n    103  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    104  \t\t}\n    106  \t\tif(sharename){\n    107  \t\t\t(*sharename) = (*topics)[1];\n    108  \t\t}\n    110  \t\tfor(i=1; i<count-1; i++){\n    111  \t\t\t(*topics)[i] = (*topics)[i+1];\n    112  \t\t}\n    113  \t\t(*topics)[0] = \"\";\n    114  \t\t(*topics)[count-1] = NULL;\n    115  \t}\n    117  }\nFunction: strtok_hier\nPath: /root/projects/mosquitto/src/topic_tok.c:32\n    32   static char *strtok_hier(char *str, char **saveptr)\n    33   {\n    36   \tif(str != NULL){\n    37   \t\t*saveptr = str;\n    38   \t}\n    40   \tif(*saveptr == NULL){\n    41   \t\treturn NULL;\n    42   \t}\n    44   \tc = strchr(*saveptr, '/');\n    45   \tif(c){\n    46   \t\tstr = *saveptr;\n    47   \t\t*saveptr = c+1;\n    48   \t\tc[0] = '\\0';\n    49   \t}else if(*saveptr){\n    51   \t\tstr = *saveptr;\n    52   \t\t*saveptr = NULL;\n    53   \t}\n    55   }\nFunction: mosquitto_validate_utf8\nPath: /root/projects/mosquitto/src/../lib/utf8_mosq.c:24\n    24   int mosquitto_validate_utf8(const char *str, int len)\n    25   {\n    26   \tint i;\n    27   \tint j;\n    28   \tint codelen;\n    29   \tint codepoint;\n    32   \tif(!str) return MOSQ_ERR_INVAL;\n    35   \tfor(i=0; i<len; i++){\n    36   \t\tif(ustr[i] == 0){\n    37   \t\t\treturn",
    "If the Client specified a Subscription Identifier for any of the overlapping subscriptions, the Server MUST include those Subscription Identifiers in the PUBLISH message resulting from those subscriptions [MQTT-3.3.4-3].": "Function: retain__queue\nPath: /root/projects/mosquitto/src/retain.c:278\n    278  int retain__queue(struct mosquitto *context, const char *sub, uint8_t sub_qos, uint32_t subscription_identifier)\n    279  {\n    280  \tstruct mosquitto__retainhier *retainhier;\n    281  \tchar *local_sub;\n    282  \tchar **split_topics;\n    283  \tint rc;\n    284  \n    285  \tassert(context);\n    286  \tassert(sub);\n    287  \n    288  \tif(!strncmp(sub, \"$share/\", strlen(\"$share/\"))){\n    289  \t\treturn MOSQ_ERR_SUCCESS;\n    290  \t}\n    291  \n    292  \trc = sub__topic_tokenise(sub, &local_sub, &split_topics, NULL);\n    293  \tif(rc) return rc;\n    294  \n    295  \tHASH_FIND(hh, db.retains, split_topics[0], strlen(split_topics[0]), retainhier);\n    296  \n    297  \tif(retainhier){\n    298  \t\tretain__search(retainhier, split_topics, context, sub, sub_qos, subscription_identifier, 0);\n    299  \t}\n    300  \tmosquitto__free(local_sub);\n    301  \tmosquitto__free(split_topics);\n    302  \n    303  \treturn MOSQ_ERR_SUCCESS;\n    304  }\nFunction: retain__search\nPath: /root/projects/mosquitto/src/retain.c:219\n    219  static int retain__search(struct mosquitto__retainhier *retainhier, cha",
    "If the Server sends multiple PUBLISH packets it MUST send, in each of them, the Subscription Identifier of the matching subscription if it has a Subscription Identifier [MQTT-3.3.4-5].": "Function: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    94   \tpacket->command = 0;\n    95   \tpacket->remaining_count = 0;\n    97   \tpacket->remaining_length = 0;\n    98   \tmosquitto__free(packet->payload);\n    99   \tpacket->payload = NULL;\n    100  \tpacket->to_process = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    151  \tpacket->to_process = packet->packet_length;\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    345  \t}\n    353  }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *prop",
    "The receiver of an MQTT Control Packet that contains the DUP flag set to 1 cannot assume that the receiver has seen an earlier copy of this packet.": "Function: plugin__handle_message\nPath: /root/projects/mosquitto/src/plugin.c:130\n    130  int plugin__handle_message(struct mosquitto *context, struct mosquitto_msg_store *stored)\n    131  {\n    154  \tevent_data.qos = stored->qos;\n    155  \tevent_data.retain = stored->retain;\n    182  \tstored->retain = event_data.retain;\n    185  }\nFunction: handle__publish\nPath: /root/projects/mosquitto/src/handle_publish.c:36\n    36   int handle__publish(struct mosquitto *context)\n    37   {\n    38   \tuint8_t dup;\n    39   \tint rc = 0;\n    41   \tuint8_t header = context->in_packet.command;\n    42   \tint res = 0;\n    43   \tstruct mosquitto_msg_store *msg, *stored = NULL;\n    44   \tstruct mosquitto_client_msg *cmsg_stored = NULL;\n    48   \tmosquitto_property *properties = NULL;\n    49   \tmosquitto_property *p, *p_prev;\n    50   \tmosquitto_property *msg_properties_last;\n    51   \tuint32_t message_expiry_interval = 0;\n    52   \tint topic_alias = -1;\n    54   \tuint16_t mid = 0;\n    56   \tif(context->state != mosq_cs_active){\n    57   \t\treturn MOSQ_ERR_PROTOCOL;\n    58   \t}\n    60   \tmsg = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    65   \tdup = (header & 0x08)>>3;\n    66   \tmsg->qos = (header & 0x06)>>1;\n    67   \tif(dup == 1 && msg->qos == 0){\n    68   \t\tlog__printf(NULL, MOSQ_LOG_INFO,\n    69   \t\t\t\t\"Invalid PUBLISH (QoS=0 and DUP=1) from %s, disconnecting.\", context->id);\n    70   \t\tdb__msg_store_free(msg);\n    71   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    72   \t}\n    73   \tif(msg->qos == 3){\n    74   \t\tlog__printf(NULL, MOSQ_LOG_INFO,\n    75   \t\t\t\t\"Invalid QoS in PUBLISH from %s, disconnecting.\", context->id);\n    77   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    78   \t}\n    79   \tif(msg->qos > context->max_qos){\n    80   \t\tlog__printf(NULL, MOSQ_LOG_INFO,\n    81   \t\t\t\t\"Too high QoS in PUBLISH from %s, disconnecting.\", context->id);\n    83   \t\treturn MOSQ_ERR_QOS_NOT_SUPPORTED;\n    84   \t}\n    85   \tmsg->retain = (header & 0x01);\n    87   \tif(msg->retain && db.config->retain_available == false){\n    89   \t\treturn MOSQ_ERR_RETAIN_NOT_SUPPORTED;\n    90   \t}\n    92   \tif(packet__read_string(&context->in_packet, &msg->topic, &slen)){\n    94   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    95   \t}\n    96   \tif(!slen && context->protocol != mosq_p_mqtt5){\n    99   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    100  ",
    "When a Server takes ownership of an incoming Application Message, the Server MUST add the Application Message to the Session State for those Clients that have matching Subscriptions as defined in section 4.7 [MQTT-4.5.0-1].": "Function: plugin__handle_message\nPath: /root/projects/mosquitto/src/plugin.c:130\n    130  int plugin__handle_message(struct mosquitto *context, struct mosquitto_msg_store *stored)\n    131  {\n    133  \tstruct mosquitto__callback *cb_base;\n    134  \tstruct mosquitto__security_options *opts;\n    135  \tint rc = MOSQ_ERR_SUCCESS;\n    137  \tif(db.config->per_listener_settings){\n    138  \t\tif(context->listener == NULL){\n    139  \t\t\treturn MOSQ_ERR_SUCCESS;\n    140  \t\t}\n    141  \t\topts = &context->listener->security_options;\n    142  \t}else{\n    143  \t\topts = &db.config->security_options;\n    144  \t}\n    145  \tif(opts->plugin_callbacks.message == NULL){\n    146  \t\treturn MOSQ_ERR_SUCCESS;\n    147  \t}\n    150  \tevent_data.client = context;\n    151  \tevent_data.topic = stored->topic;\n    152  \tevent_data.payloadlen = stored->payloadlen;\n    153  \tevent_data.payload = stored->payload;\n    154  \tevent_data.qos = stored->qos;\n    155  \tevent_data.retain = stored->retain;\n    156  \tevent_data.properties = stored->properties;\n    158  \tDL_FOREACH(opts->plugin_callbacks.message, cb_base){\n    159  \t\trc = cb_base->cb(MOSQ_EVT_MESSAGE, &event_data, cb_base->userdata);\n    177  \t\tif(rc != MOSQ_ERR_SUCCESS){\n    182  \tstored->retain = event_data.retain;\n    185  }\nFunction: retain__store\nPath: /root/projects/mosquitto/src/retain.c:94\n    94   int retain__store(const char *topic, struct mosquitto_msg_store *stored, char **split_topics)\n    95   {\n    96   \tstruct mosquitto__retainhier *retainhier;\n    97   \tstruct mosquitto__retainhier *br",
    "The Server MUST maintain the order of User Properties when forwarding the Application Message [MQTT-3.3.2-18].": "Function: plugin__handle_message\nPath: /root/projects/mosquitto/src/plugin.c:130\n    130  int plugin__handle_message(struct mosquitto *context, struct mosquitto_msg_store *stored)\n    131  {\n    156  \tevent_data.properties = stored->properties;\n    172  \t\tif(stored->properties != event_data.properties){\n    173  \t\t\tmosquitto_property_free_all(&stored->properties);\n    174  \t\t\tstored->properties = event_data.properties;\n    185  }\nFunction: alias__add\nPath: /root/projects/mosquitto/src/../lib/alias_mosq.c:25\n    25   int alias__add(struct mosquitto *mosq, const char *topic, uint16_t alias)\n    26   {\n    27   \tint i;\n    30   \tfor(i=0; i<mosq->alias_count; i++){\n    31   \t\tif(mosq->aliases[i].alias == alias){\n    32   \t\t\tmosquitto__free(mosq->aliases[i].topic);\n    33   \t\t\tmosq->aliases[i].topic = mosquitto__strdup(topic);\n    34   \t\t\tif(mosq->aliases[i].topic){\n    35   \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    36   \t\t\t}else{\n    37   \t\t\t\treturn MOSQ_ERR_NOMEM;\n    38   \t\t\t}\n    39   \t\t}\n    40   \t}\n    47   \tmosq->aliases[mosq->alias_count].alias = alias;\n    55   }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    164  \t/* The order of properties must be preserved for some types, so keep the\n    165  \t * same order for all */\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    172  \n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    175  \t\t\tmosquitto__free(p);\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    179  \n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    185  \t\ttail = p;\n    186  \n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__read\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:35\n    35   static int property__read(struct mosquitto__packet *packet, uint32_t *len, mosquitto_property *property)\n    36   {\n    38   \tuint32_t property_identifier;\n    39   \tuint8_t byte;\n    41   \tuint16_t uint16;\n    42   \tuint32_t uint32;\n    43   \tuint32_t varint;\n    44   \tchar *str1, *str2;\n    49   \trc = packet__read_varint(packet, &property_identifier, NULL);\n    50   \tif(rc){\n    51   \t\treturn rc;\n    52   \t}\n    57   \tproperty->identifier = (int32_t)property_identifier;\n    59   \tswitch(property_identifier){\n    60   \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    61   \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    62   \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    63   \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    64   \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    65   \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    66   \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    67   \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    68   \t\t\trc = packet__read_byte(packet, &byte);\n    69   \t\t\tif(rc) return rc;\n    71   \t\t\tproperty->value.i8 = byte;\n    72   \t\t\tbreak;\n    74   \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    75   \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    76   \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    77   \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    78   \t\t\trc = packet__read_uint16(packet, &uint16);\n    79   \t\t\tif(rc) return rc;\n    81   \t\t\tproperty->value.i16 = uint16;\n    82   \t\t\tbreak;\n    84   \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    85   \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    86   \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    87   \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    88   \t\t\trc = packet__read_uint32(packet, &uint32);\n    89   \t\t\tif(rc) return rc;\n    91   \t\t\tproperty->value.i32 = uint32;\n    92   \t\t\tbreak;\n    94   \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    95   \t\t\trc = packet__read_varint(packet, &varint, &byte_count);\n    96   \t\t\tif(rc) return rc;\n    98   \t\t\tproperty->value.varint = varint;\n    99   \t\t\tbreak;\n    101  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    102  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    103  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    104  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    105  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    106  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    107  \t\tcase MQTT_PROP_REASON_STRING:\n    108  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    109  \t\t\tif(rc) return rc;\n    111  \t\t\tproperty->value.s.v = str1;\n    112  \t\t\tproperty->value.s.len = slen1;\n    113  \t\t\tbreak;\n    115  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    116  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    117  \t\t\trc = packet__read_binary(packet, (uint8_t **)&str1, &slen1);\n    118  \t\t\tif(rc) return rc;\n    120  \t\t\tproperty->value.bin.v = str1;\n    121  \t\t\tproperty->value.bin.len = slen1;\n    122  \t\t\tbreak;\n    124  \t\tcase MQTT_PROP_USER_PROPERTY:\n    125  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    126  \t\t\tif(rc) return rc;\n    127  \t\t\t*len = (*len) - 2 - slen1; /* uint16, string len */\n    128  \n    129  \t\t\trc = packet__read_string(packet, &str2, &slen2);\n    130  \t\t\tif(rc){\n    131  \t\t\t\tmosquitto__free(str1);\n    132  \t\t\t\treturn rc;\n    133  \t\t\t}\n    134  \t\t\t*len = (*len) - 2 - slen2; /* uint16, string len */\n    135  \n    136  \t\t\tproperty->name.v = str1;\n    137  \t\t\tproperty->name.len = slen1;\n    138  \t\t\tproperty->value.s.v = str2;\n    139  \t\t\tproperty->value.s.len = slen2;\n    140  \t\t\tbreak;\n    142  \t\tdefault:\n    144  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property_identifier);\n    146  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    147  \t}\n    150  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: property__get_length_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:335\n    335  unsigned int property__get_length_all(const mosquitto_property *property)\n    336  {\n    337  \tconst mosquitto_property *p;\n    338  \tunsigned int len = 0;\n    341  \twhile(p){\n    342  \t\tlen += property__get_length(p);\n    343  \t\tp = p->next;\n    344  \t}\n    345  \treturn len;\n    346  }\nFunction: property__write_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:429\n    429  int property__write_all(struct mosquitto__packet *packet, const mosquitto_property *properties, bool write_len)\n    430  {\n    431  \tint rc;\n    432  \tconst mosquitto_property *p;\n    433  \n    434  \tif(write_len){\n    435  \t\trc = packet__write_varint(packet, property__get_length_all(properties));\n    436  \t\tif(rc) return rc;\n    437  \t}\n    438  \n    439  \tp = properties;\n    440  \twhile(p){\n    441  \t\trc = property__write(packet, p);\n    442  \t\tif(rc) return rc;\n    443  \t\tp = p->next;\n    444  \t}\n    445  \n    446  \treturn MOSQ_ERR_SUCCESS;\n    447  }\nFunction: property__write\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:361\n    361  static int property__write(struct mosquitto__packet *packet, const mosquitto_property *property)\n    362  {\n    363  \tint rc;\n    364  \n    365  \trc = packet__write_varint(packet, (uint32_t)property->identifier);\n    366  \tif(rc) return rc;\n    367  \n    368  \tswitch(property->identifier){\n    369  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    370  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    371  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    372  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    373  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    374  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    375  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    376  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    377  \t\t\tpacket__write_byte(packet, property->value.i8);\n    378  \t\t\tbreak;\n    379  \n    380  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    381  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    382  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    383  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    384  \t\t\tpacket__write_uint16(packet, property->value.i16);\n    385  \t\t\tbreak;\n    386  \n    387  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    388  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    389  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    390  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    391  \t\t\tpacket__write_uint32(packet, property->value.i32);\n    392  \t\t\tbreak;\n    393  \n    394  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    395  \t\t\treturn packet__write_varint(packet, property->value.varint);\n    396  \n    397  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    398  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    399  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    400  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    401  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    402  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    403  \t\tcase MQTT_PROP_REASON_STRING:\n    404  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    405  \t\t\tbreak;\n    406  \n    407  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    408  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    409  \t\t\tpacket__write_uint16(packet, property->value.bin.len);\n    410  \t\t\tpacket__write_bytes(packet, property->value.bin.v, property->value.bin.len);\n    411  \t\t\tbreak;\n    412  \n    413  \t\tcase MQTT_PROP_USER_PROPERTY:\n    414  \t\t\tpacket__write_string(packet, property->name.v, property->name.len);\n    415  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    416  \t\t\tbreak;\n    417  \n    418  \t\tdefault:\n    419  #ifdef WITH_BROKER\n    420  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property->identifier);\n    421  #endif\n    422  \t\t\treturn MOSQ_ERR_INVAL;\n    423  \t}\n    424  \n    425  \treturn MOSQ_ERR_SUCCESS;\n    426  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    280  \tmosquitto_property_free_all(&store->properties);\n    283  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    768  \tif(!stored->source_id){\n    770  \t\tdb__msg_store_free(stored);\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    786  \tif(message_expiry_interval > 0){\n    787  \t\tstored->message_expiry_time = db.now_real_s + message_expiry_interval;\n    788  \t}else{\n    789  \t\tstored->message_expiry_time = 0;\n    790  \t}\n    806  }\nFunction: handle__publish\nPath: /root/projects/mosquitto/src/handle_publish.c:36\n    36   int handle__publish(struct mosquitto *context)\n    37   {\n    38   \tuint8_t dup;\n    39   \tint rc = 0;\n    41   \tuint8_t header = context->in_packet.command;\n    42   \tint res = 0;\n    43   \tstruct mosquitto_msg_store *msg, *stored = NULL;\n    44   \tstruct mosquitto_client_msg *cmsg_stored = NULL;\n    48   \tmosquitto_property *properties = NULL;\n    49   \tmosquitto_property *p, *p_prev;\n    50   \tmosquitto_property *msg_properties_last;\n    51   \tuint32_t message_expiry_interval = 0;\n    52   \tint topic_alias = -1;\n    54   \tuint16_t mid = 0;\n    56   \tif(context->state != mosq_cs_active){\n    57   \t\treturn MOSQ_ERR_PROTOCOL;\n    58   \t}\n    60   \tmsg = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    65   \tdup = (header & 0x08)>>3;\n    66   \tmsg->qos = (header & 0x06)>>1;\n    67   \tif(dup == 1 && msg->qos == 0){\n    68   \t\tlog__printf(NULL, MOSQ_LOG_INFO,\n    69   \t\t\t\t\"Invalid PUBLISH (QoS=0 and DUP=1) from %s, disconnecting.\", context->id);\n    71   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    72   \t}\n    73   \tif(msg->qos == 3){\n    74   \t\tlog__printf(NULL, MOSQ_LOG_INFO,\n    75   \t\t\t\t\"Invalid QoS in PUBLISH from %s, disconnecting.\", context->id);\n    77   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    78   \t}\n    79   \tif(msg->qos > context->max_qos){\n    80   \t\tlog__printf(NULL, MOSQ_LOG_INFO,\n    81   \t\t\t\t\"Too high QoS in PUBLISH from %s, disconnecting.\", context->id);\n    83   \t\treturn MOSQ_ERR_QOS_NOT_SUPPORTED;\n    84   \t}\n    85   \tmsg->retain = (header & 0x01);\n    92   \tif(packet__read_string(&context->in_packet, &msg->topic, &slen)){\n    94   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    95   \t}\n    96   \tif(!slen && context->protocol != mosq_p_mqtt5){\n    99   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    100  \t}\n    102  \tif(msg->qos > 0){\n    103  \t\tif(packet__read_uint16(&context->in_packet, &mid)){\n    105  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    106  \t\t}\n    107  \t\tif(mid == 0){\n    109  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    110  \t\t}\n    113  \t\tmsg->source_mid = mid;\n    114  \t}\n    117  \tif(context->protocol == mosq_p_mqtt5){\n    118  \t\trc = property__read_all(CMD_PUBLISH, &context->in_packet, &properties);\n    119  \t\tif(rc){\n    121  \t\t\treturn rc;\n    122  \t\t}\n    124  \t\tp = properties;\n    125  \t\tp_prev = NULL;\n    126  \t\tmsg->properties = NULL;\n    127  \t\tmsg_properties_last = NULL;\n    128  \t\twhile(p){\n    129  \t\t\tswitch(p->identifier){\n    130  \t\t\t\tcase MQTT_PROP_CONTENT_TYPE:\n    131  \t\t\t\tcase MQTT_PROP_CORRELATION_DATA:\n    132  \t\t\t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    133  \t\t\t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    134  \t\t\t\tcase MQTT_PROP_USER_PROPERTY:\n    135  \t\t\t\t\tif(msg->properties){\n    136  \t\t\t\t\t\tmsg_properties_last->next = p;\n    137  \t\t\t\t\t\tmsg_properties_last = p;\n    138  \t\t\t\t\t}else{\n    139  \t\t\t\t\t\tmsg->properties = p;\n    140  \t\t\t\t\t\tmsg_properties_last = p;\n    141  \t\t\t\t\t}\n    142  \t\t\t\t\tif(p_prev){\n    143  \t\t\t\t\t\tp_prev->next = p->next;\n    144  \t\t\t\t\t\tp = p_prev->next;\n    145  \t\t\t\t\t}else{\n    146  \t\t\t\t\t\tproperties = p->next;\n    147  \t\t\t\t\t\tp = properties;\n    148  \t\t\t\t\t}\n    149  \t\t\t\t\tmsg_properties_last->next = NULL;\n    150  \t\t\t\t\tbreak;\n    152  \t\t\t\tcase MQTT_PROP_TOPIC_ALIAS:\n    153  \t\t\t\t\ttopic_alias = p->value.i16;\n    155  \t\t\t\t\tp = p->next;\n    156  \t\t\t\t\tbreak;\n    158  \t\t\t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    159  \t\t\t\t\tmessage_expiry_interval = p->value.i32;\n    161  \t\t\t\t\tp = p->next;\n    162  \t\t\t\t\tbreak;\n    164  \t\t\t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    166  \t\t\t\t\tp = p->next;\n    167  \t\t\t\t\tbreak;\n    169  \t\t\t\tdefault:\n    170  \t\t\t\t\tp = p->next;\n    171  \t\t\t\t\tbreak;\n    172  \t\t\t}\n    173  \t\t}\n    174  \t}\n    175  \tmosquitto_property_fr",
    "The Server MUST NOT send a Topic Alias in a PUBLISH packet to the Client greater than the Topic Alias Maximum value.": "Function: plugin__handle_message\nPath: /root/projects/mosquitto/src/plugin.c:130\n    130  int plugin__handle_message(struct mosquitto *context, struct mosquitto_msg_store *stored)\n    131  {\n    154  \tevent_data.qos = stored->qos;\n    155  \tevent_data.retain = stored->retain;\n    156  \tevent_data.properties = stored->properties;\n    172  \t\tif(stored->properties != event_data.properties){\n    173  \t\t\tmosquitto_property_free_all(&stored->properties);\n    174  \t\t\tstored->properties = event_data.properties;\n    182  \tstored->retain = event_data.retain;\n    185  }\nFunction: alias__add\nPath: /root/projects/mosquitto/src/../lib/alias_mosq.c:25\n    25   int alias__add(struct mosquitto *mosq, const char *topic, uint16_t alias)\n    26   {\n    27   \tint i;\n    30   \tfor(i=0; i<mosq->alias_count; i++){\n    31   \t\tif(mosq->aliases[i].alias == alias){\n    32   \t\t\tmosquitto__free(mosq->aliases[i].topic);\n    33   \t\t\tmosq->aliases[i].topic = mosquitto__strdup(topic);\n    34   \t\t\tif(mosq->aliases[i].topic){\n    35   \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    36   \t\t\t}else{\n    37   \t\t\t\treturn MOSQ_ERR_NOMEM;\n    38   \t\t\t}\n    39   \t\t}\n    40   \t}\n    47   \tmosq->aliases[mosq->alias_count].alias = alias;\n    55   }\nFunction: alias__find\nPath: /root/projects/mosquitto/src/../lib/alias_mosq.c:58\n    58   int alias__find(struct mosquitto *mosq, char **topic, uint16_t alias)\n    59   {\n    60   \tint i;\n    62   \tfor(i=0; i<mosq->alias_count; i++){\n    63   \t\tif(mosq->aliases[i].alias == alias){\n    64   \t\t\t*topic = mosquitto__strdup(mosq->aliases[i].topic);\n    65   \t\t\tif(*topic){\n    66   \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    67   \t\t\t}else{\n    68   \t\t\t\treturn MOSQ_ERR_NOMEM;\n    69   \t\t\t}\n    70   \t\t}\n    71   \t}\n    73   }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__read\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:35\n    35   static int property__read(struct mosquitto__packet *packet, uint32_t *len, mosquitto_property *property)\n    36   {\n    38   \tuint32_t property_identifier;\n    39   \tuint8_t byte;\n    41   \tuint16_t uint16;\n    42   \tuint32_t uint32;\n    43   \tuint32_t varint;\n    44   \tchar *str1, *str2;\n    49   \trc = packet__read_varint(packet, &property_identifier, NULL);\n    50   \tif(rc){\n    51   \t\treturn rc;\n    52   \t}\n    57   \tproperty->identifier = (int32_t)property_identifier;\n    59   \tswitch(property_identifier){\n    60   \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    61   \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    62   \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    63   \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    64   \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    65   \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    66   \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    67   \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    68   \t\t\trc = packet__read_byte(packet, &byte);\n    69   \t\t\tif(rc) return rc;\n    71   \t\t\tproperty->value.i8 = byte;\n    72   \t\t\tbreak;\n    74   \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    75   \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    76   \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    77   \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    78   \t\t\trc = packet__read_uint16(packet, &uint16);\n    79   \t\t\tif(rc) return rc;\n    80   \t\t\t*len -= 2; /* uint16 */\n    81   \t\t\tproperty->value.i16 = uint16;\n    82   \t\t\tbreak;\n    84   \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    85   \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    86   \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    87   \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    88   \t\t\trc = packet__read_uint32(packet, &uint32);\n    89   \t\t\tif(rc) return rc;\n    91   \t\t\tproperty->value.i32 = uint32;\n    92   \t\t\tbreak;\n    94   \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    95   \t\t\trc = packet__read_varint(packet, &varint, &byte_count);\n    96   \t\t\tif(rc) return rc;\n    98   \t\t\tproperty->value.varint = varint;\n    99   \t\t\tbreak;\n    101  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    102  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    103  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    104  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    105  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    106  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    107  \t\tcase MQTT_PROP_REASON_STRING:\n    108  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    109  \t\t\tif(rc) return rc;\n    111  \t\t\tproperty->value.s.v = str1;\n    112  \t\t\tproperty->value.s.len = slen1;\n    113  \t\t\tbreak;\n    115  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    116  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    117  \t\t\trc = packet__read_binary(packet, (uint8_t **)&str1, &slen1);\n    118  \t\t\tif(rc) return rc;\n    120  \t\t\tproperty->value.bin.v = str1;\n    121  \t\t\tproperty->value.bin.len = slen1;\n    122  \t\t\tbreak;\n    124  \t\tcase MQTT_PROP_USER_PROPERTY:\n    125  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    126  \t\t\tif(rc) return rc;\n    129  \t\t\trc = packet__read_string(packet, &str2, &slen2);\n    130  \t\t\tif(rc){\n    131  \t\t\t\tmosquitto__free(str1);\n    132  \t\t\t\treturn rc;\n    133  \t\t\t}\n    136  \t\t\tproperty->name.v = str1;\n    137  \t\t\tproperty->name.len = slen1;\n    138  \t\t\tproperty->value.s.v = str2;\n    139  \t\t\tproperty->value.s.len = slen2;\n    140  \t\t\tbreak;\n    142  \t\tdefault:\n    144  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property_identifier);\n    146  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    147  \t}\n    150  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: property__get_length_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:335\n    335  unsigned int property__get_length_all(const mosquitto_property *property)\n    336  {\n    337  \tconst mosquitto_property *p;\n    338  \tunsigned int len = 0;\n    341  \twhile(p){\n    342  \t\tlen += property__get_length(p);\n    343  \t\tp = p->next;\n    344  \t}\n    345  \treturn len;\n    346  }\nFunction: property__write_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:429\n    429  int property__write_all(struct mosquitto__packet *packet, const mosquitto_property *properties, bool write_len)\n    430  {\n    432  \tconst mosquitto_property *p;\n    440  \twhile(p){\n    441  \t\trc = property__write(packet, p);\n    442  \t\tif(rc) return rc;\n    443  \t\tp = p->next;\n    444  \t}\n    447  }\nFunction: property__write\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:361\n    361  static int property__write(struct mosquitto__packet *packet, const mosquitto_property *property)\n    362  {\n    368  \tswitch(property->identifier){\n    383  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    384  \t\t\tpacket__write_uint16(packet, property->value.i16);\n    394  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    395  \t\t\treturn packet__write_varint(packet, property->value.varint);\n    397  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    398  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    399  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    400  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    401  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    402  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    403  \t\tcase MQTT_PROP_REASON_STRING:\n    404  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    405  \t\t\tbreak;\n    407  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    408  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    409  \t\t\tpacket__write_uint16(packet, property->value.bin.len);\n    410  \t\t\tpacket__write_bytes(packet, property->value.bin.v, property->value.bin.len);\n    411  \t\t\tbreak;\n    413  \t\tcase MQTT_PROP_USER_PROPERTY:\n    414  \t\t\tpacket__write_string(packet, property->name.v, property->name.len);\n    415  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    416  \t\t\tbreak;\n    418  \t\tdefault:\n    422  \t\t\treturn MOSQ_ERR_INVAL;\n    423  \t}\n    426  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    280  \tmosquitto_property_free_all(&store->properties);\n    283  }\nFunction: db__message_remove_incoming\nPath: /root/projects/mosquitto/src/database.c:970\n    970  int db__message_remove_incoming(struct mosquitto* context, uint16_t mid)\n    971  {\n    978  \t\t\tif(tail->store->qos != 2){\n    987  }\nFunction: handle__publish\nPath: /root/projects/mosquitto/src/handle_publish.c:36\n    36   int handle__publish(struct mosquitto *context)\n    37   {\n    38   \tuint8_t dup;\n    39   \tint rc = 0;\n    41   \tuint8_t header = context->in_packet.command;\n    42   \tint res = 0;\n    43   \tstruct mosquitto_msg_store *msg, *stored = NULL;\n    44   \tstruct mosquitto_client_msg *cmsg_stored = NULL;\n    48   \tmosquitto_property *properties = NULL;\n    49   \tmosquitto_property *p, *p_prev;\n    50   \tmosquitto_property *msg_properties_last;\n    51   \tuint32_t message_expiry_interval = 0;\n    52   \tint topic_alias = -1;\n    54   \tuint16_t mid = 0;\n    56   \tif(context->state != mosq_cs_active){\n    57   \t\treturn MOSQ_ERR_PROTOCOL;\n    58   \t}\n    60   \tmsg = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    65   \tdup = (header & 0x08)>>3;\n    66   \tmsg->qos = (header & 0x06)>>1;\n    67   \tif(dup == 1 && msg->qos == 0){\n    68   \t\tlog__printf(NULL, MOSQ_LOG_INFO,\n    69   \t\t\t\t\"Invalid PUBLISH (QoS=0 and DUP=1) from %s, disconnecting.\", context->id);\n    71   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    72   \t}\n    73   \tif(msg->qos == 3){\n    74   \t\tlog__printf(NULL, MOSQ_LOG_INFO,\n    75   \t\t\t\t\"Invalid QoS in PUBLISH from %s, disconnecting.\", context->id);\n    77   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    78   \t}\n    79   \tif(msg->qos > context->max_qos){\n    80   \t\tlog__printf(NULL, MOSQ_LOG_INFO,\n    81   \t\t\t\t\"Too high QoS in PUBLISH from %s, disconnecting.\", context->id);\n    83   \t\treturn MOSQ_ERR_QOS_NOT_SUPPORTED;\n    84   \t}\n    85   \tmsg->retain = (header & 0x01);\n    87   \tif(msg->retain && db.config->retain_available == false){\n    89   \t\treturn MOSQ_ERR_RETAIN_NOT_SUPPORTED;\n    90   \t}\n    92   \tif(packet__read_string(&context->in_packet, &msg->topic, &slen)){\n    94   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    95   \t}\n    96   \tif(!slen && context->protocol != mosq_p_mqtt5){\n    99   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    100  \t}\n    102  \tif(msg->qos > 0){\n    103  \t\tif(packet__read_uint16(&context->in_packet, &mid)){\n    105  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    106  \t\t}\n    107  \t\tif(mid == 0){\n    109  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    110  \t\t}\n    113  \t\tmsg->source_mid = mid;\n    114  \t}\n    117  \tif(context->protocol == mosq_p_mqtt5){\n    118  \t\trc = property__read_all(CMD_PUBLISH, &context->in_packet, &properties);\n    119  \t\tif(rc){\n    121  \t\t\treturn rc;\n    122  \t\t}\n    124  \t\tp = properties;\n    125  \t\tp_prev = NULL;\n    126  \t\tmsg->properties = NULL;\n    127  \t\tmsg_properties_last = NULL;\n    128  \t\twhile(p){\n    129  \t\t\tswitch(p->identifier){\n    130  \t\t\t\tcase MQTT_PROP_CONTENT_TYPE:\n    131  \t\t\t\tcase MQTT_PROP_CORRELATION_DATA:\n    132  \t\t\t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    133  \t\t\t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    134  \t\t\t\tcase MQTT_PROP_USER_PROPERTY:\n    135  \t\t\t\t\tif(msg->properties){\n    136  \t\t\t\t\t\tmsg_properties_last->next = p;\n    138  \t\t\t\t\t}else{\n    139  \t\t\t\t\t\tmsg->properties = p;\n    141  \t\t\t\t\t}\n    142  \t\t\t\t\tif(p_prev){\n    143  \t\t\t\t\t\tp_prev->next = p->next;\n    144  \t\t\t\t\t\tp = p_prev->next;\n    145  \t\t\t\t\t}else{\n    146  \t\t\t\t\t\tproperties = p->next;\n    147  \t\t\t\t\t\tp = properties;\n    148  \t\t\t\t\t}\n    149  \t\t\t\t\tmsg_properties_last->next = NULL;\n    150  \t\t\t\t\tbreak;\n    152  \t\t\t\tcase MQTT_PROP_TOPIC_ALIAS:\n    153  \t\t\t\t\ttopic_alias = p->value.i16;\n    155  \t\t\t\t\tp = p->next;\n    156  \t\t\t\t\tbreak;\n    158  \t\t\t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    159  \t\t\t\t\tmessage_expiry_interval = p->value.i32;\n    161  \t\t\t\t\tp = p->next;\n    162  \t\t\t\t\tbreak;\n    164  \t\t\t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    166  \t\t\t\t\tp = p->next;\n    167  \t\t\t\t\tbreak;\n    169  \t\t\t\tdefault:\n    170  \t\t\t\t\tp = p->next;\n    171  \t\t\t\t\tbreak;\n    172  \t\t\t}\n    173  \t\t}\n    174  \t}\n    175  \tmosquitto_property_free_all(&properties);\n    177  \tif(topic_alias == 0 || (context->listener && topic_alias > context->listener->max_topic_alias)){\n    178  \t\tdb__msg_store_free(msg);\n    179  \t\treturn MOSQ_ERR_TOPIC_ALIAS_INVALID;\n    180  \t}else if(topic_alias > 0){\n    181  \t\tif(msg->topic){\n    182  \t\t\trc = alias__add(context, msg->topic, (uint16_t)topic_alias);\n    183  \t\t\tif(rc){\n    185  \t\t\t\treturn rc;\n    186  \t\t\t}\n    187  \t\t}else{\n    188  \t\t\trc = alias__find(context, &msg->topic, (uint16_t)topic_alias);\n    189  \t\t\tif(rc){\n    191  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    192  \t\t\t}\n    193  \t\t}\n    194  \t}\n    197  \trc = bridge__remap_topic_in(context, &msg->topic);\n    198  \tif(rc){\n    200  \t\treturn rc;\n    201  \t}\n    210  \tmsg->payloadlen = context->in_packet.remaining_length - context->in_packet.pos;\n    212  \tif(context->listener && context->listener->mount_point){\n    213  \t\tlen = strlen(context->listener->mount_point) + strlen(msg->topic) + 1;\n    214  \t\ttopic_mount = mosquitto__malloc(len+1);\n    215  \t\tif(!topic_mount){\n    217  \t\t\treturn MOSQ_ERR_NOMEM;\n    218  \t\t}\n    219  \t\tsnprintf(topic_mount, len, \"%s%s\", context->listener->mount_point, msg->topic);\n    220  \t\ttopic_mount[len] = '\\0';\n    223  \t\tmsg->topic = topic_mount;\n    224  \t}\n    226  \tif(msg->payloadlen){\n    227  \t\tif(db.config->message_size_limit && msg->payloadlen > db.config->message_size_limit){\n    228  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Dropped too large PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);\n    230  \t\t\tgoto process_bad_message;\n    231  \t\t}\n    233  \t\tif(msg->payload == NULL){\n    235  \t\t\treturn MOSQ_ERR_NOMEM;\n    236  \t\t}\n    240  \t\tif(packet__read_bytes(&context->in_packet, msg->payload, msg->payloadlen)){\n    242  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    243  \t\t}\n    244  \t}\n    247  \trc = mosquitto_acl_check(context, msg->topic, msg->payloadlen, msg->payload, msg->qos, msg->retain, MOSQ_ACL_WRITE);\n    248  \tif(rc == MOSQ_ERR_ACL_DENIED){\n    249  \t\tlog__printf(NULL, MOSQ_LOG_DEBUG,\n    251  \t\t\t\tcontext->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,\n    254  \t\tgoto process_bad_message;\n    255  \t}else if(rc != MOSQ_ERR_SUCCESS){\n    257  \t\treturn rc;\n    258  \t}\n    260  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Received PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);\n    262  \tif(!strncmp(msg->topic, \"$CONTROL/\", 9)){\n    264  \t\trc = control__process(context, msg);\n    266  \t\treturn rc;\n    269  \t\tgoto process_bad_message;\n    271  \t}\n    274  \t\trc = plugin__handle_message(context, msg);\n    275  \t\tif(rc == MOSQ_ERR_ACL_DENIED){\n    276  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG,\n    278  \t\t\t\t\tcontext->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,\n    282  \t\t\tgoto process_bad_message;\n    283  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    285  \t\t\treturn rc;\n    286  \t\t}\n    289  \tif(msg->qos > 0){\n    290  \t\tdb__message_store_find(context, msg->source_mid, &cmsg_stored);\n    291  \t}\n    293  \tif(cmsg_stored && cmsg_stored->store && msg->source_mid != 0 &&\n    294  \t\t\t(cmsg_stored->store->qos != msg->qos\n    295  \t\t\t || cmsg_stored->store->payloadlen != msg->payloadlen\n    296  \t\t\t || strcmp(cmsg_stored->store->topic, msg->topic)\n    297  \t\t\t || memcmp(cmsg_stored->store->payload, msg->payload, msg->payloadlen) )){\n    299  \t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Reused message ID %u from %s detected. Clearing from storage.\", msg->source_mid, context->id);\n    300  \t\tdb__message_remove_incoming(context, msg->source_mid);\n    301  \t\tcmsg_stored = NULL;\n    302  \t}\n    304  \tif(!cmsg_stored){\n    305  \t\tif(msg->qos == 0\n    306  \t\t\t\t|| db__ready_for_flight(context, mosq_md_in, msg->qos)\n    307  \t\t\t\t){\n    310  \t\t\trc = db__message_store(context, msg, message_expiry_interval, 0, mosq_mo_client);\n    311  \t\t\tif(rc) return rc;\n    312  \t\t}else{\n    315  \t\t\tgoto process_bad_message;\n    316  \t\t}\n    317  \t\tstored = msg;\n    320  \t}else{\n    323  \t\tstored = cmsg_stored->store;\n    324  \t\tcmsg_stored->dup++;\n    325  \t\tdup = cmsg_stored->dup;\n    326  \t}\n    328  \tswitch(stored->qos){\n    329  \t\tcase 0:\n    330  \t\t\trc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);\n    331  \t\t\tif(rc2 > 0) rc = 1;\n    332  \t\t\tbreak;\n    333  \t\tcase 1:\n    334  \t\t\tutil__decrement_receive_quota(context);\n    335  \t\t\trc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);\n    337  \t\t\tif(rc2 == MOSQ_ERR_SUCCESS || context->protocol != mosq_p_mqtt5){\n    338  \t\t\t\tif(send__puback(context, mid, 0, NULL)) rc = 1;\n    339  \t\t\t}else if(rc2 == MOSQ_ERR_NO_SUBSCRIBERS){\n    340  \t\t\t\tif(send__puback(context, mid, MQTT_RC_NO_MATCHING_SUBSCRIBERS, NULL)) rc = 1;\n    341  \t\t\t}else{\n    343  \t\t\t}\n    344  \t\t\tbreak;\n    345  \t\tcase 2:\n    346  \t\t\tif(dup == 0){\n    347  \t\t\t\tres = db__message_insert(context, stored->source_mid, mosq_md_in, stored->qos, stored->retain, stored, NULL, false);\n    348  \t\t\t}else{\n    355  \t\t\tif(!res){\n    356  \t\t\t\tif(dup == 0 || dup == 1){\n    357  \t\t\t\t\trc2 = send__pubrec(context, stored->source_mid, 0, NULL);\n    358  \t\t\t\t\tif(rc2) rc = rc2;\n    359  \t\t\t\t}else{\n    360  \t\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    361  \t\t\t\t}\n    362  \t\t\t}else if(res == 1){\n    364  \t\t\t}\n    365  \t\t\tbreak;\n    366  \t}\n    368  \tdb__message_write_queued_in(context);\n    371  \trc = 1;\n    372  \tif(msg){\n    373  \t\tswitch(msg->qos){\n    377  \t\t\tcase 1:\n    378  \t\t\t\trc = send__puback(context, msg->source_mid, reason_code, NULL);\n    379  \t\t\t\tbreak;\n    380  \t\t\tcase 2:\n    381  \t\t\t\trc = send__pubrec(context, msg->source_mid, reason_code, NULL);\n    382  \t\t\t\tbreak;\n    383  \t\t}\n    385  \t}\n    386  \tif(context->out_packet_count >= db.config->max_queued_messages){\n    388  \t}\n    390  }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\n",
    "If the RETAIN flag is set to 1 and the Payload contains zero bytes, the Payload is processed normally by the Server but any retained message with the same topic name MUST be removed and any future subscribers for the topic will not receive a retained message.": "Function: plugin__handle_message\nPath: /root/projects/mosquitto/src/plugin.c:130\n    130  int plugin__handle_message(struct mosquitto *context, struct mosquitto_msg_store *stored)\n    131  {\n    150  \tevent_data.client = context;\n    151  \tevent_data.topic = stored->topic;\n    152  \tevent_data.payloadlen = stored->payloadlen;\n    153  \tevent_data.payload = stored->payload;\n    154  \tevent_data.qos = stored->qos;\n    155  \tevent_data.retain = stored->retain;\n    156  \tevent_data.properties = stored->properties;\n    166  \t\tif(stored->payload != event_data.payload){\n    167  \t\t\tmosquitto__free(stored->payload);\n    168  \t\t\tstored->payload = event_data.payload;\n    169  \t\t\tstored->payloadlen = event_data.payloadlen;\n    182  \tstored->retain = event_data.retain;\n    185  }\nFunction: retain__store\nPath: /root/projects/mosquitto/src/retain.c:94\n    94   int retain__store(const char *topic, struct mosquitto_msg_store *stored, char **split_topics)\n    95   {\n    138  \tif(stored->payloadlen){\n    139  \t\tretainhier->retained = stored;\n    140  \t\tdb__msg_store_ref_inc(retainhier->retained);\n    141  #ifdef WITH_SYS_TREE\n    142  \t\tdb.retained_count++;\n    144  \t}else{\n    145  \t\tretainhier->retained = NULL;\n    146  \t\tretain__clean_empty_hierarchy(retainhier);\n    150  }\nFunction: packet__read_uint32\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:178\n    178  int packet__read_uint32(struct mosquitto__packet *packet, uint32_t *word)\n    179  {\n    180  \tuint32_t val = 0;\n    181  \tint i;\n    184  \tif(packet->pos+4 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    186  \tfor(i=0; i<4; i++){\n    187  \t\tval = (val << 8) + packet->payload[packet->pos];\n    188  \t\tpacket->pos++;\n    189  \t}\n    191  \t*word = val;\n    194  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    150  \tpacket->pos = 0;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    176  \tmosq->out_packet_count++;\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    237  \tif(mosq->out_packet && !mosq->current_out_packet){\n    243  \t\tmosq->out_packet_count--;\n    244  \t}\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    326  \t\tif(mosq->out_packet){\n    331  \t\t\tmosq->out_packet_count--;\n    332  \t\t}\n    345  \t}\n    353  }\nFunction: db__message_write_queued_in\nPath: /root/projects/mosquitto/src/database.c:1243\n    1243 int db__message_write_queued_in(struct mosquitto *context)\n    1244 {\n    1248 \tif(context->state != mosq_cs_active){\n    1249 \t\treturn MOSQ_ERR_SUCCESS;\n    1250 \t}\n    1269 }\nFunction: control__process\nPath: /root/projects/mosquitto/src/control.c:31\n    31   int control__process(struct mosquitto *context, struct mosquitto_msg_store *stored)\n    32   {\n    33   \tstruct mosquitto__callback *cb_found;\n    35   \tstruct mosquitto__security_options *opts;\n    39   \tif(db.config->per_listener_settings){\n    40   \t\topts = &context->listener->security_options;\n    41   \t}else{\n    42   \t\topts = &db.config->security_options;\n    43   \t}\n    44   \tHASH_FIND(hh, opts->plugin_callbacks.control, stored->topic, strlen(stored->topic), cb_found);\n    45   \tif(cb_found){\n    49   \t\tevent_data.payload = stored->payload;\n    50   \t\tevent_data.payloadlen = stored->payloadlen;\n    51   \t\tevent_data.qos = stored->qos;\n    52   \t\tevent_data.retain = stored->retain;\n    65   \t}\n    67   \tif(stored->qos == 1){\n    69   \t}else if(stored->qos == 2){\n    71   \t}\n    75   }\nFunction: db__ready_for_flight\nPath: /root/projects/mosquitto/src/database.c:38\n    38   bool db__ready_for_flight(struct mosquitto *context, enum mosquitto_msg_direction dir, int qos)\n    39   {\n    42   \tbool valid_count;\n    54   \tif(qos == 0){\n    60   \t\tif(db.config->max_queued_messages == 0 && db.config->max_inflight_bytes == 0){\n    61   \t\t\treturn true;\n    62   \t\t}\n    64   \t\tif(dir == mosq_md_out){\n    65   \t\t\tvalid_count = context->out_packet_count < db.config->max_queued_messages;\n    66   \t\t}else{\n    70   \t\tif(db.config->max_queued_messages == 0){\n    71   \t\t\treturn valid_bytes;\n    72   \t\t}\n    73   \t\tif(db.config->max_queued_bytes == 0){\n    74   \t\t\treturn valid_count;\n    75   \t\t}\n    76   \t}else{\n    80   \t\tif(msgs->inflight_maximum == 0){\n    81   \t\t\treturn valid_bytes;\n    82   \t\t}\n    83   \t\tif(db.config->max_inflight_bytes == 0){\n    84   \t\t\treturn valid_count;\n    85   \t\t}\n    86   \t}\n    88   \treturn valid_bytes && valid_count;\n    89   }\nFunction: db__msg_add_to_inflight_stats\nPath: /root/projects/mosquitto/src/database.c:141\n    141  void db__msg_add_to_inflight_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    142  {\n    144  \tmsg_data->inflight_bytes += msg->store->payloadlen;\n    145  \tif(msg->qos != 0){\n    147  \t\tmsg_data->inflight_bytes12 += msg->store->payloadlen;\n    148  \t}\n    149  }\nFunction: db__msg_add_to_queued_stats\nPath: /root/projects/mosquitto/src/database.c:162\n    162  void db__msg_add_to_queued_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    163  {\n    165  \tmsg_data->queued_bytes += msg->store->payloadlen;\n    166  \tif(msg->qos != 0){\n    168  \t\tmsg_data->queued_bytes12 += msg->store->payloadlen;\n    169  \t}\n    170  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    281  \tmosquitto__free(store->payload);\n    283  }\nFunction: db__message_write_inflight_out_latest\nPath: /root/projects/mosquitto/src/database.c:1198\n    1198 int db__message_write_inflight_out_latest(struct mosquitto *context)\n    1199 {\n    1203 \tif(context->state != mosq_cs_active\n    1204 \t\t\t|| context->sock == INVALID_SOCKET\n    1205 \t\t\t|| context->msgs_out.inflight == NULL){\n    1207 \t\treturn MOSQ_ERR_SUCCESS;\n    1208 \t}\n    1240 }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1097 \tuint32_t expiry_interval;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1176 \t}\n    1178 }\nFunction: db__msg_remove_from_inflight_stats\nPath: /root/projects/mosquitto/src/database.c:151\n    151  static void db__msg_remove_from_inflight_stats(struct mosquitto_msg_data *msg_data, struct mosquitto_client_msg *msg)\n    152  {\n    154  \tmsg_data->inflight_bytes -= msg->store->payloadlen;\n    155  \tif(msg->qos != 0){\n    157  \t\tmsg_data->inflight_bytes12 -= msg->store->payloadlen;\n    158  \t}\n    159  }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    450  \tenum mosquitto_msg_state state = mosq_ms_invalid;\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    503  \tif(context->sock != INVALID_SOCKET){\n    504  \t\tif(db__ready_for_flight(context, dir, qos)){\n    517  \t\t\t}else{\n    520  \t\t\t\t}else{\n    522  \t\t\t\t\treturn 1;\n    523  \t\t\t\t}\n    524  \t\t\t}\n    525  \t\t}else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){\n    528  \t\t}else{\n    538  \t\t\treturn 2;\n    539  \t\t}\n    540  \t}else{\n    541  \t\tif (db__ready_for_queue(context, qos, msg_data)){\n    543  \t\t}else{\n    552  \t\t\treturn 2;\n    553  \t\t}\n    554  \t}\n    579  \tmsg->retain = retain;\n    582  \tif(state == mosq_ms_queued){\n    584  \t\tdb__msg_add_to_queued_stats(msg_data, msg);\n    585  \t}else{\n    587  \t\tdb__msg_add_to_inflight_stats(msg_data, msg);\n    588  \t}\n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    599  \t\tif(dest_ids){\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_NOMEM;\n    608  \t\t}\n    609  \t}\n    625  \tif(dir == mosq_md_out && update){\n    626  \t\trc = db__message_write_inflight_out_latest(context);\n    627  \t\tif(rc) return rc;\n    628  \t\trc = db__message_write_queued_out(context);\n    629  \t\tif(rc) return rc;\n    630  \t}\n    633  }\nFunction: db__message_write_queued_out\nPath: /root/projects/mosquitto/src/database.c:1272\n    1272 int db__message_write_queued_out(struct mosquitto *context)\n    1273 {\n    1276 \tif(context->state != mosq_cs_active){\n    1277 \t\treturn MOSQ_ERR_SUCCESS;\n    1278 \t}\n    1299 }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    795  \tdb.msg_store_bytes += stored->payloadlen;\n    806  }\nFunction: db__message_remove_incoming\nPath: /root/projects/mosquitto/src/database.c:970\n    970  int db__message_remove_incoming(struct mosquitto* context, uint16_t mid)\n    971  {\n    978  \t\t\tif(tail->store->qos != 2){\n    987  }\nFunction: handle__publish\nPath: /root/projects/mosquitto/src/handle_publish.c:36\n    36   int handle__publish(struct mosquitto *context)\n    37   {\n    38   \tuint8_t dup;\n    39   \tint rc = 0;\n    41   \tuint8_t header = context->in_packet.command;\n    42   \tint res = 0;\n    43   \tstruct mosquitto_msg_store *msg, *stored = NULL;\n    44   \tstruct mosquitto_client_msg *cmsg_stored = NULL;\n    46   \tuint16_t slen;\n    48   \tmosquitto_property *properties = NULL;\n    49   \tmosquitto_property *p, *p_prev;\n    50   \tmosquitto_property *msg_properties_last;\n    51   \tuint32_t message_expiry_interval = 0;\n    52   \tint topic_alias = -1;\n    54   \tuint16_t mid = 0;\n    56   \tif(context->state != mosq_cs_active){\n    57   \t\treturn MOSQ_ERR_PROTOCOL;\n    58   \t}\n    60   \tmsg = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    65   \tdup = (header & 0x08)>>3;\n    66   \tmsg->qos = (header & 0x06)>>1;\n    67   \tif(dup == 1 && msg->qos == 0){\n    68   \t\tlog__printf(NULL, MOSQ_LOG_INFO,\n    69   \t\t\t\t\"Invalid PUBLISH (QoS=0 and DUP=1) from %s, disconnecting.\", context->id);\n    70   \t\tdb__msg_store_free(msg);\n    71   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    72   \t}\n    73   \tif(msg->qos == 3){\n    74   \t\tlog__printf(NULL, MOSQ_LOG_INFO,\n    75   \t\t\t\t\"Invalid QoS in PUBLISH from %s, disconnecting.\", context->id);\n    77   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    78   \t}\n    79   \tif(msg->qos > context->max_qos){\n    80   \t\tlog__printf(NULL, MOSQ_LOG_INFO,\n    81   \t\t\t\t\"Too high QoS in PUBLISH from %s, disconnecting.\", context->id);\n    83   \t\treturn MOSQ_ERR_QOS_NOT_SUPPORTED;\n    84   \t}\n    85   \tmsg->retain = (header & 0x01);\n    87   \tif(msg->retain && db.config->retain_available == false){\n    89   \t\treturn MOSQ_ERR_RETAIN_NOT_SUPPORTED;\n    90   \t}\n    92   \tif(packet__read_string(&context->in_packet, &msg->topic, &slen)){\n    94   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    95   \t}\n    96   \tif(!slen && context->protocol != mosq_p_mqtt5){\n    99   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    100  \t}\n    102  \tif(msg->qos > 0){\n    103  \t\tif(packet__read_uint16(&context->in_packet, &mid)){\n    105  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    106  \t\t}\n    107  \t\tif(mid == 0){\n    109  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    110  \t\t}\n    113  \t\tmsg->source_mid = mid;\n    114  \t}\n    117  \tif(context->protocol == mosq_p_mqtt5){\n    118  \t\trc = property__read_all(CMD_PUBLISH, &context->in_packet, &properties);\n    119  \t\tif(rc){\n    121  \t\t\treturn rc;\n    122  \t\t}\n    124  \t\tp = properties;\n    125  \t\tp_prev = NULL;\n    126  \t\tmsg->properties = NULL;\n    127  \t\tmsg_properties_last = NULL;\n    128  \t\twhile(p){\n    129  \t\t\tswitch(p->identifier){\n    130  \t\t\t\tcase MQTT_PROP_CONTENT_TYPE:\n    131  \t\t\t\tcase MQTT_PROP_CORRELATION_DATA:\n    132  \t\t\t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    133  \t\t\t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    134  \t\t\t\tcase MQTT_PROP_USER_PROPERTY:\n    135  \t\t\t\t\tif(msg->properties){\n    136  \t\t\t\t\t\tmsg_properties_last->next = p;\n    138  \t\t\t\t\t}else{\n    139  \t\t\t\t\t\tmsg->properties = p;\n    141  \t\t\t\t\t}\n    142  \t\t\t\t\tif(p_prev){\n    143  \t\t\t\t\t\tp_prev->next = p->next;\n    144  \t\t\t\t\t\tp = p_prev->next;\n    145  \t\t\t\t\t}else{\n    146  \t\t\t\t\t\tproperties = p->next;\n    147  \t\t\t\t\t\tp = properties;\n    148  \t\t\t\t\t}\n    149  \t\t\t\t\tmsg_properties_last->next = NULL;\n    150  \t\t\t\t\tbreak;\n    152  \t\t\t\tcase MQTT_PROP_TOPIC_ALIAS:\n    153  \t\t\t\t\ttopic_alias = p->value.i16;\n    155  \t\t\t\t\tp = p->next;\n    156  \t\t\t\t\tbreak;\n    158  \t\t\t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    159  \t\t\t\t\tmessage_expiry_interval = p->value.i32;\n    161  \t\t\t\t\tp = p->next;\n    162  \t\t\t\t\tbreak;\n    164  \t\t\t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    166  \t\t\t\t\tp = p->next;\n    167  \t\t\t\t\tbreak;\n    169  \t\t\t\tdefault:\n    170  \t\t\t\t\tp = p->next;\n    171  \t\t\t\t\tbreak;\n    172  \t\t\t}\n    173  \t\t}\n    174  \t}\n    175  \tmosquitto_property_free_all(&properties);\n    177  \tif(topic_alias == 0 || (context->listener && topic_alias > context->listener->max_topic_alias)){\n    179  \t\treturn MOSQ_ERR_TOPIC_ALIAS_INVALID;\n    180  \t}else if(topic_alias > 0){\n    181  \t\tif(msg->topic){\n    182  \t\t\trc = alias__add(context, msg->topic, (uint16_t)topic_alias);\n    183  \t\t\tif(rc){\n    185  \t\t\t\treturn rc;\n    186  \t\t\t}\n    187  \t\t}else{\n    188  \t\t\trc = alias__find(context, &msg->topic, (uint16_t)topic_alias);\n    189  \t\t\tif(rc){\n    191  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    192  \t\t\t}\n    193  \t\t}\n    194  \t}\n    197  \trc = bridge__remap_topic_in(context, &msg->topic);\n    198  \tif(rc){\n    200  \t\treturn rc;\n    201  \t}\n    210  \tmsg->payloadlen = context->in_packet.remaining_length - context->in_packet.pos;\n    211  \tG_PUB_BYTES_RECEIVED_INC(msg->payloadlen);\n    212  \tif(context->listener && context->listener->mount_point){\n    213  \t\tlen = strlen(context->listener->mount_point) + strlen(msg->topic) + 1;\n    214  \t\ttopic_mount = mosquitto__malloc(len+1);\n    215  \t\tif(!topic_mount){\n    217  \t\t\treturn MOSQ_ERR_NOMEM;\n    218  \t\t}\n    219  \t\tsnprintf(topic_mount, len, \"%s%s\", context->listener->mount_point, msg->topic);\n    220  \t\ttopic_mount[len] = '\\0';\n    223  \t\tmsg->topic = topic_mount;\n    224  \t}\n    226  \tif(msg->payloadlen){\n    227  \t\tif(db.config->message_size_limit && msg->payloadlen > db.config->message_size_limit){\n    228  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Dropped too large PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);\n    229  \t\t\treason_code = MQTT_RC_PACKET_TOO_LARGE;\n    230  \t\t\tgoto process_bad_message;\n    231  \t\t}\n    232  \t\tmsg->payload = mosquitto__malloc(msg->payloadlen+1);\n    233  \t\tif(msg->payload == NULL){\n    234  \t\t\tdb__msg_store_free(msg);\n    235  \t\t\treturn MOSQ_ERR_NOMEM;\n    236  \t\t}\n    237  \t\t/* Ensure payload is always zero terminated, this is the reason for the extra byte above */\n    238  \t\t((uint8_t *)msg->payload)[msg->payloadlen] = 0;\n    240  \t\tif(packet__read_bytes(&context->in_packet, msg->payload, msg->payloadlen)){\n    241  \t\t\tdb__msg_store_free(msg);\n    242  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    243  \t\t}\n    244  \t}\n    247  \trc = mosquitto_acl_check(context, msg->topic, msg->payloadlen, msg->payload, msg->qos, msg->retain, MOSQ_ACL_WRITE);\n    248  \tif(rc == MOSQ_ERR_ACL_DENIED){\n    249  \t\tlog__printf(NULL, MOSQ_LOG_DEBUG,\n    251  \t\t\t\tcontext->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,\n    252  \t\t\t\t(long)msg->payloadlen);\n    254  \t\tgoto process_bad_message;\n    255  \t}else if(rc != MOSQ_ERR_SUCCESS){\n    257  \t\treturn rc;\n    258  \t}\n    260  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Received PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);\n    262  \tif(!strncmp(msg->topic, \"$CONTROL/\", 9)){\n    264  \t\trc = control__process(context, msg);\n    266  \t\treturn rc;\n    269  \t\tgoto process_bad_message;\n    271  \t}\n    274  \t\trc = plugin__handle_message(context, msg);\n    275  \t\tif(rc == MOSQ_ERR_ACL_DENIED){\n    276  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG,\n    278  \t\t\t\t\tcontext->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,\n    279  \t\t\t\t\t(long)msg->payloadlen);\n    282  \t\t\tgoto process_bad_message;\n    283  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    285  \t\t\treturn rc;\n    286  \t\t}\n    289  \tif(msg->qos > 0){\n    290  \t\tdb__message_store_find(context, msg->source_mid, &cmsg_stored);\n    291  \t}\n    293  \tif(cmsg_stored && cmsg_stored->store && msg->source_mid != 0 &&\n    294  \t\t\t(cmsg_stored->store->qos != msg->qos\n    295  \t\t\t || cmsg_stored->store->payloadlen != msg->payloadlen\n    296  \t\t\t || strcmp(cmsg_stored->store->topic, msg->topic)\n    297  \t\t\t || memcmp(cmsg_stored->store->payload, msg->payload, msg->payloadlen) )){\n    299  \t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Reused message ID %u from %s detected. Clearing from storage.\", msg->source_mid, context->id);\n    300  \t\tdb__message_remove_incoming(context, msg->source_mid);\n    301  \t\tcmsg_stored = NULL;\n    302  \t}\n    304  \tif(!cmsg_stored){\n    305  \t\tif(msg->qos == 0\n    306  \t\t\t\t|| db__ready_for_flight(context, mosq_md_in, msg->qos)\n    307  \t\t\t\t){\n    310  \t\t\trc = db__message_store(context, msg, message_expiry_interval, 0, mosq_mo_client);\n    311  \t\t\tif(rc) return rc;\n    312  \t\t}else{\n    315  \t\t\tgoto process_bad_message;\n    316  \t\t}\n    317  \t\tstored = msg;\n    320  \t}else{\n    323  \t\tstored = cmsg_stored->store;\n    324  \t\tcmsg_stored->dup++;\n    325  \t\tdup = cmsg_stored->dup;\n    326  \t}\n    328  \tswitch(stored->qos){\n    329  \t\tcase 0:\n    330  \t\t\trc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);\n    331  \t\t\tif(rc2 > 0) rc = 1;\n    332  \t\t\tbreak;\n    333  \t\tcase 1:\n    334  \t\t\tutil__decrement_receive_quota(context);\n    335  \t\t\trc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);\n    337  \t\t\tif(rc2 == MOSQ_ERR_SUCCESS || context->protocol != mosq_p_mqtt5){\n    338  \t\t\t\tif(send__puback(context, mid, 0, NULL)) rc = 1;\n    339  \t\t\t}else if(rc2 == MOSQ_ERR_NO_SUBSCRIBERS){\n    340  \t\t\t\tif(send__puback(context, mid, MQTT_RC_NO_MATCHING_SUBSCRIBERS, NULL)) rc = 1;\n    341  \t\t\t}else{\n    343  \t\t\t}\n    344  \t\t\tbreak;\n    345  \t\tcase 2:\n    346  \t\t\tif(dup == 0){\n    347  \t\t\t\tres = db__message_insert(context, stored->source_mid, mosq_md_in, stored->qos, stored->retain, stored, NULL, false);\n    348  \t\t\t}else{\n    355  \t\t\tif(!res){\n    356  \t\t\t\tif(dup == 0 || dup == 1){\n    357  \t\t\t\t\trc2 = send__pubrec(context, stored->source_mid, 0, NULL);\n    358  \t\t\t\t\tif(rc2) rc = rc2;\n    359  \t\t\t\t}else{\n    360  \t\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    361  \t\t\t\t}\n    362  \t\t\t}else if(res == 1){\n    364  \t\t\t}\n    365  \t\t\tbreak;\n    366  \t}\n    368  \tdb__message_write_queued_in(context);\n    371  \trc = 1;\n    372  \tif(msg){\n    373  \t\tswitch(msg->qos){\n    377  \t\t\tcase 1:\n    378  \t\t\t\trc = send__puback(context, msg->source_mid, reason_code, NULL);\n    379  \t\t\t\tbreak;\n    380  \t\t\tcase 2:\n    381  \t\t\t\trc = send__pubrec(context, msg->source_mid, reason_code, NULL);\n    382  \t\t\t\tbreak;\n    383  \t\t}\n    385  \t}\n    386  \tif(context->out_packet_count >= db.config->max_queued_messages){\n    388  \t}\n    390  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    73   \tassert(packet);\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos",
    "If a CONNECT packet is received with Clean Start set to 0 and there is no Session associated with the Client Identifier, the Server MUST create a new Session [MQTT-3.1.2-6].": "Function: context__remove_from_by_id\nPath: /root/projects/mosquitto/src/context.c:302\n    302  void context__remove_from_by_id(struct mosquitto *context)\n    303  {\n    304  \tstruct mosquitto *context_found;\n    306  \tif(context->in_by_id == true && context->id){\n    307  \t\tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), context_found);\n    308  \t\tif(context_found){\n    309  \t\t\tHASH_DELETE(hh_id, db.contexts_by_id, context_found);\n    310  \t\t}\n    312  \t}\n    313  }\nFunction: packet__read_varint\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:206\n    206  int packet__read_varint(struct mosquitto__packet *packet, uint32_t *word, uint8_t *bytes)\n    207  {\n    208  \tint i;\n    211  \tuint32_t lword = 0;\n    212  \tuint8_t lbytes = 0;\n    214  \tfor(i=0; i<4; i++){\n    215  \t\tif(packet->pos < packet->remaining_length){\n    216  \t\t\tlbytes++;\n    217  \t\t\tbyte = packet->payload[packet->pos];\n    218  \t\t\tlword += (byte & 127) * remaining_mult;\n    220  \t\t\tpacket->pos++;\n    221  \t\t\tif((byte & 128) == 0){\n    222  \t\t\t\tif(lbytes > 1 && byte == 0){\n    224  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    225  \t\t\t\t}else{\n    226  \t\t\t\t\t*word = lword;\n    228  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    229  \t\t\t\t}\n    230  \t\t\t}\n    231  \t\t}else{\n    232  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    233  \t\t}\n    234  \t}\n    236  }\nFunction: packet__cleanup\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:89\n    89   void packet__cleanup(struct mosquitto__packet *packet)\n    90   {\n    94   \tpacket->command = 0;\n    97   \tpacket->remaining_length = 0;\n    101  \tpacket->pos = 0;\n    102  }\nFunction: packet__queue\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:142\n    142  int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n    143  {\n    150  \tpacket->pos = 0;\n    157  \tif(db.config->max_queued_messages > 0 && mosq->out_packet_count >= db.config->max_queued_messages){\n    159  \t\tif(mosq->is_dropping == false){\n    161  \t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n    163  \t\t\t\t\tmosq->id);\n    164  \t\t}\n    166  \t\treturn MOSQ_ERR_SUCCESS;\n    167  \t}\n    208  }\nFunction: packet__write\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:226\n    226  int packet__write(struct mosquitto *mosq)\n    227  {\n    259  \twhile(mosq->current_out_packet){\n    260  \t\tpacket = mosq->current_out_packet;\n    262  \t\twhile(packet->to_process > 0){\n    263  \t\t\twrite_length = net__write(mosq, &(packet->payload[packet->pos]), packet->to_process);\n    264  \t\t\tif(write_length > 0){\n    265  \t\t\t\tG_BYTES_SENT_INC(write_length);\n    266  \t\t\t\tpacket->to_process -= (uint32_t)write_length;\n    267  \t\t\t\tpacket->pos += (uint32_t)write_length;\n    268  \t\t\t}else{\n    276  \t\t\t\t\t\t){\n    278  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    279  \t\t\t\t}else{\n    281  \t\t\t\t\tswitch(errno){\n    282  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    283  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    284  \t\t\t\t\t\tcase COMPAT_EINTR:\n    285  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    286  \t\t\t\t\t\tcase EPROTO:\n    287  \t\t\t\t\t\t\treturn MOSQ_ERR_TLS;\n    288  \t\t\t\t\t\tdefault:\n    289  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    290  \t\t\t\t\t}\n    291  \t\t\t\t}\n    292  \t\t\t}\n    293  \t\t}\n    296  \t\tif(((packet->command)&0xF6) == CMD_PUBLISH){\n    317  \t\t\treturn MOSQ_ERR_SUCCESS;\n    319  \t\t}else if(((packet->command)&0xF0) == CMD_PUBLISH){\n    321  \t\t}\n    339  \t\tmosq->next_msg_out = db.now_s + mosq->keepalive;\n    345  \t}\n    353  }\nFunction: connect__on_authorised\nPath: /root/projects/mosquitto/src/handle_connect.c:109\n    109  int connect__on_authorised(struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)\n    110  {\n    111  \tstruct mosquitto *found_context;\n    112  \tstruct mosquitto__subleaf *leaf;\n    113  \tmosquitto_property *connack_props = NULL;\n    121  \tHASH_FIND(hh_id, db.contexts_by_id, context->id, strlen(context->id), found_context);\n    122  \tif(found_context){\n    124  \t\tif(found_context->sock == INVALID_SOCKET){\n    127  \t\t}else{\n    130  \t\t\tif(db.config->connection_messages == true){\n    131  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Client %s already connected, closing old connection.\", context->id);\n    132  \t\t\t}\n    133  \t\t}\n    135  \t\tif(context->clean_start == false && found_context->session_expiry_interval > 0){\n    136  \t\t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    137  \t\t\t\tconnect_ack |= 0x01;\n    138  \t\t\t}\n    140  \t\t\tif(found_context->msgs_in.inflight || found_context->msgs_in.queued\n    141  \t\t\t\t\t|| found_context->msgs_out.inflight || found_context->msgs_out.queued){\n    148  \t\t\t\tmemcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));\n    149  \t\t\t\tmemcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));\n    151  \t\t\t\tmemset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));\n    152  \t\t\t\tmemset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));\n    160  \t\t\t}\n    161  \t\t\tcontext->subs = found_context->subs;\n    162  \t\t\tfound_context->subs = NULL;\n    163  \t\t\tcontext->sub_count = found_context->sub_count;\n    164  \t\t\tfound_context->sub_count = 0;\n    165  \t\t\tcontext->last_mid = found_context->last_mid;\n    167  \t\t\tfor(i=0; i<context->sub_count; i++){\n    168  \t\t\t\tif(context->subs[i]){\n    169  \t\t\t\t\tleaf = context->subs[i]->hier->subs;\n    170  \t\t\t\t\twhile(leaf){\n    171  \t\t\t\t\t\tif(leaf->context == found_context){\n    172  \t\t\t\t\t\t\tleaf->context = context;\n    173  \t\t\t\t\t\t}\n    174  \t\t\t\t\t\tleaf = leaf->next;\n    175  \t\t\t\t\t}\n    177  \t\t\t\t\tif(context->subs[i]->shared){\n    178  \t\t\t\t\t\tleaf = context->subs[i]->shared->subs;\n    179  \t\t\t\t\t\twhile(leaf){\n    180  \t\t\t\t\t\t\tif(leaf->context == found_context){\n    181  \t\t\t\t\t\t\t\tleaf->context = context;\n    182  \t\t\t\t\t\t\t}\n    183  \t\t\t\t\t\t\tleaf = leaf->next;\n    184  \t\t\t\t\t\t}\n    185  \t\t\t\t\t}\n    186  \t\t\t\t}\n    187  \t\t\t}\n    188  \t\t}\n    190  \t\tif(context->clean_start == true){\n    191  \t\t\tsub__clean_session(found_context);\n    192  \t\t}\n    193  \t\tif((found_context->protocol == mosq_p_mqtt5 && found_context->session_expiry_interval == 0)\n    194  \t\t\t\t|| (found_context->protocol != mosq_p_mqtt5 && found_context->clean_start == true)\n    195  \t\t\t\t|| (context->clean_start == true)\n    196  \t\t\t\t){\n    198  \t\t\tcontext__send_will(found_context);\n    199  \t\t}\n    201  \t\tsession_expiry__remove(found_context);\n    202  \t\twill_delay__remove(found_context);\n    203  \t\twill__clear(found_context);\n    205  \t\tfound_context->clean_start = true;\n    206  \t\tfound_context->session_expiry_interval = 0;\n    207  \t\tmosquitto__set_state(found_context, mosq_cs_duplicate);\n    209  \t\tif(found_context->protocol == mosq_p_mqtt5){\n    210  \t\t\tsend__disconnect(found_context, MQTT_RC_SESSION_TAKEN_OVER, NULL);\n    211  \t\t}\n    212  \t\tdo_disconnect(found_context, MOSQ_ERR_SUCCESS);\n    213  \t}\n    221  \tif(db.config->connection_messages == true){\n    222  \t\tif(context->is_bridge){\n    223  \t\t\tif(context->username){\n    224  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    225  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    226  \t\t\t}else{\n    227  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New bridge connected from %s:%d as %s (p%d, c%d, k%d).\",\n    228  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    229  \t\t\t}\n    230  \t\t}else{\n    231  \t\t\tif(context->username){\n    232  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d, u'%s').\",\n    233  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive, context->username);\n    234  \t\t\t}else{\n    235  \t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"New client connected from %s:%d as %s (p%d, c%d, k%d).\",\n    236  \t\t\t\t\t\tcontext->address, context->remote_port, context->id, context->protocol, context->clean_start, context->keepalive);\n    237  \t\t\t}\n    238  \t\t}\n    250  \t}\n    260  \tcontext__add_to_by_id(context);\n    263  \tif(!context->clean_start){\n    269  \tif(db.config->max_keepalive &&\n    270  \t\t\t(context->keepalive > db.config->max_keepalive || context->keepalive == 0)){\n    272  \t\tcontext->keepalive = db.config->max_keepalive;\n    273  \t\tif(context->protocol == mosq_p_mqtt5){\n    274  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){\n    276  \t\t\t\tgoto error;\n    277  \t\t\t}\n    278  \t\t}else{\n    281  \t\t\tgoto error;\n    282  \t\t}\n    283  \t}\n    285  \tif(context->protocol == mosq_p_mqtt5){\n    286  \t\tif(context->listener->max_topic_alias > 0){\n    287  \t\t\tif(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){\n    289  \t\t\t\tgoto error;\n    290  \t\t\t}\n    291  \t\t}\n    292  \t\tif(context->assigned_id){\n    293  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){\n    295  \t\t\t\tgoto error;\n    296  \t\t\t}\n    297  \t\t}\n    298  \t\tif(context->auth_method){\n    299  \t\t\tif(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){\n    301  \t\t\t\tgoto error;\n    302  \t\t\t}\n    304  \t\t\tif(auth_data_out && auth_data_out_len > 0){\n    305  \t\t\t\tif(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){\n    307  \t\t\t\t\tgoto error;\n    308  \t\t\t\t}\n    309  \t\t\t}\n    310  \t\t}\n    311  \t}\n    330  }\nFunction: context__add_to_disused\nPath: /root/projects/mosquitto/src/context.c:244\n    244  void context__add_to_disused(struct mosquitto *context)\n    245  {\n    250  \tif(context->id){\n    252  \t\tmosquitto__free(context->id);\n    253  \t\tcontext->id = NULL;\n    254  \t}\n    258  }\nFunction: context__add_to_by_id\nPath: /root/projects/mosquitto/src/context.c:293\n    293  void context__add_to_by_id(struct mosquitto *context)\n    294  {\n    295  \tif(context->in_by_id == false){\n    297  \t\tHASH_ADD_KEYPTR(hh_id, db.contexts_by_id, context->id, strlen(context->id), context);\n    298  \t}\n    299  }\nFunction: db__messages_easy_queue\nPath: /root/projects/mosquitto/src/database.c:702\n    702  int db__messages_easy_queue(struct mosquitto *context, const char *topic, uint8_t qos, uint32_t payloadlen, const void *payload, int retain, uint32_t message_expiry_interval, mosquitto_property **properties)\n    703  {\n    705  \tconst char *source_id;\n    738  \tif(context && context->id){\n    739  \t\tsource_id = context->id;\n    740  \t}else{\n    755  \treturn sub__messages_queue(source_id, stored->topic, stored->qos, stored->retain, &stored);\n    756  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    430  \tchar protocol_name[7];\n    431  \tuint8_t protocol_version;\n    432  \tuint8_t connect_flags;\n    433  \tchar *client_id = NULL;\n    434  \tstruct mosquitto_message_all *will_struct = NULL;\n    437  \tchar *username = NULL, *password = NULL;\n    438  \tint rc;\n    439  \tuint16_t slen;\n    441  \tvoid *auth_data = NULL;\n    442  \tuint16_t auth_data_len = 0;\n    443  \tvoid *auth_data_out = NULL;\n    444  \tuint16_t auth_data_out_len = 0;\n    465  \tif(context->state != mosq_cs_new){\n    466  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad client %s sending multiple CONNECT messages.\", context->id);\n    468  \t\tgoto handle_connect_error;\n    469  \t}\n    474  \tif(packet__read_uint16(&context->in_packet, &slen)){\n    476  \t\tgoto handle_connect_error;\n    477  \t}\n    478  \tif(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){\n    480  \t\tgoto handle_connect_error;\n    481  \t}\n    482  \tif(packet__read_bytes(&context->in_packet, protocol_name, slen)){\n    484  \t\tgoto handle_connect_error;\n    485  \t}\n    486  \tprotocol_name[slen] = '\\0';\n    488  \tif(packet__read_byte(&context->in_packet, &protocol_version)){\n    490  \t\tgoto handle_connect_error;\n    491  \t}\n    492  \tif(!strcmp(protocol_name, PROTOCOL_NAME_v31)){\n    493  \t\tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31){\n    494  \t\t\tif(db.config->connection_messages == true){\n    495  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    496  \t\t\t\t\t\tprotocol_version, context->address);\n    497  \t\t\t}\n    498  \t\t\tsend__connack(context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);\n    500  \t\t\tgoto handle_connect_error;\n    501  \t\t}\n    503  \t\tif((protocol_version&0x80) == 0x80){\n    505  \t\t}\n    506  \t}else if(!strcmp(protocol_name, PROTOCOL_NAME)){\n    507  \t\tif((protocol_version&0x7F) == PROTOCOL_VERSION_v311){\n    510  \t\t\tif((protocol_version&0x80) == 0x80){\n    512  \t\t\t}\n    513  \t\t}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){\n    515  \t\t}else{\n    516  \t\t\tif(db.config->connection_messages == true){\n    517  \t\t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol version %d in CONNECT from %s.\",\n    518  \t\t\t\t\t\tprotocol_version, context->address);\n    519  \t\t\t}\n    522  \t\t\tgoto handle_connect_error;\n    523  \t\t}\n    524  \t\tif((context->in_packet.command&0x0F) != 0x00){\n    527  \t\t\tgoto handle_connect_error;\n    528  \t\t}\n    529  \t}else{\n    530  \t\tif(db.config->connection_messages == true){\n    531  \t\t\tlog__printf(NULL, MOSQ_LOG_INFO, \"Invalid protocol \\\"%s\\\" in CONNECT from %s.\",\n    532  \t\t\t\t\tprotocol_name, context->address);\n    533  \t\t}\n    535  \t\tgoto handle_connect_error;\n    536  \t}\n    537  \tif((protocol_version&0x7F) != PROTOCOL_VERSION_v31 && context->in_packet.command != CMD_CONNECT){\n    538  \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    539  \t}\n    541  \tif(packet__read_byte(&context->in_packet, &connect_flags)){\n    543  \t\tgoto handle_connect_error;\n    544  \t}\n    545  \tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    546  \t\tif((connect_flags & 0x01) != 0x00){\n    548  \t\t\tgoto handle_connect_error;\n    549  \t\t}\n    550  \t}\n    552  \tclean_start = (connect_flags & 0x02) >> 1;\n    553  \t/* session_expiry_interval will be overriden if the properties are read later */\n    554  \tif(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){\n    555  \t\t/* v3* has clean_start == false mean the session never expires */\n    556  \t\tcontext->session_expiry_interval = UINT32_MAX;\n    557  \t}else{\n    558  \t\tcontext->session_expiry_interval = 0;\n    559  \t}\n    560  \twill = connect_flags & 0x04;\n    561  \twill_qos = (connect_flags & 0x18) >> 3;\n    562  \tif(will_qos == 3){\n    566  \t\tgoto handle_connect_error;\n    567  \t}\n    568  \twill_retain = ((connect_flags & 0x20) == 0x20);\n    569  \tpassword_flag = connect_flags & 0x40;\n    570  \tusername_flag = connect_flags & 0x80;\n    572  \tif(will && will_retain && db.config->retain_available == false){\n    573  \t\tif(protocol_version == mosq_p_mqtt5){\n    575  \t\t}\n    577  \t\tgoto handle_connect_error;\n    578  \t}\n    580  \tif(packet__read_uint16(&context->in_packet, &(context->keepalive))){\n    582  \t\tgoto handle_connect_error;\n    583  \t}\n    585  \tif(protocol_version == PROTOCOL_VERSION_v5){\n    586  \t\trc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);\n    587  \t\tif(rc) goto handle_connect_error;\n    588  \t}\n    591  \tif(will && will_qos > context->listener->max_qos){\n    592  \t\tif(protocol_version == mosq_p_mqtt5){\n    594  \t\t}\n    596  \t\tgoto handle_connect_error;\n    597  \t}\n    605  \tif(packet__read_string(&context->in_packet, &client_id, &slen)){\n    607  \t\tgoto handle_connect_error;\n    608  \t}\n    610  \tif(slen == 0){\n    611  \t\tif(context->protocol == mosq_p_mqtt31){\n    614  \t\t\tgoto handle_connect_error;\n    615  \t\t}else{ /* mqtt311/mqtt5 */\n    616  \t\t\tmosquitto__free(client_id);\n    617  \t\t\tclient_id = NULL;\n    619  \t\t\tif(db.config->per_listener_settings){\n    620  \t\t\t\tallow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;\n    621  \t\t\t}else{\n    622  \t\t\t\tallow_zero_length_clientid = db.config->security_options.allow_zero_length_clientid;\n    623  \t\t\t}\n    624  \t\t\tif((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){\n    631  \t\t\t\tgoto handle_connect_error;\n    632  \t\t\t}else{\n    633  \t\t\t\tif(db.config->per_listener_settings){\n    634  \t\t\t\t\tclient_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);\n    635  \t\t\t\t}else{\n    636  \t\t\t\t\tclient_id = client_id_gen(&slen, db.config->security_options.auto_id_prefix, db.config->security_options.auto_id_prefix_len);\n    637  \t\t\t\t}\n    638  \t\t\t\tif(!client_id){\n    640  \t\t\t\t\tgoto handle_connect_error;\n    641  \t\t\t\t}\n    643  \t\t\t}\n    644  \t\t}\n    645  \t}\n    648  \tif(db.config->clientid_prefixes){\n    649  \t\tif(strncmp(db.config->clientid_prefixes, client_id, strlen(db.config->clientid_prefixes))){\n    656  \t\t\tgoto handle_connect_error;\n    657  \t\t}\n    658  \t}\n    660  \tif(will){\n    661  \t\trc = will__read(context, client_id, &will_struct, will_qos, will_retain);\n    662  \t\tif(rc) goto handle_connect_error;\n    663  \t}else{\n    664  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){\n    665  \t\t\tif(will_qos != 0 || will_retain != 0){\n    667  \t\t\t\tgoto handle_connect_error;\n    668  \t\t\t}\n    669  \t\t}\n    670  \t}\n    672  \tif(username_flag){\n    673  \t\trc = packet__read_string(&context->in_packet, &username, &slen);\n    674  \t\tif(rc == MOSQ_ERR_NOMEM){\n    676  \t\t\tgoto handle_connect_error;\n    677  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    678  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    681  \t\t\t}else{\n    683  \t\t\t\tgoto handle_connect_error;\n    684  \t\t\t}\n    685  \t\t}\n    686  \t}else{\n    687  \t\tif(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){\n    688  \t\t\tif(password_flag){\n    690  \t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Protocol error from %s: password without username, closing connection.\", client_id);\n    692  \t\t\t\tgoto handle_connect_error;\n    693  \t\t\t}\n    694  \t\t}\n    695  \t}\n    696  \tif(password_flag){\n    697  \t\trc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);\n    698  \t\tif(rc == MOSQ_ERR_NOMEM){\n    700  \t\t\tgoto handle_connect_error;\n    701  \t\t}else if(rc == MOSQ_ERR_MALFORMED_PACKET){\n    702  \t\t\tif(context->protocol == mosq_p_mqtt31){\n    704  \t\t\t}else{\n    706  \t\t\t\tgoto handle_connect_error;\n    707  \t\t\t}\n    708  \t\t}\n    709  \t}\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    720  \tcontext->id = client_id;\n    721  \tclient_id = NULL;\n    726  \t\tmosquitto__free(username);\n    727  \t\tusername = NULL;\n    728  \t\tmosquitto__free(password);\n    729  \t\tpassword = NULL;\n    863  \t\tcontext->username = username;\n    864  \t\tcontext->password = password;\n    865  \t\tusername = NULL; /* Avoid free() in error: below. */\n    866  \t\tpassword = NULL;\n    869  \tif(context->listener->use_username_as_clientid){\n    870  \t\tif(context->username){\n    871  \t\t\tmosquitto__free(context->id);\n    872  \t\t\tcontext->id = mosquitto__strdup(context->username);\n    873  \t\t\tif(!context->id){\n    875  \t\t\t\tgoto handle_connect_error;\n    876  \t\t\t}\n    877  \t\t}else{\n    884  \t\t\tgoto handle_connect_error;\n    885  \t\t}\n    886  \t}\n    887  \tcontext->clean_start = clean_start;\n    891  \tif(context->auth_method){\n    892  \t\trc = mosquitto_security_auth_start(context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);\n    895  \t\tif(rc == MOSQ_ERR_SUCCESS){\n    896  \t\t\treturn connect__on_authorised(context, auth_data_out, auth_data_out_len);\n    897  \t\t}else if(rc == MOSQ_ERR_AUTH_CONTINUE){\n    899  \t\t\trc = send__auth(context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);\n    901  \t\t\treturn rc;\n    902  \t\t}else{\n    906  \t\t\tif(rc == MOSQ_ERR_AUTH){\n    908  \t\t\t\tmosquitto__free(context->id);\n    909  \t\t\t\tcontext->id = NULL;\n    910  \t\t\t\tgoto handle_connect_error;\n    911  \t\t\t}else if(rc == MOSQ_ERR_NOT_SUPPORTED){\n    914  \t\t\t\tmosquitto__free(context->id);\n    915  \t\t\t\tcontext->id = NULL;\n    916  \t\t\t\tgoto handle_connect_error;\n    917  \t\t\t}else{\n    918  \t\t\t\tmosquitto__free(context->id);\n    919  \t\t\t\tcontext->id = NULL;\n    920  \t\t\t\tgoto handle_connect_error;\n    921  \t\t\t}\n    922  \t\t}\n    923  \t}else{\n    931  \t\t\tswitch(rc){\n    934  \t\t\t\tcase MOSQ_ERR_AUTH:\n    941  \t\t\t\t\tgoto handle_connect_error;\n    942  \t\t\t\t\tbreak;\n    943  \t\t\t\tdefault:\n    945  \t\t\t\t\tgoto handle_connect_error;\n    946  \t\t\t\t\tbreak;\n    947  \t\t\t}\n    949  \t\treturn connect__on_authorised(context, NULL, 0);\n    950  \t}\n    953  handle_connect_error:\n    956  \tmosquitto__free(client_id);\n    957  \tmosquitto__free(username);\n    958  \tmosquitto__free(password);\n    976  \tcontext->clean_start = true;\n    980  }\nFunction: client_id_gen\nPath: /root/projects/mosquitto/src/handle_connect.c:51\n    51   static char *client_id_gen(uint16_t *idlen, const char *auto_id_prefix, uint16_t auto_id_prefix_len)\n    52   {\n    55   \tint i;\n    56   \tint pos;\n    60   \t*idlen = (uint16_t)(auto_id_prefix_len + 36);\n    62   \tclient_id = (char *)mosquitto__calloc((size_t)(*idlen) + 1, sizeof(char));\n    63   \tif(!client_id){\n    64   \t\treturn NULL;\n    65   \t}\n    66   \tif(auto_id_prefix){\n    67   \t\tmemcpy(client_id, auto_id_prefix, auto_id_prefix_len);\n    68   \t}\n    71   \tfor(i=0; i<16; i++){\n    72   \t\tclient_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);\n    73   \t\tclient_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);\n    74   \t\tpos += 2;\n    75   \t\tif(pos == 8 || pos == 13 || pos == 18 || pos == 23){\n    76   \t\t\tclient_id[auto_id_prefix_len + pos] = '-';\n    77   \t\t\tpos++;\n    78   \t\t}\n    79   \t}\n    82   }\nFunction: will__read\nPath: /root/projects/mosquitto/src/handle_connect.c:333\n    333  static int will__read(struct mosquitto *context, const char *client_id, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)\n    334  {\n    343  \twill_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));\n    389  \tif(will_struct->msg.payloadlen > 0){\n    390  \t\tif(db.config->message_size_limit && will_struct->msg.payloadlen > (int)db.config->message_size_limit){\n    391  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Client %s connected with too large Will payload\", client_id);\n    398  \t\t\tgoto error_cleanup;\n    399  \t\t}\n    401  \t\tif(!will_struct->msg.payload){\n    403  \t\t\tgoto error_cleanup;\n    404  \t\t}\n    407  \t\tif(rc) goto error_cleanup;\n    408  \t}\n    424  }\nFunction: packet__read_byte\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:49\n    49   int packet__read_byte(struct mosquitto__packet *packet, uint8_t *byte)\n    50   {\n    52   \tif(packet->pos+1 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    54   \t*byte = packet->payload[packet->pos];\n    55   \tpacket->pos++;\n    58   }\nFunction: packet__read_bytes\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:71\n    71   int packet__read_bytes(struct mosquitto__packet *packet, void *bytes, uint32_t count)\n    72   {\n    74   \tif(packet->pos+count > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    76   \tmemcpy(bytes, &(packet->payload[packet->pos]), count);\n    77   \tpacket->pos += count;\n    80   }\nFunction: packet__read_binary\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:95\n    95   int packet__read_binary(struct mosquitto__packet *packet, uint8_t **data, uint16_t *length)\n    96   {\n    97   \tuint16_t slen;\n    100  \tassert(packet);\n    101  \trc = packet__read_uint16(packet, &slen);\n    102  \tif(rc) return rc;\n    104  \tif(slen == 0){\n    105  \t\t*data = NULL;\n    106  \t\t*length = 0;\n    107  \t\treturn MOSQ_ERR_SUCCESS;\n    108  \t}\n    110  \tif(packet->pos+slen > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    112  \t*data = mosquitto__malloc(slen+1U);\n    113  \tif(*data){\n    114  \t\tmemcpy(*data, &(packet->payload[packet->pos]), slen);\n    115  \t\t((uint8_t *)(*data))[slen] = '\\0';\n    116  \t\tpacket->pos += slen;\n    117  \t}else{\n    118  \t\treturn MOSQ_ERR_NOMEM;\n    119  \t}\n    121  \t*length = slen;\n    123  }\nFunction: packet__read_uint16\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:153\n    153  int packet__read_uint16(struct mosquitto__packet *packet, uint16_t *word)\n    154  {\n    158  \tif(packet->pos+2 > packet->remaining_length) return MOSQ_ERR_MALFORMED_PACKET;\n    160  \tmsb = packet->payload[packet->pos];\n    161  \tpacket->pos++;\n    162  \tlsb = packet->payload[packet->pos];\n    163  \tpacket->pos++;\n    165  \t*word = (uint16_t)((msb<<8) + lsb);\n    168  }\nFunction: packet__read_string\nPath: /root/projects/mosquitto/src/../lib/packet_datatypes.c:126\n    126  int packet__read_string(struct mosquitto__packet *packet, char **str, uint16_t *length)\n    127  {\n    130  \trc = packet__read_binary(packet, (uint8_t **)str, length);\n    131  \tif(rc) return rc;\n    132  \tif(*length == 0) return MOSQ_ERR_SUCCESS;\n    134  \tif(mosquitto_validate_utf8(*str, *length)){\n    135  \t\tmosquitto__free(*str);\n    136  \t\t*str = NULL;\n    137  \t\t*length = 0;\n    138  \t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    139  \t}\n    142  }\nFunction: do_disconnect\nPath: /root/projects/mosquitto/src/loop.c:277\n    277  void do_disconnect(struct mosquitto *context, int reason)\n    278  {\n    279  \tconst char *id;\n    316  \t\tif(db.config->connection_messages == true){\n    317  \t\t\tif(context->id){\n    318  \t\t\t\tid = context->id;\n    319  \t\t\t}else{\n    322  \t\t\tif(context->state != mosq_cs_disconnecting && context->state != mosq_cs_disconnect_with_will){\n    323  \t\t\t\tswitch(reason){\n    326  \t\t\t\t\tcase MOSQ_ERR_MALFORMED_PACKET:\n    327  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to malformed packet.\", id);\n    328  \t\t\t\t\t\tbreak;\n    329  \t\t\t\t\tcase MOSQ_ERR_PROTOCOL:\n    330  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to protocol error.\", id);\n    331  \t\t\t\t\t\tbreak;\n    332  \t\t\t\t\tcase MOSQ_ERR_CONN_LOST:\n    333  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s closed its connection.\", id);\n    334  \t\t\t\t\t\tbreak;\n    335  \t\t\t\t\tcase MOSQ_ERR_AUTH:\n    336  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected, not authorised.\", id);\n    337  \t\t\t\t\t\tbreak;\n    338  \t\t\t\t\tcase MOSQ_ERR_KEEPALIVE:\n    339  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s has exceeded timeout, disconnecting.\", id);\n    340  \t\t\t\t\t\tbreak;\n    341  \t\t\t\t\tcase MOSQ_ERR_OVERSIZE_PACKET:\n    342  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize packet.\", id);\n    343  \t\t\t\t\t\tbreak;\n    344  \t\t\t\t\tcase MOSQ_ERR_PAYLOAD_SIZE:\n    345  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to oversize payload.\", id);\n    346  \t\t\t\t\t\tbreak;\n    347  \t\t\t\t\tcase MOSQ_ERR_NOMEM:\n    348  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to out of memory.\", id);\n    349  \t\t\t\t\t\tbreak;\n    350  \t\t\t\t\tcase MOSQ_ERR_NOT_SUPPORTED:\n    351  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected due to using not allowed feature (QoS too high, retain not supported, or bad AUTH method).\", id);\n    352  \t\t\t\t\t\tbreak;\n    353  \t\t\t\t\tcase MOSQ_ERR_ADMINISTRATIVE_ACTION:\n    354  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    355  \t\t\t\t\t\tbreak;\n    356  \t\t\t\t\tcase MOSQ_ERR_ERRNO:\n    357  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected: %s.\", id, strerror(errno));\n    358  \t\t\t\t\t\tbreak;\n    359  \t\t\t\t\tdefault:\n    360  \t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Bad socket read/write on client %s: %s\", id, mosquitto_strerror(reason));\n    361  \t\t\t\t\t\tbreak;\n    362  \t\t\t\t}\n    363  \t\t\t}else{\n    364  \t\t\t\tif(reason == MOSQ_ERR_ADMINISTRATIVE_ACTION){\n    365  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s been disconnected by administrative action.\", id);\n    366  \t\t\t\t}else{\n    367  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Client %s disconnected.\", id);\n    368  \t\t\t\t}\n    369  \t\t\t}\n    370  \t\t}\n    374  }\nFunction: mosquitto__calloc\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:50\n    50   void *mosquitto__calloc(size_t nmemb, size_t size)\n    51   {\n    58   \tmem = calloc(nmemb, size);\n    61   \tif(mem){\n    62   \t\tmemcount += malloc_usable_size(mem);\n    66   \t}\n    70   }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    80   \tfree(mem);\n    81   }\nFunction: send__auth\nPath: /root/projects/mosquitto/src/send_auth.c:28\n    28   int send__auth(struct mosquitto *context, uint8_t reason_code, const void *auth_data, uint16_t auth_data_len)\n    29   {\n    38   \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending AUTH to %s (rc%d, %s)\", context->id, reason_code, context->auth_method);\n    81   }\nFunction: send__connack\nPath: /root/projects/mosquitto/src/send_connack.c:28\n    28   int send__connack(struct mosquitto *context, uint8_t ack, uint8_t reason_code, const mosquitto_property *properties)\n    29   {\n    40   \tif(context->id){\n    41   \t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending CONNACK to %s (%d, %d)\", context->id, ack, reason_code);\n    42   \t}else{\n    109  }\nFunction: send__disconnect\nPath: /root/projects/mosquitto/src/../lib/send_disconnect.c:37\n    37   int send__disconnect(struct mosquitto *mosq, uint8_t reason_code, const mosquitto_property *properties)\n    38   {\n    45   \tif(mosq->bridge){\n    46   \t\tlog__printf(mosq, MOSQ_LOG_DEBUG, \"Bridge %s sending DISCONNECT\", SAFE_PRINT(mosq->id));\n    47   \t}else\n    83   }\nFunction: send__pubrel\nPath: /root/projects/mosquitto/src/../lib/send_mosq.c:109\n    109  int send__pubrel(struct mosquitto *mosq, uint16_t mid, const mosquitto_property *properties)\n    112  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBREL to %s (m%d)\", SAFE_PRINT(mosq->id), mid);\n    118  }\nFunction: send__publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:42\n    42   int send__publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    43   {\n    47   \tint i;\n    49   \tbool match;\n    51   \tchar *mapped_topic = NULL;\n    78   \tif(mosq->bridge && mosq->bridge->topics && mosq->bridge->topic_remapping){\n    79   \t\tfor(i=0; i<mosq->bridge->topic_count; i++){\n    80   \t\t\tcur_topic = &mosq->bridge->topics[i];\n    81   \t\t\tif((cur_topic->direction == bd_both || cur_topic->direction == bd_out)\n    82   \t\t\t\t\t&& (cur_topic->remote_prefix || cur_topic->local_prefix)){\n    85   \t\t\t\trc = mosquitto_topic_matches_sub(cur_topic->local_topic, topic, &match);\n    86   \t\t\t\tif(rc){\n    87   \t\t\t\t\treturn rc;\n    88   \t\t\t\t}\n    89   \t\t\t\tif(match){\n    90   \t\t\t\t\tmapped_topic = mosquitto__strdup(topic);\n    91   \t\t\t\t\tif(!mapped_topic) return MOSQ_ERR_NOMEM;\n    92   \t\t\t\t\tif(cur_topic->local_prefix){\n    94   \t\t\t\t\t\tif(!strncmp(cur_topic->local_prefix, mapped_topic, strlen(cur_topic->local_prefix))){\n    95   \t\t\t\t\t\t\ttopic_temp = mosquitto__strdup(mapped_topic+strlen(cur_topic->local_prefix));\n    97   \t\t\t\t\t\t\tif(!topic_temp){\n    98   \t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    99   \t\t\t\t\t\t\t}\n    101  \t\t\t\t\t\t}\n    102  \t\t\t\t\t}\n    104  \t\t\t\t\tif(cur_topic->remote_prefix){\n    106  \t\t\t\t\t\tlen = strlen(mapped_topic) + strlen(cur_topic->remote_prefix)+1;\n    107  \t\t\t\t\t\ttopic_temp = mosquitto__malloc(len+1);\n    108  \t\t\t\t\t\tif(!topic_temp){\n    109  \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    110  \t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    111  \t\t\t\t\t\t}\n    112  \t\t\t\t\t\tsnprintf(topic_temp, len, \"%s%s\", cur_topic->remote_prefix, mapped_topic);\n    113  \t\t\t\t\t\ttopic_temp[len] = '\\0';\n    114  \t\t\t\t\t\tmosquitto__free(mapped_topic);\n    116  \t\t\t\t\t}\n    117  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, mapped_topic, (long)payloadlen);\n    119  \t\t\t\t\trc =  send__real_publish(mosq, mid, mapped_topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    120  \t\t\t\t\tmosquitto__free(mapped_topic);\n    121  \t\t\t\t\treturn rc;\n    122  \t\t\t\t}\n    123  \t\t\t}\n    124  \t\t}\n    125  \t}\n    127  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, topic, (long)payloadlen);\n    134  }\nFunction: send__real_publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:137\n    137  int send__real_publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    138  {\n    140  \tunsigned int packetlen;\n    141  \tunsigned int proplen = 0, varbytes;\n    143  \tmosquitto_property expiry_prop;\n    147  \tif(topic){\n    148  \t\tpacketlen = 2+(unsigned int)strlen(topic) + payloadlen;\n    149  \t}else{\n    150  \t\tpacketlen = 2 + payloadlen;\n    151  \t}\n    152  \tif(qos > 0) packetlen += 2; /* For message id */\n    153  \tif(mosq->protocol == mosq_p_mqtt5){\n    155  \t\tproplen += property__get_length_all(cmsg_props);\n    156  \t\tproplen += property__get_length_all(store_props);\n    157  \t\tif(expiry_interval > 0){\n    163  \t\t\tproplen += property__get_length_all(&expiry_prop);\n    164  \t\t}\n    166  \t\tvarbytes = packet__varint_bytes(proplen);\n    172  \t\t}else{\n    173  \t\t\tpacketlen += proplen + varbytes;\n    174  \t\t}\n    175  \t}\n    176  \tif(packet__check_oversize(mosq, packetlen)){\n    178  \t\tlog__printf(NULL, MOSQ_LOG_NOTICE, \"Dropping too large outgoing PUBLISH for %s (%d bytes)\", SAFE_PRINT(mosq->id), packetlen);\n    182  \t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    183  \t}\n    221  }\nFunction: mosquitto_validate_utf8\nPath: /root/projects/mosquitto/src/../lib/utf8_mosq.c:24\n    24   int mosquitto_validate_utf8(const char *str, int len)\n    25   {\n    26   \tint i;\n    27   \tint j;\n    28   \tint codelen;\n    29   \tint codepoint;\n    32   \tif(!str) return MOSQ_ERR_INVAL;\n    35   \tfor(i=0; i<len; i++){\n    36   \t\tif(ustr[i] == 0){\n    37   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    38   \t\t}else if(ustr[i] <= 0x7f){\n    40   \t\t\tcodepoint = ustr[i];\n    41   \t\t}else if((ustr[i] & 0xE0) == 0xC0){\n    43   \t\t\tif(ustr[i] == 0xC0 || ustr[i] == 0xC1){\n    45   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    46   \t\t\t}\n    48   \t\t\tcodepoint = (ustr[i] & 0x1F);\n    49   \t\t}else if((ustr[i] & 0xF0) == 0xE0){\n    52   \t\t\tcodepoint = (ustr[i] & 0x0F);\n    53   \t\t}else if((ustr[i] & 0xF8) == 0xF0){\n    55   \t\t\tif(ustr[i] > 0xF4){\n    57   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    58   \t\t\t}\n    60   \t\t\tcodepoint = (ustr[i] & 0x07);\n    61   \t\t}else{\n    63   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    64   \t\t}\n    67   \t\tif(i == len-codelen+1){\n    69   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    70   \t\t}\n    71   \t\tfor(j=0; j<codelen-1; j++){\n    72   \t\t\tif((ustr[++i] & 0xC0) != 0x80){\n    74   \t\t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    75   \t\t\t}\n    76   \t\t\tcodepoint = (codepoint<<6) | (ustr[i] & 0x3F);\n    77   \t\t}\n    80   \t\tif(codepoint >= 0xD800 && codepoint <= 0xDFFF){\n    81   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    82   \t\t}\n    88   \t\t *\t return MOSQ_ERR_MALFORMED_UTF8;\n    91   \t\tif(codelen == 3 && codepoint < 0x0800){\n    92   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    93   \t\t}else if(codelen == 4 && (codepoint < 0x10000 || codepoint > 0x10FFFF)){\n    94   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    95   \t\t}\n    98   \t\tif(codepoint >= 0xFDD0 && codepoint <= 0xFDEF){\n    99   \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    100  \t\t}\n    101  \t\tif((codepoint & 0xFFFF) == 0xFFFE || (codepoint & 0xFFFF) == 0xFFFF){\n    102  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    103  \t\t}\n    105  \t\tif(codepoint <= 0x001F || (codepoint >= 0x007F && codepoint <= 0x009F)){\n    106  \t\t\treturn MOSQ_ERR_MALFORMED_UTF8;\n    107  \t\t}\n    108  \t}\n    110  }\n",
    "A Protocol Error occurs if the Subscription Identifier has a value of 0.": "Function: plugin__handle_message\nPath: /root/projects/mosquitto/src/plugin.c:130\n    130  int plugin__handle_message(struct mosquitto *context, struct mosquitto_msg_store *stored)\n    131  {\n    156  \tevent_data.properties = stored->properties;\n    172  \t\tif(stored->properties != event_data.properties){\n    173  \t\t\tmosquitto_property_free_all(&stored->properties);\n    174  \t\t\tstored->properties = event_d",
    "If the value of Retain As Published subscription option is set to 0, the Server MUST set the RETAIN flag to 0 when forwarding an Application Message regardless of how the RETAIN flag was set in the received PUBLISH packet [MQTT-3.3.1-12].": "Function: plugin__handle_message\nPath: /root/projects/mosquitto/src/plugin.c:130\n    130  int plugin__handle_message(struct mosquitto *context, struct mosquitto_msg_store *stored)\n    131  {\n    154  \tevent_data.qos = stored->qos;\n    155  \tevent_data.retain = stored->retain;\n    182  \tstored->retai",
    "If the value of Retain As Published subscription option is set to 1, the Server MUST set the RETAIN flag equal to the RETAIN flag in the received PUBLISH packet [MQTT-3.3.1-13].": "Function: plugin__handle_message\nPath: /root/projects/mosquitto/src/plugin.c:130\n    130  int plugin__handle_message(struct mosquitto *context, struct mosquitto_msg_store *stored)\n    131  {\n    154  \tevent_data.qos = stored->qos;\n    155  \tevent_data.retain = stored->retain;\n    182  \tstored->retain = event_data.retain;\n    185  }\nFunction: db__message_write_inflight_out_single\nPath: /root/projects/mosquitto/src/database.c:1086\n    1086 static int db__message_write_inflight_out_single(struct mosquitto *context, struct mosquitto_client_msg *msg)\n    1087 {\n    1097 \tuint32_t expiry_interval;\n    1100 \tif(msg->store->message_expiry_time){\n    1101 \t\tif(db.now_real_s > msg->store->message_expiry_time){\n    1107 \t\t\treturn MOSQ_ERR_SUCCESS;\n    1108 \t\t}else{\n    1109 \t\t\texpiry_interval = (uint32_t)(msg->store->message_expiry_time - db.now_real_s);\n    1110 \t\t}\n    1111 \t}\n    1112 \tmid = msg->mid;\n    1113 \tretries = msg->dup;\n    1114 \tretain = msg->retain;\n    1115 \ttopic = msg->store->topic;\n    1116 \tqos = (uint8_t)msg->qos;\n    1117 \tpayloadlen = msg->store->payloadlen;\n    1118 \tpayload = msg->store->payload;\n    1119 \tcmsg_props = msg->properties;\n    1120 \tstore_props = msg->store->properties;\n    1122 \tswitch(msg->state){\n    1123 \t\tcase mosq_ms_publish_qos0:\n    1124 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1125 \t\t\tif(rc == MOSQ_ERR_SUCCESS || rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1127 \t\t\t}else{\n    1128 \t\t\t\treturn rc;\n    1129 \t\t\t}\n    1130 \t\t\tbreak;\n    1132 \t\tcase mosq_ms_publish_qos1:\n    1133 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1134 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1138 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1140 \t\t\t}else{\n    1141 \t\t\t\treturn rc;\n    1142 \t\t\t}\n    1143 \t\t\tbreak;\n    1145 \t\tcase mosq_ms_publish_qos2:\n    1146 \t\t\trc = send__publish(context, mid, topic, payloadlen, payload, qos, retain, retries, cmsg_props, store_props, expiry_interval);\n    1147 \t\t\tif(rc == MOSQ_ERR_SUCCESS){\n    1151 \t\t\t}else if(rc == MOSQ_ERR_OVERSIZE_PACKET){\n    1153 \t\t\t}else{\n    1154 \t\t\t\treturn rc;\n    1155 \t\t\t}\n    1156 \t\t\tbreak;\n    1158 \t\tcase mosq_ms_resend_pubrel:\n    1162 \t\t\t}else{\n    1163 \t\t\t\treturn rc;\n    1164 \t\t\t}\n    1165 \t\t\tbreak;\n    1176 \t}\n    1178 }\nFunction: db__message_insert\nPath: /root/projects/mosquitto/src/database.c:446\n    446  int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update)\n    447  {\n    472  \tif(context->protocol != mosq_p_mqtt5\n    473  \t\t\t&& db.config->allow_duplicate_messages == false\n    474  \t\t\t&& dir == mosq_md_out && retain == false && stored->dest_ids){\n    476  \t\tfor(i=0; i<stored->dest_id_count; i++){\n    477  \t\t\tif(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){\n    480  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    481  \t\t\t}\n    482  \t\t}\n    483  \t}\n    579  \tmsg->retain = retain;\n    590  \tif(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){\n    599  \t\tif(dest_ids){\n    603  \t\t\tif(!stored->dest_ids[stored->dest_id_count-1]){\n    604  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    605  \t\t\t}\n    606  \t\t}else{\n    607  \t\t\treturn MOSQ_ERR_N",
    "If the Topic Alias Maximum value is absent or zero, the Server MUST NOT send any Topic Aliases to the Client [MQTT-3.1.2-27].": "Function: plugin__handle_message\nPath: /root/projects/mosquitto/src/plugin.c:130\n    130  int plugin__handle_message(struct mosquitto *context, struct mosquitto_msg_store *stored)\n    131  {\n    154  \tevent_data.qos = stored->qos;\n    155  \tevent_data.retain = stored->retain;\n    156  \tevent_data.properties = stored->properties;\n    172  \t\tif(stored->properties != event_data.properties){\n    173  \t\t\tmosquitto_property_free_all(&stored->properties);\n    174  \t\t\tstored->properties = event_data.properties;\n    182  \tstored->retain = event_data.retain;\n    185  }\nFunction: alias__add\nPath: /root/projects/mosquitto/src/../lib/alias_mosq.c:25\n    25   int alias__add(struct mosquitto *mosq, const char *topic, uint16_t alias)\n    26   {\n    27   \tint i;\n    30   \tfor(i=0; i<mosq->alias_count; i++){\n    31   \t\tif(mosq->aliases[i].alias == alias){\n    32   \t\t\tmosquitto__free(mosq->aliases[i].topic);\n    33   \t\t\tmosq->aliases[i].topic = mosquitto__strdup(topic);\n    34   \t\t\tif(mosq->aliases[i].topic){\n    35   \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    36   \t\t\t}else{\n    37   \t\t\t\treturn MOSQ_ERR_NOMEM;\n    38   \t\t\t}\n    39   \t\t}\n    40   \t}\n    47   \tmosq->aliases[mosq->alias_count].alias = alias;\n    48   \tmosq->aliases[mosq->alias_count].topic = mosquitto__strdup(topic);\n    55   }\nFunction: alias__find\nPath: /root/projects/mosquitto/src/../lib/alias_mosq.c:58\n    58   int alias__find(struct mosquitto *mosq, char **topic, uint16_t alias)\n    59   {\n    60   \tint i;\n    62   \tfor(i=0; i<mosq->alias_count; i++){\n    63   \t\tif(mosq->aliases[i].alias == alias){\n    64   \t\t\t*topic = mosquitto__strdup(mosq->aliases[i].topic);\n    65   \t\t\tif(*topic){\n    66   \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    67   \t\t\t}else{\n    68   \t\t\t\treturn MOSQ_ERR_NOMEM;\n    69   \t\t\t}\n    70   \t\t}\n    71   \t}\n    73   }\nFunction: property__read_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:153\n    153  int property__read_all(int command, struct mosquitto__packet *packet, mosquitto_property **properties)\n    154  {\n    156  \tuint32_t proplen;\n    157  \tmosquitto_property *p, *tail = NULL;\n    159  \trc = packet__read_varint(packet, &proplen, NULL);\n    160  \tif(rc) return rc;\n    162  \t*properties = NULL;\n    166  \twhile(proplen > 0){\n    167  \t\tp = mosquitto__calloc(1, sizeof(mosquitto_property));\n    168  \t\tif(!p){\n    169  \t\t\tmosquitto_property_free_all(properties);\n    170  \t\t\treturn MOSQ_ERR_NOMEM;\n    171  \t\t}\n    173  \t\trc = property__read(packet, &proplen, p);\n    174  \t\tif(rc){\n    176  \t\t\tmosquitto_property_free_all(properties);\n    177  \t\t\treturn rc;\n    178  \t\t}\n    180  \t\tif(!(*properties)){\n    181  \t\t\t*properties = p;\n    182  \t\t}else{\n    183  \t\t\ttail->next = p;\n    184  \t\t}\n    187  \t}\n    189  \trc = mosquitto_property_check_all(command, *properties);\n    190  \tif(rc){\n    191  \t\tmosquitto_property_free_all(properties);\n    192  \t\treturn rc;\n    193  \t}\n    195  }\nFunction: mosquitto_property_free_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:249\n    249  void mosquitto_property_free_all(mosquitto_property **property)\n    250  {\n    251  \tmosquitto_property *p, *next;\n    253  \tif(!property) return;\n    255  \tp = *property;\n    256  \twhile(p){\n    257  \t\tnext = p->next;\n    258  \t\tproperty__free(&p);\n    259  \t\tp = next;\n    260  \t}\n    261  \t*property = NULL;\n    262  }\nFunction: property__read\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:35\n    35   static int property__read(struct mosquitto__packet *packet, uint32_t *len, mosquitto_property *property)\n    36   {\n    38   \tuint32_t property_identifier;\n    39   \tuint8_t byte;\n    41   \tuint16_t uint16;\n    42   \tuint32_t uint32;\n    43   \tuint32_t varint;\n    44   \tchar *str1, *str2;\n    47   \tif(!property) return MOSQ_ERR_INVAL;\n    49   \trc = packet__read_varint(packet, &property_identifier, NULL);\n    50   \tif(rc){\n    51   \t\treturn rc;\n    52   \t}\n    55   \tmemset(property, 0, sizeof(mosquitto_property));\n    57   \tproperty->identifier = (int32_t)property_identifier;\n    59   \tswitch(property_identifier){\n    60   \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    61   \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    62   \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    63   \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    64   \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    65   \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    66   \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    67   \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    68   \t\t\trc = packet__read_byte(packet, &byte);\n    69   \t\t\tif(rc) return rc;\n    71   \t\t\tproperty->value.i8 = byte;\n    72   \t\t\tbreak;\n    74   \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    75   \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    76   \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    77   \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    78   \t\t\trc = packet__read_uint16(packet, &uint16);\n    79   \t\t\tif(rc) return rc;\n    80   \t\t\t*len -= 2; /* uint16 */\n    81   \t\t\tproperty->value.i16 = uint16;\n    82   \t\t\tbreak;\n    84   \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    85   \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    86   \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    87   \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    88   \t\t\trc = packet__read_uint32(packet, &uint32);\n    89   \t\t\tif(rc) return rc;\n    91   \t\t\tproperty->value.i32 = uint32;\n    92   \t\t\tbreak;\n    94   \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    95   \t\t\trc = packet__read_varint(packet, &varint, &byte_count);\n    96   \t\t\tif(rc) return rc;\n    98   \t\t\tproperty->value.varint = varint;\n    99   \t\t\tbreak;\n    101  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    102  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    103  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    104  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    105  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    106  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    107  \t\tcase MQTT_PROP_REASON_STRING:\n    108  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    109  \t\t\tif(rc) return rc;\n    111  \t\t\tproperty->value.s.v = str1;\n    112  \t\t\tproperty->value.s.len = slen1;\n    113  \t\t\tbreak;\n    115  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    116  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    117  \t\t\trc = packet__read_binary(packet, (uint8_t **)&str1, &slen1);\n    118  \t\t\tif(rc) return rc;\n    120  \t\t\tproperty->value.bin.v = str1;\n    121  \t\t\tproperty->value.bin.len = slen1;\n    122  \t\t\tbreak;\n    124  \t\tcase MQTT_PROP_USER_PROPERTY:\n    125  \t\t\trc = packet__read_string(packet, &str1, &slen1);\n    126  \t\t\tif(rc) return rc;\n    129  \t\t\trc = packet__read_string(packet, &str2, &slen2);\n    130  \t\t\tif(rc){\n    131  \t\t\t\tmosquitto__free(str1);\n    132  \t\t\t\treturn rc;\n    133  \t\t\t}\n    136  \t\t\tproperty->name.v = str1;\n    137  \t\t\tproperty->name.len = slen1;\n    138  \t\t\tproperty->value.s.v = str2;\n    139  \t\t\tproperty->value.s.len = slen2;\n    140  \t\t\tbreak;\n    142  \t\tdefault:\n    143  #ifdef WITH_BROKER\n    144  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property_identifier);\n    145  #endif\n    146  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    147  \t}\n    150  }\nFunction: mosquitto_property_check_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:930\n    930  int mosquitto_property_check_all(int command, const mosquitto_property *properties)\n    931  {\n    932  \tconst mosquitto_property *p, *tail;\n    937  \twhile(p){\n    939  \t\tif(p->identifier == MQTT_PROP_REQUEST_PROBLEM_INFORMATION\n    940  \t\t\t\t|| p->identifier == MQTT_PROP_PAYLOAD_FORMAT_INDICATOR\n    941  \t\t\t\t|| p->identifier == MQTT_PROP_REQUEST_RESPONSE_INFORMATION\n    942  \t\t\t\t|| p->identifier == MQTT_PROP_MAXIMUM_QOS\n    943  \t\t\t\t|| p->identifier == MQTT_PROP_RETAIN_AVAILABLE\n    944  \t\t\t\t|| p->identifier == MQTT_PROP_WILDCARD_SUB_AVAILABLE\n    945  \t\t\t\t|| p->identifier == MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE\n    946  \t\t\t\t|| p->identifier == MQTT_PROP_SHARED_SUB_AVAILABLE){\n    948  \t\t\tif(p->value.i8 > 1){\n    949  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    950  \t\t\t}\n    951  \t\t}else if(p->identifier == MQTT_PROP_MAXIMUM_PACKET_SIZE){\n    952  \t\t\tif( p->value.i32 == 0){\n    953  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    954  \t\t\t}\n    955  \t\t}else if(p->identifier == MQTT_PROP_RECEIVE_MAXIMUM\n    956  \t\t\t\t|| p->identifier == MQTT_PROP_TOPIC_ALIAS){\n    958  \t\t\tif(p->value.i16 == 0){\n    959  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    960  \t\t\t}\n    961  \t\t}else if(p->identifier == MQTT_PROP_RESPONSE_TOPIC){\n    962  \t\t\tif(mosquitto_pub_topic_check(p->value.s.v) != MOSQ_ERR_SUCCESS){\n    963  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    964  \t\t\t}\n    965  \t\t}\n    968  \t\trc = mosquitto_property_check_command(command, p->identifier);\n    969  \t\tif(rc) return rc;\n    972  \t\tif(p->identifier != MQTT_PROP_USER_PROPERTY){\n    973  \t\t\ttail = p->next;\n    974  \t\t\twhile(tail){\n    975  \t\t\t\tif(p->identifier == tail->identifier){\n    976  \t\t\t\t\treturn MOSQ_ERR_DUPLICATE_PROPERTY;\n    977  \t\t\t\t}\n    978  \t\t\t\ttail = tail->next;\n    979  \t\t\t}\n    980  \t\t}\n    982  \t\tp = p->next;\n    983  \t}\n    986  }\nFunction: mosquitto_property_check_command\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:450\n    450  int mosquitto_property_check_command(int command, int identifier)\n    451  {\n    452  \tswitch(identifier){\n    453  \t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    454  \t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    455  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    456  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    457  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    458  \t\t\tif(command != CMD_PUBLISH && command != CMD_WILL){\n    459  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    460  \t\t\t}\n    461  \t\t\tbreak;\n    463  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    464  \t\t\tif(command != CMD_PUBLISH && command != CMD_SUBSCRIBE){\n    465  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    466  \t\t\t}\n    467  \t\t\tbreak;\n    469  \t\tcase MQTT_PROP_SESSION_EXPIRY_INTERVAL:\n    470  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_DISCONNECT){\n    471  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    472  \t\t\t}\n    473  \t\t\tbreak;\n    475  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    476  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    477  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK && command != CMD_AUTH){\n    478  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    479  \t\t\t}\n    480  \t\t\tbreak;\n    482  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    483  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    484  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    485  \t\tcase MQTT_PROP_MAXIMUM_QOS:\n    486  \t\tcase MQTT_PROP_RETAIN_AVAILABLE:\n    487  \t\tcase MQTT_PROP_WILDCARD_SUB_AVAILABLE:\n    488  \t\tcase MQTT_PROP_SUBSCRIPTION_ID_AVAILABLE:\n    489  \t\tcase MQTT_PROP_SHARED_SUB_AVAILABLE:\n    490  \t\t\tif(command != CMD_CONNACK){\n    491  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    492  \t\t\t}\n    493  \t\t\tbreak;\n    495  \t\tcase MQTT_PROP_WILL_DELAY_INTERVAL:\n    496  \t\t\tif(command != CMD_WILL){\n    497  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    498  \t\t\t}\n    499  \t\t\tbreak;\n    501  \t\tcase MQTT_PROP_REQUEST_PROBLEM_INFORMATION:\n    502  \t\tcase MQTT_PROP_REQUEST_RESPONSE_INFORMATION:\n    503  \t\t\tif(command != CMD_CONNECT){\n    504  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    505  \t\t\t}\n    506  \t\t\tbreak;\n    508  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    509  \t\t\tif(command != CMD_CONNACK && command != CMD_DISCONNECT){\n    510  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    511  \t\t\t}\n    512  \t\t\tbreak;\n    514  \t\tcase MQTT_PROP_REASON_STRING:\n    515  \t\t\tif(command == CMD_CONNECT || command == CMD_PUBLISH || command == CMD_SUBSCRIBE || command == CMD_UNSUBSCRIBE){\n    516  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    517  \t\t\t}\n    518  \t\t\tbreak;\n    520  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    521  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    522  \t\tcase MQTT_PROP_MAXIMUM_PACKET_SIZE:\n    523  \t\t\tif(command != CMD_CONNECT && command != CMD_CONNACK){\n    524  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    525  \t\t\t}\n    526  \t\t\tbreak;\n    528  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    529  \t\t\tif(command != CMD_PUBLISH){\n    530  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    531  \t\t\t}\n    532  \t\t\tbreak;\n    537  \t\tdefault:\n    538  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    539  \t}\n    541  }\nFunction: property__free\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:198\n    198  void property__free(mosquitto_property **property)\n    199  {\n    200  \tif(!property || !(*property)) return;\n    202  \tswitch((*property)->identifier){\n    203  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    204  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    205  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    206  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    207  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    208  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    209  \t\tcase MQTT_PROP_REASON_STRING:\n    210  \t\t\tmosquitto__free((*property)->value.s.v);\n    211  \t\t\tbreak;\n    213  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    214  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    215  \t\t\tmosquitto__free((*property)->value.bin.v);\n    216  \t\t\tbreak;\n    218  \t\tcase MQTT_PROP_USER_PROPERTY:\n    219  \t\t\tmosquitto__free((*property)->name.v);\n    220  \t\t\tmosquitto__free((*property)->value.s.v);\n    221  \t\t\tbreak;\n    242  \t}\n    244  \tfree(*property);\n    245  \t*property = NULL;\n    246  }\nFunction: property__get_length_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:335\n    335  unsigned int property__get_length_all(const mosquitto_property *property)\n    336  {\n    337  \tconst mosquitto_property *p;\n    338  \tunsigned int len = 0;\n    341  \twhile(p){\n    342  \t\tlen += property__get_length(p);\n    343  \t\tp = p->next;\n    344  \t}\n    345  \treturn len;\n    346  }\nFunction: property__write_all\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:429\n    429  int property__write_all(struct mosquitto__packet *packet, const mosquitto_property *properties, bool write_len)\n    430  {\n    432  \tconst mosquitto_property *p;\n    440  \twhile(p){\n    441  \t\trc = property__write(packet, p);\n    442  \t\tif(rc) return rc;\n    443  \t\tp = p->next;\n    444  \t}\n    447  }\nFunction: property__write\nPath: /root/projects/mosquitto/src/../lib/property_mosq.c:361\n    361  static int property__write(struct mosquitto__packet *packet, const mosquitto_property *property)\n    362  {\n    365  \trc = packet__write_varint(packet, (uint32_t)property->identifier);\n    366  \tif(rc) return rc;\n    368  \tswitch(property->identifier){\n    380  \t\tcase MQTT_PROP_SERVER_KEEP_ALIVE:\n    381  \t\tcase MQTT_PROP_RECEIVE_MAXIMUM:\n    382  \t\tcase MQTT_PROP_TOPIC_ALIAS_MAXIMUM:\n    383  \t\tcase MQTT_PROP_TOPIC_ALIAS:\n    384  \t\t\tpacket__write_uint16(packet, property->value.i16);\n    385  \t\t\tbreak;\n    394  \t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    395  \t\t\treturn packet__write_varint(packet, property->value.varint);\n    397  \t\tcase MQTT_PROP_CONTENT_TYPE:\n    398  \t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    399  \t\tcase MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER:\n    400  \t\tcase MQTT_PROP_AUTHENTICATION_METHOD:\n    401  \t\tcase MQTT_PROP_RESPONSE_INFORMATION:\n    402  \t\tcase MQTT_PROP_SERVER_REFERENCE:\n    403  \t\tcase MQTT_PROP_REASON_STRING:\n    404  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    405  \t\t\tbreak;\n    407  \t\tcase MQTT_PROP_AUTHENTICATION_DATA:\n    408  \t\tcase MQTT_PROP_CORRELATION_DATA:\n    409  \t\t\tpacket__write_uint16(packet, property->value.bin.len);\n    410  \t\t\tpacket__write_bytes(packet, property->value.bin.v, property->value.bin.len);\n    411  \t\t\tbreak;\n    413  \t\tcase MQTT_PROP_USER_PROPERTY:\n    414  \t\t\tpacket__write_string(packet, property->name.v, property->name.len);\n    415  \t\t\tpacket__write_string(packet, property->value.s.v, property->value.s.len);\n    416  \t\t\tbreak;\n    418  \t\tdefault:\n    419  #ifdef WITH_BROKER\n    420  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Unsupported property type: %d\", property->identifier);\n    421  #endif\n    422  \t\t\treturn MOSQ_ERR_INVAL;\n    423  \t}\n    426  }\nFunction: db__msg_store_free\nPath: /root/projects/mosquitto/src/database.c:267\n    267  void db__msg_store_free(struct mosquitto_msg_store *store)\n    268  {\n    279  \tmosquitto__free(store->topic);\n    280  \tmosquitto_property_free_all(&store->properties);\n    283  }\nFunction: db__message_store\nPath: /root/projects/mosquitto/src/database.c:759\n    759  int db__message_store(const struct mosquitto *source, struct mosquitto_msg_store *stored, uint32_t message_expiry_interval, dbid_t store_id, enum mosquitto_msg_origin origin)\n    760  {\n    768  \tif(!stored->source_id){\n    770  \t\tdb__msg_store_free(stored);\n    771  \t\treturn MOSQ_ERR_NOMEM;\n    772  \t}\n    786  \tif(message_expiry_interval > 0){\n    787  \t\tstored->message_expiry_time = db.now_real_s + message_expiry_interval;\n    788  \t}else{\n    789  \t\tstored->message_expiry_time = 0;\n    790  \t}\n    806  }\nFunction: db__message_remove_incoming\nPath: /root/projects/mosquitto/src/database.c:970\n    970  int db__message_remove_incoming(struct mosquitto* context, uint16_t mid)\n    971  {\n    978  \t\t\tif(tail->store->qos != 2){\n    987  }\nFunction: handle__publish\nPath: /root/projects/mosquitto/src/handle_publish.c:36\n    36   int handle__publish(struct mosquitto *context)\n    37   {\n    38   \tuint8_t dup;\n    39   \tint rc = 0;\n    41   \tuint8_t header = context->in_packet.command;\n    42   \tint res = 0;\n    43   \tstruct mosquitto_msg_store *msg, *stored = NULL;\n    44   \tstruct mosquitto_client_msg *cmsg_stored = NULL;\n    48   \tmosquitto_property *properties = NULL;\n    49   \tmosquitto_property *p, *p_prev;\n    50   \tmosquitto_property *msg_properties_last;\n    51   \tuint32_t message_expiry_interval = 0;\n    52   \tint topic_alias = -1;\n    54   \tuint16_t mid = 0;\n    56   \tif(context->state != mosq_cs_active){\n    57   \t\treturn MOSQ_ERR_PROTOCOL;\n    58   \t}\n    60   \tmsg = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store));\n    65   \tdup = (header & 0x08)>>3;\n    66   \tmsg->qos = (header & 0x06)>>1;\n    67   \tif(dup == 1 && msg->qos == 0){\n    68   \t\tlog__printf(NULL, MOSQ_LOG_INFO,\n    69   \t\t\t\t\"Invalid PUBLISH (QoS=0 and DUP=1) from %s, disconnecting.\", context->id);\n    71   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    72   \t}\n    73   \tif(msg->qos == 3){\n    74   \t\tlog__printf(NULL, MOSQ_LOG_INFO,\n    75   \t\t\t\t\"Invalid QoS in PUBLISH from %s, disconnecting.\", context->id);\n    77   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    78   \t}\n    79   \tif(msg->qos > context->max_qos){\n    80   \t\tlog__printf(NULL, MOSQ_LOG_INFO,\n    81   \t\t\t\t\"Too high QoS in PUBLISH from %s, disconnecting.\", context->id);\n    83   \t\treturn MOSQ_ERR_QOS_NOT_SUPPORTED;\n    84   \t}\n    85   \tmsg->retain = (header & 0x01);\n    87   \tif(msg->retain && db.config->retain_available == false){\n    89   \t\treturn MOSQ_ERR_RETAIN_NOT_SUPPORTED;\n    90   \t}\n    92   \tif(packet__read_string(&context->in_packet, &msg->topic, &slen)){\n    94   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    95   \t}\n    96   \tif(!slen && context->protocol != mosq_p_mqtt5){\n    99   \t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    100  \t}\n    102  \tif(msg->qos > 0){\n    103  \t\tif(packet__read_uint16(&context->in_packet, &mid)){\n    105  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    106  \t\t}\n    107  \t\tif(mid == 0){\n    109  \t\t\treturn MOSQ_ERR_PROTOCOL;\n    110  \t\t}\n    113  \t\tmsg->source_mid = mid;\n    114  \t}\n    117  \tif(context->protocol == mosq_p_mqtt5){\n    118  \t\trc = property__read_all(CMD_PUBLISH, &context->in_packet, &properties);\n    119  \t\tif(rc){\n    121  \t\t\treturn rc;\n    122  \t\t}\n    124  \t\tp = properties;\n    125  \t\tp_prev = NULL;\n    126  \t\tmsg->properties = NULL;\n    127  \t\tmsg_properties_last = NULL;\n    128  \t\twhile(p){\n    129  \t\t\tswitch(p->identifier){\n    130  \t\t\t\tcase MQTT_PROP_CONTENT_TYPE:\n    131  \t\t\t\tcase MQTT_PROP_CORRELATION_DATA:\n    132  \t\t\t\tcase MQTT_PROP_PAYLOAD_FORMAT_INDICATOR:\n    133  \t\t\t\tcase MQTT_PROP_RESPONSE_TOPIC:\n    134  \t\t\t\tcase MQTT_PROP_USER_PROPERTY:\n    135  \t\t\t\t\tif(msg->properties){\n    136  \t\t\t\t\t\tmsg_properties_last->next = p;\n    138  \t\t\t\t\t}else{\n    139  \t\t\t\t\t\tmsg->properties = p;\n    141  \t\t\t\t\t}\n    142  \t\t\t\t\tif(p_prev){\n    143  \t\t\t\t\t\tp_prev->next = p->next;\n    144  \t\t\t\t\t\tp = p_prev->next;\n    145  \t\t\t\t\t}else{\n    146  \t\t\t\t\t\tproperties = p->next;\n    147  \t\t\t\t\t\tp = properties;\n    148  \t\t\t\t\t}\n    149  \t\t\t\t\tmsg_properties_last->next = NULL;\n    150  \t\t\t\t\tbreak;\n    152  \t\t\t\tcase MQTT_PROP_TOPIC_ALIAS:\n    153  \t\t\t\t\ttopic_alias = p->value.i16;\n    155  \t\t\t\t\tp = p->next;\n    156  \t\t\t\t\tbreak;\n    158  \t\t\t\tcase MQTT_PROP_MESSAGE_EXPIRY_INTERVAL:\n    159  \t\t\t\t\tmessage_expiry_interval = p->value.i32;\n    161  \t\t\t\t\tp = p->next;\n    162  \t\t\t\t\tbreak;\n    164  \t\t\t\tcase MQTT_PROP_SUBSCRIPTION_IDENTIFIER:\n    166  \t\t\t\t\tp = p->next;\n    167  \t\t\t\t\tbreak;\n    169  \t\t\t\tdefault:\n    170  \t\t\t\t\tp = p->next;\n    171  \t\t\t\t\tbreak;\n    172  \t\t\t}\n    173  \t\t}\n    174  \t}\n    175  \tmosquitto_property_free_all(&properties);\n    177  \tif(topic_alias == 0 || (context->listener && topic_alias > context->listener->max_topic_alias)){\n    178  \t\tdb__msg_store_free(msg);\n    179  \t\treturn MOSQ_ERR_TOPIC_ALIAS_INVALID;\n    180  \t}else if(topic_alias > 0){\n    181  \t\tif(msg->topic){\n    182  \t\t\trc = alias__add(context, msg->topic, (uint16_t)topic_alias);\n    183  \t\t\tif(rc){\n    184  \t\t\t\tdb__msg_store_free(msg);\n    185  \t\t\t\treturn rc;\n    186  \t\t\t}\n    187  \t\t}else{\n    188  \t\t\trc = alias__find(context, &msg->topic, (uint16_t)topic_alias);\n    189  \t\t\tif(rc){\n    190  \t\t\t\tdb__msg_store_free(msg);\n    191  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    192  \t\t\t}\n    193  \t\t}\n    194  \t}\n    196  #ifdef WITH_BRIDGE\n    197  \trc = bridge__remap_topic_in(context, &msg->topic);\n    198  \tif(rc){\n    200  \t\treturn rc;\n    201  \t}\n    203  #endif\n    210  \tmsg->payloadlen = context->in_packet.remaining_length - context->in_packet.pos;\n    212  \tif(context->listener && context->listener->mount_point){\n    213  \t\tlen = strlen(context->listener->mount_point) + strlen(msg->topic) + 1;\n    214  \t\ttopic_mount = mosquitto__malloc(len+1);\n    215  \t\tif(!topic_mount){\n    217  \t\t\treturn MOSQ_ERR_NOMEM;\n    218  \t\t}\n    219  \t\tsnprintf(topic_mount, len, \"%s%s\", context->listener->mount_point, msg->topic);\n    220  \t\ttopic_mount[len] = '\\0';\n    223  \t\tmsg->topic = topic_mount;\n    224  \t}\n    226  \tif(msg->payloadlen){\n    227  \t\tif(db.config->message_size_limit && msg->payloadlen > db.config->message_size_limit){\n    228  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Dropped too large PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);\n    230  \t\t\tgoto process_bad_message;\n    231  \t\t}\n    233  \t\tif(msg->payload == NULL){\n    235  \t\t\treturn MOSQ_ERR_NOMEM;\n    236  \t\t}\n    240  \t\tif(packet__read_bytes(&context->in_packet, msg->payload, msg->payloadlen)){\n    242  \t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    243  \t\t}\n    244  \t}\n    247  \trc = mosquitto_acl_check(context, msg->topic, msg->payloadlen, msg->payload, msg->qos, msg->retain, MOSQ_ACL_WRITE);\n    248  \tif(rc == MOSQ_ERR_ACL_DENIED){\n    249  \t\tlog__printf(NULL, MOSQ_LOG_DEBUG,\n    251  \t\t\t\tcontext->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,\n    254  \t\tgoto process_bad_message;\n    255  \t}else if(rc != MOSQ_ERR_SUCCESS){\n    257  \t\treturn rc;\n    258  \t}\n    260  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Received PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen);\n    262  \tif(!strncmp(msg->topic, \"$CONTROL/\", 9)){\n    263  #ifdef WITH_CONTROL\n    264  \t\trc = control__process(context, msg);\n    266  \t\treturn rc;\n    267  #else\n    269  \t\tgoto process_bad_message;\n    270  #endif\n    271  \t}\n    274  \t\trc = plugin__handle_message(context, msg);\n    275  \t\tif(rc == MOSQ_ERR_ACL_DENIED){\n    276  \t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG,\n    278  \t\t\t\t\tcontext->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic,\n    282  \t\t\tgoto process_bad_message;\n    283  \t\t}else if(rc != MOSQ_ERR_SUCCESS){\n    285  \t\t\treturn rc;\n    286  \t\t}\n    289  \tif(msg->qos > 0){\n    290  \t\tdb__message_store_find(context, msg->source_mid, &cmsg_stored);\n    291  \t}\n    293  \tif(cmsg_stored && cmsg_stored->store && msg->source_mid != 0 &&\n    294  \t\t\t(cmsg_stored->store->qos != msg->qos\n    295  \t\t\t || cmsg_stored->store->payloadlen != msg->payloadlen\n    296  \t\t\t || strcmp(cmsg_stored->store->topic, msg->topic)\n    297  \t\t\t || memcmp(cmsg_stored->store->payload, msg->payload, msg->payloadlen) )){\n    299  \t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Reused message ID %u from %s detected. Clearing from storage.\", msg->source_mid, context->id);\n    300  \t\tdb__message_remove_incoming(context, msg->source_mid);\n    301  \t\tcmsg_stored = NULL;\n    302  \t}\n    304  \tif(!cmsg_stored){\n    305  \t\tif(msg->qos == 0\n    306  \t\t\t\t|| db__ready_for_flight(context, mosq_md_in, msg->qos)\n    307  \t\t\t\t){\n    310  \t\t\trc = db__message_store(context, msg, message_expiry_interval, 0, mosq_mo_client);\n    311  \t\t\tif(rc) return rc;\n    312  \t\t}else{\n    315  \t\t\tgoto process_bad_message;\n    316  \t\t}\n    317  \t\tstored = msg;\n    320  \t}else{\n    323  \t\tstored = cmsg_stored->store;\n    324  \t\tcmsg_stored->dup++;\n    325  \t\tdup = cmsg_stored->dup;\n    326  \t}\n    328  \tswitch(stored->qos){\n    329  \t\tcase 0:\n    330  \t\t\trc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);\n    331  \t\t\tif(rc2 > 0) rc = 1;\n    332  \t\t\tbreak;\n    333  \t\tcase 1:\n    334  \t\t\tutil__decrement_receive_quota(context);\n    335  \t\t\trc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored);\n    337  \t\t\tif(rc2 == MOSQ_ERR_SUCCESS || context->protocol != mosq_p_mqtt5){\n    338  \t\t\t\tif(send__puback(context, mid, 0, NULL)) rc = 1;\n    339  \t\t\t}else if(rc2 == MOSQ_ERR_NO_SUBSCRIBERS){\n    340  \t\t\t\tif(send__puback(context, mid, MQTT_RC_NO_MATCHING_SUBSCRIBERS, NULL)) rc = 1;\n    341  \t\t\t}else{\n    343  \t\t\t}\n    344  \t\t\tbreak;\n    345  \t\tcase 2:\n    346  \t\t\tif(dup == 0){\n    347  \t\t\t\tres = db__message_insert(context, stored->source_mid, mosq_md_in, stored->qos, stored->retain, stored, NULL, false);\n    348  \t\t\t}else{\n    355  \t\t\tif(!res){\n    356  \t\t\t\tif(dup == 0 || dup == 1){\n    357  \t\t\t\t\trc2 = send__pubrec(context, stored->source_mid, 0, NULL);\n    358  \t\t\t\t\tif(rc2) rc = rc2;\n    359  \t\t\t\t}else{\n    360  \t\t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    361  \t\t\t\t}\n    362  \t\t\t}else if(res == 1){\n    364  \t\t\t}\n    365  \t\t\tbreak;\n    366  \t}\n    368  \tdb__message_write_queued_in(context);\n    371  \trc = 1;\n    372  \tif(msg){\n    373  \t\tswitch(msg->qos){\n    377  \t\t\tcase 1:\n    378  \t\t\t\trc = send__puback(context, msg->source_mid, reason_code, NULL);\n    379  \t\t\t\tbreak;\n    380  \t\t\tcase 2:\n    381  \t\t\t\trc = send__pubrec(context, msg->source_mid, reason_code, NULL);\n    382  \t\t\t\tbreak;\n    383  \t\t}\n    385  \t}\n    386  \tif(context->out_packet_count >= db.config->max_queued_messages){\n    388  \t}\n    390  }\nFunction: mosquitto__free\nPath: /root/projects/mosquitto/src/../lib/memory_mosq.c:72\n    72   void mosquitto__free(void *mem)\n    73   {\n    74   #ifdef REAL_WITH_MEMORY_TRACKING\n    75   \tif(!mem){\n    76   \t\treturn;\n    77   \t}\n    78   \tmemcount -= malloc_usable_size(mem);\n    79   #endif\n    80   \tfree(mem);\n    81   }\nFunction: send__publish\nPath: /root/projects/mosquitto/src/../lib/send_publish.c:42\n    42   int send__publish(struct mosquitto *mosq, uint16_t mid, const char *topic, uint32_t payloadlen, const void *payload, uint8_t qos, bool retain, bool dup, const mosquitto_property *cmsg_props, const mosquitto_property *store_props, uint32_t expiry_interval)\n    43   {\n    46   #ifdef WITH_BRIDGE\n    47   \tint i;\n    49   \tbool match;\n    51   \tchar *mapped_topic = NULL;\n    53   #endif\n    55   \tassert(mosq);\n    60   \tif(mosq->sock == INVALID_SOCKET) return MOSQ_ERR_NO_CONN;\n    63   \tif(!mosq->retain_available){\n    65   \t}\n    67   #ifdef WITH_BROKER\n    68   \tif(mosq->listener && mosq->listener->mount_point){\n    69   \t\tlen = strlen(mosq->listener->mount_point);\n    70   \t\tif(len < strlen(topic)){\n    71   \t\t\ttopic += len;\n    72   \t\t}else{\n    74   \t\t\treturn MOSQ_ERR_SUCCESS;\n    75   \t\t}\n    76   \t}\n    77   #ifdef WITH_BRIDGE\n    78   \tif(mosq->bridge && mosq->bridge->topics && mosq->bridge->topic_remapping){\n    79   \t\tfor(i=0; i<mosq->bridge->topic_count; i++){\n    80   \t\t\tcur_topic = &mosq->bridge->topics[i];\n    81   \t\t\tif((cur_topic->direction == bd_both || cur_topic->direction == bd_out)\n    82   \t\t\t\t\t&& (cur_topic->remote_prefix || cur_topic->local_prefix)){\n    85   \t\t\t\trc = mosquitto_topic_matches_sub(cur_topic->local_topic, topic, &match);\n    86   \t\t\t\tif(rc){\n    87   \t\t\t\t\treturn rc;\n    88   \t\t\t\t}\n    89   \t\t\t\tif(match){\n    90   \t\t\t\t\tmapped_topic = mosquitto__strdup(topic);\n    91   \t\t\t\t\tif(!mapped_topic) return MOSQ_ERR_NOMEM;\n    92   \t\t\t\t\tif(cur_topic->local_prefix){\n    94   \t\t\t\t\t\tif(!strncmp(cur_topic->local_prefix, mapped_topic, strlen(cur_topic->local_prefix))){\n    95   \t\t\t\t\t\t\ttopic_temp = mosquitto__strdup(mapped_topic+strlen(cur_topic->local_prefix));\n    96   \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    97   \t\t\t\t\t\t\tif(!topic_temp){\n    98   \t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    99   \t\t\t\t\t\t\t}\n    101  \t\t\t\t\t\t}\n    102  \t\t\t\t\t}\n    104  \t\t\t\t\tif(cur_topic->remote_prefix){\n    106  \t\t\t\t\t\tlen = strlen(mapped_topic) + strlen(cur_topic->remote_prefix)+1;\n    107  \t\t\t\t\t\ttopic_temp = mosquitto__malloc(len+1);\n    108  \t\t\t\t\t\tif(!topic_temp){\n    109  \t\t\t\t\t\t\tmosquitto__free(mapped_topic);\n    110  \t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n    111  \t\t\t\t\t\t}\n    112  \t\t\t\t\t\tsnprintf(topic_temp, len, \"%s%s\", cur_topic->remote_prefix, mapped_topic);\n    113  \t\t\t\t\t\ttopic_temp[len] = '\\0';\n    114  \t\t\t\t\t\tmosquitto__free(mapped_topic);\n    116  \t\t\t\t\t}\n    117  \t\t\t\t\tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, mapped_topic, (long)payloadlen);\n    118  \t\t\t\t\tG_PUB_BYTES_SENT_INC(payloadlen);\n    119  \t\t\t\t\trc =  send__real_publish(mosq, mid, mapped_topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    120  \t\t\t\t\tmosquitto__free(mapped_topic);\n    121  \t\t\t\t\treturn rc;\n    122  \t\t\t\t}\n    123  \t\t\t}\n    124  \t\t}\n    125  \t}\n    126  #endif\n    127  \tlog__printf(NULL, MOSQ_LOG_DEBUG, \"Sending PUBLISH to %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))\", SAFE_PRINT(mosq->id), dup, qos, retain, mid, topic, (long)payloadlen);\n    128  \tG_PUB_BYTES_SENT_INC(payloadlen);\n    129  #else\n    133  \treturn send__real_publish(mosq, mid, topic, payloadlen, payload, qos, retain, dup, cmsg_props, store_props, expiry_interval);\n    134  }\n",
    "If a Server receives a packet whose size exceeds the Maximum Packet Size limit, this is a Protocol Error, and the Server MUST close the connection using DISCONNECT with Reason Code 0x95 (Packet too large).": "Function: packet__read\nPath: /root/projects/mosquitto/src/../lib/packet_mosq.c:356\n    356  int packet__read(struct mosquitto *mosq)\n    357  {\n    358  \tuint8_t byte;\n    359  \tssize_t read_length;\n    360  \tint rc = 0;\n    361  \tenum mosquitto_client_state state;\n    363  \tif(!mosq){\n    364  \t\treturn MOSQ_ERR_INVAL;\n    365  \t}\n    366  \tif(mosq->sock == INVALID_SOCKET){\n    367  \t\treturn MOSQ_ERR_NO_CONN;\n    368  \t}\n    370  \tstate = mosquitto__get_state(mosq);\n    371  \tif(state == mosq_cs_connect_pending){\n    372  \t\treturn MOSQ_ERR_SUCCESS;\n    373  \t}\n    375  \t/* This gets called if pselect() indicates that there is network data\n    376  \t * available - ie. at least one byte.  What we do depends on what data we\n    377  \t * already have.\n    378  \t * If we've not got a command, attempt to read one and save it. This should\n    379  \t * always work because it's only a single byte.\n    380  \t * Then try to read the remaining length. This may fail because it is may\n    381  \t * be more than one byte - will need to save data pending next read if it\n    382  \t * does fail.\n    383  \t * Then try to read the remaining payload, where 'payload' here means the\n    384  \t * combined variable header and actual payload. This is the most likely to\n    385  \t * fail due to longer length, so save current data and current position.\n    386  \t * After all data is read, send to mosquitto__handle_packet() to deal with.\n    387  \t * Finally, free the memory and reset everything to starting conditions.\n    388  \t */\n    389  \tif(!mosq->in_packet.command){\n    390  \t\tread_length = net__read(mosq, &byte, 1);\n    391  \t\tif(read_length == 1){\n    392  \t\t\tmosq->in_packet.command = byte;\n    393  #ifdef WITH_BROKER\n    394  \t\t\tG_BYTES_RECEIVED_INC(1);\n    395  \t\t\t/* Clients must send CONNECT as their first command. */\n    396  \t\t\tif(!(mosq->bridge) && state == mosq_cs_new && (byte&0xF0) != CMD_CONNECT){\n    397  \t\t\t\treturn MOSQ_ERR_PROTOCOL;\n    398  \t\t\t}\n    399  #endif\n    400  \t\t}else{\n    401  \t\t\tif(read_length == 0){\n    402  \t\t\t\treturn MOSQ_ERR_CONN_LOST; /* EOF */\n    403  \t\t\t}\n    404  #ifdef WIN32\n    405  \t\t\terrno = WSAGetLastError();\n    406  #endif\n    407  \t\t\tif(errno == EAGAIN || errno == COMPAT_EWOULDBLOCK){\n    408  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    409  \t\t\t}else{\n    410  \t\t\t\tswitch(errno){\n    411  \t\t\t\t\tcase COMPAT_ECONNRESET:\n    412  \t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    413  \t\t\t\t\tcase COMPAT_EINTR:\n    414  \t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    415  \t\t\t\t\tdefault:\n    416  \t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    417  \t\t\t\t}\n    418  \t\t\t}\n    419  \t\t}\n    420  \t}\n    421  \t/* remaining_count is the number of bytes that the remaining_length\n    422  \t * parameter occupied in this incoming packet. We don't use it here as such\n    423  \t * (it is used when allocating an outgoing packet), but we must be able to\n    424  \t * determine whether all of the remaining_length parameter has been read.\n    425  \t * remaining_count has three states here:\n    426  \t *   0 means that we haven't read any remaining_length bytes\n    427  \t *   <0 means we have read some remaining_length bytes but haven't finished\n    428  \t *   >0 means we have finished reading the remaining_length bytes.\n    429  \t */\n    430  \tif(mosq->in_packet.remaining_count <= 0){\n    431  \t\tdo{\n    432  \t\t\tread_length = net__read(mosq, &byte, 1);\n    433  \t\t\tif(read_length == 1){\n    434  \t\t\t\tmosq->in_packet.remaining_count--;\n    435  \t\t\t\t/* Max 4 bytes length for remaining length as defined by protocol.\n    436  \t\t\t\t * Anything more likely means a broken/malicious client.\n    437  \t\t\t\t */\n    438  \t\t\t\tif(mosq->in_packet.remaining_count < -4){\n    439  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    440  \t\t\t\t}\n    442  \t\t\t\tG_BYTES_RECEIVED_INC(1);\n    443  \t\t\t\tmosq->in_packet.remaining_length += (byte & 127) * mosq->in_packet.remaining_mult;\n    444  \t\t\t\tmosq->in_packet.remaining_mult *= 128;\n    445  \t\t\t}else{\n    446  \t\t\t\tif(read_length == 0){\n    447  \t\t\t\t\treturn MOSQ_ERR_CONN_LOST; /* EOF */\n    448  \t\t\t\t}\n    449  #ifdef WIN32\n    450  \t\t\t\terrno = WSAGetLastError();\n    451  #endif\n    452  \t\t\t\tif(errno == EAGAIN || errno == COMPAT_EWOULDBLOCK){\n    453  \t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    454  \t\t\t\t}else{\n    455  \t\t\t\t\tswitch(errno){\n    456  \t\t\t\t\t\tcase COMPAT_ECONNRESET:\n    457  \t\t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    458  \t\t\t\t\t\tcase COMPAT_EINTR:\n    459  \t\t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    460  \t\t\t\t\t\tdefault:\n    461  \t\t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    462  \t\t\t\t\t}\n    463  \t\t\t\t}\n    464  \t\t\t}\n    465  \t\t}while((byte & 128) != 0);\n    466  \t\t/* We have finished reading remaining_length, so make remaining_count\n    467  \t\t * positive. */\n    468  \t\tmosq->in_packet.remaining_count = (int8_t)(mosq->in_packet.remaining_count * -1);\n    470  #ifdef WITH_BROKER\n    471  \t\tswitch(mosq->in_packet.command & 0xF0){\n    472  \t\t\tcase CMD_CONNECT:\n    473  \t\t\t\tif(mosq->in_packet.remaining_length > 100000){ /* Arbitrary limit, make configurable */\n    474  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    475  \t\t\t\t}\n    476  \t\t\t\tbreak;\n    478  \t\t\tcase CMD_PUBACK:\n    479  \t\t\tcase CMD_PUBREC:\n    480  \t\t\tcase CMD_PUBREL:\n    481  \t\t\tcase CMD_PUBCOMP:\n    482  \t\t\tcase CMD_UNSUBACK:\n    483  \t\t\t\tif(mosq->protocol != mosq_p_mqtt5 && mosq->in_packet.remaining_length != 2){\n    484  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    485  \t\t\t\t}\n    486  \t\t\t\tbreak;\n    488  \t\t\tcase CMD_PINGREQ:\n    489  \t\t\tcase CMD_PINGRESP:\n    490  \t\t\t\tif(mosq->in_packet.remaining_length != 0){\n    491  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    492  \t\t\t\t}\n    493  \t\t\t\tbreak;\n    495  \t\t\tcase CMD_DISCONNECT:\n    496  \t\t\t\tif(mosq->protocol != mosq_p_mqtt5 && mosq->in_packet.remaining_length != 0){\n    497  \t\t\t\t\treturn MOSQ_ERR_MALFORMED_PACKET;\n    498  \t\t\t\t}\n    499  \t\t\t\tbreak;\n    500  \t\t}\n    502  \t\tif(db.config->max_packet_size > 0 && mosq->in_packet.remaining_length+1 > db.config->max_packet_size){\n    503  \t\t\tif(mosq->protocol == mosq_p_mqtt5){\n    504  \t\t\t\tsend__disconnect(mosq, MQTT_RC_PACKET_TOO_LARGE, NULL);\n    505  \t\t\t}\n    506  \t\t\treturn MOSQ_ERR_OVERSIZE_PACKET;\n    507  \t\t}\n    508  #else\n    509  \t\t/* FIXME - client case for incoming message received from broker too large */\n    510  #endif\n    511  \t\tif(mosq->in_packet.remaining_length > 0){\n    512  \t\t\tmosq->in_packet.payload = mosquitto__malloc(mosq->in_packet.remaining_length*sizeof(uint8_t));\n    513  \t\t\tif(!mosq->in_packet.payload){\n    514  \t\t\t\treturn MOSQ_ERR_NOMEM;\n    515  \t\t\t}\n    516  \t\t\tmosq->in_packet.to_process = mosq->in_packet.remaining_length;\n    517  \t\t}\n    518  \t}\n    519  \twhile(mosq->in_packet.to_process>0){\n    520  \t\tread_length = net__read(mosq, &(mosq->in_packet.payload[mosq->in_packet.pos]), mosq->in_packet.to_process);\n    521  \t\tif(read_length > 0){\n    522  \t\t\tG_BYTES_RECEIVED_INC(read_length);\n    523  \t\t\tmosq->in_packet.to_process -= (uint32_t)read_length;\n    524  \t\t\tmosq->in_packet.pos += (uint32_t)read_length;\n    525  \t\t}else{\n    526  #ifdef WIN32\n    527  \t\t\terrno = WSAGetLastError();\n    528  #endif\n    529  \t\t\tif(errno == EAGAIN || errno == COMPAT_EWOULDBLOCK){\n    530  \t\t\t\tif(mosq->in_packet.to_process > 1000){\n    531  \t\t\t\t\t/* Update last_msg_in time if more than 1000 bytes left to\n    532  \t\t\t\t\t * receive. Helps when receiving large messages.\n    533  \t\t\t\t\t * This is an arbitrary limit, but with some consideration.\n    534  \t\t\t\t\t * If a client can't send 1000 bytes in a second it\n    535  \t\t\t\t\t * probably shouldn't be using a 1 second keep alive. */\n    536  #ifdef WITH_BROKER\n    537  \t\t\t\t\tkeepalive__update(mosq);\n    538  #else\n    539  \t\t\t\t\tCOMPAT_pthread_mutex_lock(&mosq->msgtime_mutex);\n    540  \t\t\t\t\tmosq->last_msg_in = mosquitto_time();\n    541  \t\t\t\t\tCOMPAT_pthread_mutex_unlock(&mosq->msgtime_mutex);\n    542  #endif\n    543  \t\t\t\t}\n    544  \t\t\t\treturn MOSQ_ERR_SUCCESS;\n    545  \t\t\t}else{\n    546  \t\t\t\tswitch(errno){\n    547  \t\t\t\t\tcase COMPAT_ECONNRESET:\n    548  \t\t\t\t\t\treturn MOSQ_ERR_CONN_LOST;\n    549  \t\t\t\t\tcase COMPAT_EINTR:\n    550  \t\t\t\t\t\treturn MOSQ_ERR_SUCCESS;\n    551  \t\t\t\t\tdefault:\n    552  \t\t\t\t\t\treturn MOSQ_ERR_ERRNO;\n    553  \t\t\t\t}\n    554  \t\t\t}\n    555  \t\t}\n    556  \t}\n    558  \t/* All data for this packet is read. */\n    559  \tmosq->in_packet.pos = 0;\n    560  #ifdef WITH_BROKER\n    561  \tG_MSGS_RECEIVED_INC(1);\n    562  \tif(((mosq->in_packet.command)&0xF0) == CMD_PUBLISH){\n    563  \t\tG_PUB_MSGS_RECEIVED_INC(1);\n    564  \t}\n    565  #endif\n    566  \trc = handle__packet(mosq);\n    568  \t/* Free data and reset values */\n    569  \tpacket__cleanup(&mosq->in_packet);\n    571  #ifdef WITH_BROKER\n    572  \tkeepalive__update(mosq);\n    573  #else\n    574  \tCOMPAT_pthread_mutex_lock(&mosq->msgtime_mutex);\n    575  \tmosq->last_msg_in = mosquitto_time();\n    576  \tCOMPAT_pthread_mutex_unlock(&mosq->msgtime_mutex);\n    577  #endif\n    578  \treturn rc;\n    579  }\nFunction: handle__connect\nPath: /root/projects/mosquitto/src/handle_connect.c:428\n    428  int handle__connect(struct mosquitto *context)\n    429  {\n    711  \tif(context->in_packet.pos != context->in_packet.remaining_length){\n    714  \t\tgoto handle_connect_error;\n    715  \t}\n    980  }\n",
    "A receiver MUST NOT carry forward any Topic Alias mappings from one Network Connection to another [MQTT-3.3.2-7].": "Function: plugin__handle_message\nPath: /root/projects/mosquitto/src/plugin.c:130\n    130  int plugin__handle_message(struct mosquitto *context, struct mosquitto_msg_store *stored)\n    131  {\n    152  \tevent_data.payloadlen = stored->payloadlen;\n    154  \tevent_data.qos = stored->qos;\n    155  \tevent_data.retain = stored->retain;\n    156  \tevent_data.properties = stored->properties;\n    169  \t\t\tstored->payloadlen = event_data.payloadlen;\n    172  \t\tif(stored->properties != event_data.properties){\n    173  \t\t\tmosquitto_property_free_all(&stored->properties);\n    174  \t\t\tstored->properties = event_data.properties;\n    182  \tstored->retain = event_data.retain;\n    185  }\nFunction: mosquitto_security_module_init\nPath: /root/projects/mosquitto/src/security.c:388\n    388  int mosquitto_security_module_init(void)\n    389  {\n    390  \tint rc = MOSQ_ERR_SUCCESS;\n    391  \tint i;\n    393  \tif(db.config->per_listener_settings){\n    394  \t\tfor(i=0; i<db.config->listener_count; i++){\n    395  \t\t\trc = security__module_init_single(&db.config->listeners[i], &db.config->listeners[i].security_options);\n    396  \t\t\tif(rc) return rc;\n    397  \t\t}\n    398  \t}else{\n    399  \t\trc = security__module_init_single(NULL, &db.config->security_options);\n    400  \t}\n    401  \treturn rc;\n    402  }\nFunction: main\nPath: /root/projects/mosquitto/src/mosquitto.c:447\n    447  int main(int argc, char *argv[])\n    448  {\n    449  \tstruct mosquitto__config config;\n    450  #ifdef WITH_BRIDGE\n    451  \tint i;\n    452  #endif\n    453  \tint rc;\n    454  #ifdef WIN32\n    455  \tSYSTEMTIME st;\n    456  #else\n    457  \tstruct timeval tv;\n    458  #endif\n    459  \tstruct mosquitto *ctxt, *ctxt_tmp;\n    461  #if defined(WIN32) || defined(__CYGWIN__)\n    462  \tif(argc == 2){\n    463  \t\tif(!strcmp(argv[1], \"run\")){\n    464  \t\t\tservice_r"
}