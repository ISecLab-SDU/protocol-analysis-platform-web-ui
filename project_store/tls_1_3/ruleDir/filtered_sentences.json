{
    "1. Introduction -> 1.3. Updates Affecting TLS 1.2": [
        "The \"supported_versions\" ClientHello extension can be used to negotiate the version of TLS to use, in preference to the legacy_version field of the ClientHello.",
        "The \"signature_algorithms_cert\" extension allows a client to indicate which signature algorithms the client can validate in X.509 certificates."
    ],
    "2. Protocol Overview -> 2.1. Incorrect DHE Share": [
        "If the client has not provided a sufficient \"key_share\" extension (e.g., the extension includes only DHE or ECDHE groups unacceptable to or unsupported by the server), the server corrects the mismatch with a HelloRetryRequest and the client needs to restart the handshake with an appropriate \"key_share\" extension.",
        "The message flow for a full handshake with mismatched parameters involves the client sending a ClientHello with key_share, the server responding with a HelloRetryRequest and key_share, followed by the client sending another ClientHello with key_share.",
        "The server then sends ServerHello with key_share, EncryptedExtensions, CertificateRequest, Certificate, CertificateVerify, and Finished.",
        "The client responds with Certificate, CertificateVerify, and Finished, after which application data can be exchanged."
    ],
    "4. Handshake Protocol": [
        "The handshake protocol defines an enumeration of handshake types including client_hello, server_hello, new_session_ticket, end_of_early_data, encrypted_extensions, certificate, certificate_request, certificate_verify, finished, key_update, and message_hash."
    ],
    "2. Protocol Overview -> 2.3. 0-RTT Data": [
        "The client sends a ClientHello with early_data, key_share, psk_key_exchange_modes, and pre_shared_key extensions, along with optional Application Data.",
        "The server responds with a ServerHello containing pre_shared_key and key_share extensions, followed by EncryptedExtensions with early_data, and Finished.",
        "The client then sends EndOfEarlyData and Finished, after which both parties exchange Application Data.",
        "The plus symbol indicates noteworthy extensions sent in the previously noted message.",
        "The asterisk indicates optional or situation-dependent messages or extensions that are not always sent.",
        "Protection against replay for ordinary TLS 1.3 1-RTT data is provided via the server's Random value, but 0-RTT data does not depend on the ServerHello and therefore has weaker guarantees."
    ],
    "2. Protocol Overview -> 2.2. Resumption and Pre-Shared Key (PSK)": [
        "As the server is authenticating via a PSK, it does not send a Certificate or a CertificateVerify message.",
        "When a client offers resumption via a PSK, it SHOULD also supply a \"key_share\" extension to the server to allow the server to decline resumption and fall back to a full handshake, if needed.",
        "The server responds with a \"pre_shared_key\" extension to negotiate the use of PSK key establishment and can (as shown here) respond with a \"key_share\" extension to do (EC)DHE key establishment, thus providing forward secrecy."
    ],
    "3. Presentation Language -> 3.5. Enumerateds": [
        "Future extensions or additions to the protocol may define new values."
    ],
    "1. Introduction -> 1.2. Major Differences from TLS 1.2": [
        "Static RSA and Diffie-Hellman cipher suites have been removed; all public-key based key exchange mechanisms now provide forward secrecy.",
        "The newly introduced EncryptedExtensions message allows various extensions previously sent in the clear in the ServerHello to also enjoy confidentiality protection.",
        "Session resumption with and without server-side state as well as the PSK-based cipher suites of earlier TLS versions have been replaced by a single new PSK exchange."
    ],
    "4. Handshake Protocol -> 4.2. Extensions -> 4.2.6. Post-Handshake Client Authentication": [
        "Servers MUST NOT send a post-handshake CertificateRequest to clients which do not offer this extension.",
        "Servers MUST NOT send this extension.",
        "The PostHandshakeAuth structure is empty, and the extension_data field of the post_handshake_auth extension has zero length."
    ],
    "4. Handshake Protocol -> 4.2. Extensions -> 4.2.4. Certificate Authorities": [
        "The \"certificate_authorities\" extension is used to indicate the certificate authorities (CAs) which an endpoint supports and which SHOULD be used by the receiving endpoint to guide certificate selection.",
        "The body of the \"certificate_authorities\" extension consists of a CertificateAuthoritiesExtension structure.",
        "The CertificateAuthoritiesExtension structure contains a list of distinguished names of acceptable certificate authorities, represented in DER-encoded format as specified in X690.",
        "The client MAY send the \"certificate_authorities\" extension in the ClientHello message.",
        "The server MAY send the \"certificate_authorities\" extension in the CertificateRequest message.",
        "The \"trusted_ca_keys\" extension, which serves a similar purpose but is more complicated, is not used in TLS 1.3, although it may appear in ClientHello messages from clients offering prior versions of TLS."
    ],
    "4. Handshake Protocol -> 4.2. Extensions -> 4.2.2. Cookie": [
        "When sending a HelloRetryRequest, the server MAY provide a \"cookie\" extension to the client (this cookie extension is an exception to the usual rule that the only extensions that may be sent are those that appear in the ClientHello).",
        "When sending the new ClientHello, the client MUST copy the contents of the extension received in the HelloRetryRequest into a \"cookie\" extension in the new ClientHello.",
        "Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.",
        "When a server is operating statelessly, it may receive an unprotected record of type change_cipher_spec between the first and second ClientHello (see Section 5)."
    ],
    "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation": [
        "In TLS, the cryptographic negotiation proceeds by the client offering the following four sets of options in its ClientHello: A list of cipher suites which indicates the AEAD algorithm/HKDF hash pairs which the client supports.",
        "A \"supported_groups\" (Section 4.2.7) extension which indicates the (EC)DHE groups which the client supports and a \"key_share\" (Section 4.2.8) extension which contains (EC)DHE shares for some or all of these groups.",
        "A \"signature_algorithms\" (Section 4.2.3) extension which indicates the signature algorithms which the client can accept.",
        "A \"signature_algorithms_cert\" extension (Section 4.2.3) may also be added to indicate certificate-specific signature algorithms.",
        "A \"pre_shared_key\" (Section 4.2.11) extension which contains a list of symmetric key identities known to the client and a \"psk_key_exchange_modes\" (Section 4.2.9) extension which indicates the key exchange modes that may be used with PSKs.",
        "If the server does not select a PSK, then the first three of these options are entirely orthogonal: the server independently selects a cipher suite, an (EC)DHE group and key share for key establishment, and a signature algorithm/certificate pair to authenticate itself to the client.",
        "If there is no overlap between the received \"supported_groups\" and the groups supported by the server, then the server MUST abort the handshake with a \"handshake_failure\" or an \"insufficient_security\" alert.",
        "If the server selects a PSK, then it MUST also select a key establishment mode from the set indicated by the client's \"psk_key_exchange_modes\" extension (at present, PSK alone or with (EC)DHE).",
        "If the server selects an (EC)DHE group and the client did not offer a compatible \"key_share\" extension in the initial ClientHello, the server MUST respond with a HelloRetryRequest (Section 4.1.4) message.",
        "If the server successfully selects parameters and does not require a HelloRetryRequest, the server indicates the selected parameters in the ServerHello as follows: If PSK is being used, then the server will send a \"pre_shared_key\" extension indicating the selected key.",
        "When (EC)DHE is in use, the server will also provide a \"key_share\" extension.",
        "When authenticating via a certificate, the server will send the Certificate (Section 4.4.2) and CertificateVerify (Section 4.4.3) messages."
    ],
    "2. Protocol Overview": [
        "The handshake involves ClientHello, ServerHello, EncryptedExtensions, CertificateRequest, Certificate, CertificateVerify, and Finished messages, with optional extensions and application data exchange.",
        "* Indicates optional or situation-dependent messages/extensions that are not always sent.",
        "In the Key Exchange phase, the client sends the ClientHello (Section 4.1.2) message, which contains a random nonce (ClientHello.random); its offered protocol versions; a list of symmetric cipher/HKDF hash pairs; either a set of Diffie-Hellman key shares (in the \"key_share\" (Section 4.2.8) extension), a set of pre-shared key labels (in the \"pre_shared_key\" (Section 4.2.11) extension), or both; and potentially additional extensions.",
        "The combination of the ClientHello and the ServerHello determines the shared keys.",
        "If (EC)DHE key establishment is in use, then the ServerHello contains a \"key_share\" extension with the server's ephemeral Diffie-Hellman share; the server's share MUST be in the same group as one of the client's shares.",
        "If PSK key establishment is in use, then the ServerHello contains a \"pre_shared_key\" extension indicating which of the client's offered PSKs was selected.",
        "Note that implementations can use (EC)DHE and PSK together, in which case both extensions will be supplied.",
        "The server then sends two messages to establish the Server Parameters: EncryptedExtensions provides responses to ClientHello extensions that are not required to determine cryptographic parameters, excluding those specific to individual certificates.",
        "CertificateRequest specifies desired parameters for certificate-based client authentication if it is desired.",
        "TLS uses the same set of messages every time that certificate-based authentication is needed.",
        "Specifically, Certificate message contains the certificate of the endpoint and any per-certificate extensions.",
        "This message is omitted by the server if not authenticating with a certificate and by the client if the server did not send CertificateRequest (thus indicating that the client should not authenticate with a certificate).",
        "Note that if raw public keys or the cached information extension are in use, then the Certificate message will not contain a certificate but rather some other value corresponding to the server's long-term key.",
        "CertificateVerify provides a signature over the entire handshake using the private key corresponding to the public key in the Certificate message.",
        "Upon receiving the server's messages, the client responds with its Authentication messages, namely Certificate and CertificateVerify if requested, and Finished.",
        "Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3."
    ],
    "4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters": [
        "The \"oid_filters\" extension allows servers to provide a set of OID/value pairs which the server would like the client's certificate to match.",
        "This extension, if provided by the server, MUST only be sent in the CertificateRequest message.",
        "The OIDFilter structure contains certificate_extension_oid and certificate_extension_values fields.",
        "The filters parameter is a list of certificate extension OIDs from RFC5280 Profile with their allowed values, represented in DER-encoded format as specified in X690 Canonical Encoding Rules and Distinguished Encoding Rules.",
        "Some certificate extension OIDs allow multiple values (e.g., Extended Key Usage).",
        "If the server has included a non-empty filters list, the client certificate included in the response MUST contain all of the specified extension OIDs that the client recognizes.",
        "For each extension OID recognized by the client, all of the specified values MUST be present in the client certificate (but the certificate MAY have other values as well).",
        "However, the client MUST ignore and skip any unrecognized certificate extension OIDs.",
        "If the client ignored some of the required certificate extension OIDs and supplied a certificate that does not satisfy the request, the server MAY at its discretion either continue the connection without client authentication or abort the handshake with an \"unsupported_certificate\" alert.",
        "PKIX RFCs define a variety of certificate extension OIDs and their corresponding value types.",
        "Depending on the type, matching certificate extension values are not necessarily bitwise-equal.",
        "It is expected that TLS implementations will rely on their PKI libraries to perform certificate selection using certificate extension OIDs.",
        "This document defines matching rules for two standard certificate extensions defined in RFC5280 Profile: The Key Usage extension in a certificate matches the request when all key usage bits asserted in the request are also asserted in the Key Usage certificate extension.",
        "The Extended Key Usage extension in a certificate matches the request when all key purpose OIDs present in the request are also found in the Extended Key Usage certificate extension.",
        "Separate specifications may define matching rules for other certificate extensions."
    ],
    "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request": [
        "The server will send the HelloRetryRequest message in response to a ClientHello message if the server is able to find an acceptable set of parameters but the ClientHello does not contain sufficient information to proceed with the handshake.",
        "As discussed in Section 4.1.3, the HelloRetryRequest has the same format as a ServerHello message, and the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method fields have the same meaning.",
        "The server's extensions MUST contain \"supported_versions\".",
        "Additionally, the HelloRetryRequest SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair.",
        "As with the ServerHello, a HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the \"cookie\" (see Section 4.2.2) extension.",
        "Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3 and then process the extensions, starting with determining the version using \"supported_versions\".",
        "Clients MUST abort the handshake with an \"illegal_parameter\" alert if the HelloRetryRequest would not result in any change in the ClientHello.",
        "If a client receives a second HelloRetryRequest in the same connection (i.e., where the ClientHello was itself in response to a HelloRetryRequest), the client MUST abort the handshake with an \"unexpected_message\" alert.",
        "Otherwise, the client MUST process all extensions in the HelloRetryRequest and send a second updated ClientHello.",
        "The HelloRetryRequest extensions defined in this specification are: supported_versions (see Section 4.2.1), cookie (see Section 4.2.2), and key_share (see Section 4.2.8).",
        "A client which receives a cipher suite that was not offered MUST abort the handshake.",
        "Servers MUST ensure that they negotiate the same cipher suite when receiving a conformant updated ClientHello (if the server selects the cipher suite as the first step in the negotiation, then the same cipher suite negotiation will happen automatically).",
        "Upon receiving the ServerHello, clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and otherwise abort the handshake with an \"illegal_parameter\" alert.",
        "In addition, in its updated ClientHello, the client SHOULD NOT offer any pre-shared keys associated with a hash other than that of the selected cipher suite.",
        "The value of selected_version in the HelloRetryRequest \"supported_versions\" extension MUST be retained in the ServerHello, and a client MUST abort the handshake with an \"illegal_parameter\" alert if the value changes."
    ],
    "4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions": [
        "Implementations of this specification MUST send this extension in the ClientHello containing all versions of TLS which the implementations are prepared to negotiate (for this specification, that means minimally 0x0304, but if previous versions of TLS are allowed to be negotiated, the previous versions MUST be present as well).",
        "If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in RFC5246, even if ClientHello.legacy_version is 0x0304 or later.",
        "Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.",
        "If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the \"supported_versions\" extension to determine client preferences.",
        "Servers MUST only select a version of TLS present in the \"supported_versions\" extension and MUST ignore any unknown versions that are present in the extension.",
        "Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.",
        "A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the \"supported_versions\" extension.",
        "A server which negotiates TLS 1.3 MUST respond by sending a \"supported_versions\" extension containing the selected version value (0x0304).",
        "The server MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2).",
        "Clients MUST check for this extension prior to processing the rest of the ServerHello (although they will have to parse the ServerHello in order to read the extension).",
        "If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the \"supported_versions\" extension to determine the selected version.",
        "If the \"supported_versions\" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an \"illegal_parameter\" alert."
    ],
    "4. Handshake Protocol -> 4.2. Extensions -> 4.2.7. Supported Groups": [
        "When sent by the client, the \"supported_groups\" extension indicates the named groups which the client supports for key exchange, ordered from most preferred to least preferred.",
        "The \"extension_data\" field of this extension contains a \"NamedGroupList\" value.",
        "As of TLS 1.3, servers are permitted to send the \"supported_groups\" extension to the client.",
        "Clients MUST NOT act upon any information found in \"supported_groups\" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their \"key_share\" extension in subsequent connections.",
        "If the server has a group it prefers to the ones in the \"key_share\" extension but is still willing to accept the ClientHello, it SHOULD send \"supported_groups\" to update the client's view of its preferences; this extension SHOULD contain all groups the server supports, regardless of whether they are currently supported by the client."
    ],
    "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.1. Ticket Age": [
        "Clients MUST NOT attempt to use tickets which have ages greater than the \"ticket_lifetime\" value which was provided with the ticket.",
        "The addition of the \"ticket_age_add\" value prevents passive observers from correlating connections unless tickets are reused.",
        "Note that the \"ticket_lifetime\" field in the NewSessionTicket message is in seconds but the \"obfuscated_ticket_age\" is in milliseconds."
    ],
    "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.3. Processing Order": [
        "Clients are permitted to \"stream\" 0-RTT data until they receive the server's Finished, only then sending the EndOfEarlyData message, followed by the rest of the handshake.",
        "In order to avoid deadlocks, when accepting \"early_data\", servers MUST process the client's ClientHello and then immediately send their flight of messages, rather than waiting for the client's EndOfEarlyData message before sending the server's ServerHello."
    ],
    "4. Handshake Protocol -> 4.3. Server Parameters": [
        "The next two messages from the server, EncryptedExtensions and CertificateRequest, contain information from the server that determines the rest of the handshake."
    ],
    "4. Handshake Protocol -> 4.2. Extensions -> 4.2.9. Pre-Shared Key Exchange Modes": [
        "In order to use PSKs, clients MUST also send a \"psk_key_exchange_modes\" extension.",
        "The semantics of this extension are that the client only supports the use of PSKs with these modes, which restricts both the use of PSKs offered in this ClientHello and those which the server might supply via NewSessionTicket.",
        "A client MUST provide a \"psk_key_exchange_modes\" extension if it offers a \"pre_shared_key\" extension.",
        "If clients offer \"pre_shared_key\" without a \"psk_key_exchange_modes\" extension, servers MUST abort the handshake.",
        "Servers SHOULD NOT send NewSessionTicket with tickets that are not compatible with the advertised modes; however, if a server does so, the impact will just be that the client's attempts at resumption fail.",
        "The server MUST NOT send a \"psk_key_exchange_modes\" extension.",
        "In psk_ke mode, the server MUST NOT supply a \"key_share\" value.",
        "In psk_dhe_ke mode, the client and server MUST supply \"key_share\" values as described in Section 4.2.8.",
        "Any future values that are allocated must ensure that the transmitted protocol messages unambiguously identify which mode was selected by the server; at present, this is indicated by the presence of the \"key_share\" in the ServerHello."
    ],
    "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello": [
        "The server will send the ServerHello message in response to a ClientHello message to proceed with the handshake if the server is able to negotiate an acceptable set of handshake parameters based on the ClientHello.",
        "Structure of the ServerHello message: struct { ProtocolVersion legacy_version = 0x0303; Random random; opaque legacy_session_id_echo<0..32>; CipherSuite cipher_suite; uint8 legacy_compression_method = 0; Extension extensions<6..2^16-1>; } ServerHello.",
        "In TLS 1.3, the TLS server indicates its version using the \"supported_versions\" extension (Section 4.2.1), and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2.",
        "The random structure is generated by the server and MUST be generated independently of the ClientHello.random.",
        "A client which receives a legacy_session_id_echo field that does not match what it sent in the ClientHello MUST abort the handshake with an \"illegal_parameter\" alert.",
        "cipher_suite: The single cipher suite selected by the server from the list in ClientHello.cipher_suites.",
        "A client which receives a cipher suite that was not offered MUST abort the handshake with an \"illegal_parameter\" alert.",
        "legacy_compression_method: A single byte which MUST have the value 0.",
        "extensions: A list of extensions.",
        "The ServerHello MUST only include extensions which are required to establish the cryptographic context and negotiate the protocol version.",
        "All TLS 1.3 ServerHello messages MUST contain the \"supported_versions\" extension.",
        "Current ServerHello messages additionally contain either the \"pre_shared_key\" extension or the \"key_share\" extension, or both (when using a PSK with (EC)DHE key establishment).",
        "Other extensions (see Section 4.2) are sent separately in the EncryptedExtensions message.",
        "For reasons of backward compatibility with middleboxes (see Appendix D.4), the HelloRetryRequest message uses the same structure as the ServerHello, but with the Random field set to the special value of the SHA-256 of \"HelloRetryRequest\".",
        "Upon receiving a message with type server_hello, implementations MUST first examine the Random value and, if it matches this special value, process it as described in Section 4.1.4.",
        "TLS 1.3 servers which negotiate TLS 1.2 or below in response to a ClientHello MUST set the last 8 bytes of their Random value specially in their ServerHello.",
        "If negotiating TLS 1.2, TLS 1.3 servers MUST set the last 8 bytes of their Random value to the bytes: 44 4F 57 4E 47 52 44 01.",
        "If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2 servers SHOULD, set the last 8 bytes of their ServerHello.Random value to the bytes: 44 4F 57 4E 47 52 44 00.",
        "TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below MUST check that the last 8 bytes are not equal to either of these values.",
        "TLS 1.2 clients SHOULD also check that the last 8 bytes are not equal to the second value if the ServerHello indicates TLS 1.1 or below.",
        "The downgrade protection mechanism provides limited protection against downgrade attacks over and above what is provided by the Finished exchange: because the ServerKeyExchange message, which is present in TLS 1.2 and below, includes a signature over both random values, it is not possible for an active attacker to modify the random values without detection as long as ephemeral ciphers are used.",
        "A legacy TLS client performing renegotiation with TLS 1.2 or prior and which receives a TLS 1.3 ServerHello during renegotiation MUST abort the handshake with a \"protocol_version\" alert."
    ],
    "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.2. PSK Binder": [
        "The PSK binder value forms a binding between a PSK and the current handshake, as well as a binding between the handshake in which the PSK was generated (if via a NewSessionTicket message) and the current handshake.",
        "Each entry in the binders list is computed as an HMAC over a transcript hash (see Section 4.4.1) containing a partial ClientHello up to and including the PreSharedKeyExtension.identities field.",
        "The length fields for the message (including the overall length, the length of the extensions block, and the length of the \"pre_shared_key\" extension) are all set as if binders of the correct lengths were present.",
        "The PskBinderEntry is computed in the same way as the Finished message (Section 4.4.4) but with the BaseKey being the binder_key derived via the key schedule from the corresponding PSK which is being offered (see Section 7.1)."
    ],
    "4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.1. Encrypted Extensions": [
        "In all handshakes, the server MUST send the EncryptedExtensions message immediately after the ServerHello message.",
        "The EncryptedExtensions message is the first message that is encrypted under keys derived from the server_handshake_traffic_secret.",
        "The EncryptedExtensions message contains extensions that can be protected, i.e., any which are not needed to establish the cryptographic context but which are not associated with individual certificates.",
        "The client MUST check EncryptedExtensions for the presence of any forbidden extensions and if any are found MUST abort the handshake with an \"illegal_parameter\" alert.",
        "The structure of the EncryptedExtensions message is: struct { Extension extensions<0..2^16-1>; } EncryptedExtensions; where extensions is a list of extensions."
    ],
    "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello": [
        "When a client first connects to a server, it is REQUIRED to send the ClientHello as its first TLS message.",
        "In that case, the client MUST send the same ClientHello without modification, except as follows: If a \"key_share\" extension was supplied in the HelloRetryRequest, the client must replace the list of shares with a list containing a single KeyShareEntry from the indicated group.",
        "The client must update the \"pre_shared_key\" extension if present by recomputing the \"obfuscated_ticket_age\" and binder values and (optionally) removing any PSKs which are incompatible with the server's indicated cipher suite.",
        "The client may optionally add, remove, or change the length of the \"padding\" extension [RFC7685 ClientHello Padding Extension].",
        "Because TLS 1.3 forbids renegotiation, if a server has negotiated TLS 1.3 and receives a ClientHello at any other time, it MUST terminate the connection with an \"unexpected_message\" alert.",
        "If a server established a TLS connection with a previous version of TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST retain the previous protocol version.",
        "The structure of the ClientHello message includes: uint16 ProtocolVersion; opaque Random[32]; uint8 CipherSuite[2]; struct { ProtocolVersion legacy_version = 0x0303; Random random; opaque legacy_session_id<0..32>; CipherSuite cipher_suites<2..2^16-2>; opaque legacy_compression_methods<1..2^8-1>; Extension extensions<8..2^16-1>; } ClientHello; legacy_version: In previous versions of TLS, this field was used for version negotiation and represented the highest version number supported by the client.",
        "Experience has shown that many servers do not properly implement version negotiation, leading to \"version intolerance\" in which the server rejects an otherwise acceptable ClientHello with a version number higher than it supports.",
        "In TLS 1.3, the client indicates its version preferences in the \"supported_versions\" extension (Section 4.2.1) and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2.",
        "TLS 1.3 ClientHellos are identified as having a legacy_version of 0x0303 and a supported_versions extension present with 0x0304 as the highest version indicated therein.",
        "If the list contains cipher suites that the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites and process the remaining ones as usual.",
        "If the client is attempting a PSK key establishment, it SHOULD advertise at least one cipher suite indicating a Hash associated with the PSK.",
        "For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the \"null\" compression method in prior versions of TLS.",
        "If a TLS 1.3 ClientHello is received with any other value in this field, the server MUST abort the handshake with an \"illegal_parameter\" alert.",
        "Note that TLS 1.3 servers might receive TLS 1.2 or prior ClientHellos which contain other compression methods and (if negotiating such a prior version) MUST follow the procedures for the appropriate prior version of TLS.",
        "extensions: Clients request extended functionality from servers by sending data in the extensions field.",
        "In TLS 1.3, the use of certain extensions is mandatory, as functionality has moved into extensions to preserve ClientHello compatibility with previous versions of TLS.",
        "Servers MUST ignore unrecognized extensions.",
        "All versions of TLS allow an extensions field to optionally follow the compression_methods field.",
        "TLS 1.3 ClientHello messages always contain extensions (minimally \"supported_versions\", otherwise, they will be interpreted as TLS 1.2 ClientHello messages).",
        "However, TLS 1.3 servers might receive ClientHello messages without an extensions field from prior versions of TLS.",
        "The presence of extensions can be detected by determining whether there are bytes following the compression_methods field at the end of the ClientHello.",
        "Note that this method of detecting optional data differs from the normal TLS method of having a variable-length field, but it is used for compatibility with TLS before extensions were defined.",
        "TLS 1.3 servers will need to perform this check first and only attempt to negotiate TLS 1.3 if the \"supported_versions\" extension is present.",
        "If negotiating a version of TLS prior to 1.3, a server MUST check that the message either contains no data after legacy_compression_methods or that it contains a valid extensions block with no data following.",
        "In the event that a client requests additional functionality using extensions and this functionality is not supplied by the server, the client MAY abort the handshake.",
        "After sending the ClientHello message, the client waits for a ServerHello or HelloRetryRequest message."
    ],
    "4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share": [
        "The \"key_share\" extension contains the endpoint's cryptographic parameters.",
        "In the ClientHello message, the \"extension_data\" field of the key_share extension contains a KeyShareClientHello value with client_shares: a list of offered KeyShareEntry values in descending order of client preference.",
        "Each KeyShareEntry value MUST correspond to a group offered in the \"supported_groups\" extension and MUST appear in the same order.",
        "However, the values MAY be a non-contiguous subset of the \"supported_groups\" extension and MAY omit the most preferred groups.",
        "Clients MUST NOT offer any KeyShareEntry values for groups not listed in the client's \"supported_groups\" extension.",
        "In a HelloRetryRequest message, the \"extension_data\" field of the key_share extension contains a KeyShareHelloRetryRequest value with selected_group: the mutually supported group the server intends to negotiate and is requesting a retried ClientHello/KeyShare for.",
        "Upon receipt of the key_share extension in a HelloRetryRequest, the client MUST verify that (1) the selected_group field corresponds to a group which was provided in the \"supported_groups\" extension in the original ClientHello and (2) the selected_group field does not correspond to a group which was provided in the \"key_share\" extension in the original ClientHello.",
        "Otherwise, when sending the new ClientHello, the client MUST replace the original \"key_share\" extension with one containing only a new KeyShareEntry for the group indicated in the selected_group field of the triggering HelloRetryRequest.",
        "In a ServerHello message, the \"extension_data\" field of the key_share extension contains a KeyShareServerHello value with server_share: a single KeyShareEntry value that is in the same group as one of the client's shares.",
        "Servers MUST NOT send a KeyShareEntry for any group not indicated in the client's \"supported_groups\" extension and MUST NOT send a KeyShareEntry when using the \"psk_ke\" PskKeyExchangeMode.",
        "If using (EC)DHE key establishment and a HelloRetryRequest containing a \"key_share\" extension was received by the client, the client MUST verify that the selected NamedGroup in the ServerHello is the same as the NamedGroup in the HelloRetryRequest."
    ],
    "4. Handshake Protocol -> 4.2. Extensions": [
        "A number of TLS messages contain tag-length-value encoded extensions structures.",
        "The Extension structure contains ExtensionType extension_type and opaque extension_data<0..2^16-1>.",
        "ExtensionType enum includes server_name(0), max_fragment_length(1), status_request(5), supported_groups(10), signature_algorithms(13), use_srtp(14), heartbeat(15), application_layer_protocol_negotiation(16), signed_certificate_timestamp(18), client_certificate_type(19), server_certificate_type(20), padding(21), pre_shared_key(41), early_data(42), supported_versions(43), cookie(44), psk_key_exchange_modes(45), certificate_authorities(47), oid_filters(48), post_handshake_auth(49), signature_algorithms_cert(50), key_share(51), and (65535).",
        "Here: extension_type identifies the particular extension type.",
        "extension_data contains information specific to the particular extension type.",
        "Extensions are generally structured in a request/response fashion, though some extensions are just indications with no corresponding response.",
        "The client sends its extension requests in the ClientHello message, and the server sends its extension responses in the ServerHello, EncryptedExtensions, HelloRetryRequest, and Certificate messages.",
        "The server sends extension requests in the CertificateRequest message which a client MAY respond to with a Certificate message.",
        "The server MAY also send unsolicited extensions in the NewSessionTicket, though the client does not respond directly to these.",
        "Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the \"cookie\" extension in the HelloRetryRequest.",
        "Upon receiving an extension response without a corresponding request, an endpoint MUST abort the handshake with an \"unsupported_extension\" alert.",
        "The table below indicates the messages where a given extension may appear, using the following notation: CH (ClientHello), SH (ServerHello), EE (EncryptedExtensions), CT (Certificate), CR (CertificateRequest), NST (NewSessionTicket), and HRR (HelloRetryRequest).",
        "If an implementation receives an extension which it recognizes and which is not specified for the message in which it appears, it MUST abort the handshake with an \"illegal_parameter\" alert.",
        "The table indicates messages where extensions may appear: server_name in CH and EE, max_fragment_length in CH and EE, status_request in CH, CR, and CT, supported_groups in CH and EE, signature_algorithms in CH and CR, use_srtp in CH and EE, heartbeat in CH and EE, application_layer_protocol_negotiation in CH and EE, signed_certificate_timestamp in CH, CR, and CT, client_certificate_type in CH and EE, server_certificate_type in CH and EE, padding in CH, key_share in CH, SH, and HRR, pre_shared_key in CH and SH, psk_key_exchange_modes in CH, early_data in CH, EE, and NST, cookie in CH and HRR, supported_versions in CH, SH, and HRR, certificate_authorities in CH and CR, oid_filters in CR, post_handshake_auth in CH, and signature_algorithms_cert in CH and CR.",
        "When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of pre_shared_key which MUST be the last extension in the ClientHello but can appear anywhere in the ServerHello extensions block.",
        "There MUST NOT be more than one extension of the same type in a given extension block.",
        "In TLS 1.3, unlike TLS 1.2, extensions are negotiated for each handshake even when in resumption-PSK mode.",
        "The following considerations should be taken into account when designing new extensions: Some cases where a server does not agree to an extension are error conditions such as the handshake cannot continue, and some are simply refusals to support particular features.",
        "Often the fact that the extension fields are included in the inputs to the Finished message hashes will be sufficient, but extreme care is needed when the extension changes the meaning of messages sent in the handshake phase.",
        "Designers and implementors should be aware of the fact that until the handshake has been authenticated, active attackers can modify messages and insert, remove, or replace extensions."
    ],
    "4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request": [
        "The CertificateRequest message, if sent, MUST follow EncryptedExtensions.",
        "The structure of the CertificateRequest message is: struct { opaque certificate_request_context<0..2^8-1>; Extension extensions<2..2^16-1>; } CertificateRequest; certificate_request_context: An opaque string which identifies the certificate request and which will be echoed in the client's Certificate message.",
        "The certificate_request_context MUST be unique within the scope of this connection (thus preventing replay of client CertificateVerify messages).",
        "The certificate_request_context field SHALL be zero length unless used for the post-handshake authentication exchanges described in Section 4.6.2.",
        "When requesting post-handshake authentication, the server SHOULD make the certificate_request_context unpredictable to the client (e.g., by randomly generating it) in order to prevent an attacker who has temporary access to the client's private key from pre-computing valid CertificateVerify messages.",
        "extensions: A set of extensions describing the parameters of the certificate being requested.",
        "The \"signature_algorithms\" extension MUST be specified, and other extensions may optionally be included if defined for this message.",
        "Clients MUST ignore unrecognized extensions.",
        "In prior versions of TLS, the CertificateRequest message carried a list of signature algorithms and certificate authorities which the server would accept.",
        "In TLS 1.3, the list of signature algorithms is expressed by sending the \"signature_algorithms\" and optionally \"signature_algorithms_cert\" extensions.",
        "The list of certificate authorities is expressed by sending the \"certificate_authorities\" extension (see Section 4.2.4).",
        "Servers which are authenticating with a PSK MUST NOT send the CertificateRequest message in the main handshake, though they MAY send it in post-handshake authentication (see Section 4.6.2) provided that the client has sent the \"post_handshake_auth\" extension (see Section 4.2.6)."
    ],
    "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.1. The Transcript Hash": [
        "The reason for this construction is to allow the server to do a stateless HelloRetryRequest by storing just the hash of ClientHello1 in the cookie, rather than requiring the server to export the entire intermediate hash state (see Section 4.2.2).",
        "For concreteness, the transcript hash is always taken from the following sequence of handshake messages, starting at the first ClientHello and including only those messages that were sent: ClientHello, HelloRetryRequest, ClientHello, ServerHello, EncryptedExtensions, server CertificateRequest, server Certificate, server CertificateVerify, server Finished, EndOfEarlyData, client Certificate, client CertificateVerify, client Finished."
    ],
    "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.3. Client Certificate Selection": [
        "The following rules apply to certificates sent by the client: The certificate type MUST be X.509v3 [RFC5280 Profile], unless explicitly negotiated otherwise (e.g., [RFC7250 and Datagram Transport Layer Security (DTLS)]).",
        "If the \"certificate_authorities\" extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.",
        "The certificates MUST be signed using an acceptable signature algorithm, as described in Section 4.3.2.",
        "Note that the requirement for certificates to be signed using an acceptable signature algorithm relaxes the constraints on certificate-signing algorithms found in prior versions of TLS.",
        "If the CertificateRequest message contained a non-empty \"oid_filters\" extension, the end-entity certificate MUST match the extension OIDs that are recognized by the client, as described in Section 4.2.5."
    ],
    "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.1. OCSP Status and SCT Extensions": [
        "[RFC6066] and [RFC6961] provide extensions to negotiate the server sending OCSP responses to the client.",
        "In TLS 1.2 and below, the server replies with an empty extension to indicate negotiation of this extension and the OCSP information is carried in a CertificateStatus message.",
        "In TLS 1.3, the server's OCSP information is carried in an extension in the CertificateEntry containing the associated certificate.",
        "Specifically, the body of the \"status_request\" extension from the server MUST be a CertificateStatus structure as defined in [RFC6066], which is interpreted as defined in [RFC6960].",
        "TLS 1.3 servers MUST NOT act upon the presence of the status_request_v2 extension or information in the status_request_v2 extension when processing ClientHello messages; in particular, TLS 1.3 servers MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",
        "TLS 1.3 servers MUST be able to process ClientHello messages that include the status_request_v2 extension, as the status_request_v2 extension MAY be sent by clients that wish to use the status_request_v2 extension in earlier protocol versions.",
        "A server MAY request that a client present an OCSP response with its certificate by sending an empty \"status_request\" extension in its CertificateRequest message.",
        "If the client opts to send an OCSP response, the body of the client's \"status_request\" extension MUST be a CertificateStatus structure as defined in [RFC6066].",
        "Similarly, [RFC6962] provides a mechanism for a server to send a Signed Certificate Timestamp (SCT) as an extension in the ServerHello in TLS 1.2 and below.",
        "In TLS 1.3, the server's SCT information is carried in an extension in the CertificateEntry."
    ],
    "4. Handshake Protocol -> 4.4. Authentication Messages": [
        "As discussed in Section 2, TLS generally uses a common set of messages for authentication, key confirmation, and handshake integrity: Certificate, CertificateVerify, and Finished.",
        "The Certificate, CertificateVerify, and Finished messages are always sent as the last messages in their handshake flight.",
        "The Certificate and CertificateVerify messages are only sent under certain circumstances, as defined below.",
        "The Certificate, CertificateVerify, and Finished messages are encrypted under keys derived from the sender_handshake_traffic_secret.",
        "Based on these inputs, the messages then contain: Certificate: The certificate to be used for authentication, and any supporting certificates in the chain.",
        "CertificateVerify: A signature over the value Transcript-Hash(Handshake Context, Certificate).",
        "Finished: A MAC over the value Transcript-Hash(Handshake Context, Certificate, CertificateVerify) using a MAC key derived from the Base Key.",
        "The following table defines the Handshake Context and MAC Base Key for each scenario: Server mode uses ClientHello through later messages of EncryptedExtensions or CertificateRequest with server_handshake_traffic_secret as Base Key.",
        "Client mode uses ClientHello through later messages of server Finished or EndOfEarlyData with client_handshake_traffic_secret as Base Key.",
        "Post-Handshake mode uses ClientHello through client Finished plus CertificateRequest with client_application_traffic_secret_N as Base Key.",
        "client | client_application_traffic_ | | Handshake | Finished + | secret_N | | | CertificateRequest | | +-----------+-------------------------+-----------------------------+"
    ],
    "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension": [
        "The \"pre_shared_key\" extension is used to negotiate the identity of the pre-shared key to be used with a given handshake in association with PSK key establishment.",
        "The \"extension_data\" field of the \"pre_shared_key\" extension contains a \"PreSharedKeyExtension\" value.",
        "The structure includes: PskIdentity with identity (a label for a key) and obfuscated_ticket_age; PskBinderEntry; OfferedPsks with identities and binders; and PreSharedKeyExtension which varies by handshake message type.",
        "The server MUST ensure that it selects a compatible PSK (if any) and cipher suite.",
        "Implementor's note: When session resumption is the primary use case of PSKs, the most straightforward way to implement the PSK/cipher suite matching requirements is to negotiate the cipher suite first and then exclude any incompatible PSKs.",
        "If backward compatibility is important, client-provided, externally established PSKs SHOULD influence cipher suite selection.",
        "In order to accept PSK key establishment, the server sends a \"pre_shared_key\" extension indicating the selected identity.",
        "Clients MUST verify that the server's selected_identity is within the range supplied by the client, that the server selected a cipher suite indicating a Hash associated with the PSK, and that a server \"key_share\" extension is present if required by the ClientHello \"psk_key_exchange_modes\" extension.",
        "If the server supplies an \"early_data\" extension, the client MUST verify that the server's selected_identity is 0.",
        "The \"pre_shared_key\" extension MUST be the last extension in the ClientHello (this facilitates implementation as described below).",
        "Servers MUST check that the \"pre_shared_key\" extension is the last extension and otherwise fail the handshake with an \"illegal_parameter\" alert."
    ],
    "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.4. Receiving a Certificate Message": [
        "If the server supplies an empty Certificate message, the client MUST abort the handshake with a \"decode_error\" alert.",
        "If the client does not send any certificates (i.e., it sends an empty Certificate message), the server MAY at its discretion either continue the handshake without client authentication or abort the handshake with a \"certificate_required\" alert.",
        "Any endpoint receiving any certificate which it would need to validate using any signature algorithm using an MD5 hash MUST abort the handshake with a \"bad_certificate\" alert.",
        "SHA-1 is deprecated, and it is RECOMMENDED that any endpoint receiving any certificate which it would need to validate using any signature algorithm using a SHA-1 hash abort the handshake with a \"bad_certificate\" alert.",
        "Note that a certificate containing a key for one signature algorithm MAY be signed using a different signature algorithm (for instance, an RSA key signed with an ECDSA key)."
    ],
    "4. Handshake Protocol -> 4.5. End of Early Data": [
        "If the server sent an \"early_data\" extension in EncryptedExtensions, the client MUST send an EndOfEarlyData message after receiving the server Finished.",
        "If the server does not send an \"early_data\" extension in EncryptedExtensions, then the client MUST NOT send an EndOfEarlyData message.",
        "Servers MUST NOT send the EndOfEarlyData message, and clients receiving the EndOfEarlyData message MUST terminate the connection with an \"unexpected_message\" alert."
    ],
    "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.2. Server Certificate Selection": [
        "The following rules apply to the certificates sent by the server: The certificate type MUST be X.509v3 as specified in RFC5280 Profile, unless explicitly negotiated otherwise, such as with RFC7250 and Datagram Transport Layer Security (DTLS).",
        "The server's end-entity certificate's public key and associated restrictions MUST be compatible with the selected authentication algorithm from the client's signature_algorithms extension, which currently includes RSA, ECDSA, or EdDSA.",
        "The certificate MUST allow the key to be used for signing, meaning the digitalSignature bit MUST be set if the Key Usage extension is present, with a signature scheme indicated in the client's signature_algorithms or signature_algorithms_cert extensions as described in Section 4.2.3.",
        "The server_name extension as defined in RFC6066 and the certificate_authorities extension are used to guide certificate selection.",
        "As servers MAY require the presence of the \"server_name\" extension, clients SHOULD send this extension, when applicable.",
        "All certificates provided by the server MUST be signed by a signature algorithm advertised by the client if the server is able to provide such a chain, as described in Section 4.2.3.",
        "Certificates that are self-signed or certificates that are expected to be trust anchors are not validated as part of the chain and therefore MAY be signed with any algorithm.",
        "If the server cannot produce a certificate chain that is signed only via the indicated supported algorithms, then the server SHOULD continue the handshake by sending the client a certificate chain of its choice that may include algorithms not known to be supported by the client.",
        "If the client cannot construct an acceptable chain using the provided certificates and decides to abort the handshake, then the client MUST abort the handshake with an appropriate certificate-related alert, such as unsupported_certificate by default, as detailed in Section 6.2."
    ],
    "4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication": [
        "If the client opts to do so, it MUST supply both the \"pre_shared_key\" and \"early_data\" extensions.",
        "The \"extension_data\" field of this extension contains an \"EarlyDataIndication\" value.",
        "The EarlyDataIndication structure is defined with different cases for handshake message types: for new_session_ticket it contains a max_early_data_size field, while for client_hello and encrypted_extensions it contains an empty structure.",
        "The PSK used to encrypt the early data MUST be the first PSK listed in the client's \"pre_shared_key\" extension.",
        "For PSKs provisioned via NewSessionTicket, a server MUST validate that the ticket age for the selected PSK identity (computed by subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32) is within a small tolerance of the time since the ticket was issued (see Section 8).",
        "If the ticket age is not within tolerance, the server SHOULD proceed with the handshake but reject 0-RTT, and SHOULD NOT take any other action that assumes that this ClientHello is fresh.",
        "After receiving the server's Finished message, if the server has accepted early data, an EndOfEarlyData message will be sent to indicate the key change.",
        "A server which receives an \"early_data\" extension MUST behave in one of three ways: Ignore the extension and return a regular 1-RTT response.",
        "A client MUST NOT include the \"early_data\" extension in its followup ClientHello.",
        "Return its own \"early_data\" extension in EncryptedExtensions, indicating that it intends to process the early data.",
        "In order to accept early data, the server MUST have accepted a PSK cipher suite and selected the first key offered in the client's \"pre_shared_key\" extension.",
        "In addition, the server MUST verify that the following values are the same as those associated with the selected PSK: The TLS version number, the selected cipher suite, and the selected ALPN protocol if any.",
        "Future extensions MUST define their interaction with 0-RTT.",
        "If any of these checks fail, the server MUST NOT respond with the extension and must discard all the first-flight data using one of the first two mechanisms listed above (thus falling back to 1-RTT or 2-RTT).",
        "If the server chooses to accept the \"early_data\" extension, then it MUST comply with the same error-handling requirements specified for all records when processing early data records.",
        "Specifically, if the server fails to decrypt a 0-RTT record following an accepted \"early_data\" extension, it MUST terminate the connection with a \"bad_record_mac\" alert as per Section 5.2."
    ],
    "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.2. Post-Handshake Authentication": [
        "When the client has sent the \"post_handshake_auth\" extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message.",
        "If the client chooses to authenticate, the client MUST send Certificate, CertificateVerify, and Finished messages.",
        "If the client declines, the client MUST send a Certificate message containing no certificates followed by a Finished message.",
        "A client that receives a CertificateRequest message without having sent the \"post_handshake_auth\" extension MUST send an \"unexpected_message\" fatal alert.",
        "Note: Because client authentication could involve prompting the user, servers MUST be prepared for some delay, including receiving an arbitrary number of other messages between sending the CertificateRequest and receiving a response.",
        "In addition, clients which receive multiple CertificateRequests in close succession MAY respond to them in a different order than they were received (the certificate_request_context value allows the server to disambiguate the responses)."
    ],
    "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate": [
        "The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK).",
        "The client MUST send a Certificate message if and only if the server has requested client authentication via a CertificateRequest message (Section 4.3.2).",
        "If the server requests client authentication but no suitable certificate is available, the client MUST send a Certificate message containing no certificates (i.e., with the \"certificate_list\" field having length 0).",
        "A Finished message MUST be sent regardless of whether the Certificate message is empty.",
        "The structure of the Certificate message includes: an enumeration of certificate types (X509(0), RawPublicKey(2), and others up to 255); a CertificateEntry structure that contains either an ASN.1 subjectPublicKeyInfo for RawPublicKey or certificate data for X509, along with extensions; and a Certificate structure with certificate_request_context and certificate_list fields.",
        "The certificate_request_context field contains the value from the CertificateRequest message if this message is a response to one.",
        "Otherwise, in the case of server authentication, the certificate_request_context field SHALL be zero length.",
        "The certificate_list is a sequence (chain) of CertificateEntry structures, each containing a single certificate and set of extensions.",
        "The extensions are a set of extension values for the CertificateEntry.",
        "Valid extensions for server certificates at present include the OCSP Status extension from RFC6066 and the SignedCertificateTimestamp extension from RFC6962; future extensions may be defined for this message as well.",
        "Extensions in the Certificate message from the server MUST correspond to ones from the ClientHello message.",
        "Extensions in the Certificate message from the client MUST correspond to extensions in the CertificateRequest message from the server.",
        "If an extension applies to the entire chain, it SHOULD be included in the first CertificateEntry.",
        "If the corresponding certificate type extension (\"server_certificate_type\" or \"client_certificate_type\") was not negotiated in EncryptedExtensions, or the X.509 certificate type was negotiated, then each CertificateEntry contains a DER-encoded X.509 certificate.",
        "The sender's certificate MUST come in the first CertificateEntry in the list.",
        "Each following certificate SHOULD directly certify the one immediately preceding it.",
        "Note: Prior to TLS 1.3, \"certificate_list\" ordering required each certificate to certify the one immediately preceding it; however, some implementations allowed some flexibility.",
        "For maximum compatibility, all implementations SHOULD be prepared to handle potentially extraneous certificates and arbitrary orderings from any TLS version, with the exception of the end-entity certificate which MUST be first.",
        "If the RawPublicKey certificate type was negotiated, then the certificate_list MUST contain no more than one CertificateEntry, which contains an ASN.1 subjectPublicKeyInfo value as defined in RFC7250, Section 3.",
        "The OpenPGP certificate type from RFC6091 MUST NOT be used with TLS 1.3.",
        "The server's certificate_list MUST always be non-empty.",
        "A client will send an empty certificate_list if it does not have an appropriate certificate to send in response to the server's authentication request."
    ],
    "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms": [
        "TLS 1.3 provides two extensions for indicating which signature algorithms may be used in digital signatures.",
        "The \"signature_algorithms_cert\" extension applies to signatures in certificates, and the \"signature_algorithms\" extension, which originally appeared in TLS 1.2, applies to signatures in CertificateVerify messages.",
        "The keys found in certificates MUST also be of appropriate type for the signature algorithms the keys are used with.",
        "If no \"signature_algorithms_cert\" extension is present, then the \"signature_algorithms\" extension also applies to signatures appearing in certificates.",
        "Clients which desire the server to authenticate itself via a certificate MUST send the \"signature_algorithms\" extension.",
        "If a server is authenticating via a certificate and the client has not sent a \"signature_algorithms\" extension, then the server MUST abort the handshake with a \"missing_extension\" alert (seeSection 9.2).",
        "The \"signature_algorithms_cert\" extension was added to allow implementations which supported different sets of algorithms for certificates and in TLS itself to clearly signal their capabilities.",
        "TLS 1.2 implementations SHOULD also process the \"signature_algorithms_cert\" extension.",
        "Implementations which have the same policy in both cases MAY omit the \"signature_algorithms_cert\" extension.",
        "The \"extension_data\" field of these extensions contains a SignatureSchemeList value.",
        "The RSASSA-PKCS1-v1_5 algorithm values refer solely to signatures which appear in certificates and are not defined for use in signed TLS handshake messages, although they may appear in signature algorithm extensions for backward compatibility with TLS 1.2.",
        "If the public key is carried in an X.509 certificate, the public key MUST use the rsaEncryption OID.",
        "If the public key is carried in an X.509 certificate, the public key MUST use the RSASSA-PSS OID.",
        "When used in certificate signatures, the algorithm parameters MUST be DER encoded.",
        "If the corresponding public key's parameters are present, then the parameters in the signature MUST be identical to those in the public key.",
        "The legacy algorithm values refer solely to signatures which appear in certificates and are not defined for use in signed TLS handshake messages, although they may appear in signature algorithm extensions for backward compatibility with TLS 1.2.",
        "TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it (see Section 4.4.2.2).",
        "The signatures on certificates that are self-signed or certificates that are trust anchors are not validated, since they begin a certification path.",
        "A certificate that begins a certification path MAY use a signature algorithm that is not advertised as being supported in the \"signature_algorithms\" extension.",
        "Note that TLS 1.2 defines the signature algorithm extension differently.",
        "In particular: TLS 1.2 ClientHellos MAY omit the signature algorithm extension.",
        "In TLS 1.2, the signature algorithm extension contained hash/signature pairs.",
        "If TLS 1.2 is negotiated, implementations MUST be prepared to accept a signature that uses any curve that they advertised in the \"supported_groups\" extension.",
        "Implementations that advertise support for RSASSA-PSS MUST be prepared to accept a signature using that scheme even when TLS 1.2 is negotiated.",
        "In TLS 1.2, RSASSA-PSS is used with RSA cipher suites."
    ],
    "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.4. Finished": [
        "Recipients of Finished messages MUST verify that the contents are correct and if incorrect MUST terminate the connection with a \"decrypt_error\" alert.",
        "The verify_data value is computed as follows: verify_data = HMAC(finished_key, Transcript-Hash(Handshake Context, Certificate*, CertificateVerify*)), where * indicates only included if present.",
        "Any records following a Finished message MUST be encrypted under the appropriate application traffic key as described in Section 7.2.",
        "In particular, this requirement includes any alerts sent by the server in response to client Certificate and CertificateVerify messages."
    ],
    "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update": [
        "The KeyUpdate message can be sent by either peer after the peer has sent a Finished message.",
        "Implementations that receive a KeyUpdate message prior to receiving a Finished message MUST terminate the connection with an \"unexpected_message\" alert.",
        "After sending a KeyUpdate message, the sender SHALL send all its traffic using the next generation of keys, computed as described in Section 7.2.",
        "Upon receiving a KeyUpdate, the receiver MUST update its receiving keys.",
        "The KeyUpdate structure contains a request_update field that indicates whether the recipient of the KeyUpdate should respond with its own KeyUpdate.",
        "If an implementation receives any other value for request_update, the implementation MUST terminate the connection with an \"illegal_parameter\" alert.",
        "If the request_update field is set to \"update_requested\", then the receiver MUST send a KeyUpdate of its own with request_update set to \"update_not_requested\" prior to sending its next Application Data record.",
        "Note that implementations may receive an arbitrary number of messages between sending a KeyUpdate with request_update set to \"update_requested\" and receiving the peer's KeyUpdate, because those messages may already be in flight.",
        "If implementations independently send their own KeyUpdates with request_update set to \"update_requested\" and the KeyUpdates cross in flight, then each side will also send a response, with the result that each side increments by two generations.",
        "Both sender and receiver MUST encrypt their KeyUpdate messages with the old keys.",
        "Additionally, both sides MUST enforce that a KeyUpdate with the old key is received before accepting any messages encrypted with the new key."
    ],
    "5. Record Protocol": [
        "An implementation may receive an unencrypted record of type change_cipher_spec consisting of the single byte value 0x01 at any time after the first ClientHello message has been sent or received and before the peer's Finished message has been received and MUST simply drop the change_cipher_spec record without further processing.",
        "If an implementation detects a change_cipher_spec record received before the first ClientHello message or after the peer's Finished message, the change_cipher_spec record MUST be treated as an unexpected record type (though stateless servers may not be able to distinguish these cases from allowed cases).",
        "Implementations MUST NOT send record types not defined in this document unless negotiated by some extension."
    ],
    "7. Cryptographic Computations": [
        "Note that because the handshake transcript includes the random values from the Hello messages, any given handshake will have different traffic secrets, even if the same input secrets are used, as is the case when the same PSK is used for multiple connections."
    ],
    "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify": [
        "The CertificateVerify message also provides integrity for the handshake up to this point.",
        "Servers MUST send this message when authenticating via a certificate.",
        "Clients MUST send this message whenever authenticating via a certificate (i.e., when the Certificate message is non-empty).",
        "When sent, this message MUST appear immediately after the Certificate message and immediately prior to the Finished message.",
        "The structure of the CertificateVerify message is: struct { SignatureScheme algorithm; opaque signature<0..2^16-1>; } CertificateVerify.",
        "The content covered under the signature is the hash output as described in Section 4.4.1, namely: Transcript-Hash(Handshake Context, Certificate).",
        "This structure is intended to prevent an attack on previous versions of TLS in which the ServerKeyExchange format meant that attackers could obtain a signature of a message with a chosen 32-byte prefix (ClientHello.random).",
        "The context string for a server signature is \"TLS 1.3, server CertificateVerify\".",
        "The context string for a client signature is \"TLS 1.3, client CertificateVerify\".",
        "The context string is used to provide separation between signatures made in different contexts, helping against potential cross-protocol attacks.",
        "For example, if the transcript hash was 32 bytes of 01 (this length would make sense for SHA-256), the content covered by the digital signature for a server CertificateVerify would be: 2020202020202020202020202020202020202020202020202020202020202020 2020202020202020202020202020202020202020202020202020202020202020 544c5320312e332c207365727665722043657274696669636174655665726966 79 00 0101010101010101010101010101010101010101010101010101010101010101.",
        "On the sender side, the process for computing the signature field of the CertificateVerify message takes as input: the content covered by the digital signature, and the private signing key corresponding to the certificate sent in the previous message.",
        "If the CertificateVerify message is sent by a server, the signature algorithm MUST be one offered in the client's \"signature_algorithms\" extension unless no valid certificate chain can be produced without unsupported algorithms (see Section 4.2.3).",
        "If sent by a client, the signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the \"signature_algorithms\" extension in the CertificateRequest message.",
        "In addition, the signature algorithm MUST be compatible with the key in the sender's end-entity certificate.",
        "RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in \"signature_algorithms\".",
        "The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages.",
        "All SHA-1 signature algorithms in this specification are defined solely for use in legacy certificates and are not valid for CertificateVerify signatures.",
        "The receiver of a CertificateVerify message MUST verify the signature field.",
        "The verification process takes as input: the content covered by the digital signature, the public key contained in the end-entity certificate found in the associated Certificate message, and the digital signature received in the signature field of the CertificateVerify message."
    ],
    "5. Record Protocol -> 5.4. Record Padding": [
        "Later documents may define padding selection algorithms or define a padding policy request mechanism through TLS extensions or some other means."
    ],
    "6. Alert Protocol": [
        "The AlertDescription enumeration includes various alert types such as close_notify(0), unexpected_message(10), bad_record_mac(20), record_overflow(22), handshake_failure(40), bad_certificate(42), unsupported_certificate(43), certificate_revoked(44), certificate_expired(45), certificate_unknown(46), illegal_parameter(47), unknown_ca(48), access_denied(49), decode_error(50), decrypt_error(51), protocol_version(70), insufficient_security(71), internal_error(80), inappropriate_fallback(86), user_canceled(90), missing_extension(109), unsupported_extension(110), unrecognized_name(112), bad_certificate_status_response(113), unknown_psk_identity(115), certificate_required(116), and no_application_protocol(120)."
    ],
    "5. Record Protocol -> 5.1. Record Layer": [
        "Because the ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate messages can immediately precede a key change, implementations MUST send these messages in alignment with a record boundary.",
        "legacy_record_version MUST be set to 0x0303 for all records generated by a TLS 1.3 implementation other than an initial ClientHello, which is one not generated after a HelloRetryRequest, where legacy_record_version MAY also be 0x0301 for compatibility purposes.",
        "In order to maximize backward compatibility, a record containing an initial ClientHello SHOULD have legacy_record_version 0x0301, reflecting TLS 1.0, and a record containing a second ClientHello or a ServerHello MUST have legacy_record_version 0x0303, reflecting TLS 1.2."
    ],
    "9. Compliance Requirements -> 9.1. Mandatory-to-Implement Cipher Suites": [
        "In the absence of an application profile standard specifying otherwise: A TLS-compliant application MUST implement the TLS_AES_128_GCM_SHA256 cipher suite and SHOULD implement the TLS_AES_256_GCM_SHA384 and TLS_CHACHA20_POLY1305_SHA256 cipher suites (see Appendix B.4).",
        "A TLS-compliant application MUST support digital signatures with rsa_pkcs1_sha256 (for certificates), rsa_pss_rsae_sha256 (for CertificateVerify and certificates), and ecdsa_secp256r1_sha256."
    ],
    "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message": [
        "At any time after the server has received the client Finished message, the server MAY send a NewSessionTicket message.",
        "The NewSessionTicket message creates a unique association between the ticket value and a secret PSK derived from the resumption master secret (see Section 7).",
        "The client MAY use the PSK derived from the ticket for future handshakes by including the ticket value in the \"pre_shared_key\" extension in its ClientHello (Section 4.2.11).",
        "Any ticket MUST only be resumed with a cipher suite that has the same KDF hash algorithm as that used to establish the original connection.",
        "Clients MUST only resume if the new SNI value is valid for the server certificate presented in the original session and SHOULD only resume if the SNI value matches the one used in the original session.",
        "The requirement to match the SNI value is a performance optimization: normally, there is no reason to expect that different servers covered by a single certificate would be able to accept each other's tickets; hence, attempting resumption in that case would waste a single-use ticket.",
        "If an indication is provided that different servers covered by a single certificate can accept each other's tickets (externally or by any other means), clients MAY resume with a different SNI value.",
        "On resumption, if reporting an SNI value to the calling application, implementations MUST use the value sent in the resumption ClientHello rather than the value sent in the previous session.",
        "Although the resumption master secret depends on the client's second flight, a server which does not request client authentication MAY compute the remainder of the transcript independently and then send a NewSessionTicket immediately upon sending its Finished rather than waiting for the client Finished.",
        "The NewSessionTicket structure contains: ticket_lifetime indicates the lifetime in seconds as a 32-bit unsigned integer in network byte order from the time of ticket issuance.",
        "Clients MUST NOT cache tickets for longer than 7 days, regardless of the ticket_lifetime, and MAY delete tickets earlier based on local policy.",
        "A server MAY treat a ticket as valid for a shorter period of time than what is stated in the ticket_lifetime.",
        "ticket_age_add is a securely generated, random 32-bit value that is used to obscure the age of the ticket that the client includes in the \"pre_shared_key\" extension.",
        "extensions is a set of extension values for the ticket.",
        "Clients MUST ignore unrecognized extensions.",
        "The sole extension currently defined for NewSessionTicket is \"early_data\", indicating that the ticket may be used to send 0-RTT data (Section 4.2.10).",
        "Because the ticket_nonce value is distinct for each NewSessionTicket message, a different PSK will be derived for each ticket.",
        "It is RECOMMENDED that implementations place limits on the total lifetime of keying material derived from an initial non-PSK handshake; these limits should take into account the lifetime of the peer's certificate, the likelihood of intervening revocation, and the time since the peer's online CertificateVerify signature."
    ],
    "5. Record Protocol -> 5.2. Record Payload Protection": [
        "Note that the handshake protocol, including the ClientHello and ServerHello messages, authenticates the protocol version, so the legacy_record_version field is redundant."
    ],
    "8. 0-RTT and Anti-Replay -> 8.3. Freshness Checks": [
        "The server can determine the client's view of the age of the ticket by subtracting the ticket's \"ticket_age_add\" value from the \"obfuscated_ticket_age\" parameter in the client's \"pre_shared_key\" extension.",
        "When a new ClientHello is received, the expected_arrival_time is then compared against the current server wall clock time and if the times differ by more than a certain amount, 0-RTT is rejected, though the 1-RTT handshake can be allowed to complete.",
        "Both the NewSessionTicket and ClientHello messages might be retransmitted and therefore delayed, which might be hidden by TCP."
    ],
    "8. 0-RTT and Anti-Replay": [
        "Such a guarantee can be accomplished by locally recording data from recently received ClientHellos and rejecting repeats, or by any other method that provides the same or a stronger guarantee."
    ],
    "6. Alert Protocol -> 6.2. Error Alerts": [
        "bad_certificate: A certificate was corrupt, contained signatures that did not verify correctly, etc.",
        "unknown_ca: A valid certificate chain or partial chain was received, but the certificate was not accepted because the CA certificate could not be located or could not be matched with a known trust anchor.",
        "decrypt_error: A handshake (not record layer) cryptographic operation failed, including being unable to correctly verify a signature or validate a Finished message or a PSK binder.",
        "unsupported_extension: Sent by endpoints receiving any handshake message containing an extension known to be prohibited for inclusion in the given handshake message, or including any extensions in a ServerHello or Certificate not first offered in the corresponding ClientHello or CertificateRequest.",
        "unrecognized_name: Sent by servers when no server exists identified by the name provided by the client via the \"server_name\" extension (see RFC6066 Extensions: Extension Definitions).",
        "bad_certificate_status_response: Sent by clients when an invalid or unacceptable OCSP response is provided by the server via the \"status_request\" extension (see RFC6066 Extensions: Extension Definitions).",
        "no_application_protocol: Sent by servers when a client \"application_layer_protocol_negotiation\" extension advertises only protocols that the server does not support (see RFC7301 Application-Layer Protocol Negotiation Extension)."
    ],
    "9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions": [
        "In the absence of an application profile standard specifying otherwise, a TLS-compliant application MUST implement the following TLS extensions: Supported Versions (\"supported_versions\"; Section 4.2.1), Cookie (\"cookie\"; Section 4.2.2), Signature Algorithms (\"signature_algorithms\"; Section 4.2.3), Signature Algorithms Certificate (\"signature_algorithms_cert\"; Section 4.2.3), Negotiated Groups (\"supported_groups\"; Section 4.2.7), Key Share (\"key_share\"; Section 4.2.8), and Server Name Indication (\"server_name\"; Section 3 of RFC6066).",
        "All implementations MUST send and use these extensions when offering applicable features: \"supported_versions\" is REQUIRED for all ClientHello, ServerHello, and HelloRetryRequest messages.",
        "\"signature_algorithms\" is REQUIRED for certificate authentication.",
        "\"supported_groups\" is REQUIRED for ClientHello messages using DHE or ECDHE key exchange.",
        "\"key_share\" is REQUIRED for DHE or ECDHE key exchange.",
        "\"pre_shared_key\" is REQUIRED for PSK key agreement.",
        "\"psk_key_exchange_modes\" is REQUIRED for PSK key agreement.",
        "A client is considered to be attempting to negotiate using this specification if the ClientHello contains a \"supported_versions\" extension with 0x0304 contained in its body.",
        "Such a ClientHello message MUST meet the following requirements: If not containing a \"pre_shared_key\" extension, it MUST contain both a \"signature_algorithms\" extension and a \"supported_groups\" extension.",
        "If containing a \"supported_groups\" extension, it MUST also contain a \"key_share\" extension, and vice versa.",
        "Servers receiving a ClientHello which does not conform to these requirements MUST abort the handshake with a \"missing_extension\" alert.",
        "Additionally, all implementations MUST support the use of the \"server_name\" extension with applications capable of using it.",
        "Servers MAY require clients to send a valid \"server_name\" extension.",
        "Servers requiring this extension SHOULD respond to a ClientHello lacking a \"server_name\" extension by terminating the connection with a \"missing_extension\" alert."
    ],
    "8. 0-RTT and Anti-Replay -> 8.2. Client Hello Recording": [
        "An alternative form of anti-replay is to record a unique value derived from the ClientHello (generally either the random value or the PSK binder) and reject duplicates.",
        "If the expected_arrival_time is in the window, then the server checks to see if it has recorded a matching ClientHello.",
        "If a matching ClientHello is found, the server either aborts the handshake with an \"illegal_parameter\" alert or accepts the PSK but rejects 0-RTT.",
        "If no matching ClientHello is found, then the server accepts 0-RTT and then stores the ClientHello for as long as the expected_arrival_time is inside the window.",
        "The server MUST derive the storage key only from validated sections of the ClientHello.",
        "If the ClientHello contains multiple PSK identities, then an attacker can create multiple ClientHellos with different binder values for the less-preferred identity on the assumption that the server will not verify the less-preferred identity (as recommended by Section 4.2.11).",
        "If the binder for B is part of the storage key, then this ClientHello will not appear as a duplicate, which will cause the ClientHello to be accepted, and may cause side effects such as replay cache pollution, although any 0-RTT data will not be decryptable because the data will use different keys.",
        "If the validated binder or the ClientHello.random is used as the storage key, then this attack is not possible.",
        "Because this mechanism does not require storing all outstanding tickets, it may be easier to implement in distributed systems with high rates of resumption and 0-RTT, at the cost of potentially weaker anti-replay defense because of the difficulty of reliably storing and retrieving the received ClientHello messages."
    ],
    "7. Cryptographic Computations -> 7.1. Key Schedule": [
        "The key derivation schedule is: PSK -> HKDF-Extract = Early Secret -> Derive-Secret(., \"ext binder\" or \"res binder\", \"\") = binder_key -> Derive-Secret(., \"c e traffic\", ClientHello) = client_early_traffic_secret -> Derive-Secret(., \"e exp master\", ClientHello) = early_exporter_master_secret -> Derive-Secret(., \"derived\", \"\") -> (EC)DHE -> HKDF-Extract = Handshake Secret -> Derive-Secret(., \"c hs traffic\", ClientHello...ServerHello) = client_handshake_traffic_secret -> Derive-Secret(., \"s hs traffic\", ClientHello...ServerHello) = server_handshake_traffic_secret -> Derive-Secret(., \"derived\", \"\") -> 0 -> HKDF-Extract = Master Secret -> Derive-Secret(., \"c ap traffic\", ClientHello...server Finished) = client_application_traffic_secret_0 -> Derive-Secret(., \"s ap traffic\", ClientHello...server Finished) = server_application_traffic_secret_0 -> Derive-Secret(., \"exp master\", ClientHello...server Finished) = exporter_master_secret -> Derive-Secret(., \"res master\", ClientHello...client Finished) = resumption_master_secret."
    ],
    "9. Compliance Requirements -> 9.3. Protocol Invariants": [
        "For this to work, implementations MUST correctly handle extensible fields: A client sending a ClientHello MUST support all parameters advertised in the ClientHello.",
        "A server receiving a ClientHello MUST correctly ignore all unrecognized cipher suites, extensions, and other parameters.",
        "In TLS 1.3, a client receiving a CertificateRequest or NewSessionTicket MUST also ignore all unrecognized extensions.",
        "A middlebox which terminates a TLS connection MUST behave as a compliant TLS server (to the original client), including having a certificate which the client is willing to accept, and also as a compliant TLS client (to the original server), including verifying the original server's certificate.",
        "In particular, the middlebox MUST generate its own ClientHello containing only parameters the middlebox understands, and the middlebox MUST generate a fresh ServerHello random value, rather than forwarding the endpoint's value.",
        "A middlebox which forwards ClientHello parameters the middlebox does not understand MUST NOT process any messages beyond that ClientHello."
    ],
    "11. IANA Considerations": [
        "IANA has added the cipher suites listed in Appendix B.4 to the registry.",
        "IANA has updated the TLS ExtensionType Values registry to include the key_share, pre_shared_key, psk_key_exchange_modes, early_data, cookie, supported_versions, certificate_authorities, oid_filters, post_handshake_auth, and signature_algorithms_cert extensions with the values defined in this document and the Recommended value of Y.",
        "IANA has updated the TLS ExtensionType Values registry to include a TLS 1.3 column which lists the messages in which the extension may appear.",
        "This document updates an entry in the TLS Certificate Status Types registry originally created in RFC6961 Multiple Certificate Status Request Extension."
    ]
}