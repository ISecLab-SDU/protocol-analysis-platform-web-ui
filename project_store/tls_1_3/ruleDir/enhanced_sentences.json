[
  {
    "heading": "1. Introduction -> 1.3. Updates Affecting TLS 1.2",
    "sentence": "The \"supported_versions\" ClientHello extension can be used to negotiate the version of TLS to use, in preference to the legacy_version field of the ClientHello.",
    "enhanced_sentence": "During the TLS handshake initiation, when a client sends a ClientHello message, the \"supported_versions\" extension (if present) takes precedence over the legacy_version field for negotiating the TLS protocol version. This rule applies specifically to TLS 1.2 and later implementations, requiring both endpoints to support the extension mechanism. The expected outcome is that the highest mutually supported TLS version indicated in the extension will be selected, ensuring proper version negotiation even when the legacy_version field contains an older or incompatible value. This behavior provides a more robust version selection mechanism than the legacy field alone.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"1. Introduction -> 1.3. Updates Affecting TLS 1.2\"\nRule: The \"supported_versions\" ClientHello extension can be used to negotiate the version of TLS to use, in preference to the legacy_version field of the ClientHello.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview -> 2.3. 0-RTT Data",
    "sentence": "The asterisk indicates optional or situation-dependent messages or extensions that are not always sent.",
    "enhanced_sentence": "The asterisk indicates optional or situation-dependent messages or extensions that are not always sent. This notation specifically applies to the 0-RTT handshake flow where certain elements—such as the early_data extension in the ClientHello or ServerHello messages—are only included when early data is being used. The rule governs how protocol diagrams should be interpreted, clarifying that starred items are conditional on factors like PSK availability, client configuration, or server acceptance of 0-RTT data. Proper application ensures correct implementation of optional features without assuming their presence in every handshake, maintaining interoperability and adherence to the protocol’s flexibility design.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview -> 2.3. 0-RTT Data\"\nRule: The asterisk indicates optional or situation-dependent messages or extensions that are not always sent.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview -> 2.1. Incorrect DHE Share",
    "sentence": "The server then sends ServerHello with key_share, EncryptedExtensions, CertificateRequest, Certificate, CertificateVerify, and Finished.",
    "enhanced_sentence": "This rule applies when the server has successfully negotiated cryptographic parameters after a HelloRetryRequest exchange due to an initial key_share mismatch. Following the client's second ClientHello with an appropriate key_share extension, the server MUST respond with a complete handshake sequence: ServerHello (containing the negotiated key_share), EncryptedExtensions, optional CertificateRequest (if client authentication is required), Certificate (server's certificate), CertificateVerify (signature over the handshake transcript), and Finished (to verify handshake integrity). This sequence enables the establishment of a secure connection, allowing subsequent client authentication messages and application data exchange. The handshake transcript MUST include all previous messages (initial ClientHello and HelloRetryRequest) without reset.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview -> 2.1. Incorrect DHE Share\"\nRule: The server then sends ServerHello with key_share, EncryptedExtensions, CertificateRequest, Certificate, CertificateVerify, and Finished.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview -> 2.1. Incorrect DHE Share",
    "sentence": "The client responds with Certificate, CertificateVerify, and Finished, after which application data can be exchanged.",
    "enhanced_sentence": "This rule governs the client's response behavior in a TLS 1.3 full handshake after a HelloRetryRequest due to a mismatched \"key_share\" extension. It applies when the server has sent ServerHello, EncryptedExtensions, CertificateRequest, Certificate, CertificateVerify, and Finished. The client must respond with Certificate (if requested), CertificateVerify (to authenticate the certificate), and Finished (to verify handshake integrity). Prerequisites include successful negotiation of cryptographic parameters and a valid server CertificateVerify. After these messages are exchanged and verified, both parties have established authenticated encryption, allowing secure application data exchange. The handshake transcript includes all previous messages (initial ClientHello and HelloRetryRequest) for continuity.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview -> 2.1. Incorrect DHE Share\"\nRule: The client responds with Certificate, CertificateVerify, and Finished, after which application data can be exchanged.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview -> 2.1. Incorrect DHE Share",
    "sentence": "The message flow for a full handshake with mismatched parameters involves the client sending a ClientHello with key_share, the server responding with a HelloRetryRequest and key_share, followed by the client sending another ClientHello with key_share.",
    "enhanced_sentence": "This rule governs the TLS 1.3 handshake correction mechanism when the client's initial \"key_share\" extension contains only Diffie-Hellman groups that are unsupported or unacceptable to the server. The rule applies when the server receives a ClientHello with an insufficient key_share but determines that a common cryptographic parameter set exists. The expected outcome is that the server sends a HelloRetryRequest containing its supported group in the key_share extension, prompting the client to send a new ClientHello with a compatible key_share. This exchange preserves the handshake transcript integrity by incorporating both the initial and retry messages. If no common parameters exist, the server must instead abort the handshake with an appropriate alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview -> 2.1. Incorrect DHE Share\"\nRule: The message flow for a full handshake with mismatched parameters involves the client sending a ClientHello with key_share, the server responding with a HelloRetryRequest and key_share, followed by the client sending another ClientHello with key_share.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview -> 2.3. 0-RTT Data",
    "sentence": "The client then sends EndOfEarlyData and Finished, after which both parties exchange Application Data.",
    "enhanced_sentence": "When a TLS 1.3 client and server share a pre-shared key (PSK) and the client has sent early data in the first flight of a 0-RTT handshake, the client must send an EndOfEarlyData message to signal the end of early data transmission, followed by a Finished message to complete the handshake authentication. After both messages are sent and verified, both parties may securely exchange standard Application Data using keys derived from the full handshake. This rule applies only after the server has responded with ServerHello, EncryptedExtensions (including the early_data extension), and its own Finished message. Adherence to this sequence ensures proper cryptographic separation between early data and post-handshake application traffic, maintaining protocol integrity and forward secrecy for subsequent data exchanges.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview -> 2.3. 0-RTT Data\"\nRule: The client then sends EndOfEarlyData and Finished, after which both parties exchange Application Data.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview -> 2.3. 0-RTT Data",
    "sentence": "The server responds with a ServerHello containing pre_shared_key and key_share extensions, followed by EncryptedExtensions with early_data, and Finished.",
    "enhanced_sentence": "This rule governs the server's response in a TLS 1.3 0-RTT handshake when a client has sent early data using a pre-shared key (PSK). It applies immediately after the client sends a ClientHello with early_data, key_share, psk_key_exchange_modes, and pre_shared_key extensions, along with optional 0-RTT application data. The expected outcome is that the server acknowledges and accepts the early data by including the early_data extension in EncryptedExtensions, while also completing the cryptographic handshake via ServerHello (with pre_shared_key and key_share extensions) and Finished. Prerequisites include a valid shared PSK between client and server, and the client’s willingness to use 0-RTT. Note that 0-RTT data has weaker security properties (non-forward-secrecy and potential replay risks) compared to standard handshake data.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview -> 2.3. 0-RTT Data\"\nRule: The server responds with a ServerHello containing pre_shared_key and key_share extensions, followed by EncryptedExtensions with early_data, and Finished.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview -> 2.3. 0-RTT Data",
    "sentence": "The plus symbol indicates noteworthy extensions sent in the previously noted message.",
    "enhanced_sentence": "The plus symbol (+) denotes that the associated message includes noteworthy extensions that were previously mentioned in the protocol description. This notation applies specifically to the 0-RTT handshake flow, where it highlights critical extensions (such as early_data, key_share, psk_key_exchange_modes, and pre_shared_key) that enable early data transmission. The expected outcome is clear identification of these extensions within message diagrams, ensuring developers recognize their role in PSK-based authentication and encryption of 0-RTT data. Prerequisites include an established PSK (externally or from a prior handshake) and adherence to the 0-RTT message sequence as defined in TLS 1.3.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview -> 2.3. 0-RTT Data\"\nRule: The plus symbol indicates noteworthy extensions sent in the previously noted message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview -> 2.3. 0-RTT Data",
    "sentence": "The client sends a ClientHello with early_data, key_share, psk_key_exchange_modes, and pre_shared_key extensions, along with optional Application Data.",
    "enhanced_sentence": "When a client and server share a pre-shared key (PSK) from a previous handshake or external source, the client may send 0-RTT data in the first flight to reduce latency. To do this, the client MUST send a ClientHello message that includes the following extensions: early_data (to indicate support for 0-RTT), key_share (for forward secrecy in the resumed handshake), psk_key_exchange_modes (to specify acceptable PSK-based key exchange methods), and pre_shared_key (to identify the PSK). Additionally, the client MAY include optional Application Data encrypted using keys derived from the PSK. This data is sent before the handshake completes and is subject to weaker security properties, including lack of forward secrecy and replay protection. The server must validate the PSK and decide whether to accept or reject the early data based on its replay mitigation policies.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview -> 2.3. 0-RTT Data\"\nRule: The client sends a ClientHello with early_data, key_share, psk_key_exchange_modes, and pre_shared_key extensions, along with optional Application Data.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "1. Introduction -> 1.3. Updates Affecting TLS 1.2",
    "sentence": "The \"signature_algorithms_cert\" extension allows a client to indicate which signature algorithms the client can validate in X.509 certificates.",
    "enhanced_sentence": "The \"signature_algorithms_cert\" extension, when included by a client in the ClientHello message, explicitly communicates the set of signature algorithms (e.g., RSA-PSS, ECDSA) that the client is capable of validating for X.509 certificates presented by the server during the handshake. This rule applies during the TLS 1.2 or 1.3 handshake negotiation phase and requires that the client supports at least one commonly acceptable algorithm. The expected outcome is that the server selects a certificate chain whose leaf certificate and any necessary intermediate certificates are signed using one of the client-advertised algorithms, ensuring successful client validation and avoiding handshake failures due to unsupported signatures. This extension is optional but recommended for interoperability, especially when non-default algorithms are in use.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"1. Introduction -> 1.3. Updates Affecting TLS 1.2\"\nRule: The \"signature_algorithms_cert\" extension allows a client to indicate which signature algorithms the client can validate in X.509 certificates.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol",
    "sentence": "The handshake protocol defines an enumeration of handshake types including client_hello, server_hello, new_session_ticket, end_of_early_data, encrypted_extensions, certificate, certificate_request, certificate_verify, finished, key_update, and message_hash.",
    "enhanced_sentence": "The handshake protocol defines an enumeration of handshake types (client_hello, server_hello, new_session_ticket, end_of_early_data, encrypted_extensions, certificate, certificate_request, certificate_verify, finished, key_update, and message_hash) that are used to negotiate the security parameters of a TLS 1.3 connection. This rule applies throughout the handshake phase, where each message must be encapsulated in a TLSPlaintext or TLSCiphertext structure and transmitted in the strict order specified in Section 4.4.1. The expected outcome is proper progression of the handshake; any deviation in message order must result in termination of the handshake with an \"unexpected_message\" alert. Prerequisites include an established connection state capable of processing handshake messages, and any new handshake types must be assigned through IANA as described in Section 11.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol\"\nRule: The handshake protocol defines an enumeration of handshake types including client_hello, server_hello, new_session_ticket, end_of_early_data, encrypted_extensions, certificate, certificate_request, certificate_verify, finished, key_update, and message_hash.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview -> 2.1. Incorrect DHE Share",
    "sentence": "If the client has not provided a sufficient \"key_share\" extension (e.g., the extension includes only DHE or ECDHE groups unacceptable to or unsupported by the server), the server corrects the mismatch with a HelloRetryRequest and the client needs to restart the handshake with an appropriate \"key_share\" extension.",
    "enhanced_sentence": "This rule governs the server's response when a client's initial ClientHello message contains an insufficient \"key_share\" extension—specifically, when the offered Diffie-Hellman (DHE or ECDHE) groups are either unsupported by or unacceptable to the server. The rule applies during the initial handshake negotiation phase, after the server receives the ClientHello but before any key exchange or authentication occurs. If the server determines that a common group can be negotiated, it MUST send a HelloRetryRequest containing a \"key_share\" extension indicating its preferred group(s), prompting the client to restart the handshake with a new ClientHello that includes a conforming key share. The expected outcome is a successful handshake continuation with mutually supported parameters. This rule does not apply if no common cryptographic parameters exist; in such cases, the server MUST abort the handshake with an appropriate alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview -> 2.1. Incorrect DHE Share\"\nRule: If the client has not provided a sufficient \"key_share\" extension (e.g., the extension includes only DHE or ECDHE groups unacceptable to or unsupported by the server), the server corrects the mismatch with a HelloRetryRequest and the client needs to restart the handshake with an appropriate \"key_share\" extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "3. Presentation Language -> 3.5. Enumerateds",
    "sentence": "Future extensions or additions to the protocol may define new values.",
    "enhanced_sentence": "When defining enumerated types in the TLS 1.3 protocol, future extensions or additions may introduce new values beyond those currently specified. This rule applies during the parsing and interpretation of enumerated fields in protocol messages, such as during handshake negotiation or extension processing. Implementations must be able to parse and ignore unknown enumerated values unless explicitly stated otherwise in the field's definition, ensuring backward compatibility. The expected outcome is that new enumerated values can be introduced without breaking existing implementations, provided they follow the protocol's extensibility guidelines. Prerequisites include proper handling of enumerated value ranges and adherence to the specified data size constraints for each enumerated type.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"3. Presentation Language -> 3.5. Enumerateds\"\nRule: Future extensions or additions to the protocol may define new values.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.6. Post-Handshake Client Authentication",
    "sentence": "Servers MUST NOT send this extension.",
    "enhanced_sentence": "The \"post_handshake_auth\" extension is used by clients to indicate willingness to perform post-handshake authentication. This rule applies during the handshake protocol when extensions are negotiated. Servers MUST NOT send this extension under any circumstances, as it is defined only for client use. The expected outcome is that servers will never include this extension in their messages, ensuring proper role separation and preventing protocol misuse. The extension structure is empty (zero-length extension_data), and servers must only rely on client-provided extensions when deciding to send post-handshake CertificateRequests.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.6. Post-Handshake Client Authentication\"\nRule: Servers MUST NOT send this extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview -> 2.2. Resumption and Pre-Shared Key (PSK)",
    "sentence": "When a client offers resumption via a PSK, it SHOULD also supply a \"key_share\" extension to the server to allow the server to decline resumption and fall back to a full handshake, if needed.",
    "enhanced_sentence": "When a client initiates a resumption handshake by offering a PSK (established in a previous connection), it SHOULD also include a \"key_share\" extension in its ClientHello message. This allows the server to optionally decline PSK-based resumption—for example, if it requires forward secrecy or cannot validate the PSK—and fall back to a full (EC)DHE handshake. The client’s inclusion of a key_share ensures that the handshake can proceed without an additional round trip, maintaining protocol efficiency even if resumption is not accepted. This rule applies specifically to TLS 1.3 handshakes where a PSK is presented for resumption and is intended to support seamless negotiation between abbreviated and full handshake modes.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview -> 2.2. Resumption and Pre-Shared Key (PSK)\"\nRule: When a client offers resumption via a PSK, it SHOULD also supply a \"key_share\" extension to the server to allow the server to decline resumption and fall back to a full handshake, if needed.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview -> 2.2. Resumption and Pre-Shared Key (PSK)",
    "sentence": "As the server is authenticating via a PSK, it does not send a Certificate or a CertificateVerify message.",
    "enhanced_sentence": "When a TLS 1.3 server authenticates using a pre-shared key (PSK), either established in a previous session or provisioned out-of-band, it MUST omit the Certificate and CertificateVerify messages. This rule applies during the handshake phase when the server accepts a client's PSK offer, as the PSK itself serves as the authentication mechanism, eliminating the need for certificate-based authentication. The expected outcome is a streamlined handshake with reduced message exchange, while maintaining cryptographic security tied to the original PSK establishment. This behavior is conditional on the server successfully validating the client's PSK binder and agreeing to use PSK key establishment. Note that if forward secrecy is desired, the server should also perform an (EC)DHE key exchange in conjunction with the PSK.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview -> 2.2. Resumption and Pre-Shared Key (PSK)\"\nRule: As the server is authenticating via a PSK, it does not send a Certificate or a CertificateVerify message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview -> 2.2. Resumption and Pre-Shared Key (PSK)",
    "sentence": "The server responds with a \"pre_shared_key\" extension to negotiate the use of PSK key establishment and can (as shown here) respond with a \"key_share\" extension to do (EC)DHE key establishment, thus providing forward secrecy.",
    "enhanced_sentence": "This rule applies during the TLS 1.3 handshake when a client offers resumption via a PSK and includes a \"key_share\" extension. The server must respond with a \"pre_shared_key\" extension to confirm PSK-based key establishment. Additionally, the server may include a \"key_share\" extension to combine PSK with (EC)DHE key exchange, ensuring forward secrecy for the session. This dual extension response occurs only if the server accepts the PSK and opts for forward secrecy. The expected outcome is a resumed session that maintains cryptographic ties to the original connection while providing forward secrecy through ephemeral key exchange. Prerequisites include a previously established PSK from an initial handshake and the client's provision of both PSK identity and \"key_share\" extension in its ClientHello.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview -> 2.2. Resumption and Pre-Shared Key (PSK)\"\nRule: The server responds with a \"pre_shared_key\" extension to negotiate the use of PSK key establishment and can (as shown here) respond with a \"key_share\" extension to do (EC)DHE key establishment, thus providing forward secrecy.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview -> 2.3. 0-RTT Data",
    "sentence": "Protection against replay for ordinary TLS 1.3 1-RTT data is provided via the server's Random value, but 0-RTT data does not depend on the ServerHello and therefore has weaker guarantees.",
    "enhanced_sentence": "This rule governs the replay protection mechanisms for 0-RTT data in TLS 1.3, which applies when a client sends early data in the first flight using a pre-shared key (PSK) from a previous session or external source. Unlike 1-RTT data, which is protected against replay by incorporating the server's Random value from the ServerHello, 0-RTT data is encrypted and sent before the ServerHello is received, making it independent of server-generated randomness. As a result, 0-RTT data lacks inter-connection replay guarantees and is only protected against duplication within the same connection. The expected outcome is that 0-RTT data may be vulnerable to replay attacks across different connections, and servers must implement additional anti-replay measures (as described in Section 8) if the application requires stronger security. This rule applies only when early data is enabled via the early_data extension and the client and server share a valid PSK.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview -> 2.3. 0-RTT Data\"\nRule: Protection against replay for ordinary TLS 1.3 1-RTT data is provided via the server's Random value, but 0-RTT data does not depend on the ServerHello and therefore has weaker guarantees.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "1. Introduction -> 1.2. Major Differences from TLS 1.2",
    "sentence": "The newly introduced EncryptedExtensions message allows various extensions previously sent in the clear in the ServerHello to also enjoy confidentiality protection.",
    "enhanced_sentence": "The newly introduced EncryptedExtensions message, which is sent immediately after the ServerHello in the TLS 1.3 handshake, allows various extensions (such as server name indication, supported groups, or application-layer protocol negotiation) that were previously transmitted unencrypted in the ServerHello to be protected under the handshake traffic keys. This rule applies once the server has sent the ServerHello and derived the initial handshake encryption keys, ensuring that all subsequent handshake messages, including these sensitive extensions, enjoy confidentiality protection against eavesdropping. The expected outcome is that extension data which could reveal sensitive server or client information is no exposed in cleartext, enhancing privacy. Prerequisites include successful key exchange and derivation of encryption keys from the key schedule prior to sending the EncryptedExtensions message.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"1. Introduction -> 1.2. Major Differences from TLS 1.2\"\nRule: The newly introduced EncryptedExtensions message allows various extensions previously sent in the clear in the ServerHello to also enjoy confidentiality protection.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.6. Post-Handshake Client Authentication",
    "sentence": "The PostHandshakeAuth structure is empty, and the extension_data field of the post_handshake_auth extension has zero length.",
    "enhanced_sentence": "The \"post_handshake_auth\" extension is used by clients to indicate their willingness to perform post-handshake authentication. This extension MUST NOT be sent by servers. When a client includes this extension, the PostHandshakeAuth structure MUST be empty, and the extension_data field MUST have zero length. This rule applies during the initial handshake when the client sends its ClientHello message. If the extension is present, the server is permitted to later send a CertificateRequest for post-handshake authentication; if absent, the server MUST NOT do so. The presence of this extension does not obligate the client to authenticate, but signals capability.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.6. Post-Handshake Client Authentication\"\nRule: The PostHandshakeAuth structure is empty, and the extension_data field of the post_handshake_auth extension has zero length.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.6. Post-Handshake Client Authentication",
    "sentence": "Servers MUST NOT send a post-handshake CertificateRequest to clients which do not offer this extension.",
    "enhanced_sentence": "The \"post_handshake_auth\" extension is used by clients to indicate their willingness to perform post-handshake authentication. This rule applies during the handshake phase when a server considers requesting client authentication after the initial handshake is complete. Servers MUST NOT send a post-handshake CertificateRequest message to any client that did not include the \"post_handshake_auth\" extension in its ClientHello. This ensures that clients are not unexpectedly asked to perform authentication steps they did not agree to support. The rule is conditional on the client’s advertised capabilities and must be enforced to maintain protocol integrity and avoid interoperability issues.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.6. Post-Handshake Client Authentication\"\nRule: Servers MUST NOT send a post-handshake CertificateRequest to clients which do not offer this extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.4. Certificate Authorities",
    "sentence": "The \"certificate_authorities\" extension is used to indicate the certificate authorities (CAs) which an endpoint supports and which SHOULD be used by the receiving endpoint to guide certificate selection.",
    "enhanced_sentence": "The \"certificate_authorities\" extension is used by an endpoint to indicate the certificate authorities (CAs) it supports, enabling the receiving endpoint to guide its certificate selection. This extension applies when a client includes it in the ClientHello message or a server includes it in the CertificateRequest message. The expected outcome is that the recipient uses the provided list of acceptable CA distinguished names (in DER-encoded format as specified in X690) to select an appropriate certificate, either for identifying a trust anchor or defining an authorization space. Prerequisites include the endpoint’s support for TLS 1.3, as this extension replaces the deprecated \"trusted_ca_keys\" extension from earlier TLS versions.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.4. Certificate Authorities\"\nRule: The \"certificate_authorities\" extension is used to indicate the certificate authorities (CAs) which an endpoint supports and which SHOULD be used by the receiving endpoint to guide certificate selection.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.4. Certificate Authorities",
    "sentence": "The body of the \"certificate_authorities\" extension consists of a CertificateAuthoritiesExtension structure.",
    "enhanced_sentence": "The body of the \"certificate_authorities\" extension MUST consist of a CertificateAuthoritiesExtension structure, which contains a list of DER-encoded distinguished names of acceptable certificate authorities. This extension is used by an endpoint to indicate supported CAs, guiding the recipient in selecting an appropriate certificate during the handshake. It applies when included in the ClientHello (sent by the client) or CertificateRequest (sent by the server) messages. The expected outcome is that the receiving endpoint uses the provided CA list to narrow certificate choices, improving interoperability and trust alignment. Prerequisites include the endpoint’s support for this extension and adherence to the encoding format specified in X690. Note: The \"trusted_ca_keys\" extension is obsolete in TLS 1.3.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.4. Certificate Authorities\"\nRule: The body of the \"certificate_authorities\" extension consists of a CertificateAuthoritiesExtension structure.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.4. Certificate Authorities",
    "sentence": "The CertificateAuthoritiesExtension structure contains a list of distinguished names of acceptable certificate authorities, represented in DER-encoded format as specified in X690.",
    "enhanced_sentence": "The CertificateAuthoritiesExtension structure, used in the \"certificate_authorities\" extension, contains a list of distinguished names of acceptable certificate authorities, represented in DER-encoded format as specified in X690. This extension is sent by an endpoint to indicate which CAs it supports and to guide the receiving endpoint's certificate selection. It applies when a client includes it in the ClientHello message or a server includes it in the CertificateRequest message during the TLS 1.3 handshake. The expected outcome is that the recipient uses the provided CA list to select or validate an appropriate certificate, ensuring trust anchor compatibility. Prerequisites include proper DER encoding of distinguished names and adherence to X690 specifications for interoperability.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.4. Certificate Authorities\"\nRule: The CertificateAuthoritiesExtension structure contains a list of distinguished names of acceptable certificate authorities, represented in DER-encoded format as specified in X690.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.4. Certificate Authorities",
    "sentence": "The client MAY send the \"certificate_authorities\" extension in the ClientHello message.",
    "enhanced_sentence": "The client MAY send the \"certificate_authorities\" extension in the ClientHello message to indicate the list of trusted certificate authorities (CAs) it supports, represented as DER-encoded distinguished names. This extension SHOULD be used by the server to guide its certificate selection when sending its Certificate message. This rule applies during the initial ClientHello handshake phase and is optional; if sent, it allows the client to signal its CA preferences or authorization constraints. The extension is only meaningful if the server is expected to provide a certificate, and it replaces the deprecated \"trusted_ca_keys\" extension from earlier TLS versions.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.4. Certificate Authorities\"\nRule: The client MAY send the \"certificate_authorities\" extension in the ClientHello message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation",
    "sentence": "A \"signature_algorithms\" (Section 4.2.3) extension which indicates the signature algorithms which the client can accept.",
    "enhanced_sentence": "The client MUST include a \"signature_algorithms\" extension (Section 4.2.3) in its ClientHello message to indicate the set of signature algorithms it supports for server authentication. This extension is required when certificate-based authentication is used and enables the server to select a compatible signature algorithm for its CertificateVerify message. The server MUST only use a signature algorithm listed in this extension; if no mutually supported algorithm exists, the server MUST abort the handshake with a \"handshake_failure\" or \"insufficient_security\" alert. This rule applies unless a pre-shared key (PSK) is used without certificate authentication.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation\"\nRule: A \"signature_algorithms\" (Section 4.2.3) extension which indicates the signature algorithms which the client can accept.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.2. Cookie",
    "sentence": "When sending the new ClientHello, the client MUST copy the contents of the extension received in the HelloRetryRequest into a \"cookie\" extension in the new ClientHello.",
    "enhanced_sentence": "When a client receives a HelloRetryRequest containing a \"cookie\" extension from the server (which is permitted as an exception to the typical extension rules), the client MUST include that exact cookie content in a new \"cookie\" extension when constructing the subsequent ClientHello. This rule applies specifically during the handshake restart initiated by a HelloRetryRequest and ensures that the client demonstrates reachability and provides the necessary state (previously offloaded by the server) to complete the handshake, particularly when the server is operating statelessly for DoS protection. The client must not send a cookie in the initial ClientHello of any connection.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.2. Cookie\"\nRule: When sending the new ClientHello, the client MUST copy the contents of the extension received in the HelloRetryRequest into a \"cookie\" extension in the new ClientHello.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.2. Cookie",
    "sentence": "Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.",
    "enhanced_sentence": "Clients MUST NOT include a \"cookie\" extension in the initial ClientHello of any connection, even if they have previously received a cookie from the same server in a prior connection. This rule applies specifically to the first ClientHello message sent in a new TLS handshake. The cookie extension is only permitted in a ClientHello that is sent in response to a HelloRetryRequest containing a cookie from the server. Adherence to this rule ensures that the server’s anti-DoS and stateless operation mechanisms function correctly, as cookies are intended for single-use within the same handshake sequence and must not be reused across separate connections.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.2. Cookie\"\nRule: Clients MUST NOT use cookies in their initial ClientHello in subsequent connections.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.4. Certificate Authorities",
    "sentence": "The server MAY send the \"certificate_authorities\" extension in the CertificateRequest message.",
    "enhanced_sentence": "The server MAY include the \"certificate_authorities\" extension in the CertificateRequest message to indicate the list of acceptable certificate authorities (CAs) it supports and expects the client to use when selecting a certificate for client authentication. This extension, which contains a list of DER-encoded distinguished names of CAs, helps guide the client in choosing an appropriate certificate that aligns with the server's trusted authorities. This rule applies during the handshake phase when the server requests client authentication. If included, the client should use the provided CA list to select a certificate chain rooted in one of the specified authorities. Note that this extension is optional and serves as a replacement for the deprecated \"trusted_ca_keys\" extension in TLS 1.3.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.4. Certificate Authorities\"\nRule: The server MAY send the \"certificate_authorities\" extension in the CertificateRequest message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.2. Cookie",
    "sentence": "When a server is operating statelessly, it may receive an unprotected record of type change_cipher_spec between the first and second ClientHello (see Section 5).",
    "enhanced_sentence": "When a server is operating statelessly (i.e., without retaining session state between the first ClientHello and the subsequent HelloRetryRequest response), it may receive an unprotected record of type change_cipher_spec between the first and second ClientHello. This scenario typically occurs during a retry handshake initiated by a HelloRetryRequest. Since the server does not store any state, such a record might appear as the first message received. In this case, the server MUST ignore these change_cipher_spec records to avoid misinterpreting the handshake flow and to maintain stateless operation. This behavior ensures that the server correctly processes only the intended handshake messages without being disrupted by optional or legacy records. For further details on the handling of change_cipher_spec records, refer to Section 5.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.2. Cookie\"\nRule: When a server is operating statelessly, it may receive an unprotected record of type change_cipher_spec between the first and second ClientHello (see Section 5).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation",
    "sentence": "In TLS, the cryptographic negotiation proceeds by the client offering the following four sets of options in its ClientHello: A list of cipher suites which indicates the AEAD algorithm/HKDF hash pairs which the client supports.",
    "enhanced_sentence": "In TLS 1.3, the cryptographic negotiation is initiated by the client sending a ClientHello message containing four sets of cryptographic options: a list of supported cipher suites (specifying AEAD algorithm/HKDF hash pairs), a \"supported_groups\" extension indicating acceptable (EC)DHE groups, a \"key_share\" extension with corresponding key shares, and a \"signature_algorithms\" extension for acceptable signature schemes. This rule applies at the start of the handshake when establishing a new TLS 1.3 connection. The expected outcome is that the server will select compatible parameters from these client-offered options to establish a secure session. Prerequisites include the client and server both implementing TLS 1.3, with the client correctly formatting these extensions. If no overlap exists between client and server supported parameters, the handshake must be aborted with a fatal alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation\"\nRule: In TLS, the cryptographic negotiation proceeds by the client offering the following four sets of options in its ClientHello: A list of cipher suites which indicates the AEAD algorithm/HKDF hash pairs which the client supports.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.2. Cookie",
    "sentence": "When sending a HelloRetryRequest, the server MAY provide a \"cookie\" extension to the client (this cookie extension is an exception to the usual rule that the only extensions that may be sent are those that appear in the ClientHello).",
    "enhanced_sentence": "When sending a HelloRetryRequest, the server MAY include a \"cookie\" extension to the client, which serves two primary purposes: (1) enabling the server to verify client reachability at their apparent network address (providing DoS protection, especially for non-connection-oriented transports), and (2) allowing the server to offload state to the client by storing a protected hash of the ClientHello in the cookie, thereby operating statelessly. This cookie extension is an exception to the general rule that only extensions present in the ClientHello may be sent in the server’s response. The client, upon receiving the HelloRetryRequest with a cookie extension, MUST copy it into the new ClientHello. This rule applies specifically during the handshake retry phase when the server requires additional verification or state offloading, and it is conditional on the server’s need for stateless operation or DoS mitigation. The expected outcome is a validated, resumed handshake with reduced server state burden and enhanced security against certain attacks.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.2. Cookie\"\nRule: When sending a HelloRetryRequest, the server MAY provide a \"cookie\" extension to the client (this cookie extension is an exception to the usual rule that the only extensions that may be sent are those that appear in the ClientHello).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation",
    "sentence": "A \"supported_groups\" (Section 4.2.7) extension which indicates the (EC)DHE groups which the client supports and a \"key_share\" (Section 4.2.8) extension which contains (EC)DHE shares for some or all of these groups.",
    "enhanced_sentence": "During the ClientHello phase of a TLS 1.3 handshake, the client MUST include a \"supported_groups\" extension (Section 4.2.7) listing all (EC)DHE groups it is capable of using, and a \"key_share\" extension (Section 4.2.8) containing one or more public key shares corresponding to some or all of these groups. This rule applies when the client is initiating a non-PSK handshake or a PSK handshake that includes (EC)DHE key establishment. The expected outcome is that the server can select a mutually supported group from the \"supported_groups\" list and use the corresponding key share (if provided) to compute the shared secret, enabling forward-secure key exchange. If the client does not provide a key share for the server's chosen group, the server MUST respond with a HelloRetryRequest. Prerequisites include the client having generated valid key shares for the offered groups and ensuring the \"supported_groups\" and \"key_share\" extensions are correctly formatted and included in the initial ClientHello message.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation\"\nRule: A \"supported_groups\" (Section 4.2.7) extension which indicates the (EC)DHE groups which the client supports and a \"key_share\" (Section 4.2.8) extension which contains (EC)DHE shares for some or all of these groups.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation",
    "sentence": "A \"signature_algorithms_cert\" extension (Section 4.2.3) may also be added to indicate certificate-specific signature algorithms.",
    "enhanced_sentence": "During the ClientHello phase of the TLS 1.3 handshake, a client may include the \"signature_algorithms_cert\" extension (Section 4.2.3) to explicitly specify the set of signature algorithms it supports for validating server certificates, distinct from the algorithms used in handshake signatures. This extension is optional and applies only when certificate-based authentication is in use (i.e., when PSK is not selected). If provided, it allows the server to choose a certificate with a signature algorithm that aligns with the client’s stated capabilities, thereby reducing the risk of handshake failures due to unsupported certificate signatures. If omitted, the server should default to the algorithms indicated in the \"signature_algorithms\" extension for certificate validation. The presence of this extension does not override the requirement for the server to select mutually supported parameters; failure to agree on signature algorithms may still result in a fatal alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation\"\nRule: A \"signature_algorithms_cert\" extension (Section 4.2.3) may also be added to indicate certificate-specific signature algorithms.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation",
    "sentence": "A \"pre_shared_key\" (Section 4.2.11) extension which contains a list of symmetric key identities known to the client and a \"psk_key_exchange_modes\" (Section 4.2.9) extension which indicates the key exchange modes that may be used with PSKs.",
    "enhanced_sentence": "During the TLS 1.3 handshake, when a client wishes to use a pre-shared key (PSK), it must include both a \"pre_shared_key\" extension (Section 4.2.11) listing the symmetric key identities it knows and a \"psk_key_exchange_modes\" extension (Section 4.2.9) specifying the acceptable key exchange modes (e.g., PSK alone or with (EC)DHE). This rule applies in the ClientHello message, where the client offers cryptographic options. If the server selects a PSK, it must choose a key exchange mode from the client’s \"psk_key_exchange_modes\" list. The expected outcome is that the server responds with a matching \"pre_shared_key\" extension in ServerHello, and if (EC)DHE is used, a \"key_share\" extension as well. Prerequisites include the client having valid PSK identities and the server supporting at least one of the offered modes. If no PSK is selected, the server proceeds with (EC)DHE and certificate-based authentication instead.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation\"\nRule: A \"pre_shared_key\" (Section 4.2.11) extension which contains a list of symmetric key identities known to the client and a \"psk_key_exchange_modes\" (Section 4.2.9) extension which indicates the key exchange modes that may be used with PSKs.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation",
    "sentence": "If the server does not select a PSK, then the first three of these options are entirely orthogonal: the server independently selects a cipher suite, an (EC)DHE group and key share for key establishment, and a signature algorithm/certificate pair to authenticate itself to the client.",
    "enhanced_sentence": "This rule governs the server's selection of cryptographic parameters during the TLS 1.3 handshake when a pre-shared key (PSK) is not used. It applies immediately after the server receives the ClientHello, which contains client-supported options for cipher suites, (EC)DHE groups/key shares, and signature algorithms. When no PSK is selected, the server must independently and orthogonally choose: (1) a cipher suite from the client's offered list, (2) an (EC)DHE group and corresponding key share for ephemeral key exchange (provided there is group overlap), and (3) a signature algorithm and certificate pair for authentication. The expected outcome is that these three selections are made without mutual dependency—each is based solely on the server's preferences and the client's supported options. Prerequisites include a valid ClientHello with non-empty supported_groups, cipher_suites, and signature_algorithms extensions, and the server must ensure at least one common (EC)DHE group exists to avoid a handshake failure.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation\"\nRule: If the server does not select a PSK, then the first three of these options are entirely orthogonal: the server independently selects a cipher suite, an (EC)DHE group and key share for key establishment, and a signature algorithm/certificate pair to authenticate itself to the client.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation",
    "sentence": "If there is no overlap between the received \"supported_groups\" and the groups supported by the server, then the server MUST abort the handshake with a \"handshake_failure\" or an \"insufficient_security\" alert.",
    "enhanced_sentence": "During the TLS 1.3 handshake, the client sends a ClientHello message containing a \"supported_groups\" extension listing the (EC)DHE groups it supports. This rule applies when the server is processing the ClientHello and is not using a pre-shared key (PSK) without (EC)DHE. If the server finds no common (EC)DHE groups between the client's \"supported_groups\" and its own supported groups, it MUST immediately terminate the handshake by sending a fatal alert of either \"handshake_failure\" or \"insufficient_security\". This ensures that no weak or unsupported cryptographic groups are used, maintaining the security and integrity of the key exchange. Note that this requirement does not apply if a PSK is selected and used without (EC)DHE, as key establishment in that mode does not rely on group negotiation.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation\"\nRule: If there is no overlap between the received \"supported_groups\" and the groups supported by the server, then the server MUST abort the handshake with a \"handshake_failure\" or an \"insufficient_security\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation",
    "sentence": "When authenticating via a certificate, the server will send the Certificate (Section 4.4.2) and CertificateVerify (Section 4.4.3) messages.",
    "enhanced_sentence": "When the server selects certificate-based authentication (as opposed to PSK) during the TLS 1.3 handshake, it MUST send both the Certificate (Section 4.4.2) and CertificateVerify (Section 4.4.3) messages. This applies only if the server successfully negotiates parameters without requiring a HelloRetryRequest, and if no PSK is in use. The Certificate message contains the server's certificate chain, while the CertificateVerify message provides a signature over the handshake transcript to prove possession of the private key. This ensures the client can authenticate the server's identity and establish a trusted connection.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation\"\nRule: When authenticating via a certificate, the server will send the Certificate (Section 4.4.2) and CertificateVerify (Section 4.4.3) messages.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation",
    "sentence": "If the server selects a PSK, then it MUST also select a key establishment mode from the set indicated by the client's \"psk_key_exchange_modes\" extension (at present, PSK alone or with (EC)DHE).",
    "enhanced_sentence": "When the server chooses to use a Pre-Shared Key (PSK) for session resumption or pre-shared key authentication, it MUST select a key establishment mode that is explicitly supported by the client, as indicated in the client's \"psk_key_exchange_modes\" extension. This extension specifies whether the client permits PSK-only key exchange or PSK combined with (EC)DHE. The server's selection must align with one of these client-advertised modes to ensure cryptographic compatibility and negotiation integrity. This rule applies during the ServerHello message construction, following the client's offer of PSK identities and supported modes. Adherence ensures that both parties agree on the security properties of the handshake, such as forward secrecy, and prevents mismatches that would require aborting the connection. Note that this requirement is only triggered if the server actually selects a PSK; otherwise, key establishment follows non-PSK rules.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation\"\nRule: If the server selects a PSK, then it MUST also select a key establishment mode from the set indicated by the client's \"psk_key_exchange_modes\" extension (at present, PSK alone or with (EC)DHE).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation",
    "sentence": "When (EC)DHE is in use, the server will also provide a \"key_share\" extension.",
    "enhanced_sentence": "When the server selects an (EC)DHE-based key exchange (either as the primary method or in combination with a PSK) and does not require a HelloRetryRequest, it MUST provide a \"key_share\" extension in its ServerHello message. This extension contains the server's ephemeral key share for the negotiated (EC)DHE group, enabling the client to compute the shared secret. This rule applies only if the server has successfully chosen a mutually supported group from the client's \"supported_groups\" extension and the client has either provided a compatible \"key_share\" in the initial ClientHello or the server has requested one via HelloRetryRequest. The expected outcome is the establishment of a forward-secure shared key.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation\"\nRule: When (EC)DHE is in use, the server will also provide a \"key_share\" extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation",
    "sentence": "If the server selects an (EC)DHE group and the client did not offer a compatible \"key_share\" extension in the initial ClientHello, the server MUST respond with a HelloRetryRequest (Section 4.1.4) message.",
    "enhanced_sentence": "During the TLS 1.3 handshake, if the server selects an (EC)DHE group for key exchange (either as part of a PSK with (EC)DHE mode or in non-PSK mode) and the client's initial ClientHello did not include a \"key_share\" extension containing a share for that specific group, the server MUST respond with a HelloRetryRequest (Section 4.1.4) message. This rule applies only when the server and client have overlapping supported groups (as indicated in the \"supported_groups\" extension), but the client omitted the necessary key share. The expected outcome is that the client will receive the HelloRetryRequest, generate the appropriate key share for the selected group, and resend the ClientHello with the required \"key_share\" extension, allowing the handshake to proceed. This mechanism ensures forward-secure key exchange without requiring the server to abort the connection due to a missing key share.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation\"\nRule: If the server selects an (EC)DHE group and the client did not offer a compatible \"key_share\" extension in the initial ClientHello, the server MUST respond with a HelloRetryRequest (Section 4.1.4) message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview",
    "sentence": "* Indicates optional or situation-dependent messages/extensions that are not always sent.",
    "enhanced_sentence": "* Indicates messages or extensions that are optional or context-dependent, meaning their inclusion is determined by specific protocol conditions such as the selected key exchange mode (e.g., PSK-only, (EC)DHE, or combined), authentication requirements, or negotiated parameters. These elements—such as CertificateRequest, Certificate, CertificateVerify, and certain extensions—are omitted when not applicable (e.g., if client authentication is not requested or when using raw public keys). Their presence or absence must be correctly handled by implementations to ensure protocol compliance and interoperability, without affecting the core handshake integrity or security.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview\"\nRule: * Indicates optional or situation-dependent messages/extensions that are not always sent.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview",
    "sentence": "The handshake involves ClientHello, ServerHello, EncryptedExtensions, CertificateRequest, Certificate, CertificateVerify, and Finished messages, with optional extensions and application data exchange.",
    "enhanced_sentence": "The TLS 1.3 handshake protocol governs the establishment of a secure channel by negotiating cryptographic parameters, authenticating endpoints, and deriving shared keying material. This rule applies during the initial connection phase between client and server, consisting of three sequential phases: Key Exchange (ClientHello and ServerHello messages to establish shared keys), Server Parameters (EncryptedExtensions and optional CertificateRequest messages to configure handshake parameters), and Authentication (optional Certificate, CertificateVerify, and mandatory Finished messages for endpoint authentication and key confirmation). The expected outcome is a successfully established secure channel where all subsequent application data exchange is protected using the derived encryption keys. Prerequisites include compatible protocol version support and cryptographic algorithms between client and server. The handshake must complete successfully (including Finished message exchange) before application data can be securely exchanged, with any handshake failure triggering connection termination.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview\"\nRule: The handshake involves ClientHello, ServerHello, EncryptedExtensions, CertificateRequest, Certificate, CertificateVerify, and Finished messages, with optional extensions and application data exchange.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation",
    "sentence": "If the server successfully selects parameters and does not require a HelloRetryRequest, the server indicates the selected parameters in the ServerHello as follows: If PSK is being used, then the server will send a \"pre_shared_key\" extension indicating the selected key.",
    "enhanced_sentence": "During the TLS 1.3 handshake, after the client sends a ClientHello containing supported cryptographic options (cipher suites, supported groups, key shares, signature algorithms, and optionally PSK identities and PSK key exchange modes), the server must evaluate these parameters. If the server can successfully select compatible parameters without needing to request additional or corrected information via a HelloRetryRequest, it proceeds to construct the ServerHello message. Specifically, when the server opts to use a pre-shared key (PSK) for the session, it MUST include a \"pre_shared_key\" extension in the ServerHello to indicate the selected PSK identity. This rule applies only if the client previously offered PSK support and the server chooses a PSK-based key exchange mode (as indicated by the client’s \"psk_key_exchange_modes\" extension). The expected outcome is a mutually agreed-upon PSK, enabling subsequent symmetric key derivation. Note that if PSK is selected, (EC)DHE key exchange may still be used if indicated by the chosen mode, requiring an additional \"key_share\" extension. This rule does not apply if certificate-based authentication is used instead of PSK.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.1. Cryptographic Negotiation\"\nRule: If the server successfully selects parameters and does not require a HelloRetryRequest, the server indicates the selected parameters in the ServerHello as follows: If PSK is being used, then the server will send a \"pre_shared_key\" extension indicating the selected key.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview",
    "sentence": "The combination of the ClientHello and the ServerHello determines the shared keys.",
    "enhanced_sentence": "During the TLS 1.3 handshake, the shared keys are determined by the combination of the ClientHello and ServerHello messages, which together establish the cryptographic parameters for the session. This rule applies in the Key Exchange phase, where the client proposes supported protocol versions, cipher suites, and key exchange methods (via key_share or pre_shared_key extensions), and the server responds with the negotiated parameters. The expected outcome is the derivation of shared keying material, enabling subsequent encrypted communication. Prerequisites include a valid ClientHello containing necessary extensions, and the ServerHello must align with one of the client’s supported options (e.g., matching Diffie-Hellman group or pre-shared key identifier).",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview\"\nRule: The combination of the ClientHello and the ServerHello determines the shared keys.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview",
    "sentence": "If PSK key establishment is in use, then the ServerHello contains a \"pre_shared_key\" extension indicating which of the client's offered PSKs was selected.",
    "enhanced_sentence": "During the TLS 1.3 handshake, if the client has offered one or more pre-shared keys (PSKs) in the \"pre_shared_key\" extension of its ClientHello message and the server selects PSK-based key establishment (either PSK-only or PSK with (EC)DHE), then the server MUST include a \"pre_shared_key\" extension in its ServerHello response. This extension MUST indicate the specific PSK from the client's list that was selected, enabling both parties to derive the same session keys. This rule applies only when PSK establishment is negotiated and ensures mutual agreement on the shared secret used for subsequent encryption and authentication.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview\"\nRule: If PSK key establishment is in use, then the ServerHello contains a \"pre_shared_key\" extension indicating which of the client's offered PSKs was selected.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview",
    "sentence": "If (EC)DHE key establishment is in use, then the ServerHello contains a \"key_share\" extension with the server's ephemeral Diffie-Hellman share; the server's share MUST be in the same group as one of the client's shares.",
    "enhanced_sentence": "This rule applies during the TLS 1.3 handshake when (EC)DHE key exchange is negotiated. In the Key Exchange phase, after the client sends a ClientHello containing one or more \"key_share\" extension entries with its ephemeral Diffie-Hellman shares, the server must respond with a ServerHello that includes a \"key_share\" extension. The server's share must correspond to one of the groups offered by the client to ensure cryptographic compatibility and successful shared secret derivation. This requirement ensures that both parties can compute the same premaster secret, which is essential for generating the session keys used to protect subsequent application data. If the server cannot support any of the client's offered groups, it must instead respond with a \"supported_groups\" extension and a \"key_share\" retry request, triggering a HelloRetryRequest.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview\"\nRule: If (EC)DHE key establishment is in use, then the ServerHello contains a \"key_share\" extension with the server's ephemeral Diffie-Hellman share; the server's share MUST be in the same group as one of the client's shares.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview",
    "sentence": "In the Key Exchange phase, the client sends the ClientHello (Section 4.1.2) message, which contains a random nonce (ClientHello.random); its offered protocol versions; a list of symmetric cipher/HKDF hash pairs; either a set of Diffie-Hellman key shares (in the \"key_share\" (Section 4.2.8) extension), a set of pre-shared key labels (in the \"pre_shared_key\" (Section 4.2.11) extension), or both; and potentially additional extensions.",
    "enhanced_sentence": "In the Key Exchange phase of the TLS 1.3 handshake, which establishes shared keying material and selects cryptographic parameters before subsequent messages are encrypted, the client sends the ClientHello (Section 4.1.2) message. This message must include: a random nonce (ClientHello.random) for freshness; the client's supported protocol versions; a list of symmetric cipher/HKDF hash pairs for algorithm negotiation; and either a set of Diffie-Hellman key shares (via the \"key_share\" extension, Section 4.2.8), a set of pre-shared key labels (via the \"pre_shared_key\" extension, Section 4.2.11), or both, depending on the intended key exchange mode (i.e., (EC)DHE, PSK-only, or PSK with (EC)DHE). Additional extensions may be included for enhanced functionality or middlebox compatibility. The server processes this message to determine the cryptographic parameters for the connection and responds with a ServerHello that completes the key exchange. The expected outcome is the establishment of shared secret keying material, enabling subsequent handshake messages to be encrypted and setting the foundation for secure application data exchange. This rule applies unconditionally at the start of every TLS 1.3 handshake.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview\"\nRule: In the Key Exchange phase, the client sends the ClientHello (Section 4.1.2) message, which contains a random nonce (ClientHello.random); its offered protocol versions; a list of symmetric cipher/HKDF hash pairs; either a set of Diffie-Hellman key shares (in the \"key_share\" (Section 4.2.8) extension), a set of pre-shared key labels (in the \"pre_shared_key\" (Section 4.2.11) extension), or both; and potentially additional extensions.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview",
    "sentence": "Note that implementations can use (EC)DHE and PSK together, in which case both extensions will be supplied.",
    "enhanced_sentence": "During the Key Exchange phase of the TLS 1.3 handshake, implementations may combine (EC)DHE and PSK key establishment methods to achieve forward secrecy while leveraging pre-shared keys for efficiency. This rule applies when the client offers both Diffie-Hellman key shares (via the \"key_share\" extension) and pre-shared key labels (via the \"pre_shared_key\" extension) in the ClientHello message. If the server selects this hybrid mode, it MUST include both the \"key_share\" and \"pre_shared_key\" extensions in its ServerHello response. The expected outcome is the establishment of shared secret keying material that incorporates both the ephemeral (EC)DHE exchange for forward secrecy and the PSK for authentication and session resumption capabilities. This combined approach requires that both client and server support the respective extensions and have a mutually acceptable pre-shared key and compatible Diffie-Hellman parameters.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview\"\nRule: Note that implementations can use (EC)DHE and PSK together, in which case both extensions will be supplied.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview",
    "sentence": "The server then sends two messages to establish the Server Parameters: EncryptedExtensions provides responses to ClientHello extensions that are not required to determine cryptographic parameters, excluding those specific to individual certificates.",
    "enhanced_sentence": "After the ServerHello message, the server sends two messages to establish the Server Parameters: EncryptedExtensions and CertificateRequest. EncryptedExtensions provides responses to ClientHello extensions that are not required to determine cryptographic parameters (such as supported application-layer protocols or server name indication), excluding those specific to individual certificates (which are handled in the Certificate message). This rule applies during the Server Parameters phase of the TLS 1.3 handshake, immediately following key exchange, and must occur before the Authentication phase. The expected outcome is that the client receives necessary configuration details without compromising cryptographic parameter negotiation, ensuring that subsequent messages can be properly processed under encryption. Prerequisites include successful completion of the Key Exchange phase (ClientHello and ServerHello exchange) and establishment of handshake traffic secrets for encryption.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview\"\nRule: The server then sends two messages to establish the Server Parameters: EncryptedExtensions provides responses to ClientHello extensions that are not required to determine cryptographic parameters, excluding those specific to individual certificates.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview",
    "sentence": "CertificateRequest specifies desired parameters for certificate-based client authentication if it is desired.",
    "enhanced_sentence": "The CertificateRequest message is sent by the server during the Server Parameters phase of the TLS 1.3 handshake to specify the desired parameters for certificate-based client authentication, if such authentication is required. This message is optional and is omitted if client authentication is not desired. When included, it must be sent after the ServerHello and EncryptedExtensions messages and before the server's Certificate message. The CertificateRequest contains information such as acceptable certificate types, signature algorithms, and certificate authorities. Upon receiving this message, the client is expected to respond with its own Certificate and CertificateVerify messages to complete mutual authentication. If no CertificateRequest is sent, the client must not attempt certificate-based authentication.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview\"\nRule: CertificateRequest specifies desired parameters for certificate-based client authentication if it is desired.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview",
    "sentence": "This message is omitted by the server if not authenticating with a certificate and by the client if the server did not send CertificateRequest (thus indicating that the client should not authenticate with a certificate).",
    "enhanced_sentence": "The Certificate message is omitted during the Authentication phase of the TLS 1.3 handshake under specific conditions: by the server if it is not authenticating with a certificate (e.g., when using PSK-only mode), and by the client if the server did not send a CertificateRequest message (indicating that client certificate authentication is not required). This ensures that certificate-related messages are only sent when necessary for authentication, reducing unnecessary overhead and maintaining protocol efficiency. The omission must occur only after the Key Exchange and Server Parameters phases have established the cryptographic context and determined authentication requirements.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview\"\nRule: This message is omitted by the server if not authenticating with a certificate and by the client if the server did not send CertificateRequest (thus indicating that the client should not authenticate with a certificate).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview",
    "sentence": "TLS uses the same set of messages every time that certificate-based authentication is needed.",
    "enhanced_sentence": "During the TLS 1.3 handshake, whenever certificate-based authentication is required (for either the server or client), the protocol consistently uses the same sequence of messages: Certificate (containing the endpoint's certificate or raw public key), followed by CertificateVerify (providing a signature over the handshake context), and Finished (providing key confirmation and handshake integrity). This rule applies in the Authentication phase of the handshake, after key exchange and server parameters have been established. The expected outcome is mutual or unilateral authentication, binding the endpoint's identity to the session keys. Prerequisites include successful negotiation of a certificate-based cipher suite and, for client authentication, the server sending a CertificateRequest message. These messages are omitted if certificate authentication is not used.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview\"\nRule: TLS uses the same set of messages every time that certificate-based authentication is needed.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview",
    "sentence": "CertificateVerify provides a signature over the entire handshake using the private key corresponding to the public key in the Certificate message.",
    "enhanced_sentence": "The CertificateVerify message MUST be sent by an endpoint when performing certificate-based authentication, immediately following the Certificate message. It provides a signature over a cryptographic hash of the entire handshake context (excluding the CertificateVerify message itself) using the private key corresponding to the public key in the preceding Certificate message. This signature serves to prove possession of the private key and binds the endpoint’s identity to the handshake, ensuring integrity and authenticity. The message is omitted if certificate-based authentication is not used. Receivers MUST validate this signature using the public key from the Certificate message; failure to verify results in termination of the connection with a fatal alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview\"\nRule: CertificateVerify provides a signature over the entire handshake using the private key corresponding to the public key in the Certificate message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview",
    "sentence": "Specifically, Certificate message contains the certificate of the endpoint and any per-certificate extensions.",
    "enhanced_sentence": "The Certificate message, sent during the Authentication phase of the TLS 1.3 handshake, contains the endpoint's certificate chain and any per-certificate extensions (such as OCSP stapling or Signed Certificate Timestamps). This rule applies when certificate-based authentication is required—for the server if it is configured to authenticate with a certificate, and for the client only if the server has sent a CertificateRequest. The message must be omitted if the endpoint is not authenticating via certificate (e.g., using PSK-only mode) or, for the client, if no CertificateRequest was received. The expected outcome is that the recipient can validate the sender’s identity using the provided certificate and extensions, enabling subsequent messages (like CertificateVerify) to cryptographically bind the handshake to the sender’s proven identity. Prerequisites include successful negotiation of certificate-based cipher suites and, for the client, receipt of a valid CertificateRequest.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview\"\nRule: Specifically, Certificate message contains the certificate of the endpoint and any per-certificate extensions.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview",
    "sentence": "Upon receiving the server's messages, the client responds with its Authentication messages, namely Certificate and CertificateVerify if requested, and Finished.",
    "enhanced_sentence": "After successfully receiving and processing the server's Authentication messages (Certificate, CertificateVerify, and Finished) and any Server Parameters (EncryptedExtensions and optional CertificateRequest), the client proceeds to the final phase of the handshake. If the server requested client authentication via a CertificateRequest message, the client MUST send Certificate (containing its certificate chain or raw public key) and CertificateVerify (providing a signature over the handshake context). Regardless of client authentication, the client MUST always send a Finished message, which provides a MAC over the entire handshake for key confirmation and integrity. These messages are encrypted using keys derived from the client handshake traffic secret. Completion of this step allows both parties to derive the final application traffic keys and begin secure data exchange.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview\"\nRule: Upon receiving the server's messages, the client responds with its Authentication messages, namely Certificate and CertificateVerify if requested, and Finished.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview",
    "sentence": "Note that if raw public keys or the cached information extension are in use, then the Certificate message will not contain a certificate but rather some other value corresponding to the server's long-term key.",
    "enhanced_sentence": "During the Authentication phase of the TLS 1.3 handshake, when the server or client sends a Certificate message for certificate-based authentication, the content of this message depends on the negotiated extensions. If the \"raw_public_keys\" extension (RFC 7250) or the \"cached_info\" extension (RFC 7924) is negotiated and in use, the Certificate message MUST NOT contain a standard X.509 certificate structure. Instead, it MUST contain either a RawPublicKey structure (for raw public keys) or a hash of the previously cached certificate information (for the cached information extension), both of which correspond to the endpoint's long-term public key. This rule applies only when certificate-based authentication is performed and the respective extension has been successfully negotiated in the ClientHello/ServerHello exchange. The expected outcome is that the recipient correctly interprets the alternative value during the authentication process, enabling successful verification without a full certificate.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview\"\nRule: Note that if raw public keys or the cached information extension are in use, then the Certificate message will not contain a certificate but rather some other value corresponding to the server's long-term key.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "2. Protocol Overview",
    "sentence": "Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.",
    "enhanced_sentence": "During the TLS 1.3 handshake, application data MUST NOT be transmitted by either the client or server before the Finished message has been sent, except as explicitly allowed for 0-RTT (Zero Round Trip Time) early data in Section 2.3. This rule applies from the initiation of the handshake until the completion of the authentication phase, where the Finished message provides key confirmation and handshake integrity. Adherence ensures that all application-layer traffic is protected using verified cryptographic parameters and established keys, preventing data exposure to unauthenticated peers or before secure channel parameters are fully negotiated. The only prerequisite for any permitted early data transmission is a previously established PSK (Pre-Shared Key) enabling 0-RTT mode, as detailed in the exception.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"2. Protocol Overview\"\nRule: Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters",
    "sentence": "This extension, if provided by the server, MUST only be sent in the CertificateRequest message.",
    "enhanced_sentence": "The \"oid_filters\" extension, which allows servers to specify required certificate extension OID/value pairs for client certificate selection, MUST only be sent by the server in the CertificateRequest message during the TLS 1.3 handshake. This rule applies when the server requires client authentication and wishes to constrain the acceptable client certificates based on specific certificate extensions. The extension must not appear in any other handshake message. When followed, this ensures proper protocol flow where certificate requirements are communicated before the client sends its Certificate message, allowing the client to select an appropriate certificate that matches the server's specified OID filters. The server may only include this extension if it is requesting client authentication and has specific certificate extension requirements.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters\"\nRule: This extension, if provided by the server, MUST only be sent in the CertificateRequest message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters",
    "sentence": "The \"oid_filters\" extension allows servers to provide a set of OID/value pairs which the server would like the client's certificate to match.",
    "enhanced_sentence": "The \"oid_filters\" extension, when used by a server, provides a set of OID/value pairs that specify required certificate extensions and their allowed values for client authentication. This extension MUST only be sent in the CertificateRequest message during the TLS 1.3 handshake. The client MUST include a certificate that contains all recognized OIDs from the server's non-empty filters list, with each matching extension containing at least the specified values (though additional values are permitted). Unrecognized OIDs MUST be ignored by the client. If the client cannot satisfy the recognized requirements, the server MAY either continue without client authentication or abort with an \"unsupported_certificate\" alert. Implementations MUST ensure each OID appears only once in the filters list and SHOULD rely on PKI libraries for certificate matching, with specific matching rules defined for standard extensions like Key Usage and Extended Key Usage (excluding anyExtendedKeyUsage).",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters\"\nRule: The \"oid_filters\" extension allows servers to provide a set of OID/value pairs which the server would like the client's certificate to match.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters",
    "sentence": "If the server has included a non-empty filters list, the client certificate included in the response MUST contain all of the specified extension OIDs that the client recognizes.",
    "enhanced_sentence": "When the server includes a non-empty \"oid_filters\" list in its CertificateRequest message, the client MUST select a certificate that contains all extension OIDs from the filters list that it recognizes. For each recognized OID, the certificate MUST include all specified values (though it may contain additional values). The client MUST ignore any unrecognized OIDs. This rule applies during the TLS 1.3 handshake when the server requests client authentication with OID-based filtering. If the client cannot provide a certificate satisfying the recognized OID requirements, the server may either proceed without client authentication or terminate the handshake with an \"unsupported_certificate\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters\"\nRule: If the server has included a non-empty filters list, the client certificate included in the response MUST contain all of the specified extension OIDs that the client recognizes.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters",
    "sentence": "The OIDFilter structure contains certificate_extension_oid and certificate_extension_values fields.",
    "enhanced_sentence": "The OIDFilter structure, used within the \"oid_filters\" extension in the server's CertificateRequest message, contains certificate_extension_oid and certificate_extension_values fields. This structure applies when the server requires the client's certificate to include specific certificate extensions with allowed values, as defined in RFC5280 and encoded in DER format. The expected outcome is that the client, if it recognizes the OID, must include all specified values in its certificate (though it may include additional values), while ignoring any unrecognized OIDs. Prerequisites include the server sending this extension only in CertificateRequest, with no duplicate OIDs in the filters list, and the client relying on its PKI library for certificate selection and value matching according to defined rules (e.g., for Key Usage and Extended Key Usage extensions).",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters\"\nRule: The OIDFilter structure contains certificate_extension_oid and certificate_extension_values fields.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters",
    "sentence": "The filters parameter is a list of certificate extension OIDs from RFC5280 Profile with their allowed values, represented in DER-encoded format as specified in X690 Canonical Encoding Rules and Distinguished Encoding Rules.",
    "enhanced_sentence": "The filters parameter is a list of certificate extension OIDs from RFC5280 Profile with their allowed values, represented in DER-encoded format as specified in X690 Canonical Encoding Rules and Distinguished Encoding Rules. This rule applies when a server includes the \"oid_filters\" extension in a CertificateRequest message to specify required certificate attributes for client authentication. The client MUST include all recognized OIDs from the filters list in its certificate, with all specified values present (though additional values are permitted). Unrecognized OIDs MUST be ignored. If the client cannot satisfy the recognized requirements, the server MAY either continue without client authentication or abort with an \"unsupported_certificate\" alert. Each OID MUST appear only once in the filters list, and matching follows specific rules for standard extensions (e.g., Key Usage requires all requested bits to be set).",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters\"\nRule: The filters parameter is a list of certificate extension OIDs from RFC5280 Profile with their allowed values, represented in DER-encoded format as specified in X690 Canonical Encoding Rules and Distinguished Encoding Rules.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters",
    "sentence": "Some certificate extension OIDs allow multiple values (e.g., Extended Key Usage).",
    "enhanced_sentence": "Some certificate extension OIDs (such as Extended Key Usage) allow multiple values to be specified within a single certificate extension. This rule applies when a server includes an OID filter in its CertificateRequest message, specifying allowed values for particular certificate extensions. The client MUST ensure that, for any recognized extension OID in the filter, all specified values are present in the client certificate (though the certificate may include additional values). This requirement is part of the server’s policy for client certificate selection during TLS 1.3 handshake authentication. If the client cannot satisfy the filter requirements for recognized OIDs, the server may abort the handshake or proceed without client authentication. Matching is performed according to extension-specific rules (e.g., for Extended Key Usage, all requested key purpose OIDs must be present), and implementations should rely on underlying PKI libraries for accurate value comparison and certificate validation.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters\"\nRule: Some certificate extension OIDs allow multiple values (e.g., Extended Key Usage).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters",
    "sentence": "For each extension OID recognized by the client, all of the specified values MUST be present in the client certificate (but the certificate MAY have other values as well).",
    "enhanced_sentence": "When the server includes a non-empty \"oid_filters\" extension in the CertificateRequest message, the client MUST validate that for each certificate extension OID in the filters list that it recognizes, all specified values (in DER-encoded format) are present in the client certificate. The certificate MAY contain additional values beyond those specified. This rule applies during client certificate selection in the TLS 1.3 handshake, ensuring the chosen certificate meets the server's policy requirements. The client MUST ignore unrecognized OIDs and proceed with certificate selection using recognized OIDs only. If the client cannot provide a certificate satisfying all recognized OID/value requirements, the server may either continue without client authentication or abort with an \"unsupported_certificate\" alert. Matching is defined per extension type (e.g., for Key Usage, all requested bits must be set; for Extended Key Usage, all requested OIDs must be present).",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters\"\nRule: For each extension OID recognized by the client, all of the specified values MUST be present in the client certificate (but the certificate MAY have other values as well).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters",
    "sentence": "However, the client MUST ignore and skip any unrecognized certificate extension OIDs.",
    "enhanced_sentence": "When processing the \"oid_filters\" extension in a CertificateRequest message, if the server provides a non-empty filters list containing certificate extension OIDs and their allowed values, the client MUST ignore and skip any unrecognized certificate extension OIDs. This rule applies during client certificate selection and validation, ensuring that the client only enforces filtering for extensions it understands. The client is still required to include all recognized OIDs from the filters list in its certificate, with matching values. Ignoring unrecognized OIDs prevents interoperability failures due to unknown extensions while allowing the handshake to proceed. The server retains the discretion to abort the handshake with an \"unsupported_certificate\" alert if the client's certificate does not satisfy the request due to ignored required OIDs.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters\"\nRule: However, the client MUST ignore and skip any unrecognized certificate extension OIDs.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters",
    "sentence": "If the client ignored some of the required certificate extension OIDs and supplied a certificate that does not satisfy the request, the server MAY at its discretion either continue the connection without client authentication or abort the handshake with an \"unsupported_certificate\" alert.",
    "enhanced_sentence": "This rule governs server behavior when a client, in response to a CertificateRequest containing an \"oid_filters\" extension, provides a certificate that does not fully meet the server's specified certificate extension requirements. The rule applies after the server has sent a CertificateRequest with a non-empty filters list and received the client's Certificate message, which fails to include all recognized required extension OIDs or their specified values. Prerequisites include the server having provided valid OID/value pairs in the filters list, and the client having ignored some of these requirements. The expected outcome is that the server has discretionary authority to either proceed with the connection without client authentication (effectively downgrading to unauthenticated mode) or terminate the handshake by sending an \"unsupported_certificate\" alert, ensuring flexibility in handling non-conforming certificates while maintaining protocol integrity.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters\"\nRule: If the client ignored some of the required certificate extension OIDs and supplied a certificate that does not satisfy the request, the server MAY at its discretion either continue the connection without client authentication or abort the handshake with an \"unsupported_certificate\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters",
    "sentence": "Depending on the type, matching certificate extension values are not necessarily bitwise-equal.",
    "enhanced_sentence": "When processing the \"oid_filters\" extension in a TLS 1.3 CertificateRequest message, servers may specify OID/value pairs that the client's certificate must match. For recognized certificate extension OIDs, the client must ensure all specified values are present in its certificate, but note that matching is not necessarily based on bitwise equality of the DER-encoded values. Instead, matching semantics depend on the extension type—for example, Key Usage requires all requested usage bits to be set, while Extended Key Usage requires all requested purpose OIDs to be present. Implementations must rely on PKI libraries to perform correct value matching according to the extension's defined rules, and clients should ignore unrecognized OIDs. If the client cannot satisfy the request, the server may abort the handshake or proceed without client authentication.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters\"\nRule: Depending on the type, matching certificate extension values are not necessarily bitwise-equal.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters",
    "sentence": "PKIX RFCs define a variety of certificate extension OIDs and their corresponding value types.",
    "enhanced_sentence": "PKIX RFCs define a variety of certificate extension OIDs and their corresponding value types, which are used by the server in the \"oid_filters\" extension of the CertificateRequest message to specify required certificate attributes. This rule applies during the TLS 1.3 handshake when the server requests client certificate authentication and provides non-empty OID filters. The client must include all recognized OIDs from the filters in its certificate, with values matching the server's specified requirements (as defined by PKIX and extension-specific matching rules, such as for Key Usage or Extended Key Usage). Unrecognized OIDs must be ignored. Prerequisites include the server sending a valid CertificateRequest with the \"oid_filters\" extension, and the client having a PKI library capable of interpreting OIDs and performing certificate selection based on extension matching. The expected outcome is that the client provides a certificate satisfying the server's filter criteria, or the server may abort the handshake if requirements are not met.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters\"\nRule: PKIX RFCs define a variety of certificate extension OIDs and their corresponding value types.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters",
    "sentence": "It is expected that TLS implementations will rely on their PKI libraries to perform certificate selection using certificate extension OIDs.",
    "enhanced_sentence": "During the TLS 1.3 handshake, when a server includes a non-empty \"oid_filters\" extension in the CertificateRequest message, it specifies required certificate extension OIDs and their allowed values for client authentication. TLS implementations are expected to rely on their underlying PKI libraries to perform certificate selection by matching these OID/value pairs against available client certificates. This applies after the server sends the CertificateRequest and before the client responds with its chosen certificate. The expected outcome is that the client selects a certificate that satisfies all recognized OID filters, ensuring compliance with server requirements. Prerequisites include the server supporting client authentication and the client having access to a PKI library capable of interpreting RFC5280 certificate extensions and performing OID-based matching according to defined rules (e.g., for Key Usage and Extended Key Usage extensions). Unrecognized OIDs must be ignored by the client, and failure to meet recognized requirements may result in handshake abortion.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters\"\nRule: It is expected that TLS implementations will rely on their PKI libraries to perform certificate selection using certificate extension OIDs.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters",
    "sentence": "This document defines matching rules for two standard certificate extensions defined in RFC5280 Profile: The Key Usage extension in a certificate matches the request when all key usage bits asserted in the request are also asserted in the Key Usage certificate extension.",
    "enhanced_sentence": "This rule governs the server's certificate filtering mechanism in TLS 1.3 handshakes when using the \"oid_filters\" extension. It applies specifically when a server includes Key Usage extension requirements in its CertificateRequest message during the client authentication phase. The rule states that for a client certificate to satisfy the server's Key Usage filter, all key usage bits specified in the server's request must be present in the client certificate's Key Usage extension. The certificate may contain additional key usage bits beyond those requested. This matching is performed during client certificate selection, and if the client cannot provide a certificate meeting all specified extension requirements (including this Key Usage rule), the server may either continue without client authentication or abort the handshake with an \"unsupported_certificate\" alert. This rule only applies when the server includes non-empty OID filters and the client recognizes the Key Usage extension OID.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters\"\nRule: This document defines matching rules for two standard certificate extensions defined in RFC5280 Profile: The Key Usage extension in a certificate matches the request when all key usage bits asserted in the request are also asserted in the Key Usage certificate extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters",
    "sentence": "Separate specifications may define matching rules for other certificate extensions.",
    "enhanced_sentence": "Separate specifications may define matching rules for other certificate extensions beyond the Key Usage and Extended Key Usage extensions defined in RFC5280. This rule applies when the server includes the \"oid_filters\" extension in a CertificateRequest message, specifying OID/value pairs that the client's certificate must match. The expected outcome is that implementations will follow these externally defined matching rules for any recognized extension OIDs provided in the filters list, ensuring proper certificate validation and selection during the TLS 1.3 handshake. Prerequisites include the server sending a non-empty filters list and the client supporting the specified extension OIDs; unrecognized OIDs must be ignored by the client.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters\"\nRule: Separate specifications may define matching rules for other certificate extensions.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters",
    "sentence": "The Extended Key Usage extension in a certificate matches the request when all key purpose OIDs present in the request are also found in the Extended Key Usage certificate extension.",
    "enhanced_sentence": "During the TLS 1.3 handshake, when a server includes the \"oid_filters\" extension in a CertificateRequest message, it specifies required certificate extensions and their allowed values. For the Extended Key Usage extension specifically, the client's certificate is considered to match the server's request if and only if all key purpose OIDs listed in the server's filter are present in the certificate's Extended Key Usage extension. The certificate may contain additional key purpose OIDs beyond those required. This rule applies only when the server provides a non-empty filters list containing the Extended Key Usage OID, and the client recognizes and processes this extension. If the client cannot satisfy this requirement, the server may either continue without client authentication or abort the handshake with an \"unsupported_certificate\" alert. The anyExtendedKeyUsage OID must not be used in the request.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.5. OID Filters\"\nRule: The Extended Key Usage extension in a certificate matches the request when all key purpose OIDs present in the request are also found in the Extended Key Usage certificate extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request",
    "sentence": "As discussed in Section 4.1.3, the HelloRetryRequest has the same format as a ServerHello message, and the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method fields have the same meaning.",
    "enhanced_sentence": "This rule applies when a server sends a HelloRetryRequest message in response to a ClientHello that lacks sufficient information to proceed, despite having acceptable parameters. The HelloRetryRequest must structurally mirror a ServerHello message, with identical formatting and meaning for the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method fields, as defined in Section 4.1.3. This design ensures backward compatibility and consistency in message parsing. The client must validate these fields upon receipt, and if they match the original ClientHello without prompting necessary changes, the handshake must be aborted with an \"illegal_parameter\" alert. The rule is a prerequisite for the client to correctly generate an updated ClientHello, incorporating any required extensions or adjustments indicated by the server.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request\"\nRule: As discussed in Section 4.1.3, the HelloRetryRequest has the same format as a ServerHello message, and the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method fields have the same meaning.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request",
    "sentence": "The server's extensions MUST contain \"supported_versions\".",
    "enhanced_sentence": "When a server sends a HelloRetryRequest message in response to a ClientHello that lacks sufficient information to proceed, the server MUST include the \"supported_versions\" extension in its extensions list. This requirement applies specifically to the HelloRetryRequest message, which structurally resembles a ServerHello but serves a distinct purpose in negotiating handshake parameters. The \"supported_versions\" extension is essential for the client to determine the correct TLS version to use in its subsequent updated ClientHello. This rule ensures version negotiation clarity and prevents handshake ambiguity. Prerequisites include the server having identified an acceptable set of parameters from the initial ClientHello and the client having offered the \"supported_versions\" extension in its ClientHello, as the server must not include extensions not first offered by the client (except for the optional \"cookie\" extension).",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request\"\nRule: The server's extensions MUST contain \"supported_versions\".\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request",
    "sentence": "Additionally, the HelloRetryRequest SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair.",
    "enhanced_sentence": "When a server sends a HelloRetryRequest in response to an initial ClientHello that lacks sufficient information to proceed, the server SHOULD include only the minimal set of extensions required for the client to construct a valid, updated ClientHello. This applies specifically to extensions such as \"supported_versions\" (which is mandatory), \"cookie\" (if needed), and \"key_share\" (if key exchange parameters must be adjusted). The server MUST NOT include any extensions not originally offered by the client, except for the optional \"cookie\" extension. By limiting extensions to only those necessary, the server reduces handshake overhead and avoids potential ambiguities, ensuring the client can efficiently generate a conforming ClientHello response without unnecessary processing or renegotiation attempts.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request\"\nRule: Additionally, the HelloRetryRequest SHOULD contain the minimal set of extensions necessary for the client to generate a correct ClientHello pair.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request",
    "sentence": "The server will send the HelloRetryRequest message in response to a ClientHello message if the server is able to find an acceptable set of parameters but the ClientHello does not contain sufficient information to proceed with the handshake.",
    "enhanced_sentence": "The server MUST send a HelloRetryRequest message in response to a ClientHello message when the server has identified an acceptable set of parameters (such as cipher suite or key exchange method) but the initial ClientHello lacks sufficient information to proceed—typically due to missing required extensions, incompatible key shares, or the need for cookie-based client verification. This message, which structurally mirrors a ServerHello, MUST include the \"supported_versions\" extension and SHOULD contain only the minimal extensions necessary to guide the client toward a valid, updated ClientHello. The server MUST NOT include any extensions not originally offered by the client, except for the optional \"cookie\" extension. Upon receiving a HelloRetryRequest, the client MUST validate the echoed parameters, process all extensions, and send a corrected ClientHello; if the HelloRetryRequest would not change the ClientHello or if a second HelloRetryRequest is received, the client MUST abort the handshake. The server MUST ensure consistency in negotiated parameters (e.g., cipher suite and version) between the HelloRetryRequest and the subsequent ServerHello.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request\"\nRule: The server will send the HelloRetryRequest message in response to a ClientHello message if the server is able to find an acceptable set of parameters but the ClientHello does not contain sufficient information to proceed with the handshake.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request",
    "sentence": "As with the ServerHello, a HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the \"cookie\" (see Section 4.2.2) extension.",
    "enhanced_sentence": "When a server sends a HelloRetryRequest message in response to a ClientHello—typically because the initial ClientHello lacks sufficient information to proceed—the server MUST NOT include any extensions that were not first offered by the client in its ClientHello. This restriction applies to all extensions except the optional \"cookie\" extension (see Section 4.2.2), which may be included even if not previously offered by the client. This rule ensures that the server does not introduce unsupported or unexpected parameters, maintaining negotiation integrity and preventing potential handshake failures. The client must validate that the HelloRetryRequest contains only permitted extensions; if any unoffered extension (other than \"cookie\") is present, the client MUST abort the handshake with an \"illegal_parameter\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request\"\nRule: As with the ServerHello, a HelloRetryRequest MUST NOT contain any extensions that were not first offered by the client in its ClientHello, with the exception of optionally the \"cookie\" (see Section 4.2.2) extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request",
    "sentence": "If a client receives a second HelloRetryRequest in the same connection (i.e., where the ClientHello was itself in response to a HelloRetryRequest), the client MUST abort the handshake with an \"unexpected_message\" alert.",
    "enhanced_sentence": "If a client receives a second HelloRetryRequest message in the same connection—meaning the client had already responded to a previous HelloRetryRequest with an updated ClientHello—the client MUST immediately abort the handshake by sending an \"unexpected_message\" alert. This rule applies during the handshake negotiation phase when the server attempts to request further adjustments after an initial retry, indicating a possible misconfiguration, non-compliance, or protocol error. The expected outcome is termination of the connection to prevent infinite loops or inconsistent state. Prerequisites include the client having previously received and processed a HelloRetryRequest and sent a corresponding updated ClientHello.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request\"\nRule: If a client receives a second HelloRetryRequest in the same connection (i.e., where the ClientHello was itself in response to a HelloRetryRequest), the client MUST abort the handshake with an \"unexpected_message\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request",
    "sentence": "Otherwise, the client MUST process all extensions in the HelloRetryRequest and send a second updated ClientHello.",
    "enhanced_sentence": "If the client receives a HelloRetryRequest that would result in a change to the ClientHello (i.e., the server has provided new or modified parameters) and this is the first HelloRetryRequest in the connection, the client MUST process all extensions in the HelloRetryRequest (including mandatory ones like \"supported_versions\" and optional ones like \"cookie\" or \"key_share\") and then construct and send a second, updated ClientHello that incorporates the server's requested changes, ensuring that the new ClientHello aligns with the negotiated parameters and does not include any pre-shared keys with incompatible hash algorithms.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request\"\nRule: Otherwise, the client MUST process all extensions in the HelloRetryRequest and send a second updated ClientHello.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request",
    "sentence": "Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3 and then process the extensions, starting with determining the version using \"supported_versions\".",
    "enhanced_sentence": "When a client receives a HelloRetryRequest message from the server—which is sent in response to an initial ClientHello when the server finds acceptable parameters but requires additional information—the client MUST first validate the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method fields as defined in Section 4.1.3, ensuring they match the format and constraints of a ServerHello. The client MUST then process the extensions in the HelloRetryRequest, beginning with the \"supported_versions\" extension to determine the negotiated TLS version. If any of these checks fail, or if the HelloRetryRequest does not result in a necessary change to the ClientHello (e.g., no new parameters are provided), the client MUST abort the handshake with an \"illegal_parameter\" alert. Additionally, if a second HelloRetryRequest is received in the same connection, the client MUST abort with an \"unexpected_message\" alert. Otherwise, the client MUST incorporate all extensions from the HelloRetryRequest and send an updated ClientHello to proceed with the handshake.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request\"\nRule: Upon receipt of a HelloRetryRequest, the client MUST check the legacy_version, legacy_session_id_echo, cipher_suite, and legacy_compression_method as specified in Section 4.1.3 and then process the extensions, starting with determining the version using \"supported_versions\".\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request",
    "sentence": "Clients MUST abort the handshake with an \"illegal_parameter\" alert if the HelloRetryRequest would not result in any change in the ClientHello.",
    "enhanced_sentence": "When a client receives a HelloRetryRequest from the server, it MUST check whether the requested changes in the HelloRetryRequest (such as version, cipher suite, or extensions) would actually require modifications to the original ClientHello. If the HelloRetryRequest does not specify any meaningful changes—for example, if the client already offered the same parameters or if the server’s request is redundant—the client MUST treat this as an error and abort the handshake immediately by sending an \"illegal_parameter\" alert. This rule applies during the handshake negotiation phase, after the server responds to the initial ClientHello with a HelloRetryRequest. The expected outcome is to prevent infinite loops or unnecessary retries, ensuring protocol efficiency and security. Prerequisites include a valid, correctly formatted HelloRetryRequest that conforms to the client’s original offer, except where extensions like \"cookie\" are permitted.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request\"\nRule: Clients MUST abort the handshake with an \"illegal_parameter\" alert if the HelloRetryRequest would not result in any change in the ClientHello.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request",
    "sentence": "Servers MUST ensure that they negotiate the same cipher suite when receiving a conformant updated ClientHello (if the server selects the cipher suite as the first step in the negotiation, then the same cipher suite negotiation will happen automatically).",
    "enhanced_sentence": "This rule applies when a server has sent a HelloRetryRequest and subsequently receives a conformant updated ClientHello from the client. The server MUST ensure that the cipher suite negotiated in the final handshake is identical to the one specified in the original HelloRetryRequest. This requirement maintains consistency across the handshake restart and prevents negotiation downgrade attacks. If the server's typical behavior is to select the cipher suite as the first step of negotiation (before other parameters), this consistency occurs automatically. However, servers implementing alternative negotiation logic must explicitly verify that the cipher suite remains unchanged to comply with this rule.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request\"\nRule: Servers MUST ensure that they negotiate the same cipher suite when receiving a conformant updated ClientHello (if the server selects the cipher suite as the first step in the negotiation, then the same cipher suite negotiation will happen automatically).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request",
    "sentence": "A client which receives a cipher suite that was not offered MUST abort the handshake.",
    "enhanced_sentence": "During the TLS 1.3 handshake, if a client receives a HelloRetryRequest message from the server, it MUST validate that the cipher suite specified in the message matches one of the cipher suites originally offered by the client in its initial ClientHello. This rule applies specifically when processing a HelloRetryRequest, which occurs if the server requires additional information to proceed but has identified a mutually acceptable set of parameters. If the cipher suite in the HelloRetryRequest was not part of the client's initial offer, the client MUST immediately abort the handshake by sending an \"illegal_parameter\" alert. This ensures that the server does not force an unnegotiated or unsupported cipher suite, maintaining the integrity of the handshake negotiation process.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request\"\nRule: A client which receives a cipher suite that was not offered MUST abort the handshake.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request",
    "sentence": "Upon receiving the ServerHello, clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and otherwise abort the handshake with an \"illegal_parameter\" alert.",
    "enhanced_sentence": "When a client receives a ServerHello message in response to an updated ClientHello that was sent after processing a HelloRetryRequest, it MUST verify that the cipher suite specified in the ServerHello matches exactly the cipher suite that was provided in the preceding HelloRetryRequest. This rule applies specifically during the handshake flow where a HelloRetryRequest was issued by the server to request additional or corrected parameters from the client. If the cipher suites do not match, the client MUST immediately terminate the handshake by sending an \"illegal_parameter\" alert. This requirement ensures consistency in cryptographic negotiation and prevents potential downgrade or mismatch attacks. The check is only applicable when a HelloRetryRequest was previously received and processed; it does not apply to initial handshakes without a retry.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request\"\nRule: Upon receiving the ServerHello, clients MUST check that the cipher suite supplied in the ServerHello is the same as that in the HelloRetryRequest and otherwise abort the handshake with an \"illegal_parameter\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request",
    "sentence": "The HelloRetryRequest extensions defined in this specification are: supported_versions (see Section 4.2.1), cookie (see Section 4.2.2), and key_share (see Section 4.2.8).",
    "enhanced_sentence": "The HelloRetryRequest message, sent by the server when it finds acceptable parameters in the ClientHello but requires additional information to proceed, MUST include the \"supported_versions\" extension to confirm the negotiated TLS version. It SHOULD contain only the minimal set of extensions needed for the client to generate a correct updated ClientHello, and MUST NOT include any extensions not first offered by the client, except for the optional \"cookie\" extension. The extensions defined for use in HelloRetryRequest in this specification are: supported_versions (see Section 4.2.1), cookie (see Section 4.2.2), and key_share (see Section 4.2.8). Upon receiving a HelloRetryRequest, the client MUST process these extensions, verify that the message would result in meaningful changes to its ClientHello, and then send an updated ClientHello. If the HelloRetryRequest does not prompt any change or if a second HelloRetryRequest is received, the client MUST abort the handshake.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request\"\nRule: The HelloRetryRequest extensions defined in this specification are: supported_versions (see Section 4.2.1), cookie (see Section 4.2.2), and key_share (see Section 4.2.8).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request",
    "sentence": "In addition, in its updated ClientHello, the client SHOULD NOT offer any pre-shared keys associated with a hash other than that of the selected cipher suite.",
    "enhanced_sentence": "When responding to a HelloRetryRequest, the client MUST send an updated ClientHello that aligns with the server’s selected parameters. In this updated ClientHello, the client SHOULD NOT include any pre-shared keys (PSKs) that are associated with a hash algorithm different from the one used by the cipher suite selected by the server. This rule applies only if the server has indicated a specific cipher suite in the HelloRetryRequest, and the client is using PSK-based authentication. Adhering to this ensures that the client avoids unnecessary computation of partial hash transcripts for multiple hash algorithms, streamlining the handshake process and reducing resource usage. Failure to follow this recommendation may result in inefficiencies but does not inherently cause a handshake failure, as the server is expected to ignore incompatible PSK offers.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request\"\nRule: In addition, in its updated ClientHello, the client SHOULD NOT offer any pre-shared keys associated with a hash other than that of the selected cipher suite.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request",
    "sentence": "The value of selected_version in the HelloRetryRequest \"supported_versions\" extension MUST be retained in the ServerHello, and a client MUST abort the handshake with an \"illegal_parameter\" alert if the value changes.",
    "enhanced_sentence": "This rule applies during the TLS 1.3 handshake when a server sends a HelloRetryRequest to request an updated ClientHello from the client. The server must include a \"supported_versions\" extension in the HelloRetryRequest, indicating the selected TLS version. When the server subsequently sends the ServerHello message (after receiving the client's updated ClientHello), it must use the exact same TLS version value in its \"supported_versions\" extension as was specified in the HelloRetryRequest. The client is required to verify that these version values match exactly. If the client detects any change in the selected_version between the HelloRetryRequest and the ServerHello, it must immediately abort the handshake by sending an \"illegal_parameter\" alert. This ensures version consistency throughout the handshake process and prevents version downgrade or manipulation attacks.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.4. Hello Retry Request\"\nRule: The value of selected_version in the HelloRetryRequest \"supported_versions\" extension MUST be retained in the ServerHello, and a client MUST abort the handshake with an \"illegal_parameter\" alert if the value changes.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions",
    "sentence": "If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in RFC5246, even if ClientHello.legacy_version is 0x0304 or later.",
    "enhanced_sentence": "This rule governs version negotiation fallback behavior when the client omits the \"supported_versions\" extension. It applies during the initial handshake phase when the server processes the ClientHello message. If the client does not include the \"supported_versions\" extension, compliant servers that support TLS 1.2 MUST fall back to negotiating TLS 1.2 or an earlier version as defined in RFC5246, regardless of the ClientHello.legacy_version field value (even if it indicates TLS 1.3 or later with 0x0304). This ensures backward compatibility with clients that may not support the newer extension-based negotiation mechanism. The expected outcome is that the connection will proceed using TLS 1.2 or earlier protocols. This rule applies only when the server is both compliant with TLS 1.3 specifications and maintains support for TLS 1.2.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions\"\nRule: If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in RFC5246, even if ClientHello.legacy_version is 0x0304 or later.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions",
    "sentence": "If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the \"supported_versions\" extension to determine client preferences.",
    "enhanced_sentence": "When a client includes the \"supported_versions\" extension in its ClientHello message, servers MUST disregard the legacy_version field for version negotiation purposes. Instead, servers MUST exclusively use the ordered list of protocol versions provided in the \"supported_versions\" extension to determine the client's preferred TLS versions. This rule applies during the initial handshake negotiation phase when processing ClientHello messages that contain the extension. The expected outcome is that servers will select the highest mutually supported TLS version from the client's explicitly provided list, ensuring accurate version negotiation even when legacy_version values might be inconsistent with the client's actual capabilities. This rule is conditional on the presence of the \"supported_versions\" extension in the ClientHello and requires servers to implement proper extension parsing capabilities.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions\"\nRule: If this extension is present in the ClientHello, servers MUST NOT use the ClientHello.legacy_version value for version negotiation and MUST use only the \"supported_versions\" extension to determine client preferences.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions",
    "sentence": "Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.",
    "enhanced_sentence": "When a server compliant with TLS 1.3 receives a ClientHello message where the legacy_version field is set to 0x0304 (indicating TLS 1.3) or a higher value, but the \"supported_versions\" extension is absent, the server MAY choose to abort the handshake. This rule applies during the initial handshake negotiation phase, immediately after parsing the ClientHello. The expected outcome is that the server may terminate the connection to avoid potential version negotiation ambiguities or downgrade attacks. This option is available only if the server supports TLS 1.3 and the client has failed to include the mandatory \"supported_versions\" extension while using a legacy_version value that suggests support for TLS 1.3 or later. If the extension is present, servers MUST ignore legacy_version and use only the extension for version negotiation.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions\"\nRule: Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions",
    "sentence": "Servers MUST only select a version of TLS present in the \"supported_versions\" extension and MUST ignore any unknown versions that are present in the extension.",
    "enhanced_sentence": "When processing a ClientHello message containing the \"supported_versions\" extension, servers MUST use this extension exclusively for version negotiation and MUST NOT consider the ClientHello.legacy_version field. The server MUST select a TLS version only from those explicitly listed in the client's \"supported_versions\" extension, and MUST ignore any unrecognized version values present in the extension. This rule applies during the initial handshake negotiation phase after receiving a ClientHello with the extension present. The expected outcome is that the server selects a mutually supported TLS version based on the client's stated preferences, ensuring forward compatibility by disregarding unknown versions while maintaining negotiation integrity. This rule is conditional upon the client including the \"supported_versions\" extension; if absent, servers fall back to legacy version negotiation methods.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions\"\nRule: Servers MUST only select a version of TLS present in the \"supported_versions\" extension and MUST ignore any unknown versions that are present in the extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions",
    "sentence": "Implementations of this specification MUST send this extension in the ClientHello containing all versions of TLS which the implementations are prepared to negotiate (for this specification, that means minimally 0x0304, but if previous versions of TLS are allowed to be negotiated, the previous versions MUST be present as well).",
    "enhanced_sentence": "During the TLS 1.3 handshake, when a client sends a ClientHello message, it MUST include the \"supported_versions\" extension. This extension must list all TLS versions the client is willing and able to negotiate, in order of preference (with the most preferred first). At a minimum, this list MUST include 0x0304 (TLS 1.3). If the client is also configured to support earlier TLS versions (e.g., TLS 1.2 or below), those versions MUST also be included in the list. This rule applies specifically to the initial handshake phase when the client is establishing a connection. By including this extension, the client ensures that the server uses the \"supported_versions\" list—not the legacy_version field—for version negotiation. Failure to include this extension may result in the server defaulting to TLS 1.2 or earlier (if supported), or the server may abort the handshake. Prerequisites: The client must be TLS 1.3–compliant and must have a valid list of supported TLS versions configured. The expected outcome is that the server correctly identifies the client’s supported versions and proceeds with a compatible TLS version or terminates the handshake if no mutual version is available.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions\"\nRule: Implementations of this specification MUST send this extension in the ClientHello containing all versions of TLS which the implementations are prepared to negotiate (for this specification, that means minimally 0x0304, but if previous versions of TLS are allowed to be negotiated, the previous versions MUST be present as well).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions",
    "sentence": "Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.",
    "enhanced_sentence": "When processing a ClientHello that includes the \"supported_versions\" extension, servers MUST be prepared to handle cases where the client's list of supported versions does not include TLS 1.3 (0x0304). This situation may occur if the client supports only older TLS versions or has a sparse version range. The server MUST use only the \"supported_versions\" extension (and not ClientHello.legacy_version) for version negotiation. If the server supports any of the versions listed, it MUST negotiate the highest mutually supported version and respond accordingly. If no mutually supported version exists, the server SHOULD abort the handshake. This rule applies whenever the \"supported_versions\" extension is present in the ClientHello, regardless of the legacy_version field.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions\"\nRule: Servers MUST be prepared to receive ClientHellos that include this extension but do not include 0x0304 in the list of versions.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions",
    "sentence": "A server which negotiates TLS 1.3 MUST respond by sending a \"supported_versions\" extension containing the selected version value (0x0304).",
    "enhanced_sentence": "When a server successfully negotiates TLS 1.3 as the protocol version, it MUST include a \"supported_versions\" extension in its ServerHello message, with the extension containing the single ProtocolVersion value 0x0304 (TLS 1.3). This rule applies after the server has received a ClientHello containing a \"supported_versions\" extension from the client, and the server has selected TLS 1.3 from the client's offered versions. The server MUST also set the ServerHello.legacy_version field to 0x0303 (TLS 1.2) for backward compatibility. The expected outcome is that the client uses this extension (and ignores the legacy_version field) to confirm the negotiated version. If the server negotiates any version prior to TLS 1.3, it MUST NOT send this extension.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions\"\nRule: A server which negotiates TLS 1.3 MUST respond by sending a \"supported_versions\" extension containing the selected version value (0x0304).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions",
    "sentence": "A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the \"supported_versions\" extension.",
    "enhanced_sentence": "This rule applies during the ServerHello message construction when the server has selected a TLS version earlier than TLS 1.3 for negotiation. The server MUST set the ServerHello.version field to the negotiated legacy version (e.g., 0x0303 for TLS 1.2) and MUST NOT include the \"supported_versions\" extension in the ServerHello. This ensures backward compatibility with clients that only understand pre-TLS 1.3 handshake formats, as the presence of the \"supported_versions\" extension would be unexpected and potentially cause interoperability issues. This behavior is conditional on the server having received a ClientHello that either lacks the \"supported_versions\" extension or includes it but allows negotiation of a pre-TLS 1.3 version. The expected outcome is a successful handshake using the legacy version negotiation mechanism without confusing the client with unnecessary or conflicting version indicators.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions\"\nRule: A server which negotiates a version of TLS prior to TLS 1.3 MUST set ServerHello.version and MUST NOT send the \"supported_versions\" extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions",
    "sentence": "The server MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2).",
    "enhanced_sentence": "When the server negotiates TLS 1.3, it MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2) regardless of the actual negotiated version. This rule applies after the server has determined TLS 1.3 as the negotiated version using the \"supported_versions\" extension from the ClientHello. The expected outcome is that the legacy_version field maintains backward compatibility with middleboxes that expect TLS 1.2 or earlier, while the actual negotiated version is correctly indicated in the \"supported_versions\" extension. This rule is conditional on the server having received a valid ClientHello containing the \"supported_versions\" extension and having selected TLS 1.3 as the negotiated protocol version.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions\"\nRule: The server MUST set the ServerHello.legacy_version field to 0x0303 (TLS 1.2).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions",
    "sentence": "Clients MUST check for this extension prior to processing the rest of the ServerHello (although they will have to parse the ServerHello in order to read the extension).",
    "enhanced_sentence": "When a client receives a ServerHello message, it MUST immediately check for the presence of the \"supported_versions\" extension before proceeding with any further processing of the ServerHello. This check is required because the extension, if present, overrides the ServerHello.legacy_version field for determining the negotiated TLS version. Although the client must parse the ServerHello to locate the extension, it must not interpret other fields (such as legacy_version) until after confirming whether the extension exists. If the extension is present, the client MUST ignore the legacy_version value and use only the version indicated in the extension. If the extension is absent, the client MUST rely on the legacy_version field for version negotiation. This rule applies specifically during the TLS handshake after the server has responded to the ClientHello.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions\"\nRule: Clients MUST check for this extension prior to processing the rest of the ServerHello (although they will have to parse the ServerHello in order to read the extension).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions",
    "sentence": "If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the \"supported_versions\" extension to determine the selected version.",
    "enhanced_sentence": "When a client receives a ServerHello message during the TLS 1.3 handshake, it MUST check for the presence of the \"supported_versions\" extension before processing other ServerHello fields. If this extension is present, the client MUST disregard the ServerHello.legacy_version value entirely and MUST rely exclusively on the ProtocolVersion value provided in the \"supported_versions\" extension to determine the negotiated TLS version. This rule applies only when the server has selected TLS 1.3 or a compatible version explicitly listed in the client’s original \"supported_versions\" extension. The expected outcome is that the client accurately identifies the negotiated version based on the extension, ensuring version negotiation aligns with TLS 1.3 semantics and preventing downgrade attacks. If the extension contains a version not offered by the client or a version below TLS 1.3, the client MUST abort the handshake with an \"illegal_parameter\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions\"\nRule: If this extension is present, clients MUST ignore the ServerHello.legacy_version value and MUST use only the \"supported_versions\" extension to determine the selected version.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.7. Supported Groups",
    "sentence": "When sent by the client, the \"supported_groups\" extension indicates the named groups which the client supports for key exchange, ordered from most preferred to least preferred.",
    "enhanced_sentence": "When sent by the client in the ClientHello message, the \"supported_groups\" extension lists the named groups (both Elliptic Curve and Finite Field groups) that the client supports for key exchange, ordered from most to least preferred. This extension is used by the server to select an appropriate key exchange group during the handshake. The client must include this extension if it proposes groups not considered default by the protocol. The server may respond with its own \"supported_groups\" extension to indicate its preferences, especially if the client’s \"key_share\" does not include the server’s preferred group, but the client must not use this information until the handshake completes successfully. In subsequent connections, the client may use the server’s indicated preferences to optimize its \"key_share\" extension.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.7. Supported Groups\"\nRule: When sent by the client, the \"supported_groups\" extension indicates the named groups which the client supports for key exchange, ordered from most preferred to least preferred.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.7. Supported Groups",
    "sentence": "As of TLS 1.3, servers are permitted to send the \"supported_groups\" extension to the client.",
    "enhanced_sentence": "As of TLS 1.3, servers are permitted to send the \"supported_groups\" extension to the client, which lists all named groups the server supports for key exchange, ordered by preference. This extension is used to inform the client of the server’s group preferences, particularly when the server prefers a group not included in the client’s \"key_share\" extension but is still willing to proceed with the handshake. The server SHOULD include all groups it supports, regardless of client support. Clients MUST NOT use information from this extension until after the handshake completes successfully but MAY use it to adjust their \"key_share\" offerings in future connections. This rule applies during the handshake when the server responds to a ClientHello.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.7. Supported Groups\"\nRule: As of TLS 1.3, servers are permitted to send the \"supported_groups\" extension to the client.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions",
    "sentence": "If the \"supported_versions\" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an \"illegal_parameter\" alert.",
    "enhanced_sentence": "This rule governs the client's validation of the negotiated TLS version during the ServerHello processing phase. It applies when the client receives a ServerHello message containing the \"supported_versions\" extension, which must be checked immediately after parsing the extension (before processing other ServerHello contents). The client must verify that the version indicated in the server's \"supported_versions\" extension is both present in the client's originally offered versions (from the ClientHello's \"supported_versions\" extension) and is at least TLS 1.3 (0x0304). Prerequisites include: the client must have sent a \"supported_versions\" extension in its ClientHello, and the server must have responded with a ServerHello containing this extension (indicating TLS 1.3 negotiation). If the server's selected version fails these checks—meaning it was not offered by the client or is a version older than TLS 1.3—the client MUST treat this as a protocol violation and immediately abort the handshake by sending an \"illegal_parameter\" alert. This ensures version negotiation integrity and prevents downgrade or version mismatch attacks.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.1. Supported Versions\"\nRule: If the \"supported_versions\" extension in the ServerHello contains a version not offered by the client or contains a version prior to TLS 1.3, the client MUST abort the handshake with an \"illegal_parameter\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.1. Ticket Age",
    "sentence": "Clients MUST NOT attempt to use tickets which have ages greater than the \"ticket_lifetime\" value which was provided with the ticket.",
    "enhanced_sentence": "When resuming a session using a pre-shared key (PSK) extension, clients MUST NOT attempt to use tickets whose calculated age (measured in milliseconds since receipt of the NewSessionTicket message) exceeds the \"ticket_lifetime\" value (in seconds) provided with the ticket. This rule applies during the ClientHello construction phase when selecting a PSK identity for session resumption. Compliance ensures that only valid, non-expired tickets are presented to the server, preventing connection failures due to expired credentials. This requirement is conditional on the client having stored both the ticket and its associated \"ticket_lifetime\" and \"ticket_age_add\" values from the original NewSessionTicket message.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.1. Ticket Age\"\nRule: Clients MUST NOT attempt to use tickets which have ages greater than the \"ticket_lifetime\" value which was provided with the ticket.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.7. Supported Groups",
    "sentence": "The \"extension_data\" field of this extension contains a \"NamedGroupList\" value.",
    "enhanced_sentence": "The \"extension_data\" field of the \"supported_groups\" extension MUST contain a \"NamedGroupList\" value, which is an ordered list (from most to least preferred) of named elliptic curve or finite field groups that the sender supports for key exchange. When sent by the client, this list indicates its supported key exchange groups; when sent by the server (permitted in TLS 1.3), it communicates the server’s group preferences, potentially to guide future client connections. This rule applies during the handshake when the extension is included in a ClientHello or ServerHello message. Clients MUST ignore this extension until the handshake completes successfully but MAY use it to adjust \"key_share\" content in subsequent connections. The list MUST include all groups the sender supports, even if not currently supported by the peer, and MUST exclude private use ranges (0xFE00–0xFEFF for EC groups, 0x01FC–0x01FF for finite field groups).",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.7. Supported Groups\"\nRule: The \"extension_data\" field of this extension contains a \"NamedGroupList\" value.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.7. Supported Groups",
    "sentence": "Clients MUST NOT act upon any information found in \"supported_groups\" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their \"key_share\" extension in subsequent connections.",
    "enhanced_sentence": "The \"supported_groups\" extension, which may be sent by either client or server, lists the named groups supported for key exchange in order of preference. Clients MUST NOT use any information from a received \"supported_groups\" extension to alter their behavior during the current handshake before it has been successfully completed, as this could expose them to tampering or downgrade attacks. However, once a handshake has completed successfully and the extension's contents have been authenticated, clients MAY use the learned server preferences to optimize their \"key_share\" extension in future connections by offering groups the server is known to prefer. This rule applies whenever a client processes a \"supported_groups\" extension received from a server, ensuring security during handshake negotiation while allowing post-handshake operational improvements.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.7. Supported Groups\"\nRule: Clients MUST NOT act upon any information found in \"supported_groups\" prior to successful completion of the handshake but MAY use the information learned from a successfully completed handshake to change what groups they use in their \"key_share\" extension in subsequent connections.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.1. Ticket Age",
    "sentence": "The addition of the \"ticket_age_add\" value prevents passive observers from correlating connections unless tickets are reused.",
    "enhanced_sentence": "When a client includes a pre-shared key (PSK) from a NewSessionTicket in a TLS 1.3 handshake, it must compute the \"obfuscated_ticket_age\" for each PskIdentity by taking the actual ticket age in milliseconds and adding the \"ticket_age_add\" value provided with the ticket (modulo 2^32). This rule applies during the ClientHello construction when PSK resumption is attempted. The expected outcome is that passive network observers cannot correlate separate TLS connections by analyzing ticket age timings, unless the same ticket is reused across connections. This protection requires that the \"ticket_age_add\" value was randomly generated by the server when issuing the ticket and remains consistent for that specific ticket.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.1. Ticket Age\"\nRule: The addition of the \"ticket_age_add\" value prevents passive observers from correlating connections unless tickets are reused.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.7. Supported Groups",
    "sentence": "If the server has a group it prefers to the ones in the \"key_share\" extension but is still willing to accept the ClientHello, it SHOULD send \"supported_groups\" to update the client's view of its preferences; this extension SHOULD contain all groups the server supports, regardless of whether they are currently supported by the client.",
    "enhanced_sentence": "This rule governs the server's behavior when responding to a ClientHello that includes a \"key_share\" extension with groups that are acceptable but not the server's preferred choice. It applies during the ServerHello message construction phase, after the server has evaluated the client's proposed key exchange groups. If the server is willing to proceed with the connection using the client's offered groups but has a stronger preference for other supported groups not included in the client's \"key_share\", the server SHOULD include the \"supported_groups\" extension in its response. This extension MUST list all groups the server supports, in order of the server's preference, even if some are not supported by the client. The expected outcome is that the client receives updated information about the server's group preferences, which it SHOULD use to optimize future connections by including the server's preferred groups in subsequent \"key_share\" extensions. This rule applies only if the server accepts the ClientHello and proceeds with the handshake; it does not apply if the server requires a different group and must respond with a HelloRetryRequest.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.7. Supported Groups\"\nRule: If the server has a group it prefers to the ones in the \"key_share\" extension but is still willing to accept the ClientHello, it SHOULD send \"supported_groups\" to update the client's view of its preferences; this extension SHOULD contain all groups the server supports, regardless of whether they are currently supported by the client.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.1. Ticket Age",
    "sentence": "Note that the \"ticket_lifetime\" field in the NewSessionTicket message is in seconds but the \"obfuscated_ticket_age\" is in milliseconds.",
    "enhanced_sentence": "When implementing the TLS 1.3 Pre-Shared Key Extension, note that the \"ticket_lifetime\" field in the NewSessionTicket message is expressed in seconds, while the \"obfuscated_ticket_age\" field in the PskIdentity structure is in milliseconds. This rule applies when a client is preparing to resume a session using a PSK ticket, and must calculate and obfuscate the ticket age for inclusion in the ClientHello. The client must convert the ticket age to milliseconds before applying the \"ticket_age_add\" obfuscation, ensuring that the value remains within a 32-bit range and that the server can correctly validate the ticket against its lifetime (which is provided in seconds). Prerequisites include having a valid NewSessionTicket with both \"ticket_lifetime\" and \"ticket_age_add\" values, and ensuring the ticket has not expired based on the lifetime check.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.1. Ticket Age\"\nRule: Note that the \"ticket_lifetime\" field in the NewSessionTicket message is in seconds but the \"obfuscated_ticket_age\" is in milliseconds.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.3. Processing Order",
    "sentence": "In order to avoid deadlocks, when accepting \"early_data\", servers MUST process the client's ClientHello and then immediately send their flight of messages, rather than waiting for the client's EndOfEarlyData message before sending the server's ServerHello.",
    "enhanced_sentence": "When a server accepts the \"early_data\" extension in a TLS 1.3 handshake, it MUST process the ClientHello and immediately proceed to send its flight of messages (including the ServerHello) without waiting for the client's EndOfEarlyData message. This rule applies specifically when the server is configured to support 0-RTT early data and has validated the client's pre-shared key. The expected outcome is to prevent a deadlock scenario where the client waits for the server's Finished message before sending EndOfEarlyData, while the server waits for EndOfEarlyData before proceeding. By sending its flight immediately, the server ensures forward progress in the handshake, allowing the client to conclude the early data phase and complete the handshake.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.3. Processing Order\"\nRule: In order to avoid deadlocks, when accepting \"early_data\", servers MUST process the client's ClientHello and then immediately send their flight of messages, rather than waiting for the client's EndOfEarlyData message before sending the server's ServerHello.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.3. Processing Order",
    "sentence": "Clients are permitted to \"stream\" 0-RTT data until they receive the server's Finished, only then sending the EndOfEarlyData message, followed by the rest of the handshake.",
    "enhanced_sentence": "This rule governs the client's behavior when using 0-RTT (zero round-trip time) data in TLS 1.3. It applies after the client has sent an early data payload as part of its initial flight and is awaiting the server's response. The client is allowed to continue streaming additional 0-RTT application data until it receives the server's Finished message, which confirms the server has accepted the early data and completed its part of the handshake. Only upon receiving the server's Finished must the client send an EndOfEarlyData message to signal the end of early data transmission, followed by any remaining handshake messages (such as its own Finished). This rule ensures proper sequencing and avoids deadlocks, as servers are required to process the ClientHello and send their response without waiting for the client's EndOfEarlyData. Prerequisites include a valid pre-shared key (PSK) session resumption and server acceptance of early_data.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.3. Processing Order\"\nRule: Clients are permitted to \"stream\" 0-RTT data until they receive the server's Finished, only then sending the EndOfEarlyData message, followed by the rest of the handshake.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.3. Server Parameters",
    "sentence": "The next two messages from the server, EncryptedExtensions and CertificateRequest, contain information from the server that determines the rest of the handshake.",
    "enhanced_sentence": "After the server has sent its ServerHello message and both parties have derived the server_handshake_traffic_secret, the server must send the EncryptedExtensions message, which is mandatory, and may optionally send a CertificateRequest message if client authentication is required. These messages are encrypted using keys derived from the server_handshake_traffic_secret and contain critical server parameters—such as negotiated extensions and certificate request details—that define the subsequent structure and content of the handshake, including whether certificate-based client authentication will occur. The client must process these messages to proceed correctly with the handshake, such as by providing a certificate if requested.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.3. Server Parameters\"\nRule: The next two messages from the server, EncryptedExtensions and CertificateRequest, contain information from the server that determines the rest of the handshake.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.9. Pre-Shared Key Exchange Modes",
    "sentence": "In order to use PSKs, clients MUST also send a \"psk_key_exchange_modes\" extension.",
    "enhanced_sentence": "When a TLS 1.3 client offers a \"pre_shared_key\" extension to use PSKs for authentication or resumption, it MUST also include a \"psk_key_exchange_modes\" extension in the same ClientHello. This extension specifies which key exchange modes (e.g., psk_ke for PSK-only or psk_dhe_ke for PSK with (EC)DHE) the client supports for both offered and server-provided PSKs. If the client omits this extension while offering \"pre_shared_key\", servers MUST abort the handshake. The server MUST NOT send this extension and MUST only select a key exchange mode advertised by the client. For psk_ke mode, the server MUST NOT provide a \"key_share\"; for psk_dhe_ke, both parties MUST supply \"key_share\" values.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.9. Pre-Shared Key Exchange Modes\"\nRule: In order to use PSKs, clients MUST also send a \"psk_key_exchange_modes\" extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.9. Pre-Shared Key Exchange Modes",
    "sentence": "A client MUST provide a \"psk_key_exchange_modes\" extension if it offers a \"pre_shared_key\" extension.",
    "enhanced_sentence": "When a client includes the \"pre_shared_key\" extension in its ClientHello to offer pre-shared keys (PSKs) for authentication or resumption, it MUST also include the \"psk_key_exchange_modes\" extension. This extension specifies which key exchange modes (e.g., psk_ke for PSK-only or psk_dhe_ke for PSK with (EC)DHE) the client supports for PSK-based handshakes. The rule applies during the initial handshake when constructing the ClientHello message. If the client omits this extension while offering \"pre_shared_key\", servers are required to abort the handshake. Adherence ensures interoperability by clearly communicating client capabilities, allowing the server to select a compatible mode and proceed with the handshake.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.9. Pre-Shared Key Exchange Modes\"\nRule: A client MUST provide a \"psk_key_exchange_modes\" extension if it offers a \"pre_shared_key\" extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.9. Pre-Shared Key Exchange Modes",
    "sentence": "If clients offer \"pre_shared_key\" without a \"psk_key_exchange_modes\" extension, servers MUST abort the handshake.",
    "enhanced_sentence": "When a client includes the \"pre_shared_key\" extension in its ClientHello to propose the use of a pre-shared key (PSK) for authentication or resumption, it MUST also include the \"psk_key_exchange_modes\" extension to indicate which key exchange methods (e.g., PSK-only or PSK with (EC)DHE) it supports. If a server receives a ClientHello containing a \"pre_shared_key\" extension but no corresponding \"psk_key_exchange_modes\" extension, it MUST treat this as a protocol violation and abort the handshake immediately with a fatal alert. This requirement ensures that both parties agree on compatible PSK key exchange methods, preventing ambiguous or insecure handshake outcomes.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.9. Pre-Shared Key Exchange Modes\"\nRule: If clients offer \"pre_shared_key\" without a \"psk_key_exchange_modes\" extension, servers MUST abort the handshake.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.9. Pre-Shared Key Exchange Modes",
    "sentence": "In psk_ke mode, the server MUST NOT supply a \"key_share\" value.",
    "enhanced_sentence": "When the server selects psk_ke mode (PSK-only key establishment) in response to a client's \"psk_key_exchange_modes\" extension, it MUST NOT include a \"key_share\" extension in its ServerHello message. This rule applies because psk_ke mode relies solely on the pre-shared key for key derivation and does not require an additional Diffie-Hellman key exchange. The absence of a \"key_share\" value signals to the client that the handshake will proceed without (EC)DHE contribution, ensuring both parties derive session keys exclusively from the PSK. This behavior is mandatory only if the client has advertised support for psk_ke and the server chooses this mode.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.9. Pre-Shared Key Exchange Modes\"\nRule: In psk_ke mode, the server MUST NOT supply a \"key_share\" value.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.9. Pre-Shared Key Exchange Modes",
    "sentence": "The semantics of this extension are that the client only supports the use of PSKs with these modes, which restricts both the use of PSKs offered in this ClientHello and those which the server might supply via NewSessionTicket.",
    "enhanced_sentence": "The \"psk_key_exchange_modes\" extension, which must be included by the client whenever it offers a \"pre_shared_key\" extension, specifies the only key exchange modes the client supports for PSK usage. This restriction applies both to PSKs offered in the current ClientHello and to any future PSKs the server might provide via NewSessionTicket messages. Servers must strictly adhere to the client's advertised modes: they must not select an unlisted mode during the handshake and should avoid issuing NewSessionTickets incompatible with these modes to prevent resumption failures. The extension supports two defined modes: psk_ke (PSK-only, requiring no \"key_share\") and psk_dhe_ke (PSK with (EC)DHE, requiring \"key_share\" values from both parties). If a client omits this extension while offering \"pre_shared_key\", servers must abort the handshake.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.9. Pre-Shared Key Exchange Modes\"\nRule: The semantics of this extension are that the client only supports the use of PSKs with these modes, which restricts both the use of PSKs offered in this ClientHello and those which the server might supply via NewSessionTicket.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.9. Pre-Shared Key Exchange Modes",
    "sentence": "The server MUST NOT send a \"psk_key_exchange_modes\" extension.",
    "enhanced_sentence": "The server MUST NOT send a \"psk_key_exchange_modes\" extension at any point during the TLS 1.3 handshake. This rule applies because the client is solely responsible for advertising supported PSK key exchange modes, and the server must only select from the modes provided by the client in its \"psk_key_exchange_modes\" extension. Sending this extension from the server would be redundant and is explicitly prohibited by the protocol specification to avoid ambiguity and ensure interoperability. The expected outcome is that the server processes the client's advertised modes, selects a compatible one, and proceeds with the handshake without attempting to negotiate or override the client's stated preferences. This rule is unconditional and applies in all TLS 1.3 handshakes involving PSK-based authentication.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.9. Pre-Shared Key Exchange Modes\"\nRule: The server MUST NOT send a \"psk_key_exchange_modes\" extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.9. Pre-Shared Key Exchange Modes",
    "sentence": "In psk_dhe_ke mode, the client and server MUST supply \"key_share\" values as described in Section 4.2.8.",
    "enhanced_sentence": "When the server selects psk_dhe_ke mode (as indicated by the client's \"psk_key_exchange_modes\" extension), both parties MUST exchange fresh ephemeral keys to ensure forward secrecy. This rule applies during the handshake negotiation phase after the server has chosen psk_dhe_ke from the client's supported modes. The client MUST include a \"key_share\" extension in its ClientHello, and the server MUST respond with its own \"key_share\" in ServerHello as specified in Section 4.2.8. The expected outcome is a combined key derivation using both the pre-shared key and ephemeral Diffie-Hellman exchange, providing mutual authentication and forward secrecy. This requirement only applies when psk_dhe_ke is selected; it does not apply to psk_ke mode where \"key_share\" values are prohibited.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.9. Pre-Shared Key Exchange Modes\"\nRule: In psk_dhe_ke mode, the client and server MUST supply \"key_share\" values as described in Section 4.2.8.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "In TLS 1.3, the TLS server indicates its version using the \"supported_versions\" extension (Section 4.2.1), and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2.",
    "enhanced_sentence": "When a TLS 1.3 server sends a ServerHello message in response to a ClientHello, it must set the legacy_version field to 0x0303 (TLS 1.2) for backward compatibility with middleboxes, even though the actual negotiated version is indicated via the \"supported_versions\" extension. This rule applies during the initial handshake phase when the server is establishing a TLS 1.3 connection. The expected outcome is that middleboxes interpreting the legacy_version field will not interfere with the handshake, while compliant clients will correctly identify the TLS 1.3 version via the extension. Prerequisites include the server supporting TLS 1.3 and the client’s ClientHello indicating TLS 1.3 capability. The server must also include the \"supported_versions\" extension to explicitly signal TLS 1.3 support.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: In TLS 1.3, the TLS server indicates its version using the \"supported_versions\" extension (Section 4.2.1), and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.9. Pre-Shared Key Exchange Modes",
    "sentence": "Any future values that are allocated must ensure that the transmitted protocol messages unambiguously identify which mode was selected by the server; at present, this is indicated by the presence of the \"key_share\" in the ServerHello.",
    "enhanced_sentence": "When defining new values for the PskKeyExchangeMode enum (beyond the existing psk_ke and psk_dhe_ke), protocol designers must ensure that the server's selected mode is unambiguously identifiable from the transmitted handshake messages. This requirement applies during the ServerHello construction when a PSK mode is negotiated. The expected outcome is that any party inspecting the protocol flow (including the client, server, or passive observers) can definitively determine which PSK key exchange mode was chosen. This rule applies only when the client has offered a \"pre_shared_key\" extension and a corresponding \"psk_key_exchange_modes\" extension, and the server selects one of the offered modes. Currently, this identification is achieved by the presence (for psk_dhe_ke) or absence (for psk_ke) of the \"key_share\" extension in the ServerHello; future modes must provide equally clear and deterministic signaling.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.9. Pre-Shared Key Exchange Modes\"\nRule: Any future values that are allocated must ensure that the transmitted protocol messages unambiguously identify which mode was selected by the server; at present, this is indicated by the presence of the \"key_share\" in the ServerHello.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "The random structure is generated by the server and MUST be generated independently of the ClientHello.random.",
    "enhanced_sentence": "The ServerHello.random field MUST be generated by the server using a cryptographically secure random number generator, and its value MUST be statistically independent of the ClientHello.random value received from the client. This rule applies when the server constructs the ServerHello message in response to a valid ClientHello, and it ensures that both parties contribute unique, unpredictable random values to the handshake, which is critical for generating secure session keys and preventing replay attacks. The server MUST NOT derive any portion of its random value from the client's random value, except when implementing backward compatibility measures for TLS 1.2 or below, where the last 8 bytes are overwritten with specific downgrade indicators while the remaining bytes maintain full randomness. Proper adherence to this rule is essential for the security of the key exchange process.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: The random structure is generated by the server and MUST be generated independently of the ClientHello.random.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "The server will send the ServerHello message in response to a ClientHello message to proceed with the handshake if the server is able to negotiate an acceptable set of handshake parameters based on the ClientHello.",
    "enhanced_sentence": "The server MUST send a ServerHello message in response to a ClientHello message only if it can successfully negotiate a mutually acceptable set of handshake parameters, including protocol version, cipher suite, and extensions, based on the client's offered options. This message initiates the cryptographic handshake and MUST conform to the TLS 1.3 structure, including setting legacy_version to 0x0303, echoing the client's legacy_session_id, selecting a cipher suite from the client's list, and including mandatory extensions like \"supported_versions\" and either \"pre_shared_key\" or \"key_share\". The server MUST generate a secure random value, with the last 8 bytes set to specific values if downgrading to TLS 1.2 or below for backward compatibility. If the server cannot negotiate acceptable parameters, it MUST respond with a handshake failure alert instead of proceeding. This rule applies immediately after receiving a valid ClientHello and before any further handshake messages are exchanged.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: The server will send the ServerHello message in response to a ClientHello message to proceed with the handshake if the server is able to negotiate an acceptable set of handshake parameters based on the ClientHello.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "A client which receives a legacy_session_id_echo field that does not match what it sent in the ClientHello MUST abort the handshake with an \"illegal_parameter\" alert.",
    "enhanced_sentence": "When a client receives a ServerHello message in response to its ClientHello, it MUST verify that the legacy_session_id_echo field exactly matches the legacy_session_id it originally sent. This validation occurs immediately after receiving the ServerHello, before proceeding with any further handshake steps. If the values do not match, the client MUST immediately terminate the handshake by sending an \"illegal_parameter\" alert and aborting the connection. This rule applies regardless of whether the server intends to resume a session or not, as the server is required to echo the client's session_id value verbatim. The purpose of this check is to ensure protocol consistency and detect potential middlebox interference or malicious modification of the handshake parameters.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: A client which receives a legacy_session_id_echo field that does not match what it sent in the ClientHello MUST abort the handshake with an \"illegal_parameter\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "cipher_suite: The single cipher suite selected by the server from the list in ClientHello.cipher_suites.",
    "enhanced_sentence": "The cipher_suite field in the ServerHello message MUST contain exactly one cipher suite selected by the server from the list provided in ClientHello.cipher_suites. This selection occurs during the handshake negotiation phase when the server responds to a ClientHello, and it determines the cryptographic algorithms that will be used for the connection. The server MUST NOT propose a cipher suite that was not offered by the client. If a client receives a cipher suite that was not present in its ClientHello.cipher_suites list, it MUST abort the handshake with an \"illegal_parameter\" alert. This rule applies only after the server has successfully parsed the ClientHello and is proceeding with the handshake.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: cipher_suite: The single cipher suite selected by the server from the list in ClientHello.cipher_suites.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "A client which receives a cipher suite that was not offered MUST abort the handshake with an \"illegal_parameter\" alert.",
    "enhanced_sentence": "During the TLS 1.3 handshake, after a client sends a ClientHello message containing a list of supported cipher suites, the server responds with a ServerHello message that includes a single selected cipher suite. This rule applies specifically when the client processes the ServerHello message. The client MUST verify that the cipher suite in the ServerHello.cipher_suite field is one that was previously offered in the ClientHello.cipher_suites list. If the server selects a cipher suite that was not offered by the client, this constitutes a protocol violation, and the client MUST immediately abort the handshake by sending an \"illegal_parameter\" alert. This enforcement ensures that the negotiated cryptographic parameters are mutually agreed upon and prevents potential downgrade or manipulation attacks.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: A client which receives a cipher suite that was not offered MUST abort the handshake with an \"illegal_parameter\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "The ServerHello MUST only include extensions which are required to establish the cryptographic context and negotiate the protocol version.",
    "enhanced_sentence": "The ServerHello message MUST only include extensions that are strictly necessary for establishing the cryptographic context (such as key exchange parameters) and negotiating the protocol version. This rule applies when the server responds to a ClientHello message and is constructing the ServerHello message. All TLS 1.3 ServerHello messages MUST contain the \"supported_versions\" extension, and depending on the handshake mode, they MUST also include either the \"pre_shared_key\" extension, the \"key_share\" extension, or both. Any other extensions that are not essential for cryptographic setup or version negotiation MUST be deferred and sent later in the EncryptedExtensions message. This restriction ensures minimal and focused ServerHello content, reducing exposure to middlebox interference and maintaining protocol efficiency.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: The ServerHello MUST only include extensions which are required to establish the cryptographic context and negotiate the protocol version.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "Structure of the ServerHello message: struct { ProtocolVersion legacy_version = 0x0303; Random random; opaque legacy_session_id_echo<0..32>; CipherSuite cipher_suite; uint8 legacy_compression_method = 0; Extension extensions<6..2^16-1>; } ServerHello.",
    "enhanced_sentence": "The ServerHello message is sent by the server in response to a ClientHello to proceed with the handshake, provided the server can negotiate acceptable parameters. This rule applies after the client initiates the handshake with a ClientHello. The ServerHello structure is defined as: struct { ProtocolVersion legacy_version = 0x0303; Random random; opaque legacy_session_id_echo<0..32>; CipherSuite cipher_suite; uint8 legacy_compression_method = 0; Extension extensions<6..2^16-1>; } ServerHello. Prerequisites include receiving a valid ClientHello. The expected outcome is the establishment of handshake parameters, including version negotiation via the \"supported_versions\" extension (required in TLS 1.3), cipher suite selection, and random value generation. The legacy_version must be set to 0x0303 (TLS 1.2) for backward compatibility, while the actual negotiated version is indicated in the extension. The legacy_session_id_echo must match the client's provided value, or the handshake must be aborted. The cipher_suite must be one offered by the client. The random field must be securely generated, with the last 8 bytes set to specific values if downgrading to TLS 1.2 or below to signal downgrade protection. Extensions must only include those necessary for cryptographic context and version negotiation. If the ServerHello Random matches the SHA-256 of \"HelloRetryRequest\", it must be processed as a HelloRetryRequest instead.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: Structure of the ServerHello message: struct { ProtocolVersion legacy_version = 0x0303; Random random; opaque legacy_session_id_echo<0..32>; CipherSuite cipher_suite; uint8 legacy_compression_method = 0; Extension extensions<6..2^16-1>; } ServerHello.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "legacy_compression_method: A single byte which MUST have the value 0.",
    "enhanced_sentence": "The `legacy_compression_method` field is a single byte in the ServerHello message that MUST be set to 0. This field is a backward compatibility placeholder from earlier TLS versions where compression methods were negotiated, but TLS 1.3 explicitly disallows compression due to security vulnerabilities (e.g., CRIME attack). The value 0 indicates the \"null\" compression method, meaning no compression is used. This rule applies when the server constructs the ServerHello message in response to a ClientHello during the TLS 1.3 handshake. Servers MUST set this byte to 0, and clients MUST accept only this value; any other value MUST result in termination of the handshake with an \"illegal_parameter\" alert. This field has no functional purpose in TLS 1.3 and exists solely to maintain structural compatibility with older implementations.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: legacy_compression_method: A single byte which MUST have the value 0.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "extensions: A list of extensions.",
    "enhanced_sentence": "The extensions field in the ServerHello message MUST contain a list of extensions that are strictly necessary for establishing the cryptographic context and negotiating the protocol version. This field applies when the server is responding to a ClientHello and has selected an acceptable set of handshake parameters. All TLS 1.3 ServerHello messages MUST include the \"supported_versions\" extension to indicate the negotiated TLS version. Additionally, the message MUST contain either the \"pre_shared_key\" extension or the \"key_share\" extension (or both, when using a PSK with (EC)DHE key establishment). Extensions not required for cryptographic context establishment MUST NOT be included in the ServerHello and should instead be sent in the EncryptedExtensions message. The server MUST ensure that any echoed values from the ClientHello (e.g., in legacy_session_id_echo) are correctly reflected, and the client MUST validate that received extensions and values are consistent with the ClientHello; mismatches require aborting the handshake with an \"illegal_parameter\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: extensions: A list of extensions.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "All TLS 1.3 ServerHello messages MUST contain the \"supported_versions\" extension.",
    "enhanced_sentence": "During the TLS 1.3 handshake, immediately after receiving a ClientHello, the server MUST include the \"supported_versions\" extension in every ServerHello message to explicitly indicate the negotiated protocol version. This rule applies specifically to TLS 1.3 ServerHello messages and is mandatory regardless of whether the handshake proceeds normally or results in a HelloRetryRequest. The extension serves as the primary version negotiation mechanism, replacing the legacy_version field which is fixed to 0x0303 (TLS 1.2) for backward compatibility. Failure to include this extension MUST cause the client to treat the handshake as invalid and abort with an appropriate alert. This requirement ensures unambiguous version selection and prevents downgrade attacks, working in conjunction with other ServerHello extensions like \"key_share\" or \"pre_shared_key\" to establish the cryptographic context.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: All TLS 1.3 ServerHello messages MUST contain the \"supported_versions\" extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "Other extensions (see Section 4.2) are sent separately in the EncryptedExtensions message.",
    "enhanced_sentence": "During the ServerHello message construction, only extensions required for cryptographic context establishment and version negotiation (specifically \"supported_versions\" and either \"pre_shared_key\" or \"key_share\") are included. This rule applies after the server has selected an acceptable cipher suite and protocol version from the ClientHello. All other extensions defined in Section 4.2 (such as application-layer protocol negotiation, server name indication, or certificate-related extensions) MUST be deferred and sent in the subsequent EncryptedExtensions message, which is transmitted after the server's key exchange message and before the Certificate message. This separation ensures that non-essential extensions are protected under the established handshake keys, maintaining security and compatibility with middleboxes.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: Other extensions (see Section 4.2) are sent separately in the EncryptedExtensions message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "Current ServerHello messages additionally contain either the \"pre_shared_key\" extension or the \"key_share\" extension, or both (when using a PSK with (EC)DHE key establishment).",
    "enhanced_sentence": "In TLS 1.3, every ServerHello message MUST include either the \"pre_shared_key\" extension (for PSK-based session resumption), the \"key_share\" extension (for (EC)DHE key exchange), or both extensions when combining PSK with (EC)DHE key establishment. This requirement applies immediately after the server selects an acceptable cipher suite from the ClientHello and proceeds with the handshake. These extensions are essential for establishing the cryptographic context and enabling key derivation. The ServerHello MUST NOT contain any other extensions unrelated to version negotiation or cryptographic setup; those are deferred to the EncryptedExtensions message. Failure to include at least one of these required extensions, or including unsupported extensions, MUST result in the client aborting the handshake with an \"illegal_parameter\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: Current ServerHello messages additionally contain either the \"pre_shared_key\" extension or the \"key_share\" extension, or both (when using a PSK with (EC)DHE key establishment).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "Upon receiving a message with type server_hello, implementations MUST first examine the Random value and, if it matches this special value, process it as described in Section 4.1.4.",
    "enhanced_sentence": "When a client receives a ServerHello message during the TLS 1.3 handshake, it MUST first inspect the Random field. If the Random value matches the special SHA-256 hash of \"HelloRetryRequest\" (as defined in Appendix D.4), the message MUST be interpreted as a HelloRetryRequest rather than a standard ServerHello, and processed according to Section 4.1.4. This check is critical for distinguishing between a genuine ServerHello and a retry request, which uses the same message structure for backward compatibility with middleboxes but serves a different protocol function. The rule applies immediately upon receipt of any ServerHello-type message and ensures correct handshake flow interpretation.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: Upon receiving a message with type server_hello, implementations MUST first examine the Random value and, if it matches this special value, process it as described in Section 4.1.4.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "For reasons of backward compatibility with middleboxes (see Appendix D.4), the HelloRetryRequest message uses the same structure as the ServerHello, but with the Random field set to the special value of the SHA-256 of \"HelloRetryRequest\".",
    "enhanced_sentence": "When the server needs to request a retry from the client due to missing or mismatched key shares (as specified in Section 4.1.4), it sends a HelloRetryRequest message. For backward compatibility with middleboxes that may inspect or filter TLS handshake messages (see Appendix D.4), the HelloRetryRequest MUST use the identical wire format structure as a ServerHello message. However, to distinguish it from a genuine ServerHello, the Random field MUST be set to the fixed value of SHA-256(\"HelloRetryRequest\") instead of a randomly generated value. Upon receiving any server_hello message, implementations MUST first check the Random field; if it matches this predefined special value, the message MUST be processed as a HelloRetryRequest according to the retry logic, not as a standard ServerHello. This rule applies only when the server is operating in TLS 1.3 mode and determines that a HelloRetryRequest is necessary to proceed with the handshake.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: For reasons of backward compatibility with middleboxes (see Appendix D.4), the HelloRetryRequest message uses the same structure as the ServerHello, but with the Random field set to the special value of the SHA-256 of \"HelloRetryRequest\".\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "If negotiating TLS 1.2, TLS 1.3 servers MUST set the last 8 bytes of their Random value to the bytes: 44 4F 57 4E 47 52 44 01.",
    "enhanced_sentence": "When a TLS 1.3 server responds to a ClientHello and negotiates TLS 1.2 (as indicated by the legacy_version field set to 0x0303 and the absence of a supported_versions extension indicating TLS 1.3), it MUST overwrite the last 8 bytes of its ServerHello.random field with the fixed byte sequence 44 4F 57 4E 47 52 44 01. The first 24 bytes of the random field must still be generated using a secure random number generator. This rule applies during the ServerHello message construction phase of the handshake and serves as a downgrade protection mechanism: TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 must check for this value and abort the handshake with an \"illegal_parameter\" alert if detected, preventing potential version downgrade attacks. Note that this protection is only effective when ephemeral ciphers are used and does not apply when static RSA is negotiated.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: If negotiating TLS 1.2, TLS 1.3 servers MUST set the last 8 bytes of their Random value to the bytes: 44 4F 57 4E 47 52 44 01.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "TLS 1.3 servers which negotiate TLS 1.2 or below in response to a ClientHello MUST set the last 8 bytes of their Random value specially in their ServerHello.",
    "enhanced_sentence": "When a TLS 1.3 server responds to a ClientHello by negotiating TLS 1.2 or an earlier version (due to compatibility requirements or downgrade attacks), it MUST overwrite the last 8 bytes of the ServerHello.Random field with specific fixed values to signal a potential downgrade. This rule applies during the ServerHello message construction, immediately after version negotiation. If TLS 1.2 is negotiated, the last 8 bytes MUST be set to 44 4F 57 4E 47 52 44 01; for TLS 1.1 or below, they MUST be set to 44 4F 57 4E 47 52 44 00. The first 24 bytes of the Random field MUST still be generated using a secure random number generator. This mechanism enables clients to detect unauthorized downgrade attempts: if these special values are present, the client MUST abort the handshake with an \"illegal_parameter\" alert. Note that this protection is only effective when ephemeral cipher suites are used and does not apply when static RSA is negotiated.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: TLS 1.3 servers which negotiate TLS 1.2 or below in response to a ClientHello MUST set the last 8 bytes of their Random value specially in their ServerHello.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "A legacy TLS client performing renegotiation with TLS 1.2 or prior and which receives a TLS 1.3 ServerHello during renegotiation MUST abort the handshake with a \"protocol_version\" alert.",
    "enhanced_sentence": "When a legacy TLS client (supporting TLS 1.2 or earlier) is engaged in a renegotiation handshake and receives a ServerHello message indicating TLS 1.3 (either through the \"supported_versions\" extension or by detecting the downgrade protection mechanism in the Random field), it MUST immediately terminate the handshake by sending a \"protocol_version\" alert. This rule applies because TLS 1.3 does not support renegotiation, and such a scenario indicates a version mismatch or potential downgrade attack. The client must enforce this check upon processing the ServerHello during any renegotiation attempt to maintain protocol security and backward compatibility integrity.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: A legacy TLS client performing renegotiation with TLS 1.2 or prior and which receives a TLS 1.3 ServerHello during renegotiation MUST abort the handshake with a \"protocol_version\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "TLS 1.2 clients SHOULD also check that the last 8 bytes are not equal to the second value if the ServerHello indicates TLS 1.1 or below.",
    "enhanced_sentence": "When a TLS 1.2 client receives a ServerHello message indicating TLS 1.1 or below (i.e., legacy_version is 0x0302 or lower), it SHOULD check that the last 8 bytes of the server's Random field are not equal to the downgrade sentinel value 44 4F 57 4E 47 52 44 00. This check applies during the initial handshake after the ServerHello is processed and before proceeding with key exchange. If a match is detected, the client MUST abort the handshake with an \"illegal_parameter\" alert, as this indicates a potential downgrade attack where a TLS 1.3-capable server was forced to negotiate a lower version. Note that this mechanism provides limited protection and is most effective when ephemeral ciphers are used; it does not apply if static RSA is negotiated. TLS 1.2 clients should be aware that not all implementations may adhere to this due to differences with prior specifications.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: TLS 1.2 clients SHOULD also check that the last 8 bytes are not equal to the second value if the ServerHello indicates TLS 1.1 or below.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2 servers SHOULD, set the last 8 bytes of their ServerHello.Random value to the bytes: 44 4F 57 4E 47 52 44 00.",
    "enhanced_sentence": "When a server responds to a ClientHello and negotiates a TLS version below 1.3, it must include a downgrade protection mechanism in the ServerHello.Random field to signal potential downgrade attacks. Specifically, if negotiating TLS 1.1 or below, TLS 1.3 servers MUST (to indicate a forced downgrade), and TLS 1.2 servers SHOULD (for backward compatibility and detection), overwrite the last 8 bytes of the ServerHello.Random value with the fixed byte sequence: 44 4F 57 4E 47 52 44 00. This rule applies only when the negotiated protocol version is TLS 1.1 or lower, and the ServerHello.Random must otherwise be generated using a secure random number generator for the first 24 bytes. TLS 1.3 and TLS 1.2 clients are expected to check for this value upon receiving a ServerHello indicating a downgraded version; if detected, they MUST abort the handshake with an \"illegal_parameter\" alert to prevent potential downgrade attacks. Note that this mechanism provides effective protection only when ephemeral ciphers are used, as static RSA does not support this form of detection.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2 servers SHOULD, set the last 8 bytes of their ServerHello.Random value to the bytes: 44 4F 57 4E 47 52 44 00.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.2. PSK Binder",
    "sentence": "The PSK binder value forms a binding between a PSK and the current handshake, as well as a binding between the handshake in which the PSK was generated (if via a NewSessionTicket message) and the current handshake.",
    "enhanced_sentence": "The PSK binder value is a cryptographic binding mechanism that ensures the integrity and authenticity of the PSK in the current handshake. It links the PSK to the ongoing handshake and, if the PSK was established via a NewSessionTicket message, also binds the original handshake (where the PSK was generated) to the current one. This rule applies when a client includes a Pre-Shared Key extension in the ClientHello message, specifically during the computation of the PskBinderEntry for each offered PSK. The expected outcome is that the server can verify the PSK's validity and its association with the handshake context, preventing replay and misbinding attacks. Prerequisites include deriving the binder_key from the PSK using the key schedule, and correctly truncating the ClientHello (excluding the binders list) when computing the transcript hash for HMAC. If a HelloRetryRequest occurs, the initial ClientHello and the retry request must be included in the transcript for binder computation to maintain consistency across handshake flights.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.2. PSK Binder\"\nRule: The PSK binder value forms a binding between a PSK and the current handshake, as well as a binding between the handshake in which the PSK was generated (if via a NewSessionTicket message) and the current handshake.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.2. PSK Binder",
    "sentence": "The length fields for the message (including the overall length, the length of the extensions block, and the length of the \"pre_shared_key\" extension) are all set as if binders of the correct lengths were present.",
    "enhanced_sentence": "During the TLS 1.3 handshake, when computing the PSK binder for a ClientHello message, the client must set all relevant length fields—including the overall message length, the extensions block length, and the length of the \"pre_shared_key\" extension—as if the binder list were already present with the correct size. This ensures that the transcript hash used for binder computation includes a structurally complete but truncated ClientHello (excluding the actual binders), maintaining consistency between the handshake state and the cryptographic binding. This rule applies whenever a PSK is offered, and it must be followed before the binder values are calculated and inserted. The expected outcome is a valid binder that correctly binds the PSK to the handshake context, allowing the server to verify the PSK’s authenticity without discrepancies in length parsing.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.2. PSK Binder\"\nRule: The length fields for the message (including the overall length, the length of the extensions block, and the length of the \"pre_shared_key\" extension) are all set as if binders of the correct lengths were present.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello",
    "sentence": "TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below MUST check that the last 8 bytes are not equal to either of these values.",
    "enhanced_sentence": "When a TLS 1.3 client receives a ServerHello message that indicates a negotiated version of TLS 1.2 or below (as determined by the legacy_version field or the \"supported_versions\" extension), it MUST inspect the last 8 bytes of the ServerHello.random field. This check is a critical part of the downgrade protection mechanism designed to detect active attackers attempting to force a lower protocol version. The client MUST verify that these bytes do not match either of the two predefined values: 44 4F 57 4E 47 52 44 01 (indicating a TLS 1.3 server was forced to negotiate TLS 1.2) or 44 4F 57 4E 47 52 44 00 (indicating a forced negotiation to TLS 1.1 or below). If either pattern is detected, the client MUST immediately abort the handshake with an \"illegal_parameter\" alert, as this indicates a potential downgrade attack. This rule applies only after the ServerHello has been parsed and the negotiated version is confirmed to be TLS 1.2 or earlier; it does not apply if TLS 1.3 is successfully negotiated. Note that this mechanism provides effective protection only when ephemeral cipher suites are used and offers no protection when static RSA is employed.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.3. Server Hello\"\nRule: TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below MUST check that the last 8 bytes are not equal to either of these values.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.1. Encrypted Extensions",
    "sentence": "In all handshakes, the server MUST send the EncryptedExtensions message immediately after the ServerHello message.",
    "enhanced_sentence": "In all TLS 1.3 handshakes, the server MUST send the EncryptedExtensions message immediately after the ServerHello message, as it is the first message encrypted under keys derived from the server_handshake_traffic_secret. This rule applies once the ServerHello has been sent and the handshake keys have been established. The EncryptedExtensions message carries protected extensions that are not required for cryptographic context setup but are not certificate-specific, ensuring they remain confidential. The client is required to validate that no forbidden extensions are present and must abort with an \"illegal_parameter\" alert if any are detected. This sequencing is critical for maintaining the security and integrity of the handshake flow.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.1. Encrypted Extensions\"\nRule: In all handshakes, the server MUST send the EncryptedExtensions message immediately after the ServerHello message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.2. PSK Binder",
    "sentence": "Each entry in the binders list is computed as an HMAC over a transcript hash (see Section 4.4.1) containing a partial ClientHello up to and including the PreSharedKeyExtension.identities field.",
    "enhanced_sentence": "Each entry in the binders list MUST be computed as an HMAC over a transcript hash (see Section 4.4.1) that includes a partial ClientHello message, truncated to exclude the binders list itself but including all other fields up to and including the PreSharedKeyExtension.identities field. This rule applies when a client offers one or more pre-shared keys (PSKs) for session resumption or external PSK use, and it ensures cryptographic binding between the PSK and the current handshake context. The expected outcome is a verifiable binder value that allows the server to confirm the client's possession of the PSK and the integrity of the handshake negotiation up to that point. Prerequisites include: the client must have a valid PSK and corresponding binder_key derived via the key schedule (Section 7.1), and if a HelloRetryRequest is involved, the transcript must incorporate the initial ClientHello and HelloRetryRequest as specified. All message length fields in the partial ClientHello must be set as if the binders of correct lengths were present to maintain consistent hashing.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.2. PSK Binder\"\nRule: Each entry in the binders list is computed as an HMAC over a transcript hash (see Section 4.4.1) containing a partial ClientHello up to and including the PreSharedKeyExtension.identities field.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.2. PSK Binder",
    "sentence": "The PskBinderEntry is computed in the same way as the Finished message (Section 4.4.4) but with the BaseKey being the binder_key derived via the key schedule from the corresponding PSK which is being offered (see Section 7.1).",
    "enhanced_sentence": "The PskBinderEntry is computed in the same way as the Finished message (Section 4.4.4), using HMAC over a transcript hash that includes a partial ClientHello (with the binders list removed and length fields adjusted as if binders were present), but with the BaseKey replaced by the binder_key derived from the key schedule using the corresponding offered PSK (see Section 7.1). This rule applies during the ClientHello construction when a PSK is offered, ensuring the binder cryptographically binds the PSK to the current handshake (and optionally to the handshake that generated the PSK). The expected outcome is a verifiable integrity check that prevents unauthorized PSK reuse and confirms the client’s possession of the PSK. Prerequisites include the availability of a valid PSK, correct derivation of the binder_key via the key schedule, and proper handling of the transcript hash (especially in cases involving HelloRetryRequest, where prior messages must be included).",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension -> 4.2.11.2. PSK Binder\"\nRule: The PskBinderEntry is computed in the same way as the Finished message (Section 4.4.4) but with the BaseKey being the binder_key derived via the key schedule from the corresponding PSK which is being offered (see Section 7.1).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.1. Encrypted Extensions",
    "sentence": "The EncryptedExtensions message is the first message that is encrypted under keys derived from the server_handshake_traffic_secret.",
    "enhanced_sentence": "The EncryptedExtensions message MUST be the first message encrypted under keys derived from the server_handshake_traffic_secret, immediately following the ServerHello message in all TLS 1.3 handshakes. This rule applies once the server has computed the server_handshake_traffic_secret from the key schedule and is ready to send protected extensions that are not required for establishing the cryptographic context but are not certificate-specific. The expected outcome is that all subsequent handshake messages from the server are encrypted using these derived keys, ensuring confidentiality and integrity for extensions such as supported groups or application-layer protocol negotiation. Prerequisites include successful completion of the key exchange and derivation of the server_handshake_traffic_secret, and the client MUST validate that no forbidden extensions are present in this message.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.1. Encrypted Extensions\"\nRule: The EncryptedExtensions message is the first message that is encrypted under keys derived from the server_handshake_traffic_secret.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.1. Encrypted Extensions",
    "sentence": "The client MUST check EncryptedExtensions for the presence of any forbidden extensions and if any are found MUST abort the handshake with an \"illegal_parameter\" alert.",
    "enhanced_sentence": "After receiving the EncryptedExtensions message (which is sent immediately after ServerHello and is the first message encrypted under the server_handshake_traffic_secret), the client MUST validate that the message does not contain any extensions that are explicitly forbidden from appearing in this message type. The client MUST perform this check before proceeding with the handshake. If any forbidden extension is detected, the client MUST immediately terminate the handshake by sending an \"illegal_parameter\" alert. This rule applies to all TLS 1.3 handshakes and is critical for maintaining protocol security by preventing the misuse of extensions that should only appear in other handshake messages.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.1. Encrypted Extensions\"\nRule: The client MUST check EncryptedExtensions for the presence of any forbidden extensions and if any are found MUST abort the handshake with an \"illegal_parameter\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.1. Encrypted Extensions",
    "sentence": "The structure of the EncryptedExtensions message is: struct { Extension extensions<0..2^16-1>; } EncryptedExtensions; where extensions is a list of extensions.",
    "enhanced_sentence": "The EncryptedExtensions message MUST be sent by the server immediately after the ServerHello in all TLS 1.3 handshakes. It is the first message encrypted under keys derived from the server_handshake_traffic_secret. The message structure is: struct { Extension extensions<0..2^16-1>; } EncryptedExtensions; where extensions is a list of extensions. This message carries extensions that can be protected (i.e., those not needed to establish the cryptographic context and not associated with individual certificates). The client MUST validate that no forbidden extensions are present; if any are found, the handshake MUST be aborted with an \"illegal_parameter\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.1. Encrypted Extensions\"\nRule: The structure of the EncryptedExtensions message is: struct { Extension extensions<0..2^16-1>; } EncryptedExtensions; where extensions is a list of extensions.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.1. Encrypted Extensions",
    "sentence": "The EncryptedExtensions message contains extensions that can be protected, i.e., any which are not needed to establish the cryptographic context but which are not associated with individual certificates.",
    "enhanced_sentence": "The EncryptedExtensions message, which MUST be sent by the server immediately after the ServerHello in all TLS 1.3 handshakes, contains extensions that can be protected under the newly established server_handshake_traffic_secret. This rule applies specifically to extensions that are not required for establishing the initial cryptographic context (such as those in ClientHello or ServerHello) but are also not tied to individual certificates (which are handled in Certificate messages). The expected outcome is that these extensions are securely transmitted without being exposed in cleartext. Prerequisites include the successful derivation of handshake traffic secrets from the key exchange. Clients MUST validate that no forbidden extensions are present and MUST abort with an \"illegal_parameter\" alert if any are found.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.1. Encrypted Extensions\"\nRule: The EncryptedExtensions message contains extensions that can be protected, i.e., any which are not needed to establish the cryptographic context but which are not associated with individual certificates.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "If a server established a TLS connection with a previous version of TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST retain the previous protocol version.",
    "enhanced_sentence": "This rule applies when a server has an active TLS connection established using a version prior to TLS 1.3 (e.g., TLS 1.2) and subsequently receives a TLS 1.3 ClientHello as part of a renegotiation attempt. In this scenario, the server MUST maintain the originally negotiated protocol version and MUST NOT upgrade to TLS 1.3 during renegotiation. This requirement ensures backward compatibility and prevents version negotiation issues that could arise from mixing protocol versions within the same connection. The server should continue using the cryptographic parameters and session state from the initial handshake, treating the renegotiation as an extension of the existing session rather than a protocol upgrade opportunity.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: If a server established a TLS connection with a previous version of TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST retain the previous protocol version.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "Because TLS 1.3 forbids renegotiation, if a server has negotiated TLS 1.3 and receives a ClientHello at any other time, it MUST terminate the connection with an \"unexpected_message\" alert.",
    "enhanced_sentence": "After a TLS 1.3 handshake has been successfully negotiated and the connection is established, the protocol explicitly forbids renegotiation. Therefore, if a server operating under TLS 1.3 receives a ClientHello message at any time other than during the initial handshake sequence (i.e., not as the first message from the client or in response to a HelloRetryRequest), it MUST treat this as a protocol violation. The server MUST immediately terminate the connection by sending an \"unexpected_message\" fatal alert. This rule applies only when TLS 1.3 has been negotiated; if an earlier TLS version is in use and renegotiation occurs, the server MUST retain the previous protocol version and MUST NOT switch to TLS 1.3.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: Because TLS 1.3 forbids renegotiation, if a server has negotiated TLS 1.3 and receives a ClientHello at any other time, it MUST terminate the connection with an \"unexpected_message\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "The client may optionally add, remove, or change the length of the \"padding\" extension [RFC7685 ClientHello Padding Extension].",
    "enhanced_sentence": "When constructing a ClientHello in response to a HelloRetryRequest, the client MUST preserve the original message structure with minimal required modifications, but it MAY optionally adjust the \"padding\" extension (as defined in RFC 7685) by adding, removing, or changing its length. This adjustment is permitted only during HelloRetryRequest processing and must not affect other extensions or mandatory fields. The purpose is to allow clients to modify padding for traffic analysis mitigation or alignment purposes without violating the strict no-modification requirement for other parts of the ClientHello. The outcome is a valid, optionally padded ClientHello that conforms to the server’s retry request while maintaining handshake continuity. This rule applies exclusively when responding to a HelloRetryRequest and assumes the client has already received and validated such a request.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: The client may optionally add, remove, or change the length of the \"padding\" extension [RFC7685 ClientHello Padding Extension].\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "The client must update the \"pre_shared_key\" extension if present by recomputing the \"obfuscated_ticket_age\" and binder values and (optionally) removing any PSKs which are incompatible with the server's indicated cipher suite.",
    "enhanced_sentence": "When a client receives a HelloRetryRequest from the server in response to its initial ClientHello, it MUST send a new ClientHello that is identical to the first except for specific required modifications. If the client included a \"pre_shared_key\" extension in its initial ClientHello, it MUST update this extension by recomputing the \"obfuscated_ticket_age\" (to reflect the additional elapsed time since the original PSK was issued) and the binder values (to authenticate the new handshake context). Additionally, the client MAY remove any PSKs that are incompatible with the cipher suite indicated by the server in the HelloRetryRequest, ensuring only viable PSKs are offered. This rule applies specifically during the HelloRetryRequest handshake flow and ensures PSK parameters remain valid and secure in the updated handshake context.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: The client must update the \"pre_shared_key\" extension if present by recomputing the \"obfuscated_ticket_age\" and binder values and (optionally) removing any PSKs which are incompatible with the server's indicated cipher suite.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "In that case, the client MUST send the same ClientHello without modification, except as follows: If a \"key_share\" extension was supplied in the HelloRetryRequest, the client must replace the list of shares with a list containing a single KeyShareEntry from the indicated group.",
    "enhanced_sentence": "This rule applies when a client receives a HelloRetryRequest from the server in response to its initial ClientHello. In this scenario, the client MUST resend the same ClientHello message with minimal modifications to maintain protocol state consistency. Specifically, if the HelloRetryRequest contained a \"key_share\" extension indicating a preferred cryptographic group, the client MUST replace its original list of KeyShareEntry values with a new list containing only a single KeyShareEntry from the group specified by the server. This modification ensures that the key exchange aligns with the server's supported parameters while preserving all other aspects of the original ClientHello to maintain handshake continuity. The client must also perform additional required modifications as specified in the full protocol text (such as removing the \"early_data\" extension and including a \"cookie\" extension if provided). This behavior is critical for successful TLS 1.3 handshake completion after a HelloRetryRequest.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: In that case, the client MUST send the same ClientHello without modification, except as follows: If a \"key_share\" extension was supplied in the HelloRetryRequest, the client must replace the list of shares with a list containing a single KeyShareEntry from the indicated group.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "In TLS 1.3, the client indicates its version preferences in the \"supported_versions\" extension (Section 4.2.1) and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2.",
    "enhanced_sentence": "In TLS 1.3, the client MUST set the legacy_version field in the ClientHello message to 0x0303 (TLS 1.2) while simultaneously indicating its actual version preferences through the \"supported_versions\" extension. This rule applies during the initial ClientHello transmission and any subsequent ClientHello after a HelloRetryRequest, ensuring backward compatibility with servers that incorrectly handle version negotiation. The expected outcome is that TLS 1.3-capable servers will recognize the ClientHello as a TLS 1.3 handshake attempt by detecting the supported_versions extension, while legacy servers will interpret it as a TLS 1.2 ClientHello. Prerequisites include the client supporting TLS 1.3 and initiating a connection where TLS 1.3 negotiation is intended.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: In TLS 1.3, the client indicates its version preferences in the \"supported_versions\" extension (Section 4.2.1) and the legacy_version field MUST be set to 0x0303, which is the version number for TLS 1.2.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "When a client first connects to a server, it is REQUIRED to send the ClientHello as its first TLS message.",
    "enhanced_sentence": "When a client initiates a TLS 1.3 handshake, it MUST send the ClientHello as the first message in the connection. This rule applies to both initial connections and when responding to a HelloRetryRequest from the server. The ClientHello must be structured according to the TLS 1.3 specification, including setting legacy_version to 0x0303, providing a secure random value, and including mandatory extensions like \"supported_versions\". If the server responds with a HelloRetryRequest, the client MUST send the same ClientHello with specific modifications: updating the \"key_share\" extension, removing \"early_data\", including a \"cookie\" if provided, and updating the \"pre_shared_key\" extension if present. The expected outcome is that the server processes the ClientHello to negotiate protocol version, cipher suite, and other parameters. Prerequisites include the client having a secure random number generator and, if applicable, cached session information for backward compatibility. Failure to adhere to this rule may result in connection termination with an \"unexpected_message\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: When a client first connects to a server, it is REQUIRED to send the ClientHello as its first TLS message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "If the client is attempting a PSK key establishment, it SHOULD advertise at least one cipher suite indicating a Hash associated with the PSK.",
    "enhanced_sentence": "When a client is attempting a PSK key establishment (as indicated by the presence of a \"pre_shared_key\" extension in the ClientHello), it SHOULD include at least one cipher suite in the cipher_suites list that specifies the Hash algorithm associated with the PSK. This ensures that the server can properly validate the PSK binder and derive session keys using the correct hash function. This rule applies during the initial ClientHello construction or when updating the ClientHello after a HelloRetryRequest, provided that PSK-based key establishment is being attempted. The expected outcome is that the server can successfully process the PSK extension and proceed with the handshake using a compatible cipher suite.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: If the client is attempting a PSK key establishment, it SHOULD advertise at least one cipher suite indicating a Hash associated with the PSK.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "TLS 1.3 ClientHellos are identified as having a legacy_version of 0x0303 and a supported_versions extension present with 0x0304 as the highest version indicated therein.",
    "enhanced_sentence": "This rule governs the identification of TLS 1.3 ClientHello messages during the initial handshake phase, which occurs when a client first connects to a server or after receiving a HelloRetryRequest. The rule applies when a server receives a ClientHello and must determine whether it is a TLS 1.3 handshake attempt. A valid TLS 1.3 ClientHello MUST have its legacy_version field set to 0x0303 (TLS 1.2) for backward compatibility and MUST include a supported_versions extension where the highest indicated version is 0x0304 (TLS 1.3). Prerequisites include the presence of extensions in the ClientHello and proper formatting of other fields (e.g., legacy_compression_methods must be set to 0x00). The expected outcome is that the server recognizes this as a TLS 1.3 handshake attempt and proceeds with TLS 1.3 negotiation; if these conditions are not met, the server MUST treat it as a prior TLS version or abort the handshake with an appropriate alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: TLS 1.3 ClientHellos are identified as having a legacy_version of 0x0303 and a supported_versions extension present with 0x0304 as the highest version indicated therein.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "If the list contains cipher suites that the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites and process the remaining ones as usual.",
    "enhanced_sentence": "During the TLS 1.3 handshake, when a server receives a ClientHello message containing a list of cipher suites in the `cipher_suites` field, it MUST ignore any cipher suites that it does not recognize, support, or wish to use. The server MUST then proceed to evaluate the remaining cipher suites in the list as if the unrecognized or unsupported ones were never present. This rule applies specifically to the server’s processing of the ClientHello, ensuring that the handshake continues based only on mutually acceptable cipher suites. The server must still adhere to all other protocol requirements, such as validating mandatory extensions and supported versions, and must only ignore cipher suites that are explicitly not supported or unrecognized—without altering the structure or other contents of the message. The expected outcome is that the handshake proceeds normally with a subset of the client’s offered cipher suites, promoting interoperability even when clients include outdated or non-standard options.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: If the list contains cipher suites that the server does not recognize, support, or wish to use, the server MUST ignore those cipher suites and process the remaining ones as usual.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the \"null\" compression method in prior versions of TLS.",
    "enhanced_sentence": "For every TLS 1.3 ClientHello message, the `legacy_compression_methods` vector MUST contain exactly one byte, set to zero (0x00), which corresponds to the \"null\" compression method used in prior TLS versions. This rule applies during the initial handshake phase when the client sends a ClientHello to initiate or resume a TLS 1.3 connection, including after a HelloRetryRequest. The expected outcome is that servers will correctly identify and process the ClientHello as a TLS 1.3 handshake attempt. If any other value is present in this field, the server MUST abort the handshake with an \"illegal_parameter\" alert. Note that this requirement is specific to TLS 1.3; servers receiving ClientHello messages from earlier TLS versions must handle compression methods according to the respective protocol specifications.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: For every TLS 1.3 ClientHello, this vector MUST contain exactly one byte, set to zero, which corresponds to the \"null\" compression method in prior versions of TLS.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "The structure of the ClientHello message includes: uint16 ProtocolVersion; opaque Random[32]; uint8 CipherSuite[2]; struct { ProtocolVersion legacy_version = 0x0303; Random random; opaque legacy_session_id<0..32>; CipherSuite cipher_suites<2..2^16-2>; opaque legacy_compression_methods<1..2^8-1>; Extension extensions<8..2^16-1>; } ClientHello; legacy_version: In previous versions of TLS, this field was used for version negotiation and represented the highest version number supported by the client.",
    "enhanced_sentence": "The ClientHello message structure is defined as: struct { ProtocolVersion legacy_version = 0x0303; Random random; opaque legacy_session_id<0..32>; CipherSuite cipher_suites<2..2^16-2>; opaque legacy_compression_methods<1..2^8-1>; Extension extensions<8..2^16-1>; } ClientHello. This rule governs the initial handshake message sent by the client to initiate a TLS 1.3 connection or respond to a HelloRetryRequest. It applies when establishing a new TLS 1.3 connection or when the server requests a revised ClientHello. The expected outcome is a properly formatted message that enables version negotiation, cipher suite selection, and extension handling while maintaining backward compatibility. Prerequisites include: the client must generate a secure 32-byte random value; legacy_version must be set to 0x0303 (TLS 1.2) for compatibility; legacy_compression_methods must contain exactly one byte set to zero; and extensions must include at minimum the \"supported_versions\" extension with 0x0304 (TLS 1.3) as the highest version. The server will interpret missing extensions or incorrect compression methods as TLS 1.2 or lower and may abort the handshake with appropriate alerts if requirements aren't met.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: The structure of the ClientHello message includes: uint16 ProtocolVersion; opaque Random[32]; uint8 CipherSuite[2]; struct { ProtocolVersion legacy_version = 0x0303; Random random; opaque legacy_session_id<0..32>; CipherSuite cipher_suites<2..2^16-2>; opaque legacy_compression_methods<1..2^8-1>; Extension extensions<8..2^16-1>; } ClientHello; legacy_version: In previous versions of TLS, this field was used for version negotiation and represented the highest version number supported by the client.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "If a TLS 1.3 ClientHello is received with any other value in this field, the server MUST abort the handshake with an \"illegal_parameter\" alert.",
    "enhanced_sentence": "When processing a TLS 1.3 ClientHello message, the server MUST validate that the legacy_compression_methods field contains exactly one byte with the value 0x00 (corresponding to the \"null\" compression method). This rule applies immediately upon receiving the ClientHello, before any further handshake processing. If any other value is present in this field, the server MUST immediately abort the handshake by sending an \"illegal_parameter\" alert and terminating the connection. This requirement exists because TLS 1.3 explicitly prohibits compression (due to security vulnerabilities like CRIME and BREACH) and only permits the null compression method for backward compatibility formatting. Note that this rule applies specifically to TLS 1.3 ClientHello messages; servers processing ClientHello messages from earlier TLS versions must follow the compression negotiation procedures defined for those versions.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: If a TLS 1.3 ClientHello is received with any other value in this field, the server MUST abort the handshake with an \"illegal_parameter\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "Note that TLS 1.3 servers might receive TLS 1.2 or prior ClientHellos which contain other compression methods and (if negotiating such a prior version) MUST follow the procedures for the appropriate prior version of TLS.",
    "enhanced_sentence": "When a TLS 1.3 server receives a ClientHello message, it must first determine the TLS version being negotiated. If the ClientHello is identified as originating from TLS 1.2 or earlier (indicated by the absence of the \"supported_versions\" extension and potentially different legacy_version values), and the server agrees to negotiate that prior version, then the server MUST handle the legacy_compression_methods field according to the specifications of that specific prior TLS version. This includes properly processing any non-null compression methods that may be present, rather than rejecting them as would be required for a TLS 1.3 ClientHello. This rule ensures backward compatibility when the server falls back to older TLS versions, while maintaining strict security requirements for TLS 1.3 connections.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: Note that TLS 1.3 servers might receive TLS 1.2 or prior ClientHellos which contain other compression methods and (if negotiating such a prior version) MUST follow the procedures for the appropriate prior version of TLS.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "extensions: Clients request extended functionality from servers by sending data in the extensions field.",
    "enhanced_sentence": "The `extensions` field in the ClientHello message allows clients to request extended functionality from servers by including one or more extension data structures. This rule applies during the initial ClientHello or any subsequent ClientHello sent in response to a HelloRetryRequest. The client MUST include mandatory extensions such as `supported_versions` to indicate TLS 1.3 support, and MAY include optional extensions to negotiate features like key exchange mechanisms, supported groups, or pre-shared keys. Servers MUST ignore any unrecognized extensions but MUST process recognized ones appropriately. If the server does not support a requested extension, the client MAY abort the handshake. The presence of extensions is required in TLS 1.3 to maintain backward compatibility while enabling new features, and the extensions field MUST follow the `legacy_compression_methods` field.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: extensions: Clients request extended functionality from servers by sending data in the extensions field.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "All versions of TLS allow an extensions field to optionally follow the compression_methods field.",
    "enhanced_sentence": "In all versions of TLS, the extensions field is permitted to optionally follow the compression_methods field in the ClientHello message. This rule applies during the initial handshake phase when the client sends the ClientHello to initiate or resume a TLS connection. The expected outcome is that if extensions are present, they must be correctly formatted and processed according to the TLS version being negotiated; servers must ignore unrecognized extensions but may use supported ones to enable additional functionality. Prerequisites include the proper structure of the preceding ClientHello fields (legacy_version, random, legacy_session_id, cipher_suites, and compression_methods), and note that while extensions are optional in earlier TLS versions, TLS 1.3 requires certain extensions (like \"supported_versions\") for proper version identification and handshake continuation.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: All versions of TLS allow an extensions field to optionally follow the compression_methods field.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "Servers MUST ignore unrecognized extensions.",
    "enhanced_sentence": "When processing a TLS 1.3 ClientHello message, servers MUST ignore any extension that they do not recognize or support. This rule applies during the initial handshake phase when the server is parsing the extensions field of the ClientHello, which is mandatory in TLS 1.3. The expected outcome is that the server continues processing the handshake using only the recognized extensions, without generating an error or alert for unrecognized ones. This ensures backward and forward compatibility, allowing new extensions to be introduced without breaking existing implementations. Prerequisites include that the message is a valid ClientHello with a properly formatted extensions field, and that the server is operating in a TLS 1.3 context. Note that while unrecognized extensions must be ignored, the server must still validate and process all mandatory and recognized extensions as required by the protocol.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: Servers MUST ignore unrecognized extensions.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "However, TLS 1.3 servers might receive ClientHello messages without an extensions field from prior versions of TLS.",
    "enhanced_sentence": "When a TLS 1.3 server receives a ClientHello message, it must be prepared to handle messages from prior TLS versions (1.2 or earlier) that may lack an extensions field entirely. This situation occurs during initial version negotiation before the supported_versions extension is processed. The server must detect the presence of extensions by checking for bytes following the legacy_compression_methods field. If no extensions are present, the server should interpret the ClientHello as originating from a pre-TLS 1.3 client and proceed with the appropriate backward-compatible negotiation (if supported) rather than attempting TLS 1.3 processing. This rule applies specifically when the server receives a ClientHello without the supported_versions extension, indicating a legacy client connection attempt.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: However, TLS 1.3 servers might receive ClientHello messages without an extensions field from prior versions of TLS.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "TLS 1.3 ClientHello messages always contain extensions (minimally \"supported_versions\", otherwise, they will be interpreted as TLS 1.2 ClientHello messages).",
    "enhanced_sentence": "In TLS 1.3, the ClientHello message must always include an extensions field, with at minimum the \"supported_versions\" extension present. This is required to clearly signal the client’s intent to negotiate TLS 1.3. If the extensions field is absent or lacks \"supported_versions,\" the message will be interpreted as a TLS 1.2 or earlier ClientHello for backward compatibility. This rule applies during the initial handshake or after a HelloRetryRequest, ensuring proper version negotiation and preventing misinterpretation by servers. The expected outcome is unambiguous version selection, allowing TLS 1.3-capable servers to proceed with a TLS 1.3 handshake only when this extension is present. Prerequisites include setting the legacy_version field to 0x0303 (TLS 1.2) and ensuring the legacy_compression_methods field is correctly formatted.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: TLS 1.3 ClientHello messages always contain extensions (minimally \"supported_versions\", otherwise, they will be interpreted as TLS 1.2 ClientHello messages).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "In TLS 1.3, the use of certain extensions is mandatory, as functionality has moved into extensions to preserve ClientHello compatibility with previous versions of TLS.",
    "enhanced_sentence": "In TLS 1.3, the use of certain extensions is mandatory because core protocol functionality (such as version negotiation, session resumption, and supported groups) has been moved from the main ClientHello structure into extensions. This design preserves backward compatibility by making TLS 1.3 ClientHello messages appear structurally similar to those of TLS 1.2, allowing older servers to process them without error even if they do not support TLS 1.3. The rule applies when constructing any TLS 1.3 ClientHello, whether for an initial handshake or in response to a HelloRetryRequest. At a minimum, the \"supported_versions\" extension must be included to indicate TLS 1.3 support; other mandatory extensions (e.g., \"signature_algorithms\", \"supported_groups\") may also be required depending on the handshake context. If these extensions are omitted, the handshake may fail or be downgraded to an earlier TLS version. Prerequisites include setting the legacy_version field to 0x0303 (TLS 1.2) and ensuring the legacy_compression_methods field contains exactly one null byte. The expected outcome is a ClientHello that is both compliant with TLS 1.3 requirements and interoperable with older TLS implementations.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: In TLS 1.3, the use of certain extensions is mandatory, as functionality has moved into extensions to preserve ClientHello compatibility with previous versions of TLS.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "Note that this method of detecting optional data differs from the normal TLS method of having a variable-length field, but it is used for compatibility with TLS before extensions were defined.",
    "enhanced_sentence": "When parsing the ClientHello message, servers must detect the presence of extensions by checking for bytes following the legacy_compression_methods field, rather than relying on a variable-length field indicator. This detection method applies specifically during the initial handshake phase when processing ClientHello messages from clients, and is necessary for backward compatibility with TLS versions prior to the introduction of extensions (TLS 1.2 and earlier). The expected outcome is correct identification of extension data when present, allowing proper protocol negotiation. This rule applies only when the ClientHello is formatted according to pre-TLS 1.3 standards, and requires that the server first verify the message structure complies with the negotiated TLS version before proceeding with extension processing.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: Note that this method of detecting optional data differs from the normal TLS method of having a variable-length field, but it is used for compatibility with TLS before extensions were defined.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "The presence of extensions can be detected by determining whether there are bytes following the compression_methods field at the end of the ClientHello.",
    "enhanced_sentence": "The presence of extensions in a ClientHello message is determined by checking if there are any bytes remaining after the legacy_compression_methods field. This detection mechanism applies when processing any TLS ClientHello, regardless of version, and is necessary for maintaining backward compatibility with pre-extension TLS versions. For TLS 1.3 specifically, extensions are mandatory and must include at least the \"supported_versions\" extension; if no bytes follow compression_methods, the message should be treated as a pre-TLS 1.3 ClientHello. Servers must validate that any remaining bytes form a properly structured extensions block when negotiating TLS versions prior to 1.3, and abort with a \"decode_error\" alert if invalid data is present. This rule governs the fundamental parsing logic that distinguishes extended ClientHello messages from legacy format messages.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: The presence of extensions can be detected by determining whether there are bytes following the compression_methods field at the end of the ClientHello.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "TLS 1.3 servers will need to perform this check first and only attempt to negotiate TLS 1.3 if the \"supported_versions\" extension is present.",
    "enhanced_sentence": "TLS 1.3 servers MUST first check for the presence of the \"supported_versions\" extension in the ClientHello message before attempting to negotiate TLS 1.3. This rule applies immediately upon receiving a ClientHello, during the initial handshake phase. The server must parse the ClientHello structure and verify that extensions are present (by checking for bytes following the legacy_compression_methods field) and that the \"supported_versions\" extension is explicitly included. If this extension is absent, the server MUST NOT proceed with TLS 1.3 negotiation and should instead fall back to handling the ClientHello as a legacy TLS version (e.g., TLS 1.2) if supported, or terminate the connection if no compatible version is available. This ensures backward compatibility and prevents misinterpretation of ClientHello messages from older TLS versions. Prerequisites include correctly parsing the ClientHello format and distinguishing between TLS 1.3 and prior versions based on extension presence and content.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: TLS 1.3 servers will need to perform this check first and only attempt to negotiate TLS 1.3 if the \"supported_versions\" extension is present.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "If negotiating a version of TLS prior to 1.3, a server MUST check that the message either contains no data after legacy_compression_methods or that it contains a valid extensions block with no data following.",
    "enhanced_sentence": "When a server is negotiating a TLS version prior to 1.3 (as indicated by the absence of a valid \"supported_versions\" extension or through version negotiation), it MUST verify that the ClientHello message structure conforms to the expected format for that version. Specifically, the server MUST check that the data following the legacy_compression_methods field either contains no additional bytes (indicating no extensions are present, which is valid for older TLS versions) or contains a properly formatted extensions block as defined in Section 4.2, with no extraneous data following the extensions. This validation ensures backward compatibility with pre-TLS 1.3 implementations and prevents malformed messages from being processed. If the check fails (i.e., there is data after legacy_compression_methods that does not form a valid extensions block or there is data after the extensions block), the server MUST abort the handshake with a \"decode_error\" alert to indicate a malformed message. This rule applies during the initial handshake when processing the ClientHello, before any version-specific negotiation proceeds.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: If negotiating a version of TLS prior to 1.3, a server MUST check that the message either contains no data after legacy_compression_methods or that it contains a valid extensions block with no data following.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share",
    "sentence": "Each KeyShareEntry value MUST correspond to a group offered in the \"supported_groups\" extension and MUST appear in the same order.",
    "enhanced_sentence": "In the ClientHello message, when the client provides a non-empty client_shares vector in the \"key_share\" extension, each KeyShareEntry MUST correspond to a group that was previously listed in the client's \"supported_groups\" extension and MUST appear in the same descending order of preference. This ensures that the server can correctly interpret the client's group preferences and select an appropriate key share for key exchange. The client MAY omit less preferred or newer groups for efficiency but MUST NOT include any group not present in \"supported_groups\". Violation of this rule allows the server to abort the handshake with an \"illegal_parameter\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share\"\nRule: Each KeyShareEntry value MUST correspond to a group offered in the \"supported_groups\" extension and MUST appear in the same order.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "In the event that a client requests additional functionality using extensions and this functionality is not supplied by the server, the client MAY abort the handshake.",
    "enhanced_sentence": "During the TLS 1.3 handshake, after the client sends a ClientHello message containing extensions that request specific additional functionality (e.g., supported_groups, signature_algorithms, or application_layer_protocol_negotiation), and the server's response (ServerHello or subsequent messages) does not include or support the requested extension(s), the client is permitted, but not required, to abort the handshake. This rule applies once the server’s response has been processed and the client has determined that essential negotiated parameters or expected features are missing. The expected outcome is that the client may terminate the connection with a fatal alert if the missing functionality is deemed critical for the intended secure session, though it may also proceed if the omission is acceptable. Prerequisites include a valid ClientHello with extensions and a server response that omits support for one or more client-requested extensions, where such extensions are not mandatory for basic protocol operation.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: In the event that a client requests additional functionality using extensions and this functionality is not supplied by the server, the client MAY abort the handshake.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello",
    "sentence": "After sending the ClientHello message, the client waits for a ServerHello or HelloRetryRequest message.",
    "enhanced_sentence": "After sending the ClientHello message, the client enters a waiting state for the server's response, which must be either a ServerHello (to proceed with the handshake) or a HelloRetryRequest (to request a modified ClientHello). This rule applies immediately following the transmission of the ClientHello, whether it is the initial handshake attempt or a response to a prior HelloRetryRequest. The expected outcome is that the client remains ready to process the next legitimate handshake message from the server, adhering to TLS 1.3's strict message sequence. If early data is enabled, the client may optionally send early Application Data during this waiting period, but must be prepared to handle either a ServerHello or HelloRetryRequest upon receipt. This rule assumes the ClientHello has been properly formatted according to TLS 1.3 specifications, including mandatory extensions and backward-compatibility fields.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.1. Key Exchange Messages -> 4.1.2. Client Hello\"\nRule: After sending the ClientHello message, the client waits for a ServerHello or HelloRetryRequest message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share",
    "sentence": "In the ClientHello message, the \"extension_data\" field of the key_share extension contains a KeyShareClientHello value with client_shares: a list of offered KeyShareEntry values in descending order of client preference.",
    "enhanced_sentence": "In the ClientHello message, the \"extension_data\" field of the key_share extension contains a KeyShareClientHello value with client_shares: a list of offered KeyShareEntry values in descending order of client preference. This rule applies during the initial handshake phase when the client proposes key exchange parameters to establish a shared secret. Each KeyShareEntry MUST correspond to a group listed in the client's \"supported_groups\" extension and MUST appear in the same order, though it MAY be a non-contiguous subset omitting the most preferred groups for efficiency reasons. The expected outcome is that the server can select the most mutually acceptable key exchange method from the client's prioritized list. Prerequisites include: the client MUST NOT offer multiple KeyShareEntry values for the same group, MUST NOT offer groups not in \"supported_groups,\" and MUST generate key_exchange values independently for each entry. If the client_shares vector is empty, it indicates a request for group selection from the server via HelloRetryRequest.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share\"\nRule: In the ClientHello message, the \"extension_data\" field of the key_share extension contains a KeyShareClientHello value with client_shares: a list of offered KeyShareEntry values in descending order of client preference.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share",
    "sentence": "However, the values MAY be a non-contiguous subset of the \"supported_groups\" extension and MAY omit the most preferred groups.",
    "enhanced_sentence": "When constructing the client_shares vector in the ClientHello's \"key_share\" extension, the client MUST list KeyShareEntry values in descending order of preference and each MUST correspond to a group from the client's \"supported_groups\" extension. However, the client MAY include a non-contiguous subset of the \"supported_groups\" list and MAY omit the most preferred groups, for example, to avoid generating key shares for new or less widely supported groups that may be inefficient to precompute. This rule applies during the initial ClientHello construction, before any handshake retries, and allows clients to balance performance with compatibility. The expected outcome is that the server will select from the offered key shares without error, provided all listed groups are valid and no other rules (such as offering multiple shares for the same group) are violated. Prerequisites include having a valid \"supported_groups\" extension and ensuring that every KeyShareEntry's group is present in that extension.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share\"\nRule: However, the values MAY be a non-contiguous subset of the \"supported_groups\" extension and MAY omit the most preferred groups.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share",
    "sentence": "The \"key_share\" extension contains the endpoint's cryptographic parameters.",
    "enhanced_sentence": "The \"key_share\" extension contains the endpoint's cryptographic parameters for key exchange and is used during the TLS 1.3 handshake to negotiate a shared secret. This rule applies when a ClientHello, HelloRetryRequest, or ServerHello message is constructed. The extension must include one or more KeyShareEntry structures (each containing a named group and corresponding key exchange material) that align with groups listed in the \"supported_groups\" extension. Clients may send an empty client_shares vector to request group selection from the server, at the cost of an additional round trip. In a HelloRetryRequest, the server indicates a selected group for which the client must provide a new KeyShareEntry. In the ServerHello, the server responds with a single KeyShareEntry matching one of the client's offered groups. Expected outcomes include successful shared secret computation when parameters are valid, or handshake abortion with an \"illegal_parameter\" alert if requirements (such as group consistency, absence of duplicates, or adherence to supported groups) are violated. Prerequisites include the presence of the \"supported_groups\" extension and, for clients, the capability to generate key material for the offered groups.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share\"\nRule: The \"key_share\" extension contains the endpoint's cryptographic parameters.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share",
    "sentence": "Otherwise, when sending the new ClientHello, the client MUST replace the original \"key_share\" extension with one containing only a new KeyShareEntry for the group indicated in the selected_group field of the triggering HelloRetryRequest.",
    "enhanced_sentence": "After receiving a valid HelloRetryRequest with a key_share extension containing a selected_group field, and when preparing to send the new ClientHello message in response, the client MUST replace the entire original key_share extension with a new one that contains exactly one KeyShareEntry. This KeyShareEntry MUST be generated specifically for the cryptographic group indicated in the selected_group field of the HelloRetryRequest. The client MUST NOT include any other KeyShareEntry values or retain any from the original ClientHello. This ensures that the client provides the necessary key exchange material exclusively for the server-negotiated group, facilitating the completion of the handshake with the selected parameters.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share\"\nRule: Otherwise, when sending the new ClientHello, the client MUST replace the original \"key_share\" extension with one containing only a new KeyShareEntry for the group indicated in the selected_group field of the triggering HelloRetryRequest.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share",
    "sentence": "Clients MUST NOT offer any KeyShareEntry values for groups not listed in the client's \"supported_groups\" extension.",
    "enhanced_sentence": "When constructing the ClientHello message, clients MUST NOT include any KeyShareEntry values for cryptographic groups that are not explicitly listed in the client's \"supported_groups\" extension. This rule applies during the initial handshake phase when the client is offering key exchange parameters. The client's \"key_share\" extension MUST only contain groups that are a subset (though possibly non-contiguous) of those advertised in \"supported_groups\", maintaining the same preference order. Adherence ensures that the server can validate the consistency of the client's cryptographic capabilities and prevents negotiation of unsupported or unexpected groups. Servers may enforce this by aborting the handshake with an \"illegal_parameter\" alert if violated. This rule presupposes that the client has generated valid KeyShareEntry structures for each offered group and that no duplicate group entries are present.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share\"\nRule: Clients MUST NOT offer any KeyShareEntry values for groups not listed in the client's \"supported_groups\" extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share",
    "sentence": "In a HelloRetryRequest message, the \"extension_data\" field of the key_share extension contains a KeyShareHelloRetryRequest value with selected_group: the mutually supported group the server intends to negotiate and is requesting a retried ClientHello/KeyShare for.",
    "enhanced_sentence": "In a HelloRetryRequest message, the \"extension_data\" field of the key_share extension contains a KeyShareHelloRetryRequest value with selected_group: the mutually supported group the server intends to negotiate and is requesting a retried ClientHello/KeyShare for. This rule applies when the server cannot find a suitable key share in the client's initial ClientHello but identifies a mutually supported group from the client's \"supported_groups\" extension. The server uses this mechanism to request that the client generate and send a new key share specifically for the selected group. The client must verify that the selected_group was originally offered in its \"supported_groups\" extension but was not present in the original \"key_share\" extension. If these conditions are met, the client must respond with a new ClientHello containing only a KeyShareEntry for the specified group, enabling the handshake to proceed with the server's chosen cryptographic parameters.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share\"\nRule: In a HelloRetryRequest message, the \"extension_data\" field of the key_share extension contains a KeyShareHelloRetryRequest value with selected_group: the mutually supported group the server intends to negotiate and is requesting a retried ClientHello/KeyShare for.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share",
    "sentence": "Upon receipt of the key_share extension in a HelloRetryRequest, the client MUST verify that (1) the selected_group field corresponds to a group which was provided in the \"supported_groups\" extension in the original ClientHello and (2) the selected_group field does not correspond to a group which was provided in the \"key_share\" extension in the original ClientHello.",
    "enhanced_sentence": "When a client receives a HelloRetryRequest message containing a key_share extension, it MUST verify that: (1) the selected_group field corresponds to a group that was previously advertised in the client's \"supported_groups\" extension in the original ClientHello, ensuring the server's selection is within the client's supported capabilities; and (2) the selected_group field does not correspond to any group for which the client already provided a key share in the original ClientHello's \"key_share\" extension, confirming that the server is requesting a new group rather than one already offered. This verification occurs during the handshake retry phase when the server indicates it cannot proceed with the originally offered key shares. If either check fails, the client MUST abort the handshake with an \"illegal_parameter\" alert to prevent potential negotiation attacks. If both checks pass, the client MUST generate a new ClientHello with a key_share extension containing only a KeyShareEntry for the group specified in the selected_group field, ensuring a secure and mutually agreeable key exchange.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share\"\nRule: Upon receipt of the key_share extension in a HelloRetryRequest, the client MUST verify that (1) the selected_group field corresponds to a group which was provided in the \"supported_groups\" extension in the original ClientHello and (2) the selected_group field does not correspond to a group which was provided in the \"key_share\" extension in the original ClientHello.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share",
    "sentence": "Servers MUST NOT send a KeyShareEntry for any group not indicated in the client's \"supported_groups\" extension and MUST NOT send a KeyShareEntry when using the \"psk_ke\" PskKeyExchangeMode.",
    "enhanced_sentence": "When constructing the ServerHello message, servers MUST NOT include a KeyShareEntry for any cryptographic group that was not explicitly listed in the client's \"supported_groups\" extension. Additionally, servers MUST NOT send any KeyShareEntry when the handshake uses the \"psk_ke\" PskKeyExchangeMode, as this mode implies a pre-shared key exchange without (EC)DHE. This rule applies during the ServerHello response phase and ensures that the server only proposes key shares for mutually supported groups, maintaining cryptographic consistency and preventing negotiation of unsupported or insecure parameters. Adherence to this rule is required only if the server is including a \"key_share\" extension in its ServerHello. Violations may result in handshake failure due to incompatible key exchange parameters.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share\"\nRule: Servers MUST NOT send a KeyShareEntry for any group not indicated in the client's \"supported_groups\" extension and MUST NOT send a KeyShareEntry when using the \"psk_ke\" PskKeyExchangeMode.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share",
    "sentence": "If using (EC)DHE key establishment and a HelloRetryRequest containing a \"key_share\" extension was received by the client, the client MUST verify that the selected NamedGroup in the ServerHello is the same as the NamedGroup in the HelloRetryRequest.",
    "enhanced_sentence": "This rule applies when the client is using (EC)DHE key establishment and has previously received a HelloRetryRequest containing a \"key_share\" extension. The client MUST verify that the NamedGroup specified in the server_share field of the ServerHello's \"key_share\" extension exactly matches the selected_group value from the HelloRetryRequest's \"key_share\" extension. This verification ensures that the server consistently selects the same cryptographic group throughout the handshake retry process, preventing potential downgrade attacks or negotiation inconsistencies. If the groups differ, the client MUST immediately abort the handshake with an \"illegal_parameter\" alert to maintain protocol security. This check is only required when the handshake involves a HelloRetryRequest with a key_share extension and (EC)DHE key exchange is being used.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share\"\nRule: If using (EC)DHE key establishment and a HelloRetryRequest containing a \"key_share\" extension was received by the client, the client MUST verify that the selected NamedGroup in the ServerHello is the same as the NamedGroup in the HelloRetryRequest.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share",
    "sentence": "In a ServerHello message, the \"extension_data\" field of the key_share extension contains a KeyShareServerHello value with server_share: a single KeyShareEntry value that is in the same group as one of the client's shares.",
    "enhanced_sentence": "In a ServerHello message, the \"extension_data\" field of the key_share extension contains a KeyShareServerHello value with server_share: a single KeyShareEntry value that is in the same group as one of the client's shares. This rule applies when the server is responding to a valid ClientHello that included a non-empty key_share extension and the server has selected (EC)DHE key establishment. The server must choose exactly one KeyShareEntry from the groups offered by the client in its ClientHello key_share extension, ensuring cryptographic compatibility for the key exchange. The selected group must be one that was indicated in the client's \"supported_groups\" extension. The expected outcome is that both parties can compute the same premaster secret using their respective key shares. This rule does not apply if the server is using the \"psk_ke\" PskKeyExchangeMode, in which case no KeyShareEntry should be sent. If the client previously received a HelloRetryRequest, it must additionally verify that the server's selected group matches the group indicated in that HelloRetryRequest.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.8. Key Share\"\nRule: In a ServerHello message, the \"extension_data\" field of the key_share extension contains a KeyShareServerHello value with server_share: a single KeyShareEntry value that is in the same group as one of the client's shares.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions",
    "sentence": "A number of TLS messages contain tag-length-value encoded extensions structures.",
    "enhanced_sentence": "A number of TLS 1.3 handshake messages contain tag-length-value encoded extensions structures, which are used to negotiate optional features and parameters. This rule applies during the handshake phase, specifically in messages such as ClientHello, ServerHello, EncryptedExtensions, Certificate, CertificateRequest, HelloRetryRequest, and NewSessionTicket. Each extension is identified by an ExtensionType and carries type-specific data in extension_data. Extensions must only be sent in response to a corresponding request, except for the \"cookie\" extension in HelloRetryRequest. Implementations must validate that received extensions are permitted for the message type and must not include duplicate extensions in the same block. Failure to adhere to these requirements must result in handshake abortion with appropriate alerts (e.g., \"unsupported_extension\" or \"illegal_parameter\"). Additionally, the pre_shared_key extension must be the last extension in ClientHello. Prerequisites include proper extension ordering and adherence to the IANA-registered extension types. The expected outcome is secure, negotiated feature enablement without handshake disruption.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions\"\nRule: A number of TLS messages contain tag-length-value encoded extensions structures.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions",
    "sentence": "Here: extension_type identifies the particular extension type.",
    "enhanced_sentence": "The extension_type field in TLS 1.3 extension structures uniquely identifies the specific extension type being used (e.g., server_name, key_share, supported_versions) from the IANA-maintained registry. This field determines how the accompanying extension_data should be interpreted and processed. The rule applies throughout the handshake protocol when parsing any extension-bearing message (ClientHello, ServerHello, EncryptedExtensions, CertificateRequest, Certificate, HelloRetryRequest, or NewSessionTicket). Implementations must use this field to correctly identify extension types and enforce protocol requirements, including: validating that extensions appear only in permitted messages, ensuring no duplicate extension types exist within a single extension block, and verifying that extension responses correspond to prior requests (except for cookie extensions in HelloRetryRequest). Failure to properly handle extension_type may result in handshake abortion with appropriate alerts (unsupported_extension or illegal_parameter).",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions\"\nRule: Here: extension_type identifies the particular extension type.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions",
    "sentence": "The Extension structure contains ExtensionType extension_type and opaque extension_data<0..2^16-1>.",
    "enhanced_sentence": "The Extension structure, which appears in multiple TLS 1.3 handshake messages (ClientHello, ServerHello, EncryptedExtensions, Certificate, CertificateRequest, HelloRetryRequest, and NewSessionTicket), contains two mandatory fields: ExtensionType extension_type and opaque extension_data<0..2^16-1>. This structure governs the negotiation of additional protocol features beyond the base TLS 1.3 specification. The rule applies throughout the handshake phase when endpoints need to exchange capability information or additional parameters.\n\nThe expected behavior is that endpoints include appropriate extensions in specific messages (as defined in the extension specification tables), with each extension block containing at most one extension of each type. Implementations MUST NOT send extension responses without corresponding requests (except for the \"cookie\" extension in HelloRetryRequest), and MUST abort the handshake with an \"unsupported_extension\" alert if receiving an unrequested extension response. Additionally, implementations MUST abort with an \"illegal_parameter\" alert if an extension appears in a message where it is not specified.\n\nPrerequisites include: extensions must be properly formatted with valid extension types (as registered with IANA), and the pre_shared_key extension must be the last extension in ClientHello when present. All extensions must be included in the Finished message hash calculations for authentication purposes.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions\"\nRule: The Extension structure contains ExtensionType extension_type and opaque extension_data<0..2^16-1>.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions",
    "sentence": "Extensions are generally structured in a request/response fashion, though some extensions are just indications with no corresponding response.",
    "enhanced_sentence": "Extensions in TLS 1.3 are generally structured in a request/response fashion, where a client sends an extension request in a ClientHello message and the server responds with the corresponding extension in ServerHello, EncryptedExtensions, HelloRetryRequest, or Certificate messages. However, some extensions (e.g., NewSessionTicket extensions) are unilateral indications with no corresponding response. This rule applies during the handshake phase when extensions are being negotiated. The expected outcome is that endpoints only send extension responses if the peer sent the corresponding request, except for the \"cookie\" extension in HelloRetryRequest. Prerequisites include proper encoding of extensions and adherence to message-specific extension allowances as defined in the specification. If an endpoint receives an unsolicited extension response (except for permitted cases), it must abort the handshake with an \"unsupported_extension\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions\"\nRule: Extensions are generally structured in a request/response fashion, though some extensions are just indications with no corresponding response.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions",
    "sentence": "The server sends extension requests in the CertificateRequest message which a client MAY respond to with a Certificate message.",
    "enhanced_sentence": "During the TLS 1.3 handshake, when client authentication is required, the server sends a CertificateRequest message that may include extension requests (such as \"signature_algorithms\", \"certificate_authorities\", or \"oid_filters\") to specify parameters for the client's certificate response. The client MAY respond with a Certificate message that includes corresponding extension responses, provided the client supports the requested extensions and possesses a suitable certificate. This rule applies only if the server has initiated client authentication and the client is capable of providing a certificate. The client must not include unsolicited extension responses, and if it cannot comply with the server's extension requests, it should either omit the extension response or, if required, abort the handshake. The expected outcome is a mutually agreed-upon set of certificate parameters, enabling secure client authentication.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions\"\nRule: The server sends extension requests in the CertificateRequest message which a client MAY respond to with a Certificate message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions",
    "sentence": "The client sends its extension requests in the ClientHello message, and the server sends its extension responses in the ServerHello, EncryptedExtensions, HelloRetryRequest, and Certificate messages.",
    "enhanced_sentence": "This rule governs the structured exchange of TLS 1.3 extensions, which are encoded in tag-length-value format and follow a request/response model. It applies during the handshake phase: the client MUST include all its extension requests exclusively in the ClientHello message. The server MUST send its extension responses in the ServerHello (for extensions negotiated in the initial exchange), EncryptedExtensions (for most additional extensions), HelloRetryRequest (for retry scenarios, e.g., with the \"cookie\" extension), and Certificate messages (for certificate-related extensions). Prerequisites include that the server MUST NOT send an extension response unless the client first sent the corresponding request, except for the \"cookie\" extension in HelloRetryRequest. If this rule is followed, extensions are properly negotiated, enabling features like key exchange, supported versions, or application-layer protocols. Violations, such as sending an unsolicited extension response, MUST result in aborting the handshake with an \"unsupported_extension\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions\"\nRule: The client sends its extension requests in the ClientHello message, and the server sends its extension responses in the ServerHello, EncryptedExtensions, HelloRetryRequest, and Certificate messages.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions",
    "sentence": "extension_data contains information specific to the particular extension type.",
    "enhanced_sentence": "The `extension_data` field in TLS 1.3 extension structures MUST contain information that is specific to and defined by the particular `extension_type`. This rule applies to all extension-bearing messages (e.g., ClientHello, ServerHello, EncryptedExtensions, etc.) during the handshake, resumption, and post-handshake phases. The content and format of `extension_data` are strictly determined by the extension's specification (as registered with IANA) and must only be interpreted in the context of its corresponding `extension_type`. Implementations MUST ensure that when an extension is sent or processed, the `extension_data` accurately represents the semantics and requirements of that extension type, and any deviation (such as incorrect encoding, unsolicited presence, or appearance in an invalid message context) MUST result in aborting the handshake with an appropriate alert (e.g., \"unsupported_extension\" or \"illegal_parameter\"). Prerequisites include that the extension is only sent in response to a corresponding request (with exceptions like the \"cookie\" extension) and that each extension block contains no duplicate extension types.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions\"\nRule: extension_data contains information specific to the particular extension type.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions",
    "sentence": "Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the \"cookie\" extension in the HelloRetryRequest.",
    "enhanced_sentence": "In TLS 1.3, implementations MUST NOT send extension responses in ServerHello, EncryptedExtensions, HelloRetryRequest, or Certificate messages unless the remote endpoint explicitly requested that extension type in its ClientHello (or CertificateRequest for client certificate extensions). This rule applies throughout the handshake negotiation phase to maintain protocol integrity and prevent unsolicited feature activation. The sole exception is the \"cookie\" extension (type 44), which servers MAY include in HelloRetryRequest messages without prior client request to facilitate stateless hello retry operations. If an endpoint receives an extension response without a corresponding request, it MUST abort the handshake immediately with an \"unsupported_extension\" alert. This enforcement ensures that extensions follow a strict request/response pattern, preventing protocol manipulation and maintaining security consistency across implementations.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions\"\nRule: Implementations MUST NOT send extension responses if the remote endpoint did not send the corresponding extension requests, with the exception of the \"cookie\" extension in the HelloRetryRequest.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions",
    "sentence": "Upon receiving an extension response without a corresponding request, an endpoint MUST abort the handshake with an \"unsupported_extension\" alert.",
    "enhanced_sentence": "In the TLS 1.3 handshake protocol, extensions follow a request/response model where clients send extension requests in ClientHello and servers respond in ServerHello, EncryptedExtensions, HelloRetryRequest, or Certificate messages. This rule applies when an endpoint receives any extension response (except for the explicitly permitted \"cookie\" extension in HelloRetryRequest) for which no corresponding request was previously sent in the current handshake. Upon detecting such an unsolicited extension response, the endpoint MUST immediately terminate the handshake by sending an \"unsupported_extension\" alert and abort the connection. This prevents protocol manipulation attacks where an adversary might attempt to inject or modify extension responses to force use or non-use of specific features.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions\"\nRule: Upon receiving an extension response without a corresponding request, an endpoint MUST abort the handshake with an \"unsupported_extension\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions",
    "sentence": "If an implementation receives an extension which it recognizes and which is not specified for the message in which it appears, it MUST abort the handshake with an \"illegal_parameter\" alert.",
    "enhanced_sentence": "During the TLS 1.3 handshake, if an implementation receives an extension that it recognizes but which is not permitted in the message type where it appears (as defined by the protocol specification and the extension's designated message contexts, such as ClientHello, ServerHello, EncryptedExtensions, Certificate, CertificateRequest, HelloRetryRequest, or NewSessionTicket), it MUST treat this as a protocol error and immediately abort the handshake by sending an \"illegal_parameter\" alert. This rule applies to all handshake messages that carry extensions and helps ensure that endpoints correctly interpret extension contexts, preventing misuse or misinterpretation of extension data that could lead to security issues or interoperability failures. The extension’s validity in a given message is determined by the extension type and the normative tables in the specification—not merely by the implementation’s ability to parse the extension.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions\"\nRule: If an implementation receives an extension which it recognizes and which is not specified for the message in which it appears, it MUST abort the handshake with an \"illegal_parameter\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions",
    "sentence": "The table below indicates the messages where a given extension may appear, using the following notation: CH (ClientHello), SH (ServerHello), EE (EncryptedExtensions), CT (Certificate), CR (CertificateRequest), NST (NewSessionTicket), and HRR (HelloRetryRequest).",
    "enhanced_sentence": "The table below specifies the permitted message contexts for each TLS 1.3 extension, using the following notation: CH (ClientHello), SH (ServerHello), EE (EncryptedExtensions), CT (Certificate), CR (CertificateRequest), NST (NewSessionTicket), and HRR (HelloRetryRequest). This rule governs extension placement to ensure protocol interoperability and security. It applies during the handshake phase when constructing or parsing TLS messages. Implementations MUST include extensions only in messages designated by this specification. If an extension is received in an unexpected message, the handshake MUST be aborted with an \"illegal_parameter\" alert. Prerequisites include correct extension negotiation (generally request/response, except for unilateral indications like NewSessionTicket) and adherence to extension ordering constraints (e.g., pre_shared_key must be last in ClientHello). The expected outcome is secure, interoperable extension handling without handshake failures due to improper placement.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions\"\nRule: The table below indicates the messages where a given extension may appear, using the following notation: CH (ClientHello), SH (ServerHello), EE (EncryptedExtensions), CT (Certificate), CR (CertificateRequest), NST (NewSessionTicket), and HRR (HelloRetryRequest).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions",
    "sentence": "ExtensionType enum includes server_name(0), max_fragment_length(1), status_request(5), supported_groups(10), signature_algorithms(13), use_srtp(14), heartbeat(15), application_layer_protocol_negotiation(16), signed_certificate_timestamp(18), client_certificate_type(19), server_certificate_type(20), padding(21), pre_shared_key(41), early_data(42), supported_versions(43), cookie(44), psk_key_exchange_modes(45), certificate_authorities(47), oid_filters(48), post_handshake_auth(49), signature_algorithms_cert(50), key_share(51), and (65535).",
    "enhanced_sentence": "The ExtensionType enum defines the set of valid extension types that may be included in TLS 1.3 handshake messages, such as server_name(0), max_fragment_length(1), status_request(5), supported_groups(10), signature_algorithms(13), use_srtp(14), heartbeat(15), application_layer_protocol_negotiation(16), signed_certificate_timestamp(18), client_certificate_type(19), server_certificate_type(20), padding(21), pre_shared_key(41), early_data(42), supported_versions(43), cookie(44), psk_key_exchange_modes(45), certificate_authorities(47), oid_filters(48), post_handshake_auth(49), signature_algorithms_cert(50), key_share(51), and (65535). This rule applies during the construction and parsing of extension blocks in handshake messages, including ClientHello, ServerHello, EncryptedExtensions, Certificate, CertificateRequest, HelloRetryRequest, and NewSessionTicket. Each extension type must only appear once per extension block, and extensions must only be sent in messages where they are specified (e.g., server_name may appear in ClientHello and EncryptedExtensions). Implementations must not send extension responses unless the corresponding request was received, except for the cookie extension in HelloRetryRequest. If an unrecognized extension or an extension appears in an invalid message context, the handshake must be aborted with an appropriate alert. The pre_shared_key extension must be the last extension in ClientHello but may appear anywhere in ServerHello. Extensions are negotiated per handshake, even in resumption mode, though 0-RTT parameters are inherited from the previous handshake. Designers and implementers must ensure extensions do not introduce security vulnerabilities through handshake manipulation.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions\"\nRule: ExtensionType enum includes server_name(0), max_fragment_length(1), status_request(5), supported_groups(10), signature_algorithms(13), use_srtp(14), heartbeat(15), application_layer_protocol_negotiation(16), signed_certificate_timestamp(18), client_certificate_type(19), server_certificate_type(20), padding(21), pre_shared_key(41), early_data(42), supported_versions(43), cookie(44), psk_key_exchange_modes(45), certificate_authorities(47), oid_filters(48), post_handshake_auth(49), signature_algorithms_cert(50), key_share(51), and (65535).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions",
    "sentence": "There MUST NOT be more than one extension of the same type in a given extension block.",
    "enhanced_sentence": "In any TLS 1.3 extension block (such as in ClientHello, ServerHello, EncryptedExtensions, Certificate, CertificateRequest, HelloRetryRequest, or NewSessionTicket messages), implementations MUST NOT include more than one extension of the same type. This rule applies during the construction and parsing of extension lists to ensure unambiguous interpretation of extension data. If a recipient encounters duplicate extension types in a single extension block, it MUST treat this as a protocol error and abort the handshake with an \"illegal_parameter\" alert. This requirement is fundamental to maintaining consistent extension processing and preventing ambiguity or exploitation through malformed extension structures.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions\"\nRule: There MUST NOT be more than one extension of the same type in a given extension block.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request",
    "sentence": "The CertificateRequest message, if sent, MUST follow EncryptedExtensions.",
    "enhanced_sentence": "When a server authenticating with a certificate optionally requests client authentication, the CertificateRequest message MUST be sent immediately after the EncryptedExtensions message during the main handshake. This sequencing ensures that all necessary encryption parameters and extensions are established before certificate requirements are communicated. The server MUST NOT send this message if authenticating with a pre-shared key (PSK) in the main handshake, though it may be used in post-handshake authentication if the client has indicated support. Adherence to this order guarantees proper extension processing and prevents state inconsistencies.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request\"\nRule: The CertificateRequest message, if sent, MUST follow EncryptedExtensions.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions",
    "sentence": "When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of pre_shared_key which MUST be the last extension in the ClientHello but can appear anywhere in the ServerHello extensions block.",
    "enhanced_sentence": "When multiple extensions of different types are present in a ClientHello or ServerHello message, the extensions MAY appear in any order, with the exception of the pre_shared_key extension. In the ClientHello, the pre_shared_key extension MUST appear as the last extension in the list to ensure proper processing of PSK binders and to prevent manipulation by active attackers. In the ServerHello, the pre_shared_key extension MAY appear in any position within the extensions block. This rule applies during the initial handshake phase when constructing or parsing Hello messages. Implementations must enforce this ordering to maintain protocol security and interoperability; failure to do so must result in an \"illegal_parameter\" alert aborting the handshake. This rule assumes that all extensions are valid for their respective message types as defined in the extension specification table.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions\"\nRule: When multiple extensions of different types are present, the extensions MAY appear in any order, with the exception of pre_shared_key which MUST be the last extension in the ClientHello but can appear anywhere in the ServerHello extensions block.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions",
    "sentence": "In TLS 1.3, unlike TLS 1.2, extensions are negotiated for each handshake even when in resumption-PSK mode.",
    "enhanced_sentence": "In TLS 1.3, unlike TLS 1.2, extensions must be fully negotiated in every handshake, including when using resumption-PSK mode. This rule applies during the initial exchange of ClientHello and ServerHello messages, where both client and server must send and process extension requests and responses specific to the current session. The expected outcome is that each handshake establishes a fresh set of negotiated extensions, ensuring that security parameters and capabilities are up-to-date and not inherited from a previous session. Note that while 0-RTT data uses parameters from the previous handshake, all other extensions (such as supported_versions, signature_algorithms, key_share, etc.) are renegotiated. Prerequisites include proper formatting and ordering of extensions within handshake messages, and adherence to the requirement that extensions must not be repeated within the same extension block.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions\"\nRule: In TLS 1.3, unlike TLS 1.2, extensions are negotiated for each handshake even when in resumption-PSK mode.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions",
    "sentence": "Often the fact that the extension fields are included in the inputs to the Finished message hashes will be sufficient, but extreme care is needed when the extension changes the meaning of messages sent in the handshake phase.",
    "enhanced_sentence": "When designing or implementing TLS 1.3 extensions, note that including extension fields in the inputs to the Finished message hashes generally ensures that both peers agree on the negotiated parameters, providing protection against tampering. However, if an extension alters the interpretation of handshake messages (e.g., changing cryptographic semantics or redefining message contents), this mechanism alone may be insufficient. In such cases, extreme care must be taken to ensure that the extension does not introduce security vulnerabilities, especially since handshake messages are vulnerable to active modification until authentication is complete. This rule applies during the handshake phase when extensions are processed, and adherence ensures that the negotiated extensions do not undermine the security or integrity of the protocol. Prerequisites include a correct implementation of extension parsing, adherence to extension placement rules, and validation that extensions are only sent in response to corresponding requests.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions\"\nRule: Often the fact that the extension fields are included in the inputs to the Finished message hashes will be sufficient, but extreme care is needed when the extension changes the meaning of messages sent in the handshake phase.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request",
    "sentence": "The certificate_request_context MUST be unique within the scope of this connection (thus preventing replay of client CertificateVerify messages).",
    "enhanced_sentence": "The certificate_request_context field in the CertificateRequest message, which identifies the request and is echoed in the client’s Certificate message, MUST be unique within the scope of the current TLS 1.3 connection. This applies when the server requests client authentication, either during the main handshake (after EncryptedExtensions) or in post-handshake authentication. Uniqueness ensures that each CertificateVerify message from the client is bound to a specific request context, preventing replay attacks where an adversary could reuse a previously valid CertificateVerify message. For post-handshake authentication, the server SHOULD additionally make this context unpredictable (e.g., via random generation) to mitigate pre-computation attacks if the client’s private key is temporarily compromised. The field SHALL be zero-length in the main handshake unless used for post-handshake authentication.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request\"\nRule: The certificate_request_context MUST be unique within the scope of this connection (thus preventing replay of client CertificateVerify messages).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request",
    "sentence": "The certificate_request_context field SHALL be zero length unless used for the post-handshake authentication exchanges described in Section 4.6.2.",
    "enhanced_sentence": "The certificate_request_context field in the CertificateRequest message SHALL be zero length during the initial handshake, as it is only used to identify the request and prevent replay attacks within the connection. This rule applies when the server requests client authentication as part of the main handshake, following EncryptedExtensions. The expected outcome is that the client echoes this zero-length context in its Certificate response, ensuring proper message binding without unnecessary data. However, if the server is initiating post-handshake authentication as described in Section 4.6.2 (which requires the client to have advertised the \"post_handshake_auth\" extension), the certificate_request_context MUST be a non-zero length, unique, and unpredictable value to securely distinguish the post-handshake request from the initial handshake and prevent pre-computation attacks.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request\"\nRule: The certificate_request_context field SHALL be zero length unless used for the post-handshake authentication exchanges described in Section 4.6.2.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions",
    "sentence": "The table indicates messages where extensions may appear: server_name in CH and EE, max_fragment_length in CH and EE, status_request in CH, CR, and CT, supported_groups in CH and EE, signature_algorithms in CH and CR, use_srtp in CH and EE, heartbeat in CH and EE, application_layer_protocol_negotiation in CH and EE, signed_certificate_timestamp in CH, CR, and CT, client_certificate_type in CH and EE, server_certificate_type in CH and EE, padding in CH, key_share in CH, SH, and HRR, pre_shared_key in CH and SH, psk_key_exchange_modes in CH, early_data in CH, EE, and NST, cookie in CH and HRR, supported_versions in CH, SH, and HRR, certificate_authorities in CH and CR, oid_filters in CR, post_handshake_auth in CH, and signature_algorithms_cert in CH and CR.",
    "enhanced_sentence": "This rule governs the permissible placement of TLS 1.3 extensions within specific handshake messages to ensure proper negotiation and security. It applies throughout the handshake flow, from initial ClientHello to post-handshake messages like NewSessionTicket. The expected outcome is that endpoints only include extensions in messages where they are defined, preventing protocol errors and ensuring interoperability. Prerequisites include that extensions must be requested before being responded to (except for the \"cookie\" extension in HelloRetryRequest), and implementations must not send unsolicited extension responses. If an unrecognized extension is received in an invalid message context, the handshake must be aborted with an \"illegal_parameter\" alert. The specific allowed message contexts for each extension are: server_name in CH and EE, max_fragment_length in CH and EE, status_request in CH, CR, and CT, supported_groups in CH and EE, signature_algorithms in CH and CR, use_srtp in CH and EE, heartbeat in CH and EE, application_layer_protocol_negotiation in CH and EE, signed_certificate_timestamp in CH, CR, and CT, client_certificate_type in CH and EE, server_certificate_type in CH and EE, padding in CH, key_share in CH, SH, and HRR, pre_shared_key in CH and SH, psk_key_exchange_modes in CH, early_data in CH, EE, and NST, cookie in CH and HRR, supported_versions in CH, SH, and HRR, certificate_authorities in CH and CR, oid_filters in CR, post_handshake_auth in CH, and signature_algorithms_cert in CH and CR.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions\"\nRule: The table indicates messages where extensions may appear: server_name in CH and EE, max_fragment_length in CH and EE, status_request in CH, CR, and CT, supported_groups in CH and EE, signature_algorithms in CH and CR, use_srtp in CH and EE, heartbeat in CH and EE, application_layer_protocol_negotiation in CH and EE, signed_certificate_timestamp in CH, CR, and CT, client_certificate_type in CH and EE, server_certificate_type in CH and EE, padding in CH, key_share in CH, SH, and HRR, pre_shared_key in CH and SH, psk_key_exchange_modes in CH, early_data in CH, EE, and NST, cookie in CH and HRR, supported_versions in CH, SH, and HRR, certificate_authorities in CH and CR, oid_filters in CR, post_handshake_auth in CH, and signature_algorithms_cert in CH and CR.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request",
    "sentence": "The structure of the CertificateRequest message is: struct { opaque certificate_request_context<0..2^8-1>; Extension extensions<2..2^16-1>; } CertificateRequest; certificate_request_context: An opaque string which identifies the certificate request and which will be echoed in the client's Certificate message.",
    "enhanced_sentence": "The CertificateRequest message structure is defined as: struct { opaque certificate_request_context<0..2^8-1>; Extension extensions<2..2^16-1>; } CertificateRequest; This message is used by the server to request client authentication and MUST be sent after EncryptedExtensions during the main handshake (or during post-handshake authentication as specified in Section 4.6.2). The certificate_request_context is an opaque identifier that must be echoed by the client in its Certificate response and must be unique within the connection to prevent replay attacks. This field must be zero-length for main handshake requests and should be randomly generated for post-handshake authentication to prevent pre-computation attacks. The extensions field must include the \"signature_algorithms\" extension and may include other relevant extensions like \"signature_algorithms_cert\" and \"certificate_authorities\" to specify acceptable certificate parameters. Servers authenticating with PSK must not send this message in the main handshake but may send it in post-handshake authentication if the client supports it via the \"post_handshake_auth\" extension.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request\"\nRule: The structure of the CertificateRequest message is: struct { opaque certificate_request_context<0..2^8-1>; Extension extensions<2..2^16-1>; } CertificateRequest; certificate_request_context: An opaque string which identifies the certificate request and which will be echoed in the client's Certificate message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request",
    "sentence": "When requesting post-handshake authentication, the server SHOULD make the certificate_request_context unpredictable to the client (e.g., by randomly generating it) in order to prevent an attacker who has temporary access to the client's private key from pre-computing valid CertificateVerify messages.",
    "enhanced_sentence": "This rule applies when a server sends a CertificateRequest message for post-handshake authentication (after the initial handshake has completed). The server SHOULD generate the certificate_request_context field using a cryptographically secure random method to ensure it is unpredictable to the client. This prevents an attacker who gains temporary access to the client's private key from precomputing valid CertificateVerify messages for future connections, as the unpredictable context forces real-time signing. This requirement only applies when certificate_request_context is non-zero (specifically for post-handshake authentication), and the context must always be unique within the connection to prevent replay attacks. The server must have received the client's \"post_handshake_auth\" extension during the initial handshake to be permitted to make this request.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request\"\nRule: When requesting post-handshake authentication, the server SHOULD make the certificate_request_context unpredictable to the client (e.g., by randomly generating it) in order to prevent an attacker who has temporary access to the client's private key from pre-computing valid CertificateVerify messages.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request",
    "sentence": "The \"signature_algorithms\" extension MUST be specified, and other extensions may optionally be included if defined for this message.",
    "enhanced_sentence": "When a server sends a CertificateRequest message to request client authentication, the \"signature_algorithms\" extension MUST be included to specify the signature schemes the server accepts for client certificates. This requirement applies to both main handshake and post-handshake authentication scenarios. Other extensions defined for CertificateRequest (such as \"signature_algorithms_cert\" or \"certificate_authorities\") may be optionally included. This rule ensures the client can properly validate and select an appropriate certificate and signature method. Prerequisites: The server must not be authenticating with a PSK in the main handshake, and for post-handshake authentication, the client must have indicated support via the \"post_handshake_auth\" extension.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request\"\nRule: The \"signature_algorithms\" extension MUST be specified, and other extensions may optionally be included if defined for this message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request",
    "sentence": "Clients MUST ignore unrecognized extensions.",
    "enhanced_sentence": "When processing the CertificateRequest message during the main handshake or post-handshake authentication, clients MUST ignore any extension in the extensions field that they do not recognize. This rule applies after the server has sent EncryptedExtensions and only if the client is capable of and willing to proceed with certificate-based authentication. The expected outcome is that the client continues processing the handshake without error, using only the recognized extensions (such as \"signature_algorithms\", \"signature_algorithms_cert\", and \"certificate_authorities\") to determine acceptable certificate parameters, while silently discarding any unknown extensions to ensure forward compatibility and avoid interoperability issues.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request\"\nRule: Clients MUST ignore unrecognized extensions.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request",
    "sentence": "extensions: A set of extensions describing the parameters of the certificate being requested.",
    "enhanced_sentence": "The `extensions` field in the CertificateRequest message contains a set of extensions that specify the parameters and constraints for the client certificate being requested. This rule applies when the server opts to request client authentication, either during the main handshake (after EncryptedExtensions) or in post-handshake authentication. The \"signature_algorithms\" extension MUST always be included to indicate acceptable signature schemes for the client's CertificateVerify; other optional extensions, such as \"signature_algorithms_cert\" or \"certificate_authorities\", may further define certificate requirements. Clients MUST ignore any unrecognized extensions. Prerequisites include the server not using PSK-based authentication in the main handshake (unless for post-handshake, where the client must have indicated support via the \"post_handshake_auth\" extension). The expected outcome is that the client uses these extensions to select and present an appropriate certificate that meets the server’s criteria.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request\"\nRule: extensions: A set of extensions describing the parameters of the certificate being requested.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request",
    "sentence": "In prior versions of TLS, the CertificateRequest message carried a list of signature algorithms and certificate authorities which the server would accept.",
    "enhanced_sentence": "In prior versions of TLS, the CertificateRequest message carried a list of signature algorithms and certificate authorities which the server would accept. This rule applies when the server requests client authentication, and the message MUST follow EncryptedExtensions in the handshake flow. The expected outcome is that the client uses the provided information to select an appropriate certificate and signature algorithm for authentication. In TLS 1.3, this legacy behavior is replaced by extensions: the \"signature_algorithms\" (required) and optionally \"signature_algorithms_cert\" extensions express acceptable signature schemes, while the \"certificate_authorities\" extension lists acceptable certificate issuers. Prerequisites include the server authenticating with a certificate (not PSK in the main handshake) and ensuring the certificate_request_context is unique to prevent replay attacks.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request\"\nRule: In prior versions of TLS, the CertificateRequest message carried a list of signature algorithms and certificate authorities which the server would accept.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request",
    "sentence": "In TLS 1.3, the list of signature algorithms is expressed by sending the \"signature_algorithms\" and optionally \"signature_algorithms_cert\" extensions.",
    "enhanced_sentence": "In TLS 1.3, when a server requests client authentication via a CertificateRequest message (which MUST follow EncryptedExtensions and is prohibited in the main handshake when authenticating with a PSK), the list of acceptable signature algorithms for client certificate verification MUST be conveyed using the \"signature_algorithms\" extension. Additionally, the server MAY include the \"signature_algorithms_cert\" extension to specify signature algorithms acceptable for the client certificate's own chain of trust. This replaces the legacy method of embedding signature algorithms directly in the CertificateRequest structure, ensuring alignment with the extension-based design of TLS 1.3. The client MUST use these extensions to select an appropriate certificate and signature algorithm for authentication.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request\"\nRule: In TLS 1.3, the list of signature algorithms is expressed by sending the \"signature_algorithms\" and optionally \"signature_algorithms_cert\" extensions.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request",
    "sentence": "The list of certificate authorities is expressed by sending the \"certificate_authorities\" extension (see Section 4.2.4).",
    "enhanced_sentence": "When a server requests client authentication via a CertificateRequest message, it MUST specify the acceptable certificate authorities by including the \"certificate_authorities\" extension (see Section 4.2.4) within the extensions field. This rule applies after EncryptedExtensions in the main handshake or during post-handshake authentication, provided the client supports it. The expected outcome is that the client selects a certificate issued by one of the listed authorities, ensuring mutual authentication. Prerequisites include the server not using a PSK for authentication in the main handshake and the client having indicated support for post-handshake authentication if applicable.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request\"\nRule: The list of certificate authorities is expressed by sending the \"certificate_authorities\" extension (see Section 4.2.4).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request",
    "sentence": "Servers which are authenticating with a PSK MUST NOT send the CertificateRequest message in the main handshake, though they MAY send it in post-handshake authentication (see Section 4.6.2) provided that the client has sent the \"post_handshake_auth\" extension (see Section 4.2.6).",
    "enhanced_sentence": "This rule governs the server's behavior when using Pre-Shared Key (PSK) authentication in TLS 1.3. It applies during the main handshake phase and potentially during post-handshake authentication. When a server authenticates with a PSK, it MUST NOT send a CertificateRequest message in the main handshake, as PSK authentication does not require client certificate verification at this stage. However, if the client has previously indicated support by sending the \"post_handshake_auth\" extension, the server MAY initiate post-handshake authentication and send a CertificateRequest message after the main handshake is complete. This allows for optional client authentication to be requested later without interfering with the PSK-based initial authentication. The prerequisite for post-handshake certificate request is that the client must have advertised the \"post_handshake_auth\" extension capability.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.3. Server Parameters -> 4.3.2. Certificate Request\"\nRule: Servers which are authenticating with a PSK MUST NOT send the CertificateRequest message in the main handshake, though they MAY send it in post-handshake authentication (see Section 4.6.2) provided that the client has sent the \"post_handshake_auth\" extension (see Section 4.2.6).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.1. The Transcript Hash",
    "sentence": "The reason for this construction is to allow the server to do a stateless HelloRetryRequest by storing just the hash of ClientHello1 in the cookie, rather than requiring the server to export the entire intermediate hash state (see Section 4.2.2).",
    "enhanced_sentence": "This rule governs the transcript hash computation during a TLS 1.3 handshake when a HelloRetryRequest is used. It applies specifically when the server responds to an initial ClientHello (ClientHello1) with a HelloRetryRequest, requiring the client to send a new ClientHello. The expected outcome is that ClientHello1 is replaced in the transcript hash with a synthetic \"message_hash\" handshake message containing only Hash(ClientHello1), rather than the full message. This construction allows servers to implement stateless HelloRetryRequest handling by storing only the hash of ClientHello1 in the cookie instead of the entire intermediate hash state, which would be required if the full ClientHello1 were included in the transcript. The prerequisite for this rule is that the server has determined the need for a HelloRetryRequest based on the initial ClientHello parameters. This exception to the normal transcript hash computation ensures both cryptographic integrity and server implementation efficiency (see Section 4.2.2 for cookie format details).",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.1. The Transcript Hash\"\nRule: The reason for this construction is to allow the server to do a stateless HelloRetryRequest by storing just the hash of ClientHello1 in the cookie, rather than requiring the server to export the entire intermediate hash state (see Section 4.2.2).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.3. Client Certificate Selection",
    "sentence": "The following rules apply to certificates sent by the client: The certificate type MUST be X.509v3 [RFC5280 Profile], unless explicitly negotiated otherwise (e.g., [RFC7250 and Datagram Transport Layer Security (DTLS)]).",
    "enhanced_sentence": "This rule governs the format of client certificates presented during TLS 1.3 handshakes. It applies when the client sends its Certificate message in response to a CertificateRequest from the server. The client MUST use X.509v3 certificates conforming to the RFC5280 profile, unless an alternative certificate type (such as Raw Public Keys per RFC7250, particularly relevant for DTLS) has been explicitly negotiated during the handshake. This ensures interoperability and proper certificate validation. Prerequisites include successful completion of the certificate type negotiation phase and the server's request for client authentication. The expected outcome is a properly formatted certificate chain that the server can validate according to the negotiated parameters.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.3. Client Certificate Selection\"\nRule: The following rules apply to certificates sent by the client: The certificate type MUST be X.509v3 [RFC5280 Profile], unless explicitly negotiated otherwise (e.g., [RFC7250 and Datagram Transport Layer Security (DTLS)]).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.3. Client Certificate Selection",
    "sentence": "If the \"certificate_authorities\" extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.",
    "enhanced_sentence": "When a client receives a CertificateRequest message containing the \"certificate_authorities\" extension, which lists one or more trusted Certificate Authorities (CAs), the client SHOULD select a certificate chain where at least one certificate (typically the end-entity certificate or an intermediate CA certificate) is issued by a CA included in that list. This requirement applies during the TLS 1.3 handshake when client authentication is requested, ensuring that the client’s certificate is trusted by the server based on the provided CA constraints. The rule is conditional on the presence of the \"certificate_authorities\" extension and aims to facilitate interoperability by aligning the client’s certificate choice with the server’s trust preferences. Note that this is a recommendation (SHOULD) rather than a strict requirement (MUST), allowing flexibility for scenarios where the client lacks a matching certificate but may still proceed with authentication if the server permits.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.3. Client Certificate Selection\"\nRule: If the \"certificate_authorities\" extension in the CertificateRequest message was present, at least one of the certificates in the certificate chain SHOULD be issued by one of the listed CAs.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.1. The Transcript Hash",
    "sentence": "For concreteness, the transcript hash is always taken from the following sequence of handshake messages, starting at the first ClientHello and including only those messages that were sent: ClientHello, HelloRetryRequest, ClientHello, ServerHello, EncryptedExtensions, server CertificateRequest, server Certificate, server CertificateVerify, server Finished, EndOfEarlyData, client Certificate, client CertificateVerify, client Finished.",
    "enhanced_sentence": "The transcript hash computation is a critical component of TLS 1.3 cryptographic operations, used for generating signatures in CertificateVerify messages and deriving keying material. This rule applies throughout the handshake process, starting from the initial ClientHello and continuing as each specified message is sent. The expected outcome is a consistent hash value computed over the exact sequence of handshake messages that were actually transmitted, ensuring both parties compute identical hashes for authentication and key derivation. Prerequisites include: the handshake must be in progress, the hash algorithm must be negotiated, and for HelloRetryRequest scenarios, the first ClientHello must be replaced with a synthetic \"message_hash\" handshake message containing its hash. The transcript MUST include only the following messages in this specific order when they are sent: ClientHello, HelloRetryRequest, ClientHello, ServerHello, EncryptedExtensions, server CertificateRequest, server Certificate, server CertificateVerify, server Finished, EndOfEarlyData, client Certificate, client CertificateVerify, client Finished. Note that post-handshake authentication messages are excluded from this transcript.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.1. The Transcript Hash\"\nRule: For concreteness, the transcript hash is always taken from the following sequence of handshake messages, starting at the first ClientHello and including only those messages that were sent: ClientHello, HelloRetryRequest, ClientHello, ServerHello, EncryptedExtensions, server CertificateRequest, server Certificate, server CertificateVerify, server Finished, EndOfEarlyData, client Certificate, client CertificateVerify, client Finished.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.3. Client Certificate Selection",
    "sentence": "The certificates MUST be signed using an acceptable signature algorithm, as described in Section 4.3.2.",
    "enhanced_sentence": "When a client provides a certificate chain in response to a CertificateRequest message, each certificate in the chain MUST be signed using a signature algorithm that is considered acceptable according to the criteria defined in Section 4.3.2. This requirement applies during the TLS 1.3 handshake after the server has sent a CertificateRequest and before the client sends its Finished message. Compliance ensures that the server can properly validate the client’s certificate chain using supported algorithms, thereby maintaining cryptographic consistency and interoperability. This rule is conditional upon the server having previously indicated acceptable signature algorithms (e.g., via the \"signature_algorithms\" or \"signature_algorithms_cert\" extensions) and applies regardless of whether the client certificate is an end-entity or intermediate CA certificate.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.3. Client Certificate Selection\"\nRule: The certificates MUST be signed using an acceptable signature algorithm, as described in Section 4.3.2.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.3. Client Certificate Selection",
    "sentence": "If the CertificateRequest message contained a non-empty \"oid_filters\" extension, the end-entity certificate MUST match the extension OIDs that are recognized by the client, as described in Section 4.2.5.",
    "enhanced_sentence": "When a client receives a CertificateRequest message during the TLS 1.3 handshake that includes a non-empty \"oid_filters\" extension, the client MUST ensure that the end-entity certificate it selects for authentication contains all the extension OIDs listed in the \"oid_filters\" that the client recognizes and supports. This requirement applies only if the client is capable of interpreting the specified OIDs, as detailed in Section 4.2.5. The purpose of this rule is to enable the server to request specific certificate properties or extensions, ensuring that the client provides a certificate meeting the server’s policy requirements. If the client cannot provide a certificate that matches the recognized OID filters, it should respond with an empty Certificate message, unless otherwise negotiated. This rule is conditional on the presence and non-emptiness of the \"oid_filters\" extension in the CertificateRequest.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.3. Client Certificate Selection\"\nRule: If the CertificateRequest message contained a non-empty \"oid_filters\" extension, the end-entity certificate MUST match the extension OIDs that are recognized by the client, as described in Section 4.2.5.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.3. Client Certificate Selection",
    "sentence": "Note that the requirement for certificates to be signed using an acceptable signature algorithm relaxes the constraints on certificate-signing algorithms found in prior versions of TLS.",
    "enhanced_sentence": "During the TLS 1.3 handshake, when a client is selecting a certificate chain to send in response to a CertificateRequest, the client MUST ensure that all certificates in the chain are signed using a signature algorithm that is acceptable according to the negotiated parameters (as defined in Section 4.3.2). This rule applies specifically during client certificate authentication, after the server has sent a CertificateRequest and before the client sends its Certificate message. The expected outcome is that the client presents a certificate chain whose signatures are compatible with the current session's security parameters, ensuring cryptographic consistency. This requirement is a relaxation from prior TLS versions, which imposed stricter or less flexible constraints on acceptable certificate-signing algorithms, thereby allowing a broader range of algorithms in TLS 1.3 provided they are mutually supported. Prerequisites include a successful negotiation of supported signature algorithms during the handshake, and the server must have requested client authentication.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.3. Client Certificate Selection\"\nRule: Note that the requirement for certificates to be signed using an acceptable signature algorithm relaxes the constraints on certificate-signing algorithms found in prior versions of TLS.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.1. OCSP Status and SCT Extensions",
    "sentence": "Specifically, the body of the \"status_request\" extension from the server MUST be a CertificateStatus structure as defined in [RFC6066], which is interpreted as defined in [RFC6960].",
    "enhanced_sentence": "When a TLS 1.3 server includes the \"status_request\" extension in a CertificateEntry (to provide OCSP status information for the associated certificate), the extension body MUST be a CertificateStatus structure as defined in RFC 6066, and its contents MUST be interpreted according to RFC 6960. This rule applies only if the client has previously negotiated OCSP stapling via the \"status_request\" extension in the ClientHello. The expected outcome is that the client can validate the certificate's revocation status using the provided OCSP response, without requiring a separate query to the OCSP responder. Note that the deprecated status_request_v2 extension MUST NOT be used in TLS 1.3 for this purpose.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.1. OCSP Status and SCT Extensions\"\nRule: Specifically, the body of the \"status_request\" extension from the server MUST be a CertificateStatus structure as defined in [RFC6066], which is interpreted as defined in [RFC6960].\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.1. OCSP Status and SCT Extensions",
    "sentence": "In TLS 1.3, the server's OCSP information is carried in an extension in the CertificateEntry containing the associated certificate.",
    "enhanced_sentence": "In TLS 1.3, the server's OCSP information is carried in an extension in the CertificateEntry containing the associated certificate. This rule applies during the handshake when the server sends its Certificate message, specifically within the CertificateEntry structure for the end-entity certificate. The expected outcome is that the server provides a real-time Online Certificate Status Protocol (OCSP) response for the associated certificate, enabling the client to verify the certificate's revocation status without requiring a separate OCSP request. This behavior is negotiated via the \"status_request\" extension in the ClientHello, and the server's response MUST be formatted as a CertificateStatus structure as defined in RFC 6066. Note that the deprecated status_request_v2 extension MUST NOT be used in TLS 1.3, and servers MUST ignore it if present in ClientHello. Additionally, servers may request OCSP responses from clients by including an empty \"status_request\" extension in the CertificateRequest message.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.1. OCSP Status and SCT Extensions\"\nRule: In TLS 1.3, the server's OCSP information is carried in an extension in the CertificateEntry containing the associated certificate.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.1. OCSP Status and SCT Extensions",
    "sentence": "TLS 1.3 servers MUST NOT act upon the presence of the status_request_v2 extension or information in the status_request_v2 extension when processing ClientHello messages; in particular, TLS 1.3 servers MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.",
    "enhanced_sentence": "In TLS 1.3, the status_request_v2 extension [RFC6961] is deprecated and MUST NOT be used for OCSP status negotiation. When processing ClientHello messages, TLS 1.3 servers MUST ignore the presence of the status_request_v2 extension and any information it contains. This rule applies during the initial handshake phase when the server is evaluating client-provided extensions. Specifically, servers MUST NOT include the status_request_v2 extension in any subsequent handshake messages (EncryptedExtensions, CertificateRequest, or Certificate messages). Instead, OCSP status information MUST be conveyed using the status_request extension [RFC6066] within CertificateEntry structures. The expected outcome is that TLS 1.3 connections will only use the standardized status_request mechanism for OCSP responses, ensuring interoperability and deprecating the older status_request_v2 method. Note that servers MUST still be able to receive ClientHello messages containing status_request_v2 from clients supporting older TLS versions, but MUST NOT act upon it in TLS 1.3 negotiations.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.1. OCSP Status and SCT Extensions\"\nRule: TLS 1.3 servers MUST NOT act upon the presence of the status_request_v2 extension or information in the status_request_v2 extension when processing ClientHello messages; in particular, TLS 1.3 servers MUST NOT send the status_request_v2 extension in the EncryptedExtensions, CertificateRequest, or Certificate messages.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.1. OCSP Status and SCT Extensions",
    "sentence": "[RFC6066] and [RFC6961] provide extensions to negotiate the server sending OCSP responses to the client.",
    "enhanced_sentence": "This rule governs the negotiation and transmission of OCSP (Online Certificate Status Protocol) responses and SCT (Signed Certificate Timestamp) extensions during TLS 1.3 handshakes. It applies when a client requests certificate status information using the \"status_request\" extension (from RFC6066) or SCT information. In TLS 1.3, servers MUST carry OCSP responses and SCTs as extensions within the CertificateEntry associated with the relevant certificate, rather than in separate messages as in TLS 1.2. The server's OCSP response MUST use the CertificateStatus structure defined in RFC6066 and interpreted per RFC6960. Note that the status_request_v2 extension (RFC6961) is deprecated; TLS 1.3 servers MUST NOT use or act on it but MUST be able to process ClientHello messages containing it for backward compatibility. Additionally, servers MAY request OCSP responses from clients by including an empty \"status_request\" extension in the CertificateRequest message, and clients responding MUST use the same CertificateStatus structure. Prerequisites include proper support for the \"status_request\" extension and adherence to the specified message structures. The expected outcome is secure, negotiated delivery of real-time certificate status information without breaking backward compatibility.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.1. OCSP Status and SCT Extensions\"\nRule: [RFC6066] and [RFC6961] provide extensions to negotiate the server sending OCSP responses to the client.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.1. OCSP Status and SCT Extensions",
    "sentence": "TLS 1.3 servers MUST be able to process ClientHello messages that include the status_request_v2 extension, as the status_request_v2 extension MAY be sent by clients that wish to use the status_request_v2 extension in earlier protocol versions.",
    "enhanced_sentence": "TLS 1.3 servers MUST be able to receive and parse ClientHello messages containing the deprecated status_request_v2 extension [RFC6961] without generating protocol errors, even though they MUST NOT use it for OCSP status negotiation. This requirement applies during the initial handshake when processing the ClientHello message, as clients that support earlier TLS versions (1.2 or below) may include this extension for backward compatibility. The expected outcome is that the server silently ignores the presence of the status_request_v2 extension and proceeds with the handshake using only the current \"status_request\" extension [RFC6066] if present. This rule applies unconditionally to all TLS 1.3 server implementations, regardless of whether they support OCSP stapling.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.1. OCSP Status and SCT Extensions\"\nRule: TLS 1.3 servers MUST be able to process ClientHello messages that include the status_request_v2 extension, as the status_request_v2 extension MAY be sent by clients that wish to use the status_request_v2 extension in earlier protocol versions.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.1. OCSP Status and SCT Extensions",
    "sentence": "If the client opts to send an OCSP response, the body of the client's \"status_request\" extension MUST be a CertificateStatus structure as defined in [RFC6066].",
    "enhanced_sentence": "When a TLS 1.3 server requests an OCSP response by including an empty \"status_request\" extension in its CertificateRequest message, and the client chooses to provide one, the client MUST format the body of its \"status_request\" extension as a CertificateStatus structure as defined in RFC 6066. This rule applies during the client's Certificate message response phase, ensuring proper encoding and interpretation of the OCSP status information. The expected outcome is a correctly structured OCSP response that the server can validate according to RFC 6960. This requirement is conditional on the server having explicitly requested OCSP status via the empty extension in CertificateRequest.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.1. OCSP Status and SCT Extensions\"\nRule: If the client opts to send an OCSP response, the body of the client's \"status_request\" extension MUST be a CertificateStatus structure as defined in [RFC6066].\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.1. OCSP Status and SCT Extensions",
    "sentence": "A server MAY request that a client present an OCSP response with its certificate by sending an empty \"status_request\" extension in its CertificateRequest message.",
    "enhanced_sentence": "During the TLS 1.3 handshake, when a server requires client authentication, it MAY request that the client include an Online Certificate Status Protocol (OCSP) response alongside its certificate by including an empty \"status_request\" extension in its CertificateRequest message. This rule applies only after the server has received a ClientHello and is issuing a CertificateRequest to solicit client authentication. The expected outcome is that if the client opts to provide an OCSP response, it MUST format the body of its \"status_request\" extension as a CertificateStatus structure as defined in RFC 6066. Note that this mechanism is distinct from the deprecated status_request_v2 extension, which MUST NOT be used by TLS 1.3 servers.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.1. OCSP Status and SCT Extensions\"\nRule: A server MAY request that a client present an OCSP response with its certificate by sending an empty \"status_request\" extension in its CertificateRequest message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.1. OCSP Status and SCT Extensions",
    "sentence": "In TLS 1.3, the server's SCT information is carried in an extension in the CertificateEntry.",
    "enhanced_sentence": "In TLS 1.3, the server's Signed Certificate Timestamp (SCT) information MUST be carried as an extension within the CertificateEntry associated with the server's certificate, rather than in a separate ServerHello extension as in TLS 1.2 and below. This rule applies during the server's Certificate message transmission when SCTs are provided for certificate transparency. The expected outcome is that clients can validate the SCT data directly from the certificate structure, ensuring transparency information is bound to the specific certificate. Prerequisites include the server supporting certificate transparency and the client having indicated SCT capability during the handshake.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.1. OCSP Status and SCT Extensions\"\nRule: In TLS 1.3, the server's SCT information is carried in an extension in the CertificateEntry.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages",
    "sentence": "The Certificate, CertificateVerify, and Finished messages are always sent as the last messages in their handshake flight.",
    "enhanced_sentence": "The Certificate, CertificateVerify, and Finished messages must always be sent as the final messages in their respective handshake flight, following all other handshake messages in that flight. This rule applies to both client and server authentication blocks during the TLS 1.3 handshake process. These messages are encrypted using keys derived from the sender_handshake_traffic_secret and serve to provide authentication, key confirmation, and handshake integrity. The Certificate and CertificateVerify messages are only sent when certificate-based authentication is required (not in PSK handshake flows), while the Finished message is always included. This sequencing ensures proper cryptographic binding of the entire handshake transcript and prevents tampering with authentication material.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages\"\nRule: The Certificate, CertificateVerify, and Finished messages are always sent as the last messages in their handshake flight.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages",
    "sentence": "The Certificate, CertificateVerify, and Finished messages are encrypted under keys derived from the sender_handshake_traffic_secret.",
    "enhanced_sentence": "The Certificate, CertificateVerify, and Finished messages must be encrypted using keys derived from the sender_handshake_traffic_secret. This rule applies during the handshake phase when these authentication messages are transmitted as the final messages in their respective flight. The expected outcome is that these critical authentication messages are protected under handshake traffic keys, ensuring confidentiality and integrity against passive eavesdropping. This encryption is conditional on successful key derivation from the handshake traffic secret, which must be established prior to sending these messages. The specific sender_handshake_traffic_secret used depends on the role (server uses server_handshake_traffic_secret, client uses client_handshake_traffic_secret) and must correspond to the appropriate handshake context for the scenario.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages\"\nRule: The Certificate, CertificateVerify, and Finished messages are encrypted under keys derived from the sender_handshake_traffic_secret.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages",
    "sentence": "As discussed in Section 2, TLS generally uses a common set of messages for authentication, key confirmation, and handshake integrity: Certificate, CertificateVerify, and Finished.",
    "enhanced_sentence": "TLS 1.3 uses a standardized set of messages—Certificate, CertificateVerify, and Finished—to achieve authentication, key confirmation, and handshake integrity. These messages are always sent as the final messages in their respective handshake flight and are encrypted using keys derived from the sender_handshake_traffic_secret. The Certificate and CertificateVerify messages are conditionally sent based on authentication requirements (e.g., server or client certificate authentication), while the Finished message is mandatory in all handshakes. Each message is computed using a Handshake Context (a transcript of prior handshake messages) and a Base Key specific to the sender's role and handshake mode. The expected outcome is mutual authentication, verification of handshake integrity, and confirmation that both parties have derived the same session keys. Prerequisites include successful key exchange and, for certificate-based authentication, valid signing keys and certificate chains. Note that PSK handshakes (including 0-RTT) do not support certificate-based client authentication.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages\"\nRule: As discussed in Section 2, TLS generally uses a common set of messages for authentication, key confirmation, and handshake integrity: Certificate, CertificateVerify, and Finished.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages",
    "sentence": "The Certificate and CertificateVerify messages are only sent under certain circumstances, as defined below.",
    "enhanced_sentence": "The Certificate and CertificateVerify messages are only sent under specific authentication scenarios, as defined by the handshake mode and key exchange method. These messages are omitted in PSK-based handshakes (including 0-RTT) where certificate-based authentication is unavailable. They are sent when: 1) Server authentication is required (always sent by server unless using PSK), 2) Client authentication is requested via CertificateRequest (sent by client in response), or 3) During post-handshake authentication. Both messages must be encrypted using keys derived from the sender_handshake_traffic_secret and are always positioned as the final messages in their respective handshake flight, immediately preceding the Finished message. The specific Handshake Context and Base Key for MAC computation vary by mode (server, client, or post-handshake) as detailed in the subsequent table.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages\"\nRule: The Certificate and CertificateVerify messages are only sent under certain circumstances, as defined below.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages",
    "sentence": "Based on these inputs, the messages then contain: Certificate: The certificate to be used for authentication, and any supporting certificates in the chain.",
    "enhanced_sentence": "The Certificate message, which is part of the Authentication Block and always sent as the last message in its handshake flight, contains the endpoint's authentication certificate along with any supporting certificates in the chain. This rule applies when certificate-based authentication is required, such as in server authentication or when client authentication is explicitly requested via a CertificateRequest message. The message is encrypted under keys derived from the sender_handshake_traffic_secret. The expected outcome is that the recipient can validate the certificate chain and establish the sender's identity. Note that this message is only sent under circumstances requiring certificate authentication and is not available in PSK handshake flows (including 0-RTT). Prerequisites include having a valid certificate and signing key, and the handshake context must include all relevant messages up to the point of sending.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages\"\nRule: Based on these inputs, the messages then contain: Certificate: The certificate to be used for authentication, and any supporting certificates in the chain.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages",
    "sentence": "CertificateVerify: A signature over the value Transcript-Hash(Handshake Context, Certificate).",
    "enhanced_sentence": "The CertificateVerify message is used to provide explicit proof that the sender possesses the private key corresponding to the public key in the previously sent Certificate message. This rule applies when certificate-based authentication is required (e.g., in non-PSK handshake flows) and must be sent as the last message in its handshake flight, encrypted under keys derived from the sender_handshake_traffic_secret. The message must contain a digital signature computed over the value Transcript-Hash(Handshake Context, Certificate), where the Handshake Context includes all handshake messages up to (but not including) the Certificate message. The expected outcome is that the recipient can verify this signature using the public key from the Certificate, thereby authenticating the sender's identity. Prerequisites include successful transmission of the Certificate message and availability of the corresponding signing key.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages\"\nRule: CertificateVerify: A signature over the value Transcript-Hash(Handshake Context, Certificate).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages",
    "sentence": "The following table defines the Handshake Context and MAC Base Key for each scenario: Server mode uses ClientHello through later messages of EncryptedExtensions or CertificateRequest with server_handshake_traffic_secret as Base Key.",
    "enhanced_sentence": "This rule defines the specific inputs for authentication message computations in TLS 1.3 server mode. It applies when the server is generating Certificate, CertificateVerify, or Finished messages during the handshake phase. The Handshake Context must include all messages from ClientHello through the server's EncryptedExtensions or CertificateRequest (whichever comes later in the flight), providing a complete transcript of the handshake up to that point. The MAC Base Key must be derived from the server_handshake_traffic_secret, which is established through earlier key derivation steps. When followed correctly, this ensures proper computation of authentication signatures and MACs that provide handshake integrity and server authentication. Prerequisites include successful completion of the key exchange phase and derivation of the server_handshake_traffic_secret.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages\"\nRule: The following table defines the Handshake Context and MAC Base Key for each scenario: Server mode uses ClientHello through later messages of EncryptedExtensions or CertificateRequest with server_handshake_traffic_secret as Base Key.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages",
    "sentence": "Post-Handshake mode uses ClientHello through client Finished plus CertificateRequest with client_application_traffic_secret_N as Base Key.",
    "enhanced_sentence": "In Post-Handshake authentication mode, which occurs after the initial handshake is complete and the connection is in an application data phase, the client sends Certificate, CertificateVerify, and Finished messages in response to a server's CertificateRequest. This mode uses the entire handshake transcript from ClientHello through the client's initial Finished message, plus the received CertificateRequest, as the Handshake Context for authentication computations. The Base Key for deriving the MAC key in the Finished message is client_application_traffic_secret_N, which is derived from the current application traffic secret and ensures cryptographic separation from handshake traffic. This rule applies specifically when the server initiates post-handshake authentication and the client responds with authentication messages.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages\"\nRule: Post-Handshake mode uses ClientHello through client Finished plus CertificateRequest with client_application_traffic_secret_N as Base Key.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages",
    "sentence": "Finished: A MAC over the value Transcript-Hash(Handshake Context, Certificate, CertificateVerify) using a MAC key derived from the Base Key.",
    "enhanced_sentence": "The Finished message is a MAC computed over the value Transcript-Hash(Handshake Context, Certificate, CertificateVerify) using a MAC key derived from the Base Key. This rule applies during the final stage of the handshake flight, immediately following the Certificate and CertificateVerify messages (if present), and is always sent as part of the Authentication Block. The Finished message provides key confirmation and handshake integrity, ensuring that both parties have derived the same keys and that the handshake messages have not been tampered with. Prerequisites include the successful derivation of the Base Key (e.g., server_handshake_traffic_secret or client_handshake_traffic_secret) from the handshake, and the prior transmission of relevant messages as defined by the Handshake Context for the given scenario (server, client, or post-handshake mode). The message must be encrypted using keys from sender_handshake_traffic_secret.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages\"\nRule: Finished: A MAC over the value Transcript-Hash(Handshake Context, Certificate, CertificateVerify) using a MAC key derived from the Base Key.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages",
    "sentence": "client | client_application_traffic_ | | Handshake | Finished + | secret_N | | | CertificateRequest | | +-----------+-------------------------+-----------------------------+",
    "enhanced_sentence": "In post-handshake authentication scenarios, when a client receives a CertificateRequest message after the initial handshake is complete, the client MUST respond with a Certificate message (if applicable), CertificateVerify, and Finished messages. These messages are encrypted using keys derived from the client_application_traffic_secret_N. The Handshake Context for computing the Finished MAC includes all messages from ClientHello through the client's Finished message from the initial handshake, plus the post-handshake CertificateRequest. The MAC key for the Finished message is derived from the client_application_traffic_secret_N as the Base Key. This rule applies only when the server initiates post-handshake authentication and the client has a certificate to provide. The expected outcome is successful client authentication and establishment of a new application traffic secret (secret_N+1) for subsequent data encryption.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages\"\nRule: client | client_application_traffic_ | | Handshake | Finished + | secret_N | | | CertificateRequest | | +-----------+-------------------------+-----------------------------+\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages",
    "sentence": "Client mode uses ClientHello through later messages of server Finished or EndOfEarlyData with client_handshake_traffic_secret as Base Key.",
    "enhanced_sentence": "In TLS 1.3, when operating in client mode, the client's authentication messages (Certificate, CertificateVerify, and Finished) must be computed using the client_handshake_traffic_secret as the Base Key for deriving MAC keys. This rule applies specifically when the client is responding to server authentication during the handshake phase, after receiving the server's Finished message (or EndOfEarlyData in 0-RTT scenarios). The Handshake Context for these computations must include all messages from ClientHello through the server's Finished or EndOfEarlyData message. The expected outcome is proper authentication and integrity protection of client handshake messages, ensuring mutual authentication when client certificates are used. This rule only applies when certificate-based client authentication is negotiated and requires that the server has previously sent its authentication messages and derived the necessary handshake traffic secrets.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages\"\nRule: Client mode uses ClientHello through later messages of server Finished or EndOfEarlyData with client_handshake_traffic_secret as Base Key.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension",
    "sentence": "The \"pre_shared_key\" extension is used to negotiate the identity of the pre-shared key to be used with a given handshake in association with PSK key establishment.",
    "enhanced_sentence": "The \"pre_shared_key\" extension is used to negotiate the identity of the pre-shared key (PSK) to be used with a given handshake in association with PSK key establishment. This rule applies during the ClientHello and ServerHello exchange, where the client offers a list of PSK identities and binders, and the server selects one. The extension must be the last extension in the ClientHello, and servers must validate this ordering. Prerequisites include having established PSKs externally or via session tickets, with each PSK associated with a specific hash algorithm. The expected outcome is successful PSK-based authentication and key derivation if the server validates the binder for the selected identity, the client verifies the server’s selection (including index range, cipher suite compatibility, and key_share presence if required), and both parties adhere to the structural and ordering requirements. Failure to meet these conditions results in handshake abortion with an \"illegal_parameter\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension\"\nRule: The \"pre_shared_key\" extension is used to negotiate the identity of the pre-shared key to be used with a given handshake in association with PSK key establishment.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension",
    "sentence": "The \"extension_data\" field of the \"pre_shared_key\" extension contains a \"PreSharedKeyExtension\" value.",
    "enhanced_sentence": "The \"extension_data\" field of the \"pre_shared_key\" extension contains a \"PreSharedKeyExtension\" value, which is used to negotiate pre-shared key identities and binders for PSK-based key establishment during the TLS 1.3 handshake. This rule applies when a client includes the \"pre_shared_key\" extension in its ClientHello message, and the server processes it to select a compatible PSK identity. The structure includes PskIdentity entries (with identity labels and obfuscated ticket ages), PskBinderEntry values, and varies by handshake message type. Prerequisites include establishing PSKs externally or via session tickets, associating each PSK with a hash algorithm, and ensuring the extension is the last in ClientHello. The expected outcome is successful PSK negotiation if binders validate and identities match; otherwise, the handshake must be aborted with an \"illegal_parameter\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension\"\nRule: The \"extension_data\" field of the \"pre_shared_key\" extension contains a \"PreSharedKeyExtension\" value.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension",
    "sentence": "The server MUST ensure that it selects a compatible PSK (if any) and cipher suite.",
    "enhanced_sentence": "When processing a ClientHello containing the \"pre_shared_key\" extension, the server MUST select a PSK (if any) that is compatible with the negotiated cipher suite. This rule applies during the server's handshake processing, after receiving the ClientHello and before sending the ServerHello. The selected PSK must be associated with a hash algorithm that matches the hash algorithm of the chosen cipher suite. If no compatible PSK is available, the server SHOULD proceed with a non-PSK handshake. This selection must occur after validating the corresponding binder for the chosen PSK, as required by Section 4.2.11.2. The expected outcome is a consistent handshake where the key derivation material from the PSK aligns with the cryptographic parameters of the cipher suite, ensuring interoperability and security.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension\"\nRule: The server MUST ensure that it selects a compatible PSK (if any) and cipher suite.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension",
    "sentence": "In order to accept PSK key establishment, the server sends a \"pre_shared_key\" extension indicating the selected identity.",
    "enhanced_sentence": "When the server accepts PSK key establishment after successfully validating the client's PSK binder and selecting a compatible PSK identity and cipher suite, it MUST include a \"pre_shared_key\" extension in its ServerHello message. This extension must contain the \"selected_identity\" field indicating the (0-based) index of the chosen PSK identity from the client's offered list. The server must ensure the selected PSK is associated with a hash algorithm compatible with the negotiated cipher suite. If the client included an \"early_data\" extension, the server must select identity 0. This response enables the client to verify the server's selection and proceed with the PSK-based handshake.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension\"\nRule: In order to accept PSK key establishment, the server sends a \"pre_shared_key\" extension indicating the selected identity.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension",
    "sentence": "Implementor's note: When session resumption is the primary use case of PSKs, the most straightforward way to implement the PSK/cipher suite matching requirements is to negotiate the cipher suite first and then exclude any incompatible PSKs.",
    "enhanced_sentence": "When implementing the pre-shared key extension for session resumption scenarios, developers should note that the most straightforward approach to satisfy the PSK/cipher suite compatibility requirements (as specified in Section 4.2.11) is to first complete cipher suite negotiation during the handshake, then filter the available PSKs to exclude any that are incompatible with the selected cipher suite's associated hash algorithm. This rule applies during server-side processing of the ClientHello message when PSK-based resumption is attempted. The expected outcome is that the server selects a PSK identity that is both offered by the client and compatible with the negotiated cipher suite, ensuring successful session resumption. This approach requires that each PSK has an associated hash algorithm (defined during PSK establishment) and that the server validates the corresponding binder before accepting PSK key establishment.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension\"\nRule: Implementor's note: When session resumption is the primary use case of PSKs, the most straightforward way to implement the PSK/cipher suite matching requirements is to negotiate the cipher suite first and then exclude any incompatible PSKs.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension",
    "sentence": "The structure includes: PskIdentity with identity (a label for a key) and obfuscated_ticket_age; PskBinderEntry; OfferedPsks with identities and binders; and PreSharedKeyExtension which varies by handshake message type.",
    "enhanced_sentence": "The \"pre_shared_key\" extension is used to negotiate a pre-shared key identity for PSK-based key establishment during the TLS 1.3 handshake. This rule applies when a client includes the extension in the ClientHello message, offering one or more PSK identities for resumption or external key agreement. The structure consists of: PskIdentity (containing a key label and obfuscated ticket age), PskBinderEntry (an HMAC value for PSK validation), OfferedPsks (a list of identities and corresponding binders), and PreSharedKeyExtension (which varies by handshake message type). The server must validate the binder of the selected PSK, ensure cipher suite compatibility, and respond with a selected_identity index. Clients must verify that the server’s choice is valid and consistent with other handshake parameters. The extension must be the last in ClientHello, and servers must enforce this order. Prerequisites include established PSKs (via session tickets or external means) and correct computation of obfuscated_ticket_age and binders as specified. Failure to adhere to these requirements results in handshake abortion with an \"illegal_parameter\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension\"\nRule: The structure includes: PskIdentity with identity (a label for a key) and obfuscated_ticket_age; PskBinderEntry; OfferedPsks with identities and binders; and PreSharedKeyExtension which varies by handshake message type.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.4. Receiving a Certificate Message",
    "sentence": "If the server supplies an empty Certificate message, the client MUST abort the handshake with a \"decode_error\" alert.",
    "enhanced_sentence": "During the TLS 1.3 handshake, when the server is expected to provide a certificate chain for authentication (e.g., in non-PSK handshakes), if it sends an empty Certificate message (containing no certificates), the client MUST treat this as a protocol violation and immediately abort the handshake by sending a \"decode_error\" alert. This rule applies specifically to server authentication scenarios and ensures that clients do not proceed with unauthenticated connections when a certificate is required. The client must only enforce this rule when the handshake context indicates that server authentication is expected.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.4. Receiving a Certificate Message\"\nRule: If the server supplies an empty Certificate message, the client MUST abort the handshake with a \"decode_error\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension",
    "sentence": "Servers MUST check that the \"pre_shared_key\" extension is the last extension and otherwise fail the handshake with an \"illegal_parameter\" alert.",
    "enhanced_sentence": "When processing a ClientHello message that includes the \"pre_shared_key\" extension, servers MUST verify that this extension appears as the final extension in the ClientHello extensions list. This requirement applies specifically during the ClientHello parsing phase of the handshake protocol. If the \"pre_shared_key\" extension is not positioned last, the server MUST immediately terminate the handshake by sending an \"illegal_parameter\" alert. This ordering constraint is designed to facilitate consistent implementation of PSK validation logic, particularly for binder computation and verification, by ensuring all other extensions are processed before PSK-related operations. The rule applies regardless of whether the server ultimately accepts or rejects PSK key establishment.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension\"\nRule: Servers MUST check that the \"pre_shared_key\" extension is the last extension and otherwise fail the handshake with an \"illegal_parameter\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension",
    "sentence": "The \"pre_shared_key\" extension MUST be the last extension in the ClientHello (this facilitates implementation as described below).",
    "enhanced_sentence": "The \"pre_shared_key\" extension MUST be the last extension in the ClientHello message. This requirement applies during the TLS 1.3 handshake when the client is attempting to resume a session or use a pre-shared key for authentication. The extension must appear after all other extensions to simplify parsing and binder validation, as the binder value depends on the entire ClientHello message up to (but not including) the binder itself. If the server receives a ClientHello where the \"pre_shared_key\" extension is not the final extension, it MUST terminate the handshake with an \"illegal_parameter\" alert. This ordering ensures consistent and secure processing of PSK-based handshakes across implementations.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension\"\nRule: The \"pre_shared_key\" extension MUST be the last extension in the ClientHello (this facilitates implementation as described below).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.4. Receiving a Certificate Message",
    "sentence": "If the client does not send any certificates (i.e., it sends an empty Certificate message), the server MAY at its discretion either continue the handshake without client authentication or abort the handshake with a \"certificate_required\" alert.",
    "enhanced_sentence": "This rule governs server behavior when processing the Certificate message during the TLS 1.3 handshake, specifically when the client provides no certificates (i.e., sends an empty Certificate structure). It applies after the server has requested client authentication via a CertificateRequest message and has received the client's Certificate message in response. The server has discretionary authority to either proceed with the handshake without authenticating the client (treating the session as unauthenticated) or terminate the connection by sending a \"certificate_required\" alert. This decision may be based on server policy, security requirements, or the context of the connection. Note that if the server did not request a certificate, this rule does not apply, and the client is not expected to send one.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.4. Receiving a Certificate Message\"\nRule: If the client does not send any certificates (i.e., it sends an empty Certificate message), the server MAY at its discretion either continue the handshake without client authentication or abort the handshake with a \"certificate_required\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension",
    "sentence": "If the server supplies an \"early_data\" extension, the client MUST verify that the server's selected_identity is 0.",
    "enhanced_sentence": "When the server includes an \"early_data\" extension in its ServerHello message, indicating acceptance of 0-RTT data, the client MUST verify that the server's selected_identity in the \"pre_shared_key\" extension is exactly 0. This rule applies during the TLS 1.3 handshake after the server has responded to the client's ClientHello, which included both \"pre_shared_key\" and \"early_data\" extensions. The expected outcome is that the client confirms the server has selected the first PSK identity from the client's offered list (index 0), which is the identity explicitly associated with 0-RTT data. If the selected_identity is any value other than 0, the client MUST immediately abort the handshake with an \"illegal_parameter\" alert. This requirement ensures consistency between the PSK used for handshake resumption and the one intended for early data transmission, maintaining security and protocol integrity.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension\"\nRule: If the server supplies an \"early_data\" extension, the client MUST verify that the server's selected_identity is 0.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension",
    "sentence": "Clients MUST verify that the server's selected_identity is within the range supplied by the client, that the server selected a cipher suite indicating a Hash associated with the PSK, and that a server \"key_share\" extension is present if required by the ClientHello \"psk_key_exchange_modes\" extension.",
    "enhanced_sentence": "When processing the server's \"pre_shared_key\" extension in response to a ClientHello containing PSK identities, the client MUST perform the following verifications to ensure a secure and consistent handshake: (1) The server's selected_identity must be a valid index (0-based) within the list of identities offered by the client; (2) The server must have selected a cipher suite whose associated Hash algorithm matches the one bound to the chosen PSK (e.g., for resumption PSKs, the Hash from the original connection; for external PSKs, the pre-established or default SHA-256 Hash); and (3) If the client included a \"psk_key_exchange_modes\" extension indicating that a key exchange is required (e.g., \"psk_dhe_ke\"), the server must provide a \"key_share\" extension. These checks apply after the server has selected a PSK and sent its ServerHello. If any verification fails, the client MUST immediately abort the handshake with an \"illegal_parameter\" alert to prevent inconsistent or insecure state negotiation.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.11. Pre-Shared Key Extension\"\nRule: Clients MUST verify that the server's selected_identity is within the range supplied by the client, that the server selected a cipher suite indicating a Hash associated with the PSK, and that a server \"key_share\" extension is present if required by the ClientHello \"psk_key_exchange_modes\" extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.4. Receiving a Certificate Message",
    "sentence": "Any endpoint receiving any certificate which it would need to validate using any signature algorithm using an MD5 hash MUST abort the handshake with a \"bad_certificate\" alert.",
    "enhanced_sentence": "During the TLS 1.3 handshake, when an endpoint (client or server) receives a certificate that it must validate—meaning the certificate is part of a chain requiring signature verification, excluding self-signed certificates or trust anchors—and that validation would rely on any signature algorithm utilizing an MD5 hash, the endpoint MUST immediately abort the handshake by sending a \"bad_certificate\" alert. This rule applies upon processing the Certificate message and is mandatory due to known vulnerabilities in MD5. Note that this requirement does not apply to certificates that are trust anchors or self-signed, as they do not require chain validation.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.4. Receiving a Certificate Message\"\nRule: Any endpoint receiving any certificate which it would need to validate using any signature algorithm using an MD5 hash MUST abort the handshake with a \"bad_certificate\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.4. Receiving a Certificate Message",
    "sentence": "SHA-1 is deprecated, and it is RECOMMENDED that any endpoint receiving any certificate which it would need to validate using any signature algorithm using a SHA-1 hash abort the handshake with a \"bad_certificate\" alert.",
    "enhanced_sentence": "During the TLS 1.3 handshake, when an endpoint receives a certificate message that requires validation using a signature algorithm that employs a SHA-1 hash (except for self-signed certificates or trust anchors), it is RECOMMENDED to abort the handshake with a \"bad_certificate\" alert. This applies to both client and server endpoints during certificate chain validation, as SHA-1 is considered deprecated and insecure. The endpoint should transition to using SHA-256 or stronger hashing algorithms to ensure interoperability and security. Note that this rule does not apply if the certificate is a trust anchor or self-signed, where SHA-1 may still be accepted.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.4. Receiving a Certificate Message\"\nRule: SHA-1 is deprecated, and it is RECOMMENDED that any endpoint receiving any certificate which it would need to validate using any signature algorithm using a SHA-1 hash abort the handshake with a \"bad_certificate\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.4. Receiving a Certificate Message",
    "sentence": "Note that a certificate containing a key for one signature algorithm MAY be signed using a different signature algorithm (for instance, an RSA key signed with an ECDSA key).",
    "enhanced_sentence": "When receiving a Certificate message, endpoints MUST be prepared to handle certificates where the signature algorithm used to sign the certificate differs from the signature algorithm associated with the public key contained within the certificate. For example, a certificate containing an RSA public key MAY be signed using an ECDSA signature algorithm. This flexibility is permitted to accommodate diverse PKI hierarchies and cross-algorithm certificate issuance practices. Endpoints MUST correctly validate such certificates according to the signature algorithm indicated in the certificate's signature field, regardless of the key type, provided all other validation criteria (e.g., trusted CA, hash algorithm restrictions) are met. This rule applies during certificate chain validation, which occurs after receiving the Certificate message and before proceeding with the handshake.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.4. Receiving a Certificate Message\"\nRule: Note that a certificate containing a key for one signature algorithm MAY be signed using a different signature algorithm (for instance, an RSA key signed with an ECDSA key).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.5. End of Early Data",
    "sentence": "If the server does not send an \"early_data\" extension in EncryptedExtensions, then the client MUST NOT send an EndOfEarlyData message.",
    "enhanced_sentence": "During the TLS 1.3 handshake, if the server does not include an \"early_data\" extension in its EncryptedExtensions message, it indicates that the server has not accepted 0-RTT (Zero-Round-Trip-Time) early data. In this case, the client MUST NOT send an EndOfEarlyData message. This rule applies after the client receives the server's Finished message and before transitioning to handshake traffic keys. Adherence ensures proper synchronization of encryption states and prevents protocol errors, as the EndOfEarlyData message is only valid when 0-RTT data was negotiated and must be encrypted under the client_early_traffic_secret. Violating this requirement may cause the server to terminate the connection with an \"unexpected_message\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.5. End of Early Data\"\nRule: If the server does not send an \"early_data\" extension in EncryptedExtensions, then the client MUST NOT send an EndOfEarlyData message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.5. End of Early Data",
    "sentence": "If the server sent an \"early_data\" extension in EncryptedExtensions, the client MUST send an EndOfEarlyData message after receiving the server Finished.",
    "enhanced_sentence": "This rule governs the client's obligation to signal the end of 0-RTT data transmission when early data has been negotiated. The rule applies specifically when the server includes an \"early_data\" extension in its EncryptedExtensions message during the TLS 1.3 handshake, indicating acceptance of early data. After receiving the server's Finished message, the client MUST send an EndOfEarlyData message to formally conclude the early data phase. This message serves as a cryptographic boundary, indicating that all 0-RTT application_data messages have been transmitted and subsequent records will be protected under handshake traffic keys rather than early data keys. The EndOfEarlyData message must be encrypted using keys derived from the client_early_traffic_secret. If the server does not send an \"early_data\" extension, the client MUST NOT send this message. Note that servers are prohibited from sending EndOfEarlyData messages, and clients receiving such messages must terminate the connection with an \"unexpected_message\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.5. End of Early Data\"\nRule: If the server sent an \"early_data\" extension in EncryptedExtensions, the client MUST send an EndOfEarlyData message after receiving the server Finished.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.5. End of Early Data",
    "sentence": "Servers MUST NOT send the EndOfEarlyData message, and clients receiving the EndOfEarlyData message MUST terminate the connection with an \"unexpected_message\" alert.",
    "enhanced_sentence": "The EndOfEarlyData message is exclusively sent by clients to indicate the completion of 0-RTT data transmission and the transition to handshake traffic keys. This rule applies only when the server has accepted early data by including an \"early_data\" extension in EncryptedExtensions. Servers MUST NOT send the EndOfEarlyData message under any circumstances, as it is a client-only message. If a client receives an EndOfEarlyData message from a server, it MUST treat this as a protocol violation and immediately terminate the connection with an \"unexpected_message\" alert. This ensures proper protocol flow and prevents potential security issues arising from incorrect message sequencing.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.5. End of Early Data\"\nRule: Servers MUST NOT send the EndOfEarlyData message, and clients receiving the EndOfEarlyData message MUST terminate the connection with an \"unexpected_message\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.2. Server Certificate Selection",
    "sentence": "The following rules apply to the certificates sent by the server: The certificate type MUST be X.509v3 as specified in RFC5280 Profile, unless explicitly negotiated otherwise, such as with RFC7250 and Datagram Transport Layer Security (DTLS).",
    "enhanced_sentence": "This rule governs the server's certificate type selection during the TLS 1.3 handshake, specifically in the Certificate message. It applies when the server is providing its certificate chain for authentication, following the client's CertificateRequest and prior to the CertificateVerify message. The server MUST use X.509v3 certificates as defined in RFC5280, unless an alternative certificate type (such as Raw Public Keys per RFC7250, particularly relevant for DTLS or constrained environments) has been explicitly negotiated during the handshake. Adherence ensures interoperability with standard client implementations and proper chain validation. This requirement is conditional on the absence of prior explicit negotiation for alternative certificate types and assumes the handshake has progressed to the authentication phase where certificate exchange is required.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.2. Server Certificate Selection\"\nRule: The following rules apply to the certificates sent by the server: The certificate type MUST be X.509v3 as specified in RFC5280 Profile, unless explicitly negotiated otherwise, such as with RFC7250 and Datagram Transport Layer Security (DTLS).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.2. Server Certificate Selection",
    "sentence": "The server_name extension as defined in RFC6066 and the certificate_authorities extension are used to guide certificate selection.",
    "enhanced_sentence": "During the TLS 1.3 handshake, when the server is selecting which certificate to present to the client, it MUST use the server_name extension (from RFC6066) to match the requested hostname and the certificate_authorities extension to identify acceptable certificate issuers. This rule applies after the ClientHello is received and before the server sends its Certificate message. The expected outcome is that the server selects a certificate chain that aligns with the client's indicated server name preferences and trusted certificate authorities, thereby increasing the likelihood of successful authentication. This guidance is conditional upon the client including these extensions in its ClientHello message; if absent, the server relies on other selection criteria such as local configuration and transport-layer endpoint.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.2. Server Certificate Selection\"\nRule: The server_name extension as defined in RFC6066 and the certificate_authorities extension are used to guide certificate selection.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.2. Server Certificate Selection",
    "sentence": "The certificate MUST allow the key to be used for signing, meaning the digitalSignature bit MUST be set if the Key Usage extension is present, with a signature scheme indicated in the client's signature_algorithms or signature_algorithms_cert extensions as described in Section 4.2.3.",
    "enhanced_sentence": "During the TLS 1.3 handshake, when the server selects a certificate to send to the client in response to the client's signature_algorithms or signature_algorithms_cert extensions (as detailed in Section 4.2.3), the server MUST ensure that the certificate's public key is explicitly authorized for signing. Specifically, if the certificate includes a Key Usage extension, the digitalSignature bit MUST be set. This requirement applies only when the server is providing a certificate chain that is not self-signed or a trust anchor, and it ensures that the selected certificate is compatible with one of the client-advertised signature schemes (e.g., RSA, ECDSA, or EdDSA). Adherence to this rule enables proper authentication and prevents handshake failures due to incompatible or improperly configured certificates.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.2. Server Certificate Selection\"\nRule: The certificate MUST allow the key to be used for signing, meaning the digitalSignature bit MUST be set if the Key Usage extension is present, with a signature scheme indicated in the client's signature_algorithms or signature_algorithms_cert extensions as described in Section 4.2.3.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.2. Server Certificate Selection",
    "sentence": "As servers MAY require the presence of the \"server_name\" extension, clients SHOULD send this extension, when applicable.",
    "enhanced_sentence": "During the TLS 1.3 handshake, when the server is selecting a certificate to present to the client, it may rely on the client-provided \"server_name\" extension (RFC6066) to identify the intended server and choose an appropriate certificate. Therefore, clients SHOULD include the \"server_name\" extension in the ClientHello message when connecting to a server identified by a domain name, unless the connection is made by raw IP address. This rule applies during the initial handshake phase, before certificate transmission, and ensures that the server can accurately select a certificate that matches the client’s expected service. The expected outcome is improved interoperability and correct certificate selection, reducing the risk of handshake failures due to mismatched certificates. Note that this guidance is conditional on the client having a specific server name to indicate; it does not apply to anonymous or raw IP-based connections.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.2. Server Certificate Selection\"\nRule: As servers MAY require the presence of the \"server_name\" extension, clients SHOULD send this extension, when applicable.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.2. Server Certificate Selection",
    "sentence": "The server's end-entity certificate's public key and associated restrictions MUST be compatible with the selected authentication algorithm from the client's signature_algorithms extension, which currently includes RSA, ECDSA, or EdDSA.",
    "enhanced_sentence": "During the TLS 1.3 handshake, when the server selects and sends its certificate chain in response to the client's CertificateRequest, the server's end-entity certificate MUST be compatible with the authentication algorithm chosen from the client's signature_algorithms extension (which currently supports RSA, ECDSA, or EdDSA). This means the certificate's public key type and any associated usage restrictions (e.g., Key Usage extension with the digitalSignature bit set) must align with the selected signature scheme. This rule applies after the client has advertised supported algorithms and before the server sends its Certificate message. Adherence ensures that the client can validate the server's signature correctly, maintaining protocol integrity. Prerequisites include the client having sent the signature_algorithms extension, and the server having a valid certificate that meets these criteria. If no compatible certificate is available, the server may send an alternative chain, but it should avoid deprecated algorithms like SHA-1 unless explicitly permitted by the client.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.2. Server Certificate Selection\"\nRule: The server's end-entity certificate's public key and associated restrictions MUST be compatible with the selected authentication algorithm from the client's signature_algorithms extension, which currently includes RSA, ECDSA, or EdDSA.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.2. Server Certificate Selection",
    "sentence": "All certificates provided by the server MUST be signed by a signature algorithm advertised by the client if the server is able to provide such a chain, as described in Section 4.2.3.",
    "enhanced_sentence": "When the server selects and provides a certificate chain during the TLS 1.3 handshake, it MUST ensure that all certificates in the chain (excluding self-signed or trust anchor certificates) are signed using a signature algorithm that the client has advertised as supported in its `signature_algorithms` or `signature_algorithms_cert` extensions, provided the server has such a chain available. This requirement applies only if the server is capable of supplying a chain that complies with the client’s advertised algorithms. If no such chain is available, the server MAY proceed by sending an alternative chain, but SHOULD avoid deprecated algorithms like SHA-1 unless explicitly permitted by the client. This rule ensures cryptographic compatibility and supports secure, interoperable certificate validation, as further detailed in Section 4.2.3.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.2. Server Certificate Selection\"\nRule: All certificates provided by the server MUST be signed by a signature algorithm advertised by the client if the server is able to provide such a chain, as described in Section 4.2.3.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.2. Server Certificate Selection",
    "sentence": "Certificates that are self-signed or certificates that are expected to be trust anchors are not validated as part of the chain and therefore MAY be signed with any algorithm.",
    "enhanced_sentence": "During server certificate selection in TLS 1.3, certificates that are self-signed or are intended to be trust anchors (such as root certificates included for client convenience) are exempt from signature algorithm validation requirements. This exemption applies because these certificates are not validated as part of the certificate chain during the handshake—they are either the root of trust or are presented for informational purposes. Consequently, such certificates MAY be signed using any signature algorithm, regardless of the algorithms advertised by the client in the signature_algorithms or signature_algorithms_cert extensions. This rule applies when the server is constructing its certificate message and must be followed to ensure interoperability when including trust anchors or self-signed certificates. The expected outcome is that these certificates are accepted without signature validation, allowing greater flexibility in certificate presentation while maintaining security through the validation of the remainder of the chain.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.2. Server Certificate Selection\"\nRule: Certificates that are self-signed or certificates that are expected to be trust anchors are not validated as part of the chain and therefore MAY be signed with any algorithm.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.2. Server Certificate Selection",
    "sentence": "If the client cannot construct an acceptable chain using the provided certificates and decides to abort the handshake, then the client MUST abort the handshake with an appropriate certificate-related alert, such as unsupported_certificate by default, as detailed in Section 6.2.",
    "enhanced_sentence": "This rule governs the client's behavior when it is unable to validate the server's certificate chain during the TLS 1.3 handshake. It applies after the server has sent its Certificate message, and the client has attempted to construct a valid chain from the provided certificates to a trusted root, considering constraints such as the client's signature_algorithms extension, server_name indication, and certificate_authorities. If the client determines that the chain is unacceptable—for example, due to missing trust anchors, unsupported signature algorithms (unless self-signed or a trust anchor), or incompatible key usage—and opts to terminate the connection, it MUST send a certificate-related alert (like unsupported_certificate) to abort the handshake cleanly, as specified in Section 6.2, rather than proceeding or failing silently. This ensures both parties are aware of the certificate validation failure and the reason for handshake termination.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.2. Server Certificate Selection\"\nRule: If the client cannot construct an acceptable chain using the provided certificates and decides to abort the handshake, then the client MUST abort the handshake with an appropriate certificate-related alert, such as unsupported_certificate by default, as detailed in Section 6.2.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.2. Server Certificate Selection",
    "sentence": "If the server cannot produce a certificate chain that is signed only via the indicated supported algorithms, then the server SHOULD continue the handshake by sending the client a certificate chain of its choice that may include algorithms not known to be supported by the client.",
    "enhanced_sentence": "This rule governs server behavior during the TLS 1.3 handshake when the server is unable to provide a certificate chain that strictly adheres to the client's advertised signature algorithms. It applies during the Certificate message transmission phase, after the server has processed the client's signature_algorithms and signature_algorithms_cert extensions. The rule takes effect only if the server cannot construct a chain where all certificates (except trust anchors or self-signed certificates) are signed using algorithms indicated as supported by the client. In such cases, the server SHOULD proceed by sending an alternative certificate chain that may include algorithms not explicitly supported by the client, while still complying with other certificate requirements (X.509v3 format, key usage restrictions, etc.). This fallback chain MUST avoid using the deprecated SHA-1 hash algorithm unless explicitly permitted by the client's advertisement. The expected outcome is that the handshake continues, allowing the client to evaluate the provided chain; if the client cannot validate it, the client MUST abort with an appropriate certificate-related alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate -> 4.4.2.2. Server Certificate Selection\"\nRule: If the server cannot produce a certificate chain that is signed only via the indicated supported algorithms, then the server SHOULD continue the handshake by sending the client a certificate chain of its choice that may include algorithms not known to be supported by the client.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication",
    "sentence": "If the client opts to do so, it MUST supply both the \"pre_shared_key\" and \"early_data\" extensions.",
    "enhanced_sentence": "When a client opts to send 0-RTT early data in its first flight of messages, it MUST supply both the \"pre_shared_key\" and \"early_data\" extensions in the ClientHello. This rule applies only when the client is using a PSK that allows early data and chooses to take advantage of 0-RTT resumption. The expected outcome is that the server, upon receiving both extensions, can validate and process the early data if all associated parameters (TLS version, cipher suite, ALPN, etc.) match those tied to the PSK. Prerequisites include: the PSK must support early data, the client must list the intended PSK first in the \"pre_shared_key\" extension, and the client must ensure that the early data parameters align exactly with those negotiated or provisioned for the PSK. Failure to include both extensions when sending early data is a protocol violation and may result in connection failure or fallback to a full handshake.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication\"\nRule: If the client opts to do so, it MUST supply both the \"pre_shared_key\" and \"early_data\" extensions.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication",
    "sentence": "The \"extension_data\" field of this extension contains an \"EarlyDataIndication\" value.",
    "enhanced_sentence": "When a client opts to send early data (0-RTT) in its first flight using a PSK that permits early data, it MUST include both the \"pre_shared_key\" and \"early_data\" extensions in the ClientHello. The \"extension_data\" field of the \"early_data\" extension MUST contain an \"EarlyDataIndication\" value, which for ClientHello is an empty structure (as defined in Section 4.6.1). This rule applies only if the server has previously indicated support for early data via a \"max_early_data_size\" value in a NewSessionTicket or external provisioning. The expected outcome is that the server, upon receiving this extension, will evaluate whether to accept, ignore, or request a retry of the early data based on PSK validity, ticket age, and parameter consistency (TLS version, cipher suite, ALPN). If accepted, the server responds with an \"early_data\" extension in EncryptedExtensions; if rejected, the client may retransmit application data post-handshake only under matching negotiated conditions.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication\"\nRule: The \"extension_data\" field of this extension contains an \"EarlyDataIndication\" value.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication",
    "sentence": "After receiving the server's Finished message, if the server has accepted early data, an EndOfEarlyData message will be sent to indicate the key change.",
    "enhanced_sentence": "After receiving the server's Finished message, if the server has accepted early data by including the \"early_data\" extension in its EncryptedExtensions and the client has sent 0-RTT data in the first flight, the client MUST send an EndOfEarlyData message encrypted with the 0-RTT traffic keys to signal the transition from early data encryption keys to the new handshake traffic keys. This key change indication is required to maintain cryptographic separation between early data and subsequent application data, and it occurs immediately before the client proceeds with the remainder of the handshake or application data exchange.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication\"\nRule: After receiving the server's Finished message, if the server has accepted early data, an EndOfEarlyData message will be sent to indicate the key change.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication",
    "sentence": "A client MUST NOT include the \"early_data\" extension in its followup ClientHello.",
    "enhanced_sentence": "When a server responds to a ClientHello containing an \"early_data\" extension with a HelloRetryRequest, the client MUST NOT include the \"early_data\" extension in the followup ClientHello. This rule applies specifically to the scenario where 0-RTT data was attempted but rejected by the server via a retry request. The expected outcome is that the client falls back to a standard 1-RTT or 2-RTT handshake without attempting to send early data again. This rule is conditional on the server having previously indicated rejection of early data through the HelloRetryRequest mechanism.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication\"\nRule: A client MUST NOT include the \"early_data\" extension in its followup ClientHello.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication",
    "sentence": "The PSK used to encrypt the early data MUST be the first PSK listed in the client's \"pre_shared_key\" extension.",
    "enhanced_sentence": "When a client opts to send early data (0-RTT) in TLS 1.3, it MUST supply both the \"pre_shared_key\" and \"early_data\" extensions in the ClientHello. The PSK used to encrypt the early data MUST be the first PSK listed in the client's \"pre_shared_key\" extension. This rule applies only if the server has previously indicated that early data is allowed for that PSK (e.g., via max_early_data_size in a NewSessionTicket). The expected outcome is that the server, when accepting early data, will select this first PSK identity and validate that the associated connection parameters (TLS version, cipher suite, and ALPN protocol) match those negotiated when the PSK was established. If the client lists multiple PSKs, only the first one is eligible for 0-RTT encryption; any other PSKs in the list are considered for 1-RTT resumption only.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication\"\nRule: The PSK used to encrypt the early data MUST be the first PSK listed in the client's \"pre_shared_key\" extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication",
    "sentence": "The EarlyDataIndication structure is defined with different cases for handshake message types: for new_session_ticket it contains a max_early_data_size field, while for client_hello and encrypted_extensions it contains an empty structure.",
    "enhanced_sentence": "The EarlyDataIndication structure is defined with different cases for handshake message types to support 0-RTT (zero round-trip time) data transmission when using a pre-shared key (PSK). This rule applies during the TLS 1.3 handshake protocol when early data is negotiated. For new_session_ticket messages, the structure contains a max_early_data_size field that specifies the maximum amount of early data the client is permitted to send when using the associated PSK. For client_hello and encrypted_extensions messages, the structure contains an empty body, serving as a signal that early data is being offered (by the client) or accepted (by the server). The expected outcome is proper coordination of 0-RTT data capabilities between client and server, enabling reduced latency for resumed sessions. Prerequisites include: both parties must support the PSK and early data extension; the client must list the PSK first in its pre_shared_key extension; and all associated connection parameters (TLS version, cipher suite, ALPN protocol) must match those from the original session where the PSK was established.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication\"\nRule: The EarlyDataIndication structure is defined with different cases for handshake message types: for new_session_ticket it contains a max_early_data_size field, while for client_hello and encrypted_extensions it contains an empty structure.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication",
    "sentence": "For PSKs provisioned via NewSessionTicket, a server MUST validate that the ticket age for the selected PSK identity (computed by subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32) is within a small tolerance of the time since the ticket was issued (see Section 8).",
    "enhanced_sentence": "When a client attempts to use a PSK provisioned via NewSessionTicket for 0-RTT early data in TLS 1.3, the server MUST validate that the ticket age (computed by subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32) is within a small tolerance of the actual time elapsed since the ticket was issued (see Section 8 for tolerance details). This validation applies during the processing of the ClientHello message when the client includes both \"pre_shared_key\" and \"early_data\" extensions, and specifically when the server is considering accepting 0-RTT data. The expected outcome is that if the ticket age exceeds the tolerance window, the server SHOULD proceed with the handshake but reject 0-RTT data and SHOULD NOT treat the ClientHello as fresh. This rule is a prerequisite for ensuring replay protection and only applies to PSKs established via NewSessionTicket, not externally provisioned PSKs.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication\"\nRule: For PSKs provisioned via NewSessionTicket, a server MUST validate that the ticket age for the selected PSK identity (computed by subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32) is within a small tolerance of the time since the ticket was issued (see Section 8).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication",
    "sentence": "A server which receives an \"early_data\" extension MUST behave in one of three ways: Ignore the extension and return a regular 1-RTT response.",
    "enhanced_sentence": "When a server receives an \"early_data\" extension in a ClientHello message, it MUST select one of three behaviors: Ignore the extension and proceed with a regular 1-RTT handshake response. This option applies when the server cannot or chooses not to process early data, such as when the PSK-associated parameters (TLS version, cipher suite, ALPN) do not match, the ticket age is outside tolerance, or the server is configured to reject 0-RTT. In this case, the server skips past early data by attempting trial decryption of received records using handshake traffic keys (discarding undecryptable records up to max_early_data_size), then processes the first successfully decrypted record as the start of the client’s second flight. This ensures fallback to a standard 1-RTT handshake without accepting potentially invalid or replayed early data.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication\"\nRule: A server which receives an \"early_data\" extension MUST behave in one of three ways: Ignore the extension and return a regular 1-RTT response.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication",
    "sentence": "If the ticket age is not within tolerance, the server SHOULD proceed with the handshake but reject 0-RTT, and SHOULD NOT take any other action that assumes that this ClientHello is fresh.",
    "enhanced_sentence": "When processing a ClientHello that includes an \"early_data\" extension for 0-RTT data transmission using a PSK established via a NewSessionTicket, the server MUST validate that the ticket age (computed by subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age modulo 2^32) is within a small tolerance of the time since the ticket was issued. If the ticket age is not within tolerance, indicating potential clock skew or replay risk, the server SHOULD proceed with the handshake (allowing 1-RTT or 2-RTT completion) but reject 0-RTT by not including the \"early_data\" extension in its EncryptedExtensions and skipping early data records. Additionally, the server SHOULD NOT take any other action that assumes this ClientHello is fresh (e.g., basing cryptographic decisions on its timeliness beyond the handshake flow). This rule applies only when the server is using a PSK from a NewSessionTicket and early data is attempted; it ensures continued connection progress while mitigating replay risks associated with stale tickets.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication\"\nRule: If the ticket age is not within tolerance, the server SHOULD proceed with the handshake but reject 0-RTT, and SHOULD NOT take any other action that assumes that this ClientHello is fresh.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication",
    "sentence": "Return its own \"early_data\" extension in EncryptedExtensions, indicating that it intends to process the early data.",
    "enhanced_sentence": "When a server receives a ClientHello containing both \"pre_shared_key\" and \"early_data\" extensions and decides to accept the client's 0-RTT data, it MUST include its own \"early_data\" extension in the EncryptedExtensions message. This rule applies only if the server has accepted a PSK cipher suite, selected the first key from the client's \"pre_shared_key\" extension, and verified that the TLS version, cipher suite, and ALPN protocol match those associated with the selected PSK. The extension indicates the server's intent to fully process the in-flight early data under the 0-RTT traffic keys. If any of these conditions are not met, the server MUST NOT include this extension and must instead ignore the early data or request a HelloRetryRequest.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication\"\nRule: Return its own \"early_data\" extension in EncryptedExtensions, indicating that it intends to process the early data.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication",
    "sentence": "In order to accept early data, the server MUST have accepted a PSK cipher suite and selected the first key offered in the client's \"pre_shared_key\" extension.",
    "enhanced_sentence": "When processing a ClientHello containing an \"early_data\" extension, the server MUST only accept 0-RTT early data if it has both accepted a pre-shared key (PSK) cipher suite and selected the first PSK offered in the client's \"pre_shared_key\" extension. This rule applies during the handshake negotiation phase when the server is evaluating whether to enable early data processing. The expected outcome is that the server confirms the PSK used for early data encryption matches the first identity in the client’s list, ensuring consistency with the client’s intended key selection. Prerequisites include the server supporting PSK-based resumption, successful validation of the PSK’s associated parameters (TLS version, cipher suite, and ALPN protocol), and adherence to the ticket age tolerance checks for NewSessionTicket-based PSKs. If these conditions are not met, the server MUST reject early data and proceed with a standard 1-RTT or 2-RTT handshake.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication\"\nRule: In order to accept early data, the server MUST have accepted a PSK cipher suite and selected the first key offered in the client's \"pre_shared_key\" extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication",
    "sentence": "In addition, the server MUST verify that the following values are the same as those associated with the selected PSK: The TLS version number, the selected cipher suite, and the selected ALPN protocol if any.",
    "enhanced_sentence": "When a server accepts early data by including the \"early_data\" extension in its EncryptedExtensions message, it MUST verify that the following parameters match those associated with the selected PSK (which must be the first PSK in the client's \"pre_shared_key\" extension): the TLS version number, the selected cipher suite, and the selected ALPN protocol (if any). This verification applies during the processing of the client's first flight in a 0-RTT handshake and ensures that the cryptographic context used for early data decryption aligns with the parameters originally negotiated or provisioned for that PSK. If any of these values differ, the server MUST NOT accept early data and must discard all first-flight data using fallback mechanisms (either ignoring the extension or issuing a HelloRetryRequest), as proceeding with mismatched parameters would compromise security and protocol integrity.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication\"\nRule: In addition, the server MUST verify that the following values are the same as those associated with the selected PSK: The TLS version number, the selected cipher suite, and the selected ALPN protocol if any.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.2. Post-Handshake Authentication",
    "sentence": "If the client declines, the client MUST send a Certificate message containing no certificates followed by a Finished message.",
    "enhanced_sentence": "When a server requests post-handshake client authentication via a CertificateRequest message (after the client has previously indicated support via the \"post_handshake_auth\" extension), and the client chooses to decline authentication, the client MUST respond by sending a Certificate message containing no certificates (i.e., with certificates list of length zero) immediately followed by a Finished message. These two messages MUST be sent consecutively without any intervening messages. This response signals the server that the client is explicitly declining to authenticate while still maintaining protocol continuity and cryptographic integrity.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.2. Post-Handshake Authentication\"\nRule: If the client declines, the client MUST send a Certificate message containing no certificates followed by a Finished message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication",
    "sentence": "Specifically, if the server fails to decrypt a 0-RTT record following an accepted \"early_data\" extension, it MUST terminate the connection with a \"bad_record_mac\" alert as per Section 5.2.",
    "enhanced_sentence": "When a server has accepted the \"early_data\" extension in the EncryptedExtensions message (indicating it will process 0-RTT data), it must strictly validate the integrity and authenticity of all early data records. This rule applies after the server has verified and accepted the PSK, cipher suite, TLS version, and ALPN protocol associated with the early data. If the server is unable to decrypt any 0-RTT record—indicating a potential integrity failure, replay attack, or corrupted data—it MUST immediately terminate the connection by sending a \"bad_record_mac\" alert as specified in Section 5.2. This ensures that any tampering or errors in early data are treated as a fatal protocol violation, preventing insecure or inconsistent state progression.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication\"\nRule: Specifically, if the server fails to decrypt a 0-RTT record following an accepted \"early_data\" extension, it MUST terminate the connection with a \"bad_record_mac\" alert as per Section 5.2.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.2. Post-Handshake Authentication",
    "sentence": "If the client chooses to authenticate, the client MUST send Certificate, CertificateVerify, and Finished messages.",
    "enhanced_sentence": "When a server requests client authentication via a CertificateRequest message after the handshake has completed, and the client has previously indicated support by including the \"post_handshake_auth\" extension, the client MUST respond with a set of consecutive messages. If the client chooses to authenticate, it MUST send Certificate, CertificateVerify, and Finished messages in immediate succession without any intervening messages of other types. This ensures the server can verify the client's identity and the integrity of the post-handshake exchange. If the client declines to authenticate, it MUST instead send a Certificate message with no certificates followed by a Finished message. Note that this rule only applies if the client had advertised the \"post_handshake_auth\" extension; otherwise, the client MUST respond with an \"unexpected_message\" fatal alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.2. Post-Handshake Authentication\"\nRule: If the client chooses to authenticate, the client MUST send Certificate, CertificateVerify, and Finished messages.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication",
    "sentence": "Future extensions MUST define their interaction with 0-RTT.",
    "enhanced_sentence": "When defining new TLS extensions that may be used in conjunction with 0-RTT data transmission, extension specifications MUST explicitly define how the extension interacts with the 0-RTT handshake mode. This rule applies during the extension design phase and requires that the specification document clearly addresses: whether the extension can be used in 0-RTT contexts, how its parameters are negotiated when early data is present, and any special handling required when the extension appears in ClientHello messages containing early data. The expected outcome is that implementations can properly process the extension in both 0-RTT and full handshake scenarios without ambiguity. This requirement is conditional on the extension being potentially usable in connections where 0-RTT data might be sent or received, and ensures that future extensions maintain the security and interoperability properties of the 0-RTT mechanism.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication\"\nRule: Future extensions MUST define their interaction with 0-RTT.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication",
    "sentence": "If the server chooses to accept the \"early_data\" extension, then it MUST comply with the same error-handling requirements specified for all records when processing early data records.",
    "enhanced_sentence": "When a server accepts the \"early_data\" extension by including it in its EncryptedExtensions message, it commits to processing the client's 0-RTT data records. In this scenario, the server MUST apply the same error-handling requirements as for all other TLS records: specifically, if decryption of any early data record fails (e.g., due to a bad record MAC), the server MUST terminate the connection immediately with a \"bad_record_mac\" alert as specified in Section 5.2. This rule applies only after the server has validated all prerequisites for accepting early data, including using the correct PSK, confirming matching TLS version, cipher suite, and ALPN protocol, and ensuring the ticket age is within tolerance. The expected outcome is consistent security handling—early data must not be silently ignored or skipped once accepted, preserving protocol integrity against certain attacks.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication\"\nRule: If the server chooses to accept the \"early_data\" extension, then it MUST comply with the same error-handling requirements specified for all records when processing early data records.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.2. Post-Handshake Authentication",
    "sentence": "When the client has sent the \"post_handshake_auth\" extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message.",
    "enhanced_sentence": "This rule governs the server's ability to initiate post-handshake client authentication in TLS 1.3. It applies only when the client has previously indicated support by including the \"post_handshake_auth\" extension during the initial handshake (as defined in Section 4.2.6). After the handshake completes, the server MAY send a CertificateRequest message at any time to request client authentication. The client MUST respond with either: (1) Certificate, CertificateVerify, and Finished messages if authenticating, or (2) an empty Certificate message followed by Finished if declining. All response messages must be sent consecutively without interruption. If the client did not send the \"post_handshake_auth\" extension, it MUST respond with an \"unexpected_message\" fatal alert. Servers should account for potential delays in client response due to user interaction and handle possible out-of-order responses when multiple requests are sent (using certificate_request_context for disambiguation).",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.2. Post-Handshake Authentication\"\nRule: When the client has sent the \"post_handshake_auth\" extension (see Section 4.2.6), a server MAY request client authentication at any time after the handshake has completed by sending a CertificateRequest message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.2. Post-Handshake Authentication",
    "sentence": "A client that receives a CertificateRequest message without having sent the \"post_handshake_auth\" extension MUST send an \"unexpected_message\" fatal alert.",
    "enhanced_sentence": "In the TLS 1.3 protocol, post-handshake authentication is only permitted if the client has previously indicated support by including the \"post_handshake_auth\" extension during the initial handshake. If a client receives a CertificateRequest message from the server without having sent this extension, it indicates a protocol violation, as the server is attempting to request authentication in an unsupported context. The client MUST respond by immediately terminating the connection with an \"unexpected_message\" fatal alert. This rule applies at any point after the handshake has completed and ensures that clients only engage in post-handshake authentication when they have explicitly advertised capability, maintaining protocol integrity and preventing unsolicited authentication requests.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.2. Post-Handshake Authentication\"\nRule: A client that receives a CertificateRequest message without having sent the \"post_handshake_auth\" extension MUST send an \"unexpected_message\" fatal alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "The client MUST send a Certificate message if and only if the server has requested client authentication via a CertificateRequest message (Section 4.3.2).",
    "enhanced_sentence": "The client MUST send a Certificate message if and only if the server has explicitly requested client authentication via a CertificateRequest message (Section 4.3.2). This rule governs the conditional transmission of client certificates during the TLS 1.3 handshake and applies immediately after the server's CertificateRequest message in the protocol flow. When followed, the expected outcome is that the client provides its certificate chain for server validation, enabling mutual authentication. If no suitable certificate is available, the client MUST still send a Certificate message with an empty certificate_list (zero-length), but MUST proceed to send a Finished message regardless. Prerequisites include successful negotiation of a certificate-based key exchange method and proper handling of the certificate_request_context field, which must match the value from the server's CertificateRequest.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: The client MUST send a Certificate message if and only if the server has requested client authentication via a CertificateRequest message (Section 4.3.2).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication",
    "sentence": "If any of these checks fail, the server MUST NOT respond with the extension and must discard all the first-flight data using one of the first two mechanisms listed above (thus falling back to 1-RTT or 2-RTT).",
    "enhanced_sentence": "When a server receives an \"early_data\" extension in a ClientHello message and is considering accepting 0-RTT early data, it MUST first validate that the selected PSK cipher suite is accepted, the first key in the client's \"pre_shared_key\" extension is chosen, and the TLS version, cipher suite, and ALPN protocol (if any) match those associated with the PSK. If any of these checks fail, the server MUST NOT include the \"early_data\" extension in its EncryptedExtensions response. Instead, it MUST discard all received first-flight data by either: (1) skipping past early data using trial decryption with handshake traffic keys (falling back to 1-RTT), or (2) ignoring encrypted application_data records and potentially requesting a HelloRetryRequest (falling back to 2-RTT). This ensures that the server does not process potentially incompatible or replayed 0-RTT data and maintains handshake integrity.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.10. Early Data Indication\"\nRule: If any of these checks fail, the server MUST NOT respond with the extension and must discard all the first-flight data using one of the first two mechanisms listed above (thus falling back to 1-RTT or 2-RTT).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK).",
    "enhanced_sentence": "The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK). This rule applies during the handshake phase after the server has sent its ServerHello and EncryptedExtensions messages, and before sending the CertificateVerify message. The expected outcome is that the server provides its certificate chain to the client for authentication purposes. This rule is conditional upon the negotiated key exchange method requiring certificate-based authentication (such as RSA, ECDHE_RSA, ECDHE_ECDSA, or DHE_RSA). The server's certificate_list MUST always be non-empty and properly structured, with the server's own certificate first in the chain, followed by any intermediate certificates. The certificate_request_context field SHALL be zero length for server authentication.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: The server MUST send a Certificate message whenever the agreed-upon key exchange method uses certificates for authentication (this includes all key exchange methods defined in this document except PSK).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "If the server requests client authentication but no suitable certificate is available, the client MUST send a Certificate message containing no certificates (i.e., with the \"certificate_list\" field having length 0).",
    "enhanced_sentence": "This rule governs client authentication behavior in TLS 1.3 handshakes. It applies when the server has explicitly requested client authentication via a CertificateRequest message during the handshake protocol flow. If the client lacks a suitable certificate that meets the server's requested criteria (as specified in the CertificateRequest), the client MUST still respond with a Certificate message, but with an empty certificate_list field (length 0). This signals to the server that client authentication cannot be completed, though the handshake continues. The client MUST subsequently send a Finished message regardless of the empty Certificate message. This rule ensures proper protocol continuation even when client authentication fails, maintaining compatibility and preventing handshake aborts due to missing client certificates.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: If the server requests client authentication but no suitable certificate is available, the client MUST send a Certificate message containing no certificates (i.e., with the \"certificate_list\" field having length 0).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "A Finished message MUST be sent regardless of whether the Certificate message is empty.",
    "enhanced_sentence": "In TLS 1.3 handshakes, a Finished message MUST be sent by both client and server after the Certificate message, even when the Certificate message is empty (i.e., contains no certificates). This rule applies specifically when client authentication is requested by the server but the client has no suitable certificate to provide, resulting in an empty Certificate message. The Finished message serves as cryptographic proof of the handshake integrity and must be transmitted to complete the authentication phase, ensuring the handshake can proceed to establish a secure connection regardless of certificate availability. This requirement holds only after the Certificate message has been sent or explicitly omitted as empty, following the rules for certificate transmission in Section 4.4.2.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: A Finished message MUST be sent regardless of whether the Certificate message is empty.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "The certificate_request_context field contains the value from the CertificateRequest message if this message is a response to one.",
    "enhanced_sentence": "The certificate_request_context field in the Certificate message MUST be populated with the exact value received from the CertificateRequest message when the Certificate message is sent in response to a client authentication request. This ensures the client's response is correctly associated with the server's specific authentication challenge, preventing context confusion in scenarios with multiple in-flight handshakes. If the Certificate message is sent for server authentication (without a preceding CertificateRequest), the certificate_request_context field SHALL be zero-length. This rule applies only when certificate-based authentication is negotiated and the recipient has explicitly requested authentication via a CertificateRequest.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: The certificate_request_context field contains the value from the CertificateRequest message if this message is a response to one.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "Otherwise, in the case of server authentication, the certificate_request_context field SHALL be zero length.",
    "enhanced_sentence": "When the server sends a Certificate message for server authentication (i.e., not in response to a client CertificateRequest), the certificate_request_context field MUST be set to a zero-length value. This applies during the standard server authentication flow where the server provides its certificate chain to the client without having received a prior CertificateRequest message. The expected outcome is that the client correctly interprets the server's certificate without any context from a certificate request, ensuring proper authentication. This rule applies only when the server is providing its own certificate for authentication and no CertificateRequest message has been exchanged in the current handshake.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: Otherwise, in the case of server authentication, the certificate_request_context field SHALL be zero length.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "Extensions in the Certificate message from the client MUST correspond to extensions in the CertificateRequest message from the server.",
    "enhanced_sentence": "When the server requests client authentication via a CertificateRequest message, any extensions included in the client's Certificate message MUST correspond exactly to those specified in the server's CertificateRequest. This rule applies only when client authentication is explicitly requested by the server and the client responds with a Certificate message (which may contain an empty certificate_list if no suitable certificate is available). The expected outcome is that the client includes only those extensions that were requested by the server, ensuring proper validation and alignment with the server's authentication requirements. This requirement does not apply to server certificates, which instead must align with extensions from the ClientHello.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: Extensions in the Certificate message from the client MUST correspond to extensions in the CertificateRequest message from the server.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "If an extension applies to the entire chain, it SHOULD be included in the first CertificateEntry.",
    "enhanced_sentence": "When constructing a Certificate message (either from server or client), if an extension (such as OCSP Status or SignedCertificateTimestamp) applies to the entire certificate chain rather than a specific certificate, it SHOULD be included in the extensions field of the first CertificateEntry (which contains the end-entity certificate). This ensures that the extension is properly associated with the chain as a whole and avoids redundant or inconsistent inclusion in multiple entries. This rule applies only when extensions are present and relevant to the chain; it does not override requirements for extensions to correspond to those requested in ClientHello or CertificateRequest messages.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: If an extension applies to the entire chain, it SHOULD be included in the first CertificateEntry.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "Extensions in the Certificate message from the server MUST correspond to ones from the ClientHello message.",
    "enhanced_sentence": "During server authentication, when the server sends a Certificate message in response to a ClientHello, any extensions included in the Certificate message (such as OCSP Status or SignedCertificateTimestamp) MUST correspond exactly to the extensions that were requested by the client in the ClientHello message. This rule applies only if the negotiated key exchange method requires certificate-based authentication (excluding PSK). The purpose is to ensure that the server does not provide unsolicited or mismatched certificate-related data, maintaining alignment with client capabilities and expectations. If an extension was not offered in the ClientHello, it MUST NOT appear in the server’s Certificate message. This requirement helps prevent protocol errors and ensures consistent interpretation of certificate extensions by both parties.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: Extensions in the Certificate message from the server MUST correspond to ones from the ClientHello message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "The extensions are a set of extension values for the CertificateEntry.",
    "enhanced_sentence": "The extensions are a set of extension values for the CertificateEntry, which are included in the Certificate message during the TLS 1.3 handshake. This rule applies when a peer (either client or server) is sending its certificate chain for authentication. The extensions must correspond to those previously negotiated: server certificate extensions must match those from the ClientHello, and client certificate extensions must match those from the CertificateRequest. If an extension applies to the entire certificate chain, it should be included in the first CertificateEntry. The expected outcome is that the receiving peer can properly validate and process the certificate chain, including any relevant status or transparency information (such as OCSP or SCT extensions). Prerequisites include successful negotiation of certificate types in the EncryptedExtensions and, for client authentication, a prior CertificateRequest from the server.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: The extensions are a set of extension values for the CertificateEntry.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "Valid extensions for server certificates at present include the OCSP Status extension from RFC6066 and the SignedCertificateTimestamp extension from RFC6962; future extensions may be defined for this message as well.",
    "enhanced_sentence": "When constructing a Certificate message for server authentication, the server MUST include only extensions that are explicitly defined for use in this context. Currently, the only valid extensions are the OCSP Status extension (from RFC6066) and the SignedCertificateTimestamp extension (from RFC6962). These extensions MUST correspond to ones previously advertised in the ClientHello message. Future extensions may be defined for this message, but implementations MUST ignore any unrecognized extensions. This rule applies during the TLS 1.3 handshake when the server sends its Certificate message in response to a key exchange method requiring certificate-based authentication (excluding PSK). The expected outcome is that the client can properly validate the server’s certificate chain, including any provided status information, without encountering errors due to unsupported or malformed extensions. Prerequisites include successful negotiation of certificate-based authentication and proper handling of extension correspondence between ClientHello and Certificate messages.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: Valid extensions for server certificates at present include the OCSP Status extension from RFC6066 and the SignedCertificateTimestamp extension from RFC6962; future extensions may be defined for this message as well.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "If the corresponding certificate type extension (\"server_certificate_type\" or \"client_certificate_type\") was not negotiated in EncryptedExtensions, or the X.509 certificate type was negotiated, then each CertificateEntry contains a DER-encoded X.509 certificate.",
    "enhanced_sentence": "This rule governs the format of certificate data within Certificate messages during TLS 1.3 handshakes. It applies when either: (1) no explicit certificate type extension (\"server_certificate_type\" or \"client_certificate_type\") was negotiated during the EncryptedExtensions exchange, or (2) the X.509 certificate type (value 0) was explicitly negotiated. In these cases, each CertificateEntry in the certificate_list MUST contain a single DER-encoded X.509 certificate. This ensures proper certificate chain processing when X.509 certificates are used, maintaining compatibility with standard PKI validation. The rule applies to both server and client Certificate messages, with the prerequisite that certificate-based authentication is being used (i.e., not pure PSK authentication).",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: If the corresponding certificate type extension (\"server_certificate_type\" or \"client_certificate_type\") was not negotiated in EncryptedExtensions, or the X.509 certificate type was negotiated, then each CertificateEntry contains a DER-encoded X.509 certificate.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "The certificate_list is a sequence (chain) of CertificateEntry structures, each containing a single certificate and set of extensions.",
    "enhanced_sentence": "The certificate_list is a sequence (chain) of CertificateEntry structures, each containing a single certificate and set of extensions. This rule applies when a Certificate message is sent for authentication, which occurs for the server if the key exchange method uses certificates (excluding PSK), and for the client only if explicitly requested by the server via a CertificateRequest. The expected outcome is a properly structured chain where the sender's certificate is first, followed by intermediates (each SHOULD certify the preceding one), with trust anchors optionally omitted. Extensions must align with those in ClientHello (server) or CertificateRequest (client), and if applicable to the entire chain, SHOULD be in the first CertificateEntry. If X.509 is negotiated (or no certificate type extension was negotiated), each entry contains a DER-encoded X.509 certificate; if RawPublicKey is negotiated, the list MUST contain only one entry with a subjectPublicKeyInfo. Prerequisites include successful negotiation of certificate-based authentication and, for the client, receipt of a CertificateRequest. The server's certificate_list MUST be non-empty; the client's may be empty if no suitable certificate is available.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: The certificate_list is a sequence (chain) of CertificateEntry structures, each containing a single certificate and set of extensions.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "The structure of the Certificate message includes: an enumeration of certificate types (X509(0), RawPublicKey(2), and others up to 255); a CertificateEntry structure that contains either an ASN.1 subjectPublicKeyInfo for RawPublicKey or certificate data for X509, along with extensions; and a Certificate structure with certificate_request_context and certificate_list fields.",
    "enhanced_sentence": "The Certificate message structure, which conveys the endpoint's certificate chain to the peer, applies during the TLS 1.3 handshake when certificate-based authentication is required. The server MUST send this message if the negotiated key exchange method uses certificates (excluding PSK), and the client MUST send it only if the server has explicitly requested client authentication via a CertificateRequest. If no suitable client certificate is available, the client MUST send an empty certificate_list. The message includes: an enumeration of certificate types (e.g., X509(0), RawPublicKey(2)); a CertificateEntry structure containing either ASN.1 subjectPublicKeyInfo (for RawPublicKey) or X.509 certificate data, along with extensions; and a Certificate structure with certificate_request_context (zero-length for server authentication, or matching the CertificateRequest value for client responses) and certificate_list (a sequence of CertificateEntry structures). The sender's certificate MUST be first in the list, followed by any supporting certificates, and extensions MUST align with those in the ClientHello (for server) or CertificateRequest (for client). If X.509 was negotiated, each entry contains a DER-encoded certificate; if RawPublicKey was negotiated, only one entry is permitted. Prerequisites include successful negotiation of certificate types in EncryptedExtensions and adherence to extension handling rules. The expected outcome is proper authentication and chain validation, enabling subsequent handshake steps like the Finished message.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: The structure of the Certificate message includes: an enumeration of certificate types (X509(0), RawPublicKey(2), and others up to 255); a CertificateEntry structure that contains either an ASN.1 subjectPublicKeyInfo for RawPublicKey or certificate data for X509, along with extensions; and a Certificate structure with certificate_request_context and certificate_list fields.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "The sender's certificate MUST come in the first CertificateEntry in the list.",
    "enhanced_sentence": "When a Certificate message is sent (server authentication in all non-PSK key exchanges, or client authentication when requested), the sender's end-entity certificate MUST be placed as the first CertificateEntry in the certificate_list. This applies regardless of whether X.509 or RawPublicKey certificate types are negotiated. The rule ensures that the peer can immediately identify the sender's own certificate for validation, with subsequent entries (if any) forming the chain. This ordering is mandatory for proper authentication and chain processing, and implementations MUST reject messages where the end-entity certificate is not first. Note that while the rest of the chain may have flexibility or omissions for compatibility, the sender's certificate MUST always be positionally unambiguous.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: The sender's certificate MUST come in the first CertificateEntry in the list.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "Each following certificate SHOULD directly certify the one immediately preceding it.",
    "enhanced_sentence": "When constructing a certificate chain in the Certificate message (for both server and client authentication), the sender's end-entity certificate MUST be the first entry in the certificate_list. Each subsequent certificate SHOULD directly certify the one immediately preceding it, forming a valid chain where each certificate is issued by the entity represented by the next certificate in the list. This rule applies when X.509 certificates are used (as negotiated in EncryptedExtensions) and ensures that the recipient can efficiently validate the chain by following issuer relationships. However, to support transitional configurations and maximize interoperability, implementations MUST be prepared to handle chains that may include extraneous certificates or non-standard orderings, as long as the end-entity certificate is first. Trust anchor certificates MAY be omitted from the chain if peers are known to possess them independently.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: Each following certificate SHOULD directly certify the one immediately preceding it.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "For maximum compatibility, all implementations SHOULD be prepared to handle potentially extraneous certificates and arbitrary orderings from any TLS version, with the exception of the end-entity certificate which MUST be first.",
    "enhanced_sentence": "When processing the Certificate message (sent during server authentication or in response to a CertificateRequest for client authentication), implementations MUST validate that the end-entity certificate (the sender's own certificate) is the first entry in the certificate_list. For maximum compatibility with peers using any TLS version, implementations SHOULD be prepared to handle certificate chains that may contain extraneous certificates (such as transitional or deprecated intermediates) and arbitrary ordering of intermediate certificates, provided the end-entity certificate remains first. This flexibility ensures proper validation even when chains include certificates not directly part of the certification path or when senders use non-standard ordering, except that the RawPublicKey certificate type (if negotiated) MUST contain exactly one CertificateEntry and the OpenPGP certificate type is prohibited.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: For maximum compatibility, all implementations SHOULD be prepared to handle potentially extraneous certificates and arbitrary orderings from any TLS version, with the exception of the end-entity certificate which MUST be first.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "Note: Prior to TLS 1.3, \"certificate_list\" ordering required each certificate to certify the one immediately preceding it; however, some implementations allowed some flexibility.",
    "enhanced_sentence": "Note: In TLS versions prior to 1.3, the \"certificate_list\" field required strict ordering where each certificate (except the first) must directly certify the certificate immediately preceding it in the chain. However, some implementations exhibited leniency by accepting non-conforming chains—such as those containing transitional or deprecated intermediates, or incorrectly ordered certificates—as long as the chain could be validated against a trusted anchor. For TLS 1.3, while the specification recommends that each certificate SHOULD certify the preceding one, implementations MUST be prepared to handle extraneous certificates and arbitrary orderings (with the exception that the end-entity certificate MUST always be first) to ensure backward compatibility and robust interoperability. This rule applies during the processing of the Certificate message in the handshake, when the receiver validates the provided certificate chain.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: Note: Prior to TLS 1.3, \"certificate_list\" ordering required each certificate to certify the one immediately preceding it; however, some implementations allowed some flexibility.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "The server's certificate_list MUST always be non-empty.",
    "enhanced_sentence": "The server's certificate_list MUST always be non-empty when the server sends a Certificate message, which occurs whenever the negotiated key exchange method requires certificate-based authentication (excluding PSK-only modes). This rule applies during the server authentication phase of the handshake, ensuring that the server provides at least one valid certificate for chain validation. The expected outcome is that the client receives a verifiable certificate chain establishing the server's identity. This requirement does not apply to client certificates, where an empty certificate_list is permitted when no suitable certificate is available.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: The server's certificate_list MUST always be non-empty.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "If the RawPublicKey certificate type was negotiated, then the certificate_list MUST contain no more than one CertificateEntry, which contains an ASN.1 subjectPublicKeyInfo value as defined in RFC7250, Section 3.",
    "enhanced_sentence": "This rule applies when the RawPublicKey certificate type (value 2) has been successfully negotiated during the EncryptedExtensions handshake phase. In such cases, the certificate_list in the Certificate message MUST contain exactly zero or one CertificateEntry. If present, the single CertificateEntry MUST contain only an ASN.1 subjectPublicKeyInfo value as specified in RFC7250, Section 3, and MUST NOT contain any certificate chain or X.509 data. This ensures that when raw public keys are used for authentication, the certificate message conveys only the necessary public key material without extraneous certificate structures, maintaining protocol efficiency and compliance with the negotiated authentication method.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: If the RawPublicKey certificate type was negotiated, then the certificate_list MUST contain no more than one CertificateEntry, which contains an ASN.1 subjectPublicKeyInfo value as defined in RFC7250, Section 3.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "The keys found in certificates MUST also be of appropriate type for the signature algorithms the keys are used with.",
    "enhanced_sentence": "When a TLS 1.3 endpoint processes certificates during the handshake (such as those received in Certificate messages), the public keys contained in those certificates MUST be of a type that is compatible with the signature algorithm used to sign the certificate. This rule applies whenever certificates are validated, including when the \"signature_algorithms_cert\" extension is used to specify acceptable algorithms for certificate signatures, or when the \"signature_algorithms\" extension applies by default. The expected outcome is that certificate signatures are verifiable using the corresponding public key without cryptographic mismatches. Prerequisites include proper support for the indicated signature algorithms (e.g., RSASSA-PSS requires RSA keys with appropriate OIDs, ECDSA requires EC keys) and adherence to the signature algorithm preferences signaled in handshake extensions.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: The keys found in certificates MUST also be of appropriate type for the signature algorithms the keys are used with.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate",
    "sentence": "A client will send an empty certificate_list if it does not have an appropriate certificate to send in response to the server's authentication request.",
    "enhanced_sentence": "When the server requests client authentication via a CertificateRequest message and the client does not possess a suitable certificate that meets the server's criteria (as specified in the CertificateRequest extensions and negotiated parameters), the client MUST respond with a Certificate message containing an empty certificate_list (i.e., with a zero-length sequence of CertificateEntry structures). This rule applies specifically during the client authentication phase of the TLS 1.3 handshake, immediately following the server's CertificateRequest. The expected outcome is that the server, upon receiving an empty certificate_list, may either proceed without client authentication (if configured to allow it) or terminate the handshake with an appropriate alert. Note that the client MUST still send a Finished message after the empty Certificate message to complete the handshake. This behavior is mandatory and ensures interoperability when client certificates are requested but unavailable.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.2. Certificate\"\nRule: A client will send an empty certificate_list if it does not have an appropriate certificate to send in response to the server's authentication request.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "The \"signature_algorithms_cert\" extension applies to signatures in certificates, and the \"signature_algorithms\" extension, which originally appeared in TLS 1.2, applies to signatures in CertificateVerify messages.",
    "enhanced_sentence": "The \"signature_algorithms_cert\" extension applies to signatures in certificates, and the \"signature_algorithms\" extension (originally from TLS 1.2) applies to signatures in CertificateVerify messages. This rule governs how endpoints signal and validate acceptable signature algorithms during the TLS 1.3 handshake. It applies when certificates are presented for authentication or when CertificateVerify messages are exchanged. If no \"signature_algorithms_cert\" extension is present, the \"signature_algorithms\" extension also applies to certificate signatures. Clients MUST send the \"signature_algorithms\" extension if they require server certificate authentication; servers MUST abort with a \"missing_extension\" alert if this extension is absent. Prerequisites include proper key-type alignment with signature algorithms (e.g., RSA keys with RSA-based signatures). The expected outcome is secure, mutually understood algorithm negotiation, preventing handshake failures due to unsupported or mismatched signature schemes.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: The \"signature_algorithms_cert\" extension applies to signatures in certificates, and the \"signature_algorithms\" extension, which originally appeared in TLS 1.2, applies to signatures in CertificateVerify messages.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "Clients which desire the server to authenticate itself via a certificate MUST send the \"signature_algorithms\" extension.",
    "enhanced_sentence": "During the TLS 1.3 handshake, if a client requires server authentication via a certificate, it MUST include the \"signature_algorithms\" extension in its ClientHello message. This extension indicates the client's supported signature schemes for verifying the server's CertificateVerify message and, if no \"signature_algorithms_cert\" extension is present, also applies to signatures in the server's certificate. If the server is configured to authenticate with a certificate and the client omits this extension, the server MUST terminate the handshake with a \"missing_extension\" alert. This rule applies only to TLS 1.3; TLS 1.2 implementations may omit the extension.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: Clients which desire the server to authenticate itself via a certificate MUST send the \"signature_algorithms\" extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "If no \"signature_algorithms_cert\" extension is present, then the \"signature_algorithms\" extension also applies to signatures appearing in certificates.",
    "enhanced_sentence": "During the TLS 1.3 handshake, when a client sends the \"signature_algorithms\" extension but omits the \"signature_algorithms_cert\" extension, the server MUST interpret the algorithms listed in \"signature_algorithms\" as applicable to both CertificateVerify messages and signatures in certificates. This rule applies when the server is selecting or validating certificate chains, ensuring that the signature algorithms used in the presented certificates are among those supported and preferred by the client. The client MUST send the \"signature_algorithms\" extension if it requires server authentication; failure to do so results in a handshake abort with a \"missing_extension\" alert. This behavior allows backward compatibility and simplifies signaling for implementations with uniform algorithm support for certificates and handshake signatures.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: If no \"signature_algorithms_cert\" extension is present, then the \"signature_algorithms\" extension also applies to signatures appearing in certificates.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "TLS 1.3 provides two extensions for indicating which signature algorithms may be used in digital signatures.",
    "enhanced_sentence": "TLS 1.3 provides two extensions—\"signature_algorithms\" and \"signature_algorithms_cert\"—to indicate supported signature algorithms for digital signatures. The \"signature_algorithms\" extension applies to signatures in CertificateVerify messages and must be sent by clients requesting server certificate authentication; if omitted, the server must abort the handshake with a \"missing_extension\" alert. The \"signature_algorithms_cert\" extension applies to signatures in certificates and is optional; if absent, the \"signature_algorithms\" extension also governs certificate signatures. These extensions are used during the handshake negotiation phase, specifically in the ClientHello and CertificateRequest messages, to ensure both endpoints agree on cryptographically acceptable algorithms. Keys used with these algorithms must be of appropriate type (e.g., RSA keys for RSA-based signatures), and algorithms are listed in descending order of preference. Legacy or weak algorithms (e.g., SHA-1) should be deprioritized or avoided, and endpoints must adhere to backward-compatibility rules when negotiating TLS 1.2.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: TLS 1.3 provides two extensions for indicating which signature algorithms may be used in digital signatures.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "Implementations which have the same policy in both cases MAY omit the \"signature_algorithms_cert\" extension.",
    "enhanced_sentence": "When an implementation uses identical signature algorithm policies for both certificate signatures (in server/client certificates) and CertificateVerify message signatures, it MAY omit the \"signature_algorithms_cert\" extension during the handshake. This applies when constructing ClientHello or EncryptedExtensions messages, provided the \"signature_algorithms\" extension is present and fully represents the acceptable algorithms for both use cases. If omitted, the receiving endpoint MUST treat the \"signature_algorithms\" extension as governing both certificate validation and CertificateVerify signatures. This optimization reduces handshake size without altering protocol behavior, as both extensions would convey identical information. Note: This rule assumes the implementation has already ensured cryptographic consistency between key types and signature algorithms (e.g., RSA keys with PSS signatures).",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: Implementations which have the same policy in both cases MAY omit the \"signature_algorithms_cert\" extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "The \"signature_algorithms_cert\" extension was added to allow implementations which supported different sets of algorithms for certificates and in TLS itself to clearly signal their capabilities.",
    "enhanced_sentence": "The \"signature_algorithms_cert\" extension applies during the TLS 1.3 handshake when a client or server wishes to advertise distinct signature algorithm preferences for certificate validation versus TLS handshake signatures. This extension MUST be included in the ClientHello or CertificateRequest messages if the endpoint supports different algorithm sets for certificates and CertificateVerify messages. If omitted, the algorithms listed in the \"signature_algorithms\" extension apply to both contexts. Implementations MUST interpret the extension’s SignatureSchemeList in descending order of preference and MUST only use the advertised algorithms when verifying certificate signatures. This rule is critical for backward compatibility and algorithm agility, particularly in cases involving RSA-PSS or legacy algorithms, and ensures endpoints can clearly signal and respect differentiated cryptographic capabilities.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: The \"signature_algorithms_cert\" extension was added to allow implementations which supported different sets of algorithms for certificates and in TLS itself to clearly signal their capabilities.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "TLS 1.2 implementations SHOULD also process the \"signature_algorithms_cert\" extension.",
    "enhanced_sentence": "TLS 1.2 implementations SHOULD also process the \"signature_algorithms_cert\" extension when it is present in a ClientHello or ServerHello message, even though this extension was introduced in TLS 1.3. This processing applies during the handshake negotiation phase when signature algorithms for certificates are being selected. The expected outcome is that the implementation correctly interprets the client's or server's supported certificate signature algorithms, allowing for proper validation and interoperability with TLS 1.3 peers. This rule applies only if the implementation supports TLS 1.2 and is interacting with an endpoint that includes the \"signature_algorithms_cert\" extension for backward compatibility or future-proofing. If the extension is absent, the \"signature_algorithms\" extension should be used for certificate signatures as in standard TLS 1.2 behavior.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: TLS 1.2 implementations SHOULD also process the \"signature_algorithms_cert\" extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "If a server is authenticating via a certificate and the client has not sent a \"signature_algorithms\" extension, then the server MUST abort the handshake with a \"missing_extension\" alert (seeSection 9.2).",
    "enhanced_sentence": "This rule governs the server's behavior during the TLS 1.3 handshake when certificate-based authentication is required. It applies specifically when the server is configured to authenticate itself using a certificate, and the client's ClientHello message does not include the mandatory \"signature_algorithms\" extension. The absence of this extension prevents the server from determining which signature schemes the client supports for verifying the server's CertificateVerify message, which is essential for establishing a secure connection. Therefore, the server MUST immediately terminate the handshake by sending a \"missing_extension\" alert (as defined in Section 9.2) to avoid proceeding with an insecure or incompatible authentication process. This requirement is conditional on the server performing certificate authentication; if the server is not authenticating (e.g., in anonymous or pre-shared key modes), this rule does not apply. Additionally, note that the \"signature_algorithms\" extension is always required from the client in TLS 1.3 when server certificate authentication is expected, unlike in TLS 1.2 where it was optional.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: If a server is authenticating via a certificate and the client has not sent a \"signature_algorithms\" extension, then the server MUST abort the handshake with a \"missing_extension\" alert (seeSection 9.2).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "The \"extension_data\" field of these extensions contains a SignatureSchemeList value.",
    "enhanced_sentence": "The \"extension_data\" field of both the \"signature_algorithms\" and \"signature_algorithms_cert\" extensions MUST contain a SignatureSchemeList value, which is an ordered list of supported signature algorithms in descending order of preference. This rule applies during the TLS 1.3 handshake when a client sends these extensions in the ClientHello message to indicate acceptable signature schemes for CertificateVerify messages and/or certificates. The server MUST use this list to select an appropriate signature algorithm when generating signatures, and if the client omits the \"signature_algorithms\" extension while requiring server authentication, the server MUST abort the handshake. The SignatureSchemeList MUST only include valid SignatureScheme values as defined in the protocol, and legacy or deprecated algorithms (e.g., those using SHA-1, MD5, or DSA) SHOULD be avoided or listed with the lowest priority.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: The \"extension_data\" field of these extensions contains a SignatureSchemeList value.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "If the public key is carried in an X.509 certificate, the public key MUST use the rsaEncryption OID.",
    "enhanced_sentence": "When a server or client presents an X.509 certificate containing a public key for authentication during the TLS 1.3 handshake, and the certificate signature uses an RSASSA-PSS algorithm (as indicated in the \"signature_algorithms_cert\" or \"signature_algorithms\" extension), the public key in that certificate MUST use the rsaEncryption OID (1.2.840.113549.1.1.1) rather than the RSASSA-PSS OID. This requirement ensures backward compatibility with existing certificate validation implementations and maintains consistency with the defined signature scheme. If this condition is not met, the receiving endpoint MUST treat the certificate as invalid and abort the handshake with an appropriate alert. This rule applies specifically to certificates signed with RSASSA-PSS algorithms and does not affect certificates using other signature schemes such as RSASSA-PKCS1-v1_5 or ECDSA.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: If the public key is carried in an X.509 certificate, the public key MUST use the rsaEncryption OID.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "When used in certificate signatures, the algorithm parameters MUST be DER encoded.",
    "enhanced_sentence": "When a signature algorithm is used for signing certificates in TLS 1.3 (as indicated by the \"signature_algorithms_cert\" extension or, if absent, the \"signature_algorithms\" extension), the algorithm parameters included in the certificate signature MUST be DER encoded. This rule applies during the certificate verification phase of the handshake, when the recipient validates the signature on the certificate. The expected outcome is that the parameters are unambiguously and correctly represented, ensuring interoperability and compliance with ASN.1 standards. This requirement is conditional on the algorithm in use requiring parameters (e.g., certain ECDSA or RSASSA-PSS signatures) and assumes that the public key's parameters, if present, are also DER encoded and must match those in the signature.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: When used in certificate signatures, the algorithm parameters MUST be DER encoded.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "A certificate that begins a certification path MAY use a signature algorithm that is not advertised as being supported in the \"signature_algorithms\" extension.",
    "enhanced_sentence": "A certificate that begins a certification path (i.e., a self-signed certificate or a trust anchor) MAY use a signature algorithm that is not advertised as being supported in the \"signature_algorithms\" extension, because such certificates are not validated during the TLS handshake. This rule applies during certificate chain validation when the server or client is authenticating via a certificate. The expected outcome is that the handshake proceeds normally even if the root certificate uses an algorithm not listed in the extension, provided all other certificate validations succeed. This exception only applies to certificates that initiate the certification path; intermediate and end-entity certificates must still comply with the advertised signature algorithms.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: A certificate that begins a certification path MAY use a signature algorithm that is not advertised as being supported in the \"signature_algorithms\" extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it (see Section 4.4.2.2).",
    "enhanced_sentence": "During the TLS 1.3 handshake, when a server is authenticating itself by presenting a certificate chain, it MUST NOT offer any certificate signed using a SHA-1 based signature algorithm (such as RSA-SHA1 or ECDSA-SHA1) unless it is impossible to construct a valid and trusted certificate chain without including such a certificate. This rule applies specifically to the server's certificate message and is intended to phase out the use of cryptographically weak SHA-1 hashes in favor of more secure algorithms (e.g., SHA-256 or stronger). The only exception is when a SHA-1 signed certificate is strictly necessary to complete the chain to a trusted root, as further detailed in Section 4.4.2.2. Servers MUST prioritize offering certificates signed with modern, secure algorithms whenever available.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless no valid certificate chain can be produced without it (see Section 4.4.2.2).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "If the public key is carried in an X.509 certificate, the public key MUST use the RSASSA-PSS OID.",
    "enhanced_sentence": "This rule applies when a TLS 1.3 endpoint receives an X.509 certificate containing a public key intended for use with RSASSA-PSS signature algorithms (specifically those identified with the \"RSASSA-PSS PSS\" SignatureScheme values). The rule governs certificate validation during the handshake, specifically when processing the server's Certificate message or when the client presents a certificate for client authentication. For RSASSA-PSS signatures in certificates, the corresponding public key MUST use the RSASSA-PSS OID (1.2.840.113549.1.1.10) rather than the traditional rsaEncryption OID. This requirement ensures proper algorithm parameter alignment between the public key and signature algorithm. If this condition is not met, the receiving endpoint MUST treat the certificate as invalid and abort the handshake with an appropriate alert. This rule applies only when the certificate is used with TLS 1.3 handshakes and when RSASSA-PSS algorithms are negotiated through the signature_algorithms or signature_algorithms_cert extensions.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: If the public key is carried in an X.509 certificate, the public key MUST use the RSASSA-PSS OID.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "If the corresponding public key's parameters are present, then the parameters in the signature MUST be identical to those in the public key.",
    "enhanced_sentence": "When a TLS 1.3 endpoint processes a digital signature in a certificate (e.g., during server or client authentication), if the corresponding public key includes explicit cryptographic parameters (such as those found in RSASSA-PSS keys with OID RSASSA-PSS, which may specify hash algorithm, mask generation function, or salt length), then the parameters embedded within the signature's algorithm identifier MUST exactly match those present in the public key. This rule applies during certificate signature verification to ensure consistency between the key’s intended usage and the signature’s construction, preventing parameter substitution attacks. The requirement is only enforced when parameters are explicitly provided in the public key; if no parameters are present, the signature may use default or contextually implied values. Adherence ensures that the signature validates correctly and maintains the security properties of the designated algorithm.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: If the corresponding public key's parameters are present, then the parameters in the signature MUST be identical to those in the public key.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "The signatures on certificates that are self-signed or certificates that are trust anchors are not validated, since they begin a certification path.",
    "enhanced_sentence": "During TLS 1.3 certificate validation, implementations MUST NOT validate the signatures on certificates that are self-signed or that serve as trust anchors, as these certificates form the starting point of certification paths. This rule applies when building and verifying certificate chains during the handshake, specifically when processing the server's certificate or any intermediate certificates. The expected outcome is that these certificates are accepted without signature verification against their own public keys, though they must still meet other validation requirements (such as being properly formatted and within validity periods). This exception applies only to certificates that are explicitly configured as trust anchors in the client's trust store or that are genuinely self-signed (with the same subject and issuer). All other certificates in the chain MUST have their signatures validated according to the advertised signature algorithms in the \"signature_algorithms\" or \"signature_algorithms_cert\" extensions.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: The signatures on certificates that are self-signed or certificates that are trust anchors are not validated, since they begin a certification path.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "If TLS 1.2 is negotiated, implementations MUST be prepared to accept a signature that uses any curve that they advertised in the \"supported_groups\" extension.",
    "enhanced_sentence": "When TLS 1.2 is negotiated, implementations MUST be prepared to accept signatures in CertificateVerify messages that use any elliptic curve they previously advertised in the \"supported_groups\" extension. This requirement applies specifically during the certificate verification phase of the handshake, where the server presents its certificate and corresponding signature. The rule ensures backward compatibility with TLS 1.2's less constrained curve selection for ECDSA signatures, even though the signature algorithm extension might not explicitly specify curve preferences. Implementations must have advertised supported curves in the \"supported_groups\" extension during the initial handshake negotiation for this requirement to apply.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: If TLS 1.2 is negotiated, implementations MUST be prepared to accept a signature that uses any curve that they advertised in the \"supported_groups\" extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "Note that TLS 1.2 defines the signature algorithm extension differently.",
    "enhanced_sentence": "Note that TLS 1.2 defines the signature algorithm extension differently: in TLS 1.2, the extension uses hash/signature pairs encoded in two octets, whereas TLS 1.3 uses a unified SignatureScheme enum that includes additional algorithms and clearer semantics. This rule applies when implementations support both TLS 1.3 and TLS 1.2, requiring that during a TLS 1.2 handshake, the behavior and encoding of the signature_algorithms extension must conform to the TLS 1.2 specification. The expected outcome is correct interoperability when negotiating TLS 1.2, including proper handling of legacy algorithms and encoding. Prerequisites include understanding both TLS 1.2 and TLS 1.3 extension structures and ensuring backward compatibility without offering deprecated algorithms like MD5 or DSA.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: Note that TLS 1.2 defines the signature algorithm extension differently.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "In particular: TLS 1.2 ClientHellos MAY omit the signature algorithm extension.",
    "enhanced_sentence": "When negotiating TLS 1.2, implementations MUST recognize that TLS 1.2 ClientHello messages MAY omit the signature_algorithms extension. This applies specifically during the handshake initiation phase when a client is establishing a TLS 1.2 connection. If omitted, the server MUST rely on default signature algorithms supported by the implementation for certificate verification and handshake signatures. However, if the client intends to request server authentication via certificate, it MUST include the signature_algorithms extension; otherwise, the server MUST abort the handshake with a missing_extension alert. This rule is conditional on TLS 1.2 being negotiated and does not apply to TLS 1.3 connections, where the extension requirements differ.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: In particular: TLS 1.2 ClientHellos MAY omit the signature algorithm extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "In TLS 1.2, the signature algorithm extension contained hash/signature pairs.",
    "enhanced_sentence": "In TLS 1.2, the signature algorithm extension contained hash/signature pairs, which were encoded as two-octet values. This rule applies when negotiating TLS 1.2, where the extension is used to indicate supported algorithms for digital signatures in handshake messages. The expected outcome is that endpoints correctly interpret these pairs to agree on acceptable signature schemes, with the client listing algorithms in descending order of preference. Prerequisites include the client sending the extension if server authentication is desired, and the server aborting the handshake with a \"missing_extension\" alert if the extension is absent when required. Note that TLS 1.3 redefines this extension with a new SignatureScheme enum, but implementations supporting TLS 1.2 must adhere to this legacy encoding and behavior.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: In TLS 1.2, the signature algorithm extension contained hash/signature pairs.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.4. Finished",
    "sentence": "Recipients of Finished messages MUST verify that the contents are correct and if incorrect MUST terminate the connection with a \"decrypt_error\" alert.",
    "enhanced_sentence": "After receiving a Finished message, which is the final message in the Authentication Block and provides authentication of the handshake and computed keys, recipients MUST verify that the contents (specifically, the verify_data computed using HMAC with the finished_key derived from the Base Key via HKDF-Expand-Label) are correct by comparing them against the expected value derived from the handshake transcript. If the contents are incorrect, indicating a potential integrity or authentication failure, the recipient MUST immediately terminate the connection with a \"decrypt_error\" alert. This verification is mandatory and applies once the Finished message is received, before any application data is exchanged or the connection is considered secure. Note that this rule assumes the handshake context, including Certificate and CertificateVerify messages if present, has been properly processed and the necessary keys have been correctly derived.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.4. Finished\"\nRule: Recipients of Finished messages MUST verify that the contents are correct and if incorrect MUST terminate the connection with a \"decrypt_error\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms",
    "sentence": "Implementations that advertise support for RSASSA-PSS MUST be prepared to accept a signature using that scheme even when TLS 1.2 is negotiated.",
    "enhanced_sentence": "When a TLS implementation (client or server) advertises support for RSASSA-PSS signature schemes in either the \"signature_algorithms\" or \"signature_algorithms_cert\" extension during the handshake, it MUST be capable of processing and validating signatures created with RSASSA-PSS algorithms, even when the negotiated protocol version is TLS 1.2 rather than TLS 1.3. This requirement applies specifically to signatures in CertificateVerify messages and, if no separate \"signature_algorithms_cert\" extension is provided, also to signatures appearing in certificates. The implementation must handle both RSASSA-PSS variants (those using the rsaEncryption OID and those using the RSASSA-PSS OID) according to their respective parameter requirements, ensuring backward compatibility while maintaining the security properties expected from PSS signatures.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.2. Extensions -> 4.2.3. Signature Algorithms\"\nRule: Implementations that advertise support for RSASSA-PSS MUST be prepared to accept a signature using that scheme even when TLS 1.2 is negotiated.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.4. Finished",
    "sentence": "Any records following a Finished message MUST be encrypted under the appropriate application traffic key as described in Section 7.2.",
    "enhanced_sentence": "After a Finished message has been sent and received (and its contents verified), the handshake is considered complete, and both parties have mutually authenticated and derived the necessary session keys. From this point onward, all subsequent records—including Application Data, alerts, or any other non-handshake messages—MUST be encrypted using the application traffic key(s) established during the key schedule as specified in Section 7.2. This ensures that all post-handshake communication is protected under the newly negotiated encryption context, maintaining confidentiality and integrity for the remainder of the session.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.4. Finished\"\nRule: Any records following a Finished message MUST be encrypted under the appropriate application traffic key as described in Section 7.2.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.4. Finished",
    "sentence": "In particular, this requirement includes any alerts sent by the server in response to client Certificate and CertificateVerify messages.",
    "enhanced_sentence": "After the server has sent its Finished message and the handshake authentication block is complete, any subsequent alerts (including those generated in response to client Certificate or CertificateVerify messages) MUST be encrypted using the application traffic keys as defined in Section 7.2. This requirement applies once the server has transmitted its Finished message, indicating the transition from handshake to application data phase. The expected outcome is that all post-Finished communications, including error notifications, are confidentiality-protected under the established session keys. This rule is conditional on the successful computation and exchange of Finished messages by both parties, which validates the handshake and derives the necessary traffic keys.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.4. Finished\"\nRule: In particular, this requirement includes any alerts sent by the server in response to client Certificate and CertificateVerify messages.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update",
    "sentence": "Implementations that receive a KeyUpdate message prior to receiving a Finished message MUST terminate the connection with an \"unexpected_message\" alert.",
    "enhanced_sentence": "The KeyUpdate message is only valid after both peers have completed the handshake by exchanging Finished messages. If an implementation receives a KeyUpdate message before it has received the peer's Finished message (indicating an incomplete handshake), it MUST treat this as a protocol violation and terminate the connection with an \"unexpected_message\" alert. This rule prevents premature key updates that could compromise handshake security and ensures cryptographic keys are only updated after a fully authenticated and encrypted channel has been established.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update\"\nRule: Implementations that receive a KeyUpdate message prior to receiving a Finished message MUST terminate the connection with an \"unexpected_message\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update",
    "sentence": "The KeyUpdate message can be sent by either peer after the peer has sent a Finished message.",
    "enhanced_sentence": "The KeyUpdate message can be sent by either peer after the peer has sent a Finished message, indicating that the sender is updating its sending cryptographic keys. This rule applies only in the post-handshake phase, once both peers have completed the initial handshake by exchanging Finished messages. The expected outcome is that the sender switches to the next generation of keys for all subsequent traffic, and the receiver must update its receiving keys accordingly. Prerequisites include: the connection must be fully established with Finished messages exchanged, and the KeyUpdate message must be encrypted with the current (old) keys. If a KeyUpdate is received before the Finished message, the connection must be terminated with an \"unexpected_message\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update\"\nRule: The KeyUpdate message can be sent by either peer after the peer has sent a Finished message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.4. Finished",
    "sentence": "The verify_data value is computed as follows: verify_data = HMAC(finished_key, Transcript-Hash(Handshake Context, Certificate*, CertificateVerify*)), where * indicates only included if present.",
    "enhanced_sentence": "The verify_data value in the Finished message is computed as follows: verify_data = HMAC(finished_key, Transcript-Hash(Handshake Context, Certificate*, CertificateVerify*)), where * indicates that Certificate and CertificateVerify are only included in the hash input if they are present in the handshake. This rule applies when a party (client or server) is generating the Finished message, which is the final message in the Authentication Block and is essential for authenticating the handshake and the derived keys. The expected outcome is a cryptographically verified value that ensures the integrity and authenticity of the entire handshake exchange up to this point. Prerequisites include: the finished_key must be derived using HKDF-Expand-Label from the Base Key as specified; the HMAC must use the negotiated handshake Hash algorithm; and the handshake transcript must include all previous handshake messages, with Certificate and CertificateVerify conditionally added based on their presence. Recipients must verify this value; if incorrect, they must terminate the connection with a \"decrypt_error\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.4. Finished\"\nRule: The verify_data value is computed as follows: verify_data = HMAC(finished_key, Transcript-Hash(Handshake Context, Certificate*, CertificateVerify*)), where * indicates only included if present.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update",
    "sentence": "After sending a KeyUpdate message, the sender SHALL send all its traffic using the next generation of keys, computed as described in Section 7.2.",
    "enhanced_sentence": "After sending a KeyUpdate message (which must be encrypted with the current generation of keys), the sender SHALL immediately transition to using the next generation of keys, computed as described in Section 7.2, for all subsequent traffic. This rule applies only after the handshake is complete (i.e., after the sender has sent its Finished message) and ensures cryptographic key freshness. The receiver MUST update its receiving keys upon receiving a KeyUpdate and MUST enforce that the KeyUpdate is received and validated with the old keys before accepting any messages encrypted with the new keys to prevent truncation attacks. If the KeyUpdate request_update field is set to \"update_requested\", the receiver MUST respond with its own KeyUpdate before sending further Application Data.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update\"\nRule: After sending a KeyUpdate message, the sender SHALL send all its traffic using the next generation of keys, computed as described in Section 7.2.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update",
    "sentence": "If an implementation receives any other value for request_update, the implementation MUST terminate the connection with an \"illegal_parameter\" alert.",
    "enhanced_sentence": "After the handshake has completed (i.e., after a Finished message has been received), if an implementation receives a KeyUpdate message where the request_update field contains a value other than the defined enumeration values (update_not_requested(0) or update_requested(1)), the implementation MUST treat this as a protocol violation and terminate the connection immediately by sending an \"illegal_parameter\" alert. This rule ensures that only valid, specified values are processed, preventing undefined behavior or potential security issues arising from malformed key update requests.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update\"\nRule: If an implementation receives any other value for request_update, the implementation MUST terminate the connection with an \"illegal_parameter\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update",
    "sentence": "Upon receiving a KeyUpdate, the receiver MUST update its receiving keys.",
    "enhanced_sentence": "After the handshake has completed (as indicated by the receipt of a Finished message), upon receiving a KeyUpdate message, the receiver MUST immediately update its receiving cryptographic keys to the next generation, as specified in Section 7.2, and begin decrypting subsequent incoming traffic with the new keys. The receiver MUST also verify that the KeyUpdate message itself is encrypted with the old keys before processing it. If the request_update field in the KeyUpdate is set to \"update_requested\", the receiver MUST respond with its own KeyUpdate (with request_update set to \"update_not_requested\") before sending any further Application Data. This ensures synchronization of key states and maintains forward secrecy.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update\"\nRule: Upon receiving a KeyUpdate, the receiver MUST update its receiving keys.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update",
    "sentence": "If the request_update field is set to \"update_requested\", then the receiver MUST send a KeyUpdate of its own with request_update set to \"update_not_requested\" prior to sending its next Application Data record.",
    "enhanced_sentence": "After the TLS 1.3 handshake has completed (i.e., after both peers have sent Finished messages), if a peer receives a KeyUpdate message with the request_update field set to \"update_requested\", it MUST respond by sending its own KeyUpdate message with request_update set to \"update_not_requested\" before transmitting any subsequent Application Data records. This ensures that both sides update their cryptographic keys in a coordinated manner, maintaining synchronization and preventing truncation attacks. The response KeyUpdate MUST be encrypted using the current (old) generation of keys, and the receiver must not accept any messages encrypted with new keys until it has received and processed the peer's KeyUpdate message. This rule applies only during the post-handshake phase and does not trigger if the KeyUpdate is received before the Finished message, which would instead result in connection termination.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update\"\nRule: If the request_update field is set to \"update_requested\", then the receiver MUST send a KeyUpdate of its own with request_update set to \"update_not_requested\" prior to sending its next Application Data record.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update",
    "sentence": "The KeyUpdate structure contains a request_update field that indicates whether the recipient of the KeyUpdate should respond with its own KeyUpdate.",
    "enhanced_sentence": "The KeyUpdate structure contains a request_update field that indicates whether the recipient of the KeyUpdate should respond with its own KeyUpdate. This field is defined by the KeyUpdateRequest enumeration, which includes update_not_requested(0) and update_requested(1). This rule applies after both peers have completed the handshake by sending Finished messages and are in the application data phase. If the request_update field is set to \"update_requested\", the recipient MUST respond by sending its own KeyUpdate message with request_update set to \"update_not_requested\" before sending any subsequent Application Data records. This mechanism ensures either peer can trigger a bidirectional key update, maintaining cryptographic synchronization. Implementations MUST terminate the connection with an \"illegal_parameter\" alert if they receive any value other than the defined enumeration values. KeyUpdate messages MUST be encrypted using the current (old) keys, and both parties MUST enforce that a KeyUpdate encrypted with the old keys is received and processed before accepting any traffic encrypted with the new keys to prevent truncation attacks.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update\"\nRule: The KeyUpdate structure contains a request_update field that indicates whether the recipient of the KeyUpdate should respond with its own KeyUpdate.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update",
    "sentence": "Both sender and receiver MUST encrypt their KeyUpdate messages with the old keys.",
    "enhanced_sentence": "After establishing a secure connection through the TLS 1.3 handshake (including the exchange of Finished messages), either peer may initiate a key update by sending a KeyUpdate message. This message MUST be encrypted and authenticated using the current (old) encryption keys and algorithms, not the new keys that are about to be activated. The receiver MUST also process and respond to KeyUpdate messages using the old keys until the key update is complete. This ensures cryptographic continuity and prevents truncation attacks by verifying that both parties have successfully synchronized the key update before switching to the new keys. The rule applies only after the handshake is fully completed and both sides have active encryption contexts.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update\"\nRule: Both sender and receiver MUST encrypt their KeyUpdate messages with the old keys.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update",
    "sentence": "Note that implementations may receive an arbitrary number of messages between sending a KeyUpdate with request_update set to \"update_requested\" and receiving the peer's KeyUpdate, because those messages may already be in flight.",
    "enhanced_sentence": "When an implementation sends a KeyUpdate message with request_update set to \"update_requested\", it must be prepared to receive an arbitrary number of messages (including Application Data, alerts, or other handshake messages) before receiving the peer's corresponding KeyUpdate response. This occurs because messages already in transit at the time of the KeyUpdate request may arrive before the peer processes and responds to the update. Implementations must continue to process these messages using the current receive keys until the peer's KeyUpdate is received and processed. This behavior ensures that in-flight messages are not incorrectly rejected due to premature key updates, maintaining protocol continuity without requiring retransmission or causing connection failures. The rule applies specifically during the post-handshake phase, after the Finished message has been exchanged, and assumes that both endpoints are following the key update procedure correctly.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update\"\nRule: Note that implementations may receive an arbitrary number of messages between sending a KeyUpdate with request_update set to \"update_requested\" and receiving the peer's KeyUpdate, because those messages may already be in flight.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update",
    "sentence": "If implementations independently send their own KeyUpdates with request_update set to \"update_requested\" and the KeyUpdates cross in flight, then each side will also send a response, with the result that each side increments by two generations.",
    "enhanced_sentence": "This rule governs the handling of simultaneous KeyUpdate requests during the TLS 1.3 post-handshake phase. When both peers independently send KeyUpdate messages with request_update set to \"update_requested\" and these messages cross in transit, each side must respond to the received KeyUpdate as required by the protocol. The expected outcome is that each peer will process both the received update request and send its own response, resulting in each side incrementing their key generation by two (from the initial update plus the response). This applies only after both sides have completed the handshake (including sending Finished messages) and are in the active communication phase. Prerequisites include proper encryption of KeyUpdate messages with the current keys and enforcement that KeyUpdates with old keys are processed before accepting messages with new keys to prevent truncation attacks.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update\"\nRule: If implementations independently send their own KeyUpdates with request_update set to \"update_requested\" and the KeyUpdates cross in flight, then each side will also send a response, with the result that each side increments by two generations.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update",
    "sentence": "Additionally, both sides MUST enforce that a KeyUpdate with the old key is received before accepting any messages encrypted with the new key.",
    "enhanced_sentence": "After either peer sends a KeyUpdate message (encrypted with the old keys), both sides MUST ensure that the corresponding KeyUpdate message from the peer (also encrypted with the old keys) is received and processed before accepting any subsequent messages encrypted with the new generation of keys. This rule applies during the key update exchange initiated after the handshake is complete (i.e., after Finished messages have been exchanged) and is critical to preventing message truncation attacks by ensuring both endpoints synchronize key transitions. The expected outcome is a secure, coordinated key update without gaps in cryptographic protection. Prerequisites include successful completion of the TLS 1.3 handshake and proper derivation of traffic secrets as defined in Section 7.2.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.3. Key and Initialization Vector Update\"\nRule: Additionally, both sides MUST enforce that a KeyUpdate with the old key is received before accepting any messages encrypted with the new key.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "5. Record Protocol",
    "sentence": "If an implementation detects a change_cipher_spec record received before the first ClientHello message or after the peer's Finished message, the change_cipher_spec record MUST be treated as an unexpected record type (though stateless servers may not be able to distinguish these cases from allowed cases).",
    "enhanced_sentence": "This rule governs the handling of change_cipher_spec records that occur outside the valid protocol window. The change_cipher_spec record type is maintained in TLS 1.3 solely for backward compatibility and should only appear between the first ClientHello message and the peer's Finished message during the handshake phase. If an implementation receives a change_cipher_spec record before the first ClientHello message (indicating no handshake has started) or after the peer's Finished message (indicating the handshake is complete), it MUST be treated as an unexpected record type. This requires terminating the connection with an \"unexpected_message\" alert, as specified for all unexpected record types. Note that stateless servers may have difficulty distinguishing these invalid cases from valid ones due to lack of session context, but stateful implementations must enforce this timing validation.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"5. Record Protocol\"\nRule: If an implementation detects a change_cipher_spec record received before the first ClientHello message or after the peer's Finished message, the change_cipher_spec record MUST be treated as an unexpected record type (though stateless servers may not be able to distinguish these cases from allowed cases).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "5. Record Protocol",
    "sentence": "An implementation may receive an unencrypted record of type change_cipher_spec consisting of the single byte value 0x01 at any time after the first ClientHello message has been sent or received and before the peer's Finished message has been received and MUST simply drop the change_cipher_spec record without further processing.",
    "enhanced_sentence": "During the TLS 1.3 handshake, an implementation may receive an unencrypted change_cipher_spec record (with the fixed value 0x01) at any time between the first ClientHello message being sent or received and before the peer's Finished message is received. This record type exists solely for backward compatibility with middleboxes that expect it in earlier TLS versions. The implementation MUST silently discard such records without any processing or alert generation. This rule applies only to unencrypted records with the exact value 0x01; any protected change_cipher_spec record or one with a different value MUST result in an \"unexpected_message\" alert and handshake abortion. Note that this exception is time-bound: records received before the first ClientHello or after the peer's Finished must be treated as unexpected and handled accordingly.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"5. Record Protocol\"\nRule: An implementation may receive an unencrypted record of type change_cipher_spec consisting of the single byte value 0x01 at any time after the first ClientHello message has been sent or received and before the peer's Finished message has been received and MUST simply drop the change_cipher_spec record without further processing.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "5. Record Protocol",
    "sentence": "Implementations MUST NOT send record types not defined in this document unless negotiated by some extension.",
    "enhanced_sentence": "Implementations MUST NOT send record types not defined in this document (i.e., types other than handshake, application_data, alert, and change_cipher_spec) unless explicitly negotiated through a TLS extension. This restriction applies throughout the entire TLS 1.3 connection lifecycle, from initial handshake to application data exchange. When followed, this rule ensures interoperability and prevents transmission of unsupported or unnegotiated record types that could cause protocol errors. If an implementation receives an unexpected record type, it MUST terminate the connection with an \"unexpected_message\" alert. Note that new record types may be introduced via IANA registration, but their use must still be negotiated through extensions before transmission.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"5. Record Protocol\"\nRule: Implementations MUST NOT send record types not defined in this document unless negotiated by some extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify",
    "sentence": "Servers MUST send this message when authenticating via a certificate.",
    "enhanced_sentence": "Servers MUST send a CertificateVerify message immediately after their Certificate message and before the Finished message when performing certificate-based authentication. This message provides explicit proof of possession of the private key corresponding to the server's certificate and ensures handshake integrity up to this point. The server's signature algorithm MUST be one offered in the client's \"signature_algorithms\" extension (unless no valid chain can be produced otherwise), MUST be compatible with the server's end-entity certificate, MUST NOT use SHA-1, and MUST use RSASSA-PSS for RSA keys. Receivers MUST validate the signature using the public key from the associated Certificate message and terminate the handshake with a \"decrypt_error\" alert if verification fails.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify\"\nRule: Servers MUST send this message when authenticating via a certificate.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "7. Cryptographic Computations",
    "sentence": "Note that because the handshake transcript includes the random values from the Hello messages, any given handshake will have different traffic secrets, even if the same input secrets are used, as is the case when the same PSK is used for multiple connections.",
    "enhanced_sentence": "This rule governs the derivation of traffic secrets during the TLS 1.3 handshake. It applies after the handshake transcript is finalized and before the key schedule generates application traffic keys. The expected outcome is that each connection using the same Pre-Shared Key (PSK) will produce unique traffic secrets, ensuring forward secrecy across sessions. Prerequisites include: (1) successful exchange of ClientHello and ServerHello messages containing fresh random values, (2) inclusion of these messages in the handshake transcript, and (3) availability of valid input secrets (e.g., PSK or Diffie-Hellman derived secrets). This behavior prevents key reuse across connections even when PSK reuse occurs, maintaining cryptographic separation between sessions.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"7. Cryptographic Computations\"\nRule: Note that because the handshake transcript includes the random values from the Hello messages, any given handshake will have different traffic secrets, even if the same input secrets are used, as is the case when the same PSK is used for multiple connections.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify",
    "sentence": "The CertificateVerify message also provides integrity for the handshake up to this point.",
    "enhanced_sentence": "The CertificateVerify message provides integrity for the handshake transcript up to this point by including a digital signature over a hash of all previous handshake messages (specifically, Transcript-Hash(Handshake Context, Certificate)). This rule applies when a server or client is authenticating via a certificate, immediately following the Certificate message and before the Finished message. The expected outcome is that the recipient can verify the signature using the sender’s public key, ensuring that the handshake has not been tampered with and that the sender possesses the corresponding private key. Prerequisites include: a valid certificate chain, a signature algorithm compatible with the sender’s public key and compliant with the peer’s advertised or requested algorithms (excluding SHA-1 and, for RSA, requiring RSASSA-PSS), and correct construction of the signature input (including a 64-byte pad, context string, separator, and transcript hash). If verification fails, the handshake must be aborted with a \"decrypt_error\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify\"\nRule: The CertificateVerify message also provides integrity for the handshake up to this point.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify",
    "sentence": "When sent, this message MUST appear immediately after the Certificate message and immediately prior to the Finished message.",
    "enhanced_sentence": "The CertificateVerify message MUST be positioned immediately after the Certificate message and immediately before the Finished message in the handshake sequence. This strict ordering applies whenever certificate-based authentication is performed—servers MUST send it when authenticating with a certificate, and clients MUST send it when the Certificate message is non-empty. The rule ensures that the explicit proof of private key possession (via digital signature) is provided right after the certificate is presented and before the handshake concludes, maintaining protocol integrity and preventing misordering attacks. Prerequisites include a valid certificate chain and a compatible signature algorithm as specified in the \"signature_algorithms\" extension. The expected outcome is a verifiable link between the certificate and the endpoint’s private key, enabling the receiver to validate the signature before proceeding to the Finished message.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify\"\nRule: When sent, this message MUST appear immediately after the Certificate message and immediately prior to the Finished message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify",
    "sentence": "Clients MUST send this message whenever authenticating via a certificate (i.e., when the Certificate message is non-empty).",
    "enhanced_sentence": "In TLS 1.3, clients MUST send the CertificateVerify message immediately after the Certificate message and before the Finished message whenever they are authenticating with a certificate (i.e., when the Certificate message is non-empty). This message provides explicit proof of possession of the private key corresponding to the client's certificate and ensures handshake integrity up to this point. The client's signature MUST be computed using an algorithm from the server's CertificateRequest supported_signature_algorithms, MUST be compatible with the client's end-entity certificate key, MUST NOT use SHA-1, and MUST follow the specified signature structure (including the 64-byte pad, context string \"TLS 1.3, client CertificateVerify\", separator, and transcript hash). If the server fails to verify this signature, it MUST terminate the handshake with a \"decrypt_error\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify\"\nRule: Clients MUST send this message whenever authenticating via a certificate (i.e., when the Certificate message is non-empty).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify",
    "sentence": "The content covered under the signature is the hash output as described in Section 4.4.1, namely: Transcript-Hash(Handshake Context, Certificate).",
    "enhanced_sentence": "The content covered under the signature in the CertificateVerify message is the hash output as described in Section 4.4.1, specifically: Transcript-Hash(Handshake Context, Certificate). This rule applies when a server or client is providing explicit proof of possession of the private key corresponding to its certificate, immediately following the Certificate message and before the Finished message. The expected outcome is that the signature, computed over a structured concatenation including this hash, can be verified by the recipient using the sender’s public key, ensuring handshake integrity and authentication. Prerequisites include: a non-empty Certificate message, a valid signature algorithm compatible with the sender’s certificate and the peer’s advertised supported algorithms (excluding SHA-1 and requiring RSASSA-PSS for RSA), and correct computation of the Transcript-Hash. Failure to comply results in handshake termination with a \"decrypt_error\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify\"\nRule: The content covered under the signature is the hash output as described in Section 4.4.1, namely: Transcript-Hash(Handshake Context, Certificate).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify",
    "sentence": "The structure of the CertificateVerify message is: struct { SignatureScheme algorithm; opaque signature<0..2^16-1>; } CertificateVerify.",
    "enhanced_sentence": "The CertificateVerify message provides explicit proof of private key ownership corresponding to the endpoint's certificate and ensures handshake integrity up to this point. It MUST be sent by servers when authenticating via certificate, and by clients whenever the Certificate message is non-empty. This message MUST appear immediately after the Certificate message and before the Finished message.\n\nThe structure is: struct { SignatureScheme algorithm; opaque signature<0..2^16-1>; } CertificateVerify.\n\nPrerequisites: The algorithm MUST be compatible with the sender's end-entity certificate and comply with client/server signature algorithm restrictions. RSA signatures MUST use RSASSA-PSS, and SHA-1 MUST NOT be used.\n\nThe signature is computed over a specific concatenation: 64 bytes of 0x20, the context string (\"TLS 1.3, server CertificateVerify\" or \"TLS 1.3, client CertificateVerify\"), a 0x00 separator, and Transcript-Hash(Handshake Context, Certificate). This construction prevents chosen-prefix attacks.\n\nExpected outcome: Receivers MUST verify the signature using the public key from the associated Certificate message. Verification failure MUST result in handshake termination with a \"decrypt_error\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify\"\nRule: The structure of the CertificateVerify message is: struct { SignatureScheme algorithm; opaque signature<0..2^16-1>; } CertificateVerify.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify",
    "sentence": "The context string for a client signature is \"TLS 1.3, client CertificateVerify\".",
    "enhanced_sentence": "The context string \"TLS 1.3, client CertificateVerify\" is used exclusively for client authentication signatures and MUST be included in the signature computation when a client sends a CertificateVerify message. This rule applies when a client is authenticating with a certificate (i.e., when the client's Certificate message is non-empty) and provides explicit proof of possession of the private key corresponding to the presented certificate. The context string ensures cryptographic separation between client and server signatures (\"TLS 1.3, server CertificateVerify\") to prevent cross-protocol attacks. The signature MUST be computed using an algorithm present in the server's CertificateRequest supported_signature_algorithms, MUST be compatible with the client's end-entity certificate key, MUST NOT use SHA-1, and MUST use RSASSA-PSS for RSA keys. The receiving server MUST verify this signature using the client's public key and terminate the handshake with a \"decrypt_error\" alert if verification fails.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify\"\nRule: The context string for a client signature is \"TLS 1.3, client CertificateVerify\".\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify",
    "sentence": "This structure is intended to prevent an attack on previous versions of TLS in which the ServerKeyExchange format meant that attackers could obtain a signature of a message with a chosen 32-byte prefix (ClientHello.random).",
    "enhanced_sentence": "The CertificateVerify message structure includes a 64-byte pad (0x20 repeated 64 times), a context-specific string, a 0x00 separator, and the transcript hash to form the signed content. This design specifically prevents a chosen-prefix attack present in earlier TLS versions where attackers could manipulate the ServerKeyExchange format to obtain signatures with a chosen 32-byte prefix (ClientHello.random). This rule applies when a server or client sends a CertificateVerify message for authentication, which must occur immediately after the Certificate message and before the Finished message. The expected outcome is that the signature covers a structured, context-separated input that eliminates the risk of prefix manipulation, ensuring that only a genuine party possessing the correct private key can produce a valid signature. Prerequisites include: the endpoint must have sent a non-empty Certificate message, the signature algorithm must be supported and compatible with the certificate's public key (with RSA requiring RSASSA-PSS and SHA-1 prohibited), and the receiver must validate the signature using the public key from the associated certificate, terminating the handshake with a \"decrypt_error\" alert upon failure.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify\"\nRule: This structure is intended to prevent an attack on previous versions of TLS in which the ServerKeyExchange format meant that attackers could obtain a signature of a message with a chosen 32-byte prefix (ClientHello.random).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify",
    "sentence": "The context string is used to provide separation between signatures made in different contexts, helping against potential cross-protocol attacks.",
    "enhanced_sentence": "The context string (\"TLS 1.3, server CertificateVerify\" or \"TLS 1.3, client CertificateVerify\") is used to provide separation between signatures made in different contexts, helping against potential cross-protocol attacks. This rule applies when constructing or verifying the CertificateVerify message, which must be sent immediately after the Certificate message and before the Finished message whenever certificate-based authentication is used. The context string is concatenated with a 64-byte pad and a separator byte before the transcript hash to form the signed content. The expected outcome is that signatures are bound to their specific TLS 1.3 handshake role (client or server), preventing signature reuse across different protocols or contexts. Prerequisites include having a valid end-entity certificate with a compatible private key, and the signature algorithm must be supported and negotiated per the protocol's rules (e.g., from the client's \"signature_algorithms\" extension for servers, or the CertificateRequest for clients).",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify\"\nRule: The context string is used to provide separation between signatures made in different contexts, helping against potential cross-protocol attacks.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify",
    "sentence": "If the CertificateVerify message is sent by a server, the signature algorithm MUST be one offered in the client's \"signature_algorithms\" extension unless no valid certificate chain can be produced without unsupported algorithms (see Section 4.2.3).",
    "enhanced_sentence": "When a server sends the CertificateVerify message during TLS 1.3 handshake authentication, the signature algorithm used MUST be one that was previously advertised in the client's \"signature_algorithms\" extension. This requirement ensures cryptographic algorithm compatibility between client and server, maintaining protocol security and interoperability. The only exception is when no valid certificate chain can be constructed without using algorithms not supported by the client (as detailed in Section 4.2.3). This rule applies specifically to server authentication immediately following the Certificate message and before the Finished message. Proper adherence results in successful signature verification and handshake continuation, while violation requires termination with a \"decrypt_error\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify\"\nRule: If the CertificateVerify message is sent by a server, the signature algorithm MUST be one offered in the client's \"signature_algorithms\" extension unless no valid certificate chain can be produced without unsupported algorithms (see Section 4.2.3).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify",
    "sentence": "The context string for a server signature is \"TLS 1.3, server CertificateVerify\".",
    "enhanced_sentence": "The context string \"TLS 1.3, server CertificateVerify\" is used exclusively for server-side signatures in the CertificateVerify message, which provides explicit proof of possession of the private key corresponding to the server's certificate and ensures handshake integrity. This rule applies when a server authenticates via a certificate, immediately following the Certificate message and before the Finished message. The context string is concatenated with a 64-byte pad (0x20 repeated) and a null separator before the transcript hash (Handshake Context + Certificate) to form the signed content, preventing cross-protocol and chosen-prefix attacks. Prerequisites include: the server must have sent a non-empty Certificate message, the signature algorithm must be one offered in the client's \"signature_algorithms\" extension (unless unavoidable for certificate chain validity), and it must be compatible with the server's end-entity certificate (RSA signatures must use RSASSA-PSS; SHA-1 is prohibited). The expected outcome is a verifiable digital signature that, when validated by the client using the server's public key, confirms authentication and handshake integrity without triggering a \"decrypt_error\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify\"\nRule: The context string for a server signature is \"TLS 1.3, server CertificateVerify\".\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify",
    "sentence": "On the sender side, the process for computing the signature field of the CertificateVerify message takes as input: the content covered by the digital signature, and the private signing key corresponding to the certificate sent in the previous message.",
    "enhanced_sentence": "This rule governs the generation of the CertificateVerify message signature, which provides explicit proof of possession of the private key corresponding to the certificate presented earlier in the handshake. It applies immediately after sending the Certificate message and before the Finished message, when a server or client is authenticating via a certificate. The expected outcome is a valid digital signature computed over the handshake transcript (as specified in Section 4.4.1) using the private key associated with the previously transmitted certificate. Prerequisites include: a valid end-entity certificate must have been sent in the preceding Certificate message, the selected signature algorithm must be compatible with the certificate's public key and comply with client/server algorithm restrictions, and SHA-1 must not be used. The signature is computed over a structured input that includes a 64-byte pad, a context string (\"TLS 1.3, server CertificateVerify\" or \"TLS 1.3, client CertificateVerify\"), a separator byte, and the transcript hash to prevent chosen-prefix attacks.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify\"\nRule: On the sender side, the process for computing the signature field of the CertificateVerify message takes as input: the content covered by the digital signature, and the private signing key corresponding to the certificate sent in the previous message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify",
    "sentence": "If sent by a client, the signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the \"signature_algorithms\" extension in the CertificateRequest message.",
    "enhanced_sentence": "When a client sends a CertificateVerify message during TLS 1.3 handshake authentication, the signature algorithm used MUST be one that was explicitly listed in the supported_signature_algorithms field of the server's CertificateRequest message. This rule applies after the client has sent its Certificate message and before sending the Finished message, ensuring that the client's signature algorithm selection aligns with the server's advertised capabilities. The expected outcome is a valid, verifiable signature that provides proof of possession of the private key corresponding to the client certificate. Prerequisites include: the client must be authenticating with a certificate, the server must have sent a CertificateRequest containing a \"signature_algorithms\" extension, and the selected algorithm must also be compatible with the client's end-entity certificate key.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify\"\nRule: If sent by a client, the signature algorithm used in the signature MUST be one of those present in the supported_signature_algorithms field of the \"signature_algorithms\" extension in the CertificateRequest message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify",
    "sentence": "RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in \"signature_algorithms\".",
    "enhanced_sentence": "When generating a CertificateVerify message for RSA-based authentication, the endpoint MUST use an RSASSA-PSS signature algorithm. This requirement applies regardless of whether RSASSA-PKCS1-v1_5 algorithms were advertised in the \"signature_algorithms\" extension during handshake negotiation. The rule applies to both clients and servers when they are authenticating with an RSA certificate and must produce a CertificateVerify message immediately following their Certificate message. The expected outcome is enhanced security by mandating the more modern and secure RSASSA-PSS algorithm over the deprecated RSASSA-PKCS1-v1_5, even when the latter is technically supported by both parties. This rule is conditional on the endpoint using an RSA certificate key and is enforced during the signature computation phase of the CertificateVerify message construction.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify\"\nRule: RSA signatures MUST use an RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5 algorithms appear in \"signature_algorithms\".\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify",
    "sentence": "In addition, the signature algorithm MUST be compatible with the key in the sender's end-entity certificate.",
    "enhanced_sentence": "When a CertificateVerify message is sent (by either client or server), the signature algorithm specified in the `algorithm` field MUST be compatible with the public key contained in the sender's end-entity certificate. This rule applies immediately after the Certificate message is sent and before the Finished message. The expected outcome is that the recipient can successfully verify the signature using the public key from the sender's certificate, ensuring proof of possession of the corresponding private key. Prerequisites include: the sender must have selected a signature algorithm that is both supported by the peer (as indicated in the \"signature_algorithms\" extension) and appropriate for the key type (e.g., RSA keys must use RSASSA-PSS; ECDSA keys must use an ECDSA-based algorithm). Incompatibility results in handshake termination with a \"decrypt_error\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify\"\nRule: In addition, the signature algorithm MUST be compatible with the key in the sender's end-entity certificate.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify",
    "sentence": "The receiver of a CertificateVerify message MUST verify the signature field.",
    "enhanced_sentence": "The receiver of a CertificateVerify message MUST verify the signature field by using the public key from the sender's end-entity certificate (received in the preceding Certificate message) to validate the digital signature against the computed transcript hash (as defined in Section 4.4.1). This verification MUST occur immediately after receiving the CertificateVerify message, which appears after the Certificate message and before the Finished message in the handshake sequence. The signature algorithm used MUST be consistent with the sender’s certificate key and the negotiated signature algorithms (as specified in \"signature_algorithms\" extensions). If verification fails, the receiver MUST abort the handshake with a \"decrypt_error\" alert to ensure integrity and authentication of the handshake.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify\"\nRule: The receiver of a CertificateVerify message MUST verify the signature field.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "5. Record Protocol -> 5.1. Record Layer",
    "sentence": "Because the ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate messages can immediately precede a key change, implementations MUST send these messages in alignment with a record boundary.",
    "enhanced_sentence": "Implementations MUST send ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate messages aligned with record boundaries because these messages can immediately precede a key change in the TLS 1.3 handshake or post-handshake update process. This alignment ensures that the subsequent record, which uses the new keying material, starts cleanly without fragmentation issues. If a message preceding a key change is not record-aligned, implementations MUST terminate the connection with an \"unexpected_message\" alert. This rule applies during both the initial handshake and any subsequent key updates, and it is stricter than TLS 1.2 requirements to prevent interleaving and boundary errors during cryptographic transitions.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"5. Record Protocol -> 5.1. Record Layer\"\nRule: Because the ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate messages can immediately precede a key change, implementations MUST send these messages in alignment with a record boundary.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify",
    "sentence": "For example, if the transcript hash was 32 bytes of 01 (this length would make sense for SHA-256), the content covered by the digital signature for a server CertificateVerify would be: 2020202020202020202020202020202020202020202020202020202020202020 2020202020202020202020202020202020202020202020202020202020202020 544c5320312e332c207365727665722043657274696669636174655665726966 79 00 0101010101010101010101010101010101010101010101010101010101010101.",
    "enhanced_sentence": "The CertificateVerify message provides explicit proof of private key ownership for the certificate presented and ensures handshake integrity. This message MUST be sent by servers when authenticating with a certificate and by clients when providing a non-empty Certificate message. It MUST appear immediately after the Certificate message and before the Finished message.\n\nThe digital signature in the CertificateVerify message covers a specific structure designed to prevent prefix attacks from earlier TLS versions. The signature input consists of:\n- 64 bytes of octet 0x20 (padding)\n- The context string (\"TLS 1.3, server CertificateVerify\" for servers, \"TLS 1.3, client CertificateVerify\" for clients)\n- A single 0x00 byte separator\n- The Transcript-Hash(Handshake Context, Certificate) value\n\nFor example, if using SHA-256 (producing a 32-byte hash) where the transcript hash consists of 32 bytes of 0x01, the server's signature input would be:\n2020202020202020202020202020202020202020202020202020202020202020\n2020202020202020202020202020202020202020202020202020202020202020\n544c5320312e332c207365727665722043657274696669636174655665726966\n79 00 0101010101010101010101010101010101010101010101010101010101010101\n\nPrerequisites: The sender must have a valid certificate chain, the signature algorithm must be compatible with the certificate's public key, and the algorithm must be supported by the peer (as indicated in signature_algorithms extensions). RSA signatures must use RSASSA-PSS, and SHA-1 MUST NOT be used.\n\nExpected outcome: The receiver verifies the signature using the public key from the associated Certificate message. If verification fails, the handshake MUST be terminated with a \"decrypt_error\" alert. Successful verification confirms the endpoint possesses the private key and validates handshake integrity.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify\"\nRule: For example, if the transcript hash was 32 bytes of 01 (this length would make sense for SHA-256), the content covered by the digital signature for a server CertificateVerify would be: 2020202020202020202020202020202020202020202020202020202020202020 2020202020202020202020202020202020202020202020202020202020202020 544c5320312e332c207365727665722043657274696669636174655665726966 79 00 0101010101010101010101010101010101010101010101010101010101010101.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify",
    "sentence": "The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages.",
    "enhanced_sentence": "When generating or processing a CertificateVerify message during TLS 1.3 handshake authentication, the signature algorithm used MUST NOT be SHA-1 or any SHA-1-based signature scheme (e.g., ecdsa_sha1, rsa_pkcs1_sha1). This rule applies immediately after the Certificate message and before the Finished message, whether the sender is a server or a client performing certificate-based authentication. The expected outcome is that only cryptographically secure hash algorithms (such as those from the SHA-2 or SHA-3 families) are used for signing, ensuring the integrity and authenticity of the handshake transcript. Prerequisites include: the endpoint must possess a valid certificate and corresponding private key, and the selected signature algorithm must be compatible with the certificate's public key and conform to the supported algorithms advertised in the \"signature_algorithms\" extension. SHA-1 is permitted only for validating legacy certificates but is explicitly prohibited for signing in CertificateVerify due to its vulnerability to collision attacks.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify\"\nRule: The SHA-1 algorithm MUST NOT be used in any signatures of CertificateVerify messages.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify",
    "sentence": "The verification process takes as input: the content covered by the digital signature, the public key contained in the end-entity certificate found in the associated Certificate message, and the digital signature received in the signature field of the CertificateVerify message.",
    "enhanced_sentence": "The receiver of a CertificateVerify message MUST verify the signature field. This verification applies immediately after receiving the CertificateVerify message, which follows the Certificate message and precedes the Finished message in the handshake flow. The process takes as input: the content covered by the digital signature (as defined in Section 4.4.1, including the 64-byte pad, context string, separator, and transcript hash), the public key contained in the end-entity certificate from the associated Certificate message, and the digital signature received in the signature field of the CertificateVerify message. Prerequisites include: the signature algorithm must be compatible with the sender’s end-entity certificate and comply with algorithm restrictions (e.g., no SHA-1, RSA must use RSASSA-PSS). The expected outcome is successful signature validation, confirming the sender possesses the private key corresponding to its certificate and ensuring handshake integrity. If verification fails, the receiver MUST terminate the handshake with a \"decrypt_error\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify\"\nRule: The verification process takes as input: the content covered by the digital signature, the public key contained in the end-entity certificate found in the associated Certificate message, and the digital signature received in the signature field of the CertificateVerify message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify",
    "sentence": "All SHA-1 signature algorithms in this specification are defined solely for use in legacy certificates and are not valid for CertificateVerify signatures.",
    "enhanced_sentence": "This rule governs the selection of signature algorithms for CertificateVerify messages in TLS 1.3. It applies when an endpoint (client or server) is generating a CertificateVerify signature to prove possession of the private key corresponding to its certificate. The rule explicitly prohibits the use of any SHA-1 based signature algorithms (such as ecdsa_sha1 or rsa_pkcs1_sha1) for CertificateVerify signatures, even if they appear in supported signature algorithm lists. SHA-1 algorithms are only permitted for validating legacy certificates in the certificate chain, but never for signing CertificateVerify messages. The expected outcome is that endpoints will use stronger hash algorithms (like SHA-256 or SHA-384) for CertificateVerify signatures, ensuring modern cryptographic security. This rule applies regardless of whether SHA-1 algorithms were advertised in signature_algorithms extensions, and receivers must reject CertificateVerify messages with SHA-1 signatures, terminating the handshake with a \"decrypt_error\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.4. Authentication Messages -> 4.4.3. Certificate Verify\"\nRule: All SHA-1 signature algorithms in this specification are defined solely for use in legacy certificates and are not valid for CertificateVerify signatures.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "6. Alert Protocol",
    "sentence": "The AlertDescription enumeration includes various alert types such as close_notify(0), unexpected_message(10), bad_record_mac(20), record_overflow(22), handshake_failure(40), bad_certificate(42), unsupported_certificate(43), certificate_revoked(44), certificate_expired(45), certificate_unknown(46), illegal_parameter(47), unknown_ca(48), access_denied(49), decode_error(50), decrypt_error(51), protocol_version(70), insufficient_security(71), internal_error(80), inappropriate_fallback(86), user_canceled(90), missing_extension(109), unsupported_extension(110), unrecognized_name(112), bad_certificate_status_response(113), unknown_psk_identity(115), certificate_required(116), and no_application_protocol(120).",
    "enhanced_sentence": "The AlertDescription enumeration defines all standardized alert types used in TLS 1.3 to signal connection closure or error conditions. This rule applies whenever an implementation needs to generate or process an alert message during any phase of the TLS connection. Each alert type corresponds to a specific condition: close_notify(0) indicates normal connection termination, while error alerts (e.g., unexpected_message(10), bad_record_mac(20), handshake_failure(40)) indicate abnormal conditions that require connection termination. All error alerts MUST be sent with AlertLevel=fatal and MUST result in immediate connection termination, with secrets being discarded (except PSKs from session tickets, which should be discarded if possible). Unknown alert types MUST be treated as error alerts. Prerequisites include establishing an encrypted connection state for alert transmission, and proper handling requires that implementations correctly map protocol errors to the appropriate alert type while ignoring the legacy severity level field.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"6. Alert Protocol\"\nRule: The AlertDescription enumeration includes various alert types such as close_notify(0), unexpected_message(10), bad_record_mac(20), record_overflow(22), handshake_failure(40), bad_certificate(42), unsupported_certificate(43), certificate_revoked(44), certificate_expired(45), certificate_unknown(46), illegal_parameter(47), unknown_ca(48), access_denied(49), decode_error(50), decrypt_error(51), protocol_version(70), insufficient_security(71), internal_error(80), inappropriate_fallback(86), user_canceled(90), missing_extension(109), unsupported_extension(110), unrecognized_name(112), bad_certificate_status_response(113), unknown_psk_identity(115), certificate_required(116), and no_application_protocol(120).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "5. Record Protocol -> 5.1. Record Layer",
    "sentence": "legacy_record_version MUST be set to 0x0303 for all records generated by a TLS 1.3 implementation other than an initial ClientHello, which is one not generated after a HelloRetryRequest, where legacy_record_version MAY also be 0x0301 for compatibility purposes.",
    "enhanced_sentence": "The legacy_record_version field in TLSPlaintext records MUST be set to 0x0303 (representing TLS 1.2) for all records generated by a TLS 1.3 implementation, with one specific exception: for an initial ClientHello (defined as one not sent in response to a HelloRetryRequest), the value MAY also be set to 0x0301 (representing TLS 1.0) to improve backward compatibility with older middleboxes that might otherwise incorrectly block the connection. This rule applies to all records transmitted during the TLS 1.3 handshake and application data exchange phases. The expected outcome is that TLS 1.3 implementations maintain interoperability with legacy infrastructure while correctly ignoring this deprecated field for protocol processing. Note that this field is purely for backward compatibility and MUST be ignored by receivers; the actual protocol version is negotiated through the supported_versions extension in the handshake.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"5. Record Protocol -> 5.1. Record Layer\"\nRule: legacy_record_version MUST be set to 0x0303 for all records generated by a TLS 1.3 implementation other than an initial ClientHello, which is one not generated after a HelloRetryRequest, where legacy_record_version MAY also be 0x0301 for compatibility purposes.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "9. Compliance Requirements -> 9.1. Mandatory-to-Implement Cipher Suites",
    "sentence": "A TLS-compliant application MUST support digital signatures with rsa_pkcs1_sha256 (for certificates), rsa_pss_rsae_sha256 (for CertificateVerify and certificates), and ecdsa_secp256r1_sha256.",
    "enhanced_sentence": "A TLS-compliant application MUST support the following digital signature algorithms to ensure interoperability and baseline security: rsa_pkcs1_sha256 (for validating X.509 certificates), rsa_pss_rsae_sha256 (for both CertificateVerify messages and certificates), and ecdsa_secp256r1_sha256. This requirement applies during the TLS 1.3 handshake when processing certificate chains and verifying signed handshake messages. Compliance ensures that the application can authenticate peers using commonly accepted and standards-compliant cryptographic methods, provided that the necessary certificate types and key materials (RSA or ECDSA keys) are available and correctly configured.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"9. Compliance Requirements -> 9.1. Mandatory-to-Implement Cipher Suites\"\nRule: A TLS-compliant application MUST support digital signatures with rsa_pkcs1_sha256 (for certificates), rsa_pss_rsae_sha256 (for CertificateVerify and certificates), and ecdsa_secp256r1_sha256.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message",
    "sentence": "At any time after the server has received the client Finished message, the server MAY send a NewSessionTicket message.",
    "enhanced_sentence": "After the server has successfully received and validated the client's Finished message, completing the full handshake, the server MAY send one or more NewSessionTicket messages at any time. This message creates a resumable session ticket containing a PSK derived from the resumption master secret, allowing the client to perform future abbreviated handshakes by including the ticket in the \"pre_shared_key\" extension. The server may issue multiple tickets for parallel connections or to encapsulate updated authentication state (e.g., after post-handshake client authentication). Each ticket must specify a lifetime not exceeding 7 days and include a unique nonce and securely generated random value for age obscurity. The associated PSK may only be used with a cipher suite matching the original connection's KDF hash algorithm, and clients should resume only when the SNI matches the original session to avoid wasting single-use tickets.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message\"\nRule: At any time after the server has received the client Finished message, the server MAY send a NewSessionTicket message.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "5. Record Protocol -> 5.1. Record Layer",
    "sentence": "In order to maximize backward compatibility, a record containing an initial ClientHello SHOULD have legacy_record_version 0x0301, reflecting TLS 1.0, and a record containing a second ClientHello or a ServerHello MUST have legacy_record_version 0x0303, reflecting TLS 1.2.",
    "enhanced_sentence": "This rule governs the backward-compatible handling of the legacy_record_version field in unencrypted TLS 1.3 handshake records. It applies specifically during the initial handshake phase before record protection is engaged. An initial ClientHello (sent prior to any HelloRetryRequest) SHOULD set legacy_record_version to 0x0301 (TLS 1.0) to improve interoperability with legacy middleboxes that may inspect or filter older TLS versions. In contrast, any subsequent ClientHello (triggered by a HelloRetryRequest) or the ServerHello response MUST set legacy_record_version to 0x0303 (TLS 1.2), as these messages occur later in the handshake and require stricter version signaling alignment. Note that this field is deprecated and MUST be ignored by receivers; its sole purpose is outward compatibility. The expected outcome is successful handshake progression even when intermediate network elements expect older TLS version values, while maintaining internal protocol consistency. Prerequisites: This rule only applies to plaintext handshake records before encryption begins; once record protection is active, the legacy version field is set to 0x0303 for all records.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"5. Record Protocol -> 5.1. Record Layer\"\nRule: In order to maximize backward compatibility, a record containing an initial ClientHello SHOULD have legacy_record_version 0x0301, reflecting TLS 1.0, and a record containing a second ClientHello or a ServerHello MUST have legacy_record_version 0x0303, reflecting TLS 1.2.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message",
    "sentence": "The NewSessionTicket message creates a unique association between the ticket value and a secret PSK derived from the resumption master secret (see Section 7).",
    "enhanced_sentence": "The NewSessionTicket message creates a unique association between the ticket value and a secret PSK derived from the resumption master secret (see Section 7). This rule applies after the server has received the client Finished message, when the server may send one or more NewSessionTicket messages to enable future session resumption. The expected outcome is that each ticket becomes a unique PSK identity that clients can use in subsequent handshakes by including the ticket in the \"pre_shared_key\" extension of their ClientHello. Prerequisites include: the connection must have completed the initial handshake (with server receiving client Finished), the resumption master secret must be available, and each ticket must be associated with a unique ticket_nonce to ensure distinct PSK derivation. The server must generate a fresh random ticket_age_add value for each ticket and should respect the maximum ticket lifetime of 7 days.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message\"\nRule: The NewSessionTicket message creates a unique association between the ticket value and a secret PSK derived from the resumption master secret (see Section 7).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message",
    "sentence": "Any ticket MUST only be resumed with a cipher suite that has the same KDF hash algorithm as that used to establish the original connection.",
    "enhanced_sentence": "When a client attempts to resume a session using a PSK derived from a NewSessionTicket, it MUST only use a cipher suite whose Key Derivation Function (KDF) hash algorithm matches the one used in the original connection that generated the ticket. This rule applies during the resumption handshake when the client includes the ticket in the \"pre_shared_key\" extension of its ClientHello. Adherence ensures cryptographic consistency and prevents security vulnerabilities that could arise from mixing incompatible hash algorithms. The original connection must have been fully established, including the derivation of the resumption master secret, and the server must have issued a valid ticket for this rule to be applicable.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message\"\nRule: Any ticket MUST only be resumed with a cipher suite that has the same KDF hash algorithm as that used to establish the original connection.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message",
    "sentence": "The client MAY use the PSK derived from the ticket for future handshakes by including the ticket value in the \"pre_shared_key\" extension in its ClientHello (Section 4.2.11).",
    "enhanced_sentence": "After successfully completing a full TLS 1.3 handshake and receiving a valid NewSessionTicket message from the server, the client MAY use the PSK derived from that ticket for future handshakes. This is achieved by including the ticket value in the \"pre_shared_key\" extension of subsequent ClientHello messages (Section 4.2.11), enabling resumption handshakes with reduced overhead. This option applies only when the client wishes to resume a previous session and the ticket has not expired (ticket lifetime ≤ 7 days). The expected outcome is a successful abbreviated handshake using the pre-shared key, provided the server accepts the ticket and all resumption conditions are met (including matching cipher suite KDF hash algorithms and valid SNI values). Note that servers may issue multiple tickets, and clients should manage them according to local policy, potentially using different tickets for parallel connections.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message\"\nRule: The client MAY use the PSK derived from the ticket for future handshakes by including the ticket value in the \"pre_shared_key\" extension in its ClientHello (Section 4.2.11).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message",
    "sentence": "Clients MUST only resume if the new SNI value is valid for the server certificate presented in the original session and SHOULD only resume if the SNI value matches the one used in the original session.",
    "enhanced_sentence": "When a client receives a NewSessionTicket message and considers resuming a session using the provided PSK in a future handshake, it MUST only proceed with resumption if the new Server Name Indication (SNI) value is valid for the server certificate that was presented in the original session. Additionally, the client SHOULD only resume if the new SNI value exactly matches the one used in the original session. This rule applies after the server has sent the NewSessionTicket and the client is preparing a ClientHello with the \"pre_shared_key\" extension. The expected outcome is that resumption only occurs when the SNI is both certificate-valid and, ideally, identical to the original, preventing unnecessary ticket use and ensuring security consistency. Prerequisites include having an established session with a valid server certificate and a received NewSessionTicket containing a resumption PSK.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message\"\nRule: Clients MUST only resume if the new SNI value is valid for the server certificate presented in the original session and SHOULD only resume if the SNI value matches the one used in the original session.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message",
    "sentence": "Although the resumption master secret depends on the client's second flight, a server which does not request client authentication MAY compute the remainder of the transcript independently and then send a NewSessionTicket immediately upon sending its Finished rather than waiting for the client Finished.",
    "enhanced_sentence": "This rule governs the timing of NewSessionTicket message transmission in TLS 1.3. It applies specifically to servers that do not require client authentication. Although the resumption master secret calculation depends on the client's second flight (which includes the client's Finished message), such servers MAY compute the remainder of the handshake transcript independently. This allows them to send a NewSessionTicket immediately after transmitting their own Finished message, without waiting to receive the client's Finished message. The expected outcome is reduced connection setup latency for clients expected to open multiple parallel TLS connections, as they can immediately benefit from session resumption capabilities. This optimization is only permissible when client authentication is not requested, as the complete handshake transcript including client authentication would otherwise be necessary for proper cryptographic computations.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message\"\nRule: Although the resumption master secret depends on the client's second flight, a server which does not request client authentication MAY compute the remainder of the transcript independently and then send a NewSessionTicket immediately upon sending its Finished rather than waiting for the client Finished.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message",
    "sentence": "The NewSessionTicket structure contains: ticket_lifetime indicates the lifetime in seconds as a 32-bit unsigned integer in network byte order from the time of ticket issuance.",
    "enhanced_sentence": "The NewSessionTicket structure contains: ticket_lifetime indicates the lifetime in seconds as a 32-bit unsigned integer in network byte order from the time of ticket issuance. This rule applies after the server has received the client Finished message and when issuing a new session ticket for resumption purposes. The expected outcome is that clients can use this ticket for future handshakes within the specified lifetime period. Prerequisites include: the server MUST NOT use values greater than 604800 seconds (7 days), a value of zero indicates immediate ticket discard, and clients MUST NOT cache tickets longer than 7 days regardless of the stated lifetime. The server must generate this value as part of creating a unique association between the ticket and a PSK derived from the resumption master secret.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message\"\nRule: The NewSessionTicket structure contains: ticket_lifetime indicates the lifetime in seconds as a 32-bit unsigned integer in network byte order from the time of ticket issuance.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message",
    "sentence": "The requirement to match the SNI value is a performance optimization: normally, there is no reason to expect that different servers covered by a single certificate would be able to accept each other's tickets; hence, attempting resumption in that case would waste a single-use ticket.",
    "enhanced_sentence": "This rule governs client behavior during TLS 1.3 session resumption when using pre-shared keys (PSKs) from NewSessionTicket messages. It applies when a client considers resuming a session with a different Server Name Indication (SNI) value than was used in the original session that produced the ticket. The expected outcome is that clients SHOULD only attempt resumption if the SNI value matches the one used in the original session, as this prevents wasting single-use tickets on servers that are unlikely to accept them. This requirement is a performance optimization based on the observation that different servers covered by a single certificate (e.g., via Subject Alternative Names) typically cannot accept each other's tickets due to cryptographic binding. The prerequisite is that the client has received a valid NewSessionTicket and is preparing a ClientHello with the \"pre_shared_key\" extension. However, if external information indicates that servers under a shared certificate can accept cross-tickets, clients MAY resume with a different SNI value.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message\"\nRule: The requirement to match the SNI value is a performance optimization: normally, there is no reason to expect that different servers covered by a single certificate would be able to accept each other's tickets; hence, attempting resumption in that case would waste a single-use ticket.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message",
    "sentence": "If an indication is provided that different servers covered by a single certificate can accept each other's tickets (externally or by any other means), clients MAY resume with a different SNI value.",
    "enhanced_sentence": "When a client receives a NewSessionTicket message and intends to resume a session using the PSK derived from that ticket, it MUST normally resume only if the SNI value matches the one used in the original session, as a performance optimization to avoid wasting single-use tickets. However, if an external indication or other reliable means confirms that different servers covered by a single certificate can accept each other's tickets, the client MAY resume the session with a different SNI value. This rule applies during the ClientHello phase of a resumed handshake, where the client includes the ticket in the \"pre_shared_key\" extension. The expected outcome is that resumption may proceed successfully even with a changed SNI, provided the server supports cross-ticket acceptance. Prerequisites include the server having issued the ticket after the initial handshake and the resumed cipher suite using the same KDF hash algorithm as the original connection.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message\"\nRule: If an indication is provided that different servers covered by a single certificate can accept each other's tickets (externally or by any other means), clients MAY resume with a different SNI value.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message",
    "sentence": "On resumption, if reporting an SNI value to the calling application, implementations MUST use the value sent in the resumption ClientHello rather than the value sent in the previous session.",
    "enhanced_sentence": "When a TLS 1.3 session is being resumed using a PSK from a NewSessionTicket, if the implementation needs to report the Server Name Indication (SNI) value to the calling application, it MUST use the SNI value that was sent in the current resumption ClientHello message, not the SNI value from the original session that generated the ticket. This rule applies specifically during the resumption handshake after the client has included the ticket in the \"pre_shared_key\" extension. The expected outcome is that the application receives the SNI value actually requested in the resumed connection, which may differ from the original session if the client is connecting to a different server covered by the same certificate. This requirement ensures consistent SNI reporting regardless of whether the server accepts resumptions with different SNI values. Note that if the server policy rejects all PSK identities with mismatched SNI values, both values will be identical, but implementations must still follow this rule for correctness.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message\"\nRule: On resumption, if reporting an SNI value to the calling application, implementations MUST use the value sent in the resumption ClientHello rather than the value sent in the previous session.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message",
    "sentence": "A server MAY treat a ticket as valid for a shorter period of time than what is stated in the ticket_lifetime.",
    "enhanced_sentence": "After issuing a NewSessionTicket message, a server MAY enforce a shorter validity period for the ticket than the ticket_lifetime value it transmitted, based on local policy or security considerations such as key rotation, certificate expiration, or risk of revocation. This rule applies when a client attempts to resume a session using the ticket, and the server must validate the ticket's acceptability. If the server determines the ticket has expired according to its internal policy, it MUST reject the resumption attempt and either negotiate a full handshake or, if no acceptable PSK is provided, abort the connection. This rule is conditional on the server having initially issued the ticket with a valid ticket_lifetime and the client presenting the ticket in a \"pre_shared_key\" extension during a subsequent handshake.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message\"\nRule: A server MAY treat a ticket as valid for a shorter period of time than what is stated in the ticket_lifetime.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message",
    "sentence": "extensions is a set of extension values for the ticket.",
    "enhanced_sentence": "The `extensions` field in the NewSessionTicket message contains a set of extension values that provide additional metadata or capabilities associated with the ticket. This rule applies after the server has received the client's Finished message and is issuing a new session ticket for resumption purposes. The expected outcome is that clients can use these extensions to understand ticket-specific properties, such as whether 0-RTT data is permitted (via the `early_data` extension). Clients MUST ignore any unrecognized extensions, ensuring forward compatibility. Prerequisites include the successful completion of the handshake and derivation of the resumption master secret. The server may include extensions to convey ticket-specific parameters that enhance the functionality or security of the resumed session.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message\"\nRule: extensions is a set of extension values for the ticket.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message",
    "sentence": "Clients MUST ignore unrecognized extensions.",
    "enhanced_sentence": "When processing a NewSessionTicket message received after the server has sent its Finished message, clients MUST ignore any extension in the \"extensions\" field that they do not recognize. This rule applies to all NewSessionTicket messages, including multiple tickets sent on a single connection. The expected behavior is that clients silently skip unsupported extensions without generating errors or altering the processing of recognized extensions (such as the \"early_data\" extension). This ensures forward compatibility as new extensions may be defined in future versions of the protocol, while maintaining the integrity of the session ticket mechanism.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message\"\nRule: Clients MUST ignore unrecognized extensions.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message",
    "sentence": "ticket_age_add is a securely generated, random 32-bit value that is used to obscure the age of the ticket that the client includes in the \"pre_shared_key\" extension.",
    "enhanced_sentence": "The `ticket_age_add` field in the NewSessionTicket message is a securely generated, random 32-bit value that the server MUST generate uniquely for each ticket. This value is used to cryptographically obscure the true age of the ticket when the client includes it in the \"pre_shared_key\" extension during a subsequent resumption handshake. The client calculates the obfuscated ticket age by adding its locally computed ticket age to this `ticket_age_add` value modulo 2^32 before transmitting it to the server. This mechanism prevents passive observers from correlating sessions based on ticket age timing information while allowing the server to accurately verify that the ticket is within its valid lifetime by subtracting the `ticket_age_add` value. This rule applies when the server issues new session tickets after the handshake is complete (post-client Finished message) and is essential for maintaining privacy properties during TLS 1.3 session resumption.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message\"\nRule: ticket_age_add is a securely generated, random 32-bit value that is used to obscure the age of the ticket that the client includes in the \"pre_shared_key\" extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message",
    "sentence": "The sole extension currently defined for NewSessionTicket is \"early_data\", indicating that the ticket may be used to send 0-RTT data (Section 4.2.10).",
    "enhanced_sentence": "The NewSessionTicket message MAY include an \"extensions\" field, where the only currently defined extension is \"early_data\". This extension indicates that the ticket can be used to establish a 0-RTT resumption handshake, allowing the client to send application data immediately upon connection (as specified in Section 4.2.10). This rule applies when the server issues a NewSessionTicket after a successful full handshake, provided that the original handshake and cipher suite support 0-RTT. The expected outcome is that clients receiving a ticket with the \"early_data\" extension may use it to send early data up to the specified max_early_data_size in subsequent connections. Implementations MUST ignore any unrecognized extensions in the ticket, and servers MUST only include the \"early_data\" extension if the associated PSK and cipher suite are compatible with 0-RTT data transmission.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message\"\nRule: The sole extension currently defined for NewSessionTicket is \"early_data\", indicating that the ticket may be used to send 0-RTT data (Section 4.2.10).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "5. Record Protocol -> 5.2. Record Payload Protection",
    "sentence": "Note that the handshake protocol, including the ClientHello and ServerHello messages, authenticates the protocol version, so the legacy_record_version field is redundant.",
    "enhanced_sentence": "When implementing TLS 1.3 record payload protection, note that the handshake protocol (including ClientHello and ServerHello messages) has already authenticated the negotiated protocol version through cryptographic verification. This authentication occurs during the initial handshake phase before any encrypted records are exchanged. Therefore, the legacy_record_version field in the TLSCiphertext structure, which is always set to 0x0303 for compatibility, serves no security purpose and is functionally redundant. This rule applies specifically to TLS 1.3 implementations after successful version negotiation. The expected outcome is that implementations correctly recognize that the legacy_record_version field provides no additional security validation and should not be used for any version-related decisions. The prerequisite is that a valid TLS 1.3 handshake has been completed, establishing authenticated protocol version agreement between both endpoints.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"5. Record Protocol -> 5.2. Record Payload Protection\"\nRule: Note that the handshake protocol, including the ClientHello and ServerHello messages, authenticates the protocol version, so the legacy_record_version field is redundant.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message",
    "sentence": "Because the ticket_nonce value is distinct for each NewSessionTicket message, a different PSK will be derived for each ticket.",
    "enhanced_sentence": "After a TLS 1.3 handshake completes (post-server Finished message), when a server sends multiple NewSessionTicket messages on a single connection—either sequentially or after specific events like post-handshake authentication—each ticket MUST contain a unique ticket_nonce value. This distinct nonce ensures that each derived PSK (computed as HKDF-Expand-Label(resumption_master_secret, \"resumption\", ticket_nonce, Hash.length)) is cryptographically separate, preventing ticket correlation and enabling secure parallel use (e.g., for multiple HTTP connections or connection racing). Prerequisites: The resumption_master_secret must be established, and tickets must only be resumed with the same KDF hash algorithm as the original connection. Expected outcome: Clients can independently use each ticket for future handshakes without compromising security or affecting other tickets.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"4. Handshake Protocol -> 4.6. Post-Handshake Messages -> 4.6.1. New Session Ticket Message\"\nRule: Because the ticket_nonce value is distinct for each NewSessionTicket message, a different PSK will be derived for each ticket.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "6. Alert Protocol -> 6.2. Error Alerts",
    "sentence": "bad_certificate: A certificate was corrupt, contained signatures that did not verify correctly, etc.",
    "enhanced_sentence": "bad_certificate: A fatal alert sent when a certificate is found to be invalid during certificate verification, including cases where the certificate structure is corrupt, cryptographic signatures fail to verify, or other integrity checks fail. This alert applies during the handshake phase when processing certificates (typically in CertificateVerify or Certificate messages) and requires immediate termination of the connection. The implementation MUST close the connection after sending this alert and MUST NOT process any further data. Prerequisites include successful parsing of the certificate structure and active certificate validation according to the negotiated security parameters.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"6. Alert Protocol -> 6.2. Error Alerts\"\nRule: bad_certificate: A certificate was corrupt, contained signatures that did not verify correctly, etc.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "6. Alert Protocol -> 6.2. Error Alerts",
    "sentence": "unknown_ca: A valid certificate chain or partial chain was received, but the certificate was not accepted because the CA certificate could not be located or could not be matched with a known trust anchor.",
    "enhanced_sentence": "unknown_ca: This fatal alert MUST be sent by a TLS 1.3 implementation when it receives a valid certificate chain or partial chain during the handshake, but cannot accept the certificate because the Certificate Authority (CA) certificate is either not found in the local trust store or cannot be matched with any known trust anchor. This condition typically occurs during server or client certificate verification. Upon sending this alert, the implementation MUST immediately terminate the connection as required for all fatal alerts. This alert applies when the certificate structure is syntactically correct and signatures are valid, but trust cannot be established due to missing or unrecognized CA credentials.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"6. Alert Protocol -> 6.2. Error Alerts\"\nRule: unknown_ca: A valid certificate chain or partial chain was received, but the certificate was not accepted because the CA certificate could not be located or could not be matched with a known trust anchor.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "8. 0-RTT and Anti-Replay -> 8.3. Freshness Checks",
    "sentence": "The server can determine the client's view of the age of the ticket by subtracting the ticket's \"ticket_age_add\" value from the \"obfuscated_ticket_age\" parameter in the client's \"pre_shared_key\" extension.",
    "enhanced_sentence": "This rule applies during the TLS 1.3 handshake when a client attempts to resume a session using a pre-shared key (PSK) for 0-RTT data. The server must verify the freshness of the PSK to mitigate replay risks. To do this, the server calculates the client's perceived ticket age by subtracting the \"ticket_age_add\" value (a random nonce from the original NewSessionTicket message) from the \"obfuscated_ticket_age\" provided in the client's \"pre_shared_key\" extension. This computed value, combined with the server's stored adjusted creation time of the ticket, allows the server to estimate the ClientHello's arrival time and compare it against the current time. If the difference exceeds a configured threshold (typically on the order of seconds), the server should reject 0-RTT data to prevent potential replay attacks, though it may still proceed with a 1-RTT handshake. This mechanism requires that the server previously stored the ticket's creation time adjusted for estimated RTT and that the client correctly includes the obfuscated age in the extension.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"8. 0-RTT and Anti-Replay -> 8.3. Freshness Checks\"\nRule: The server can determine the client's view of the age of the ticket by subtracting the ticket's \"ticket_age_add\" value from the \"obfuscated_ticket_age\" parameter in the client's \"pre_shared_key\" extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "8. 0-RTT and Anti-Replay",
    "sentence": "Such a guarantee can be accomplished by locally recording data from recently received ClientHellos and rejecting repeats, or by any other method that provides the same or a stronger guarantee.",
    "enhanced_sentence": "To mitigate replay attacks on 0-RTT data, each server instance (e.g., a machine, thread, or entity within the infrastructure) MUST ensure that it accepts the same 0-RTT handshake at most once. This applies during the processing of ClientHello messages in the TLS 1.3 handshake when early data is present. The expected outcome is that duplicate ClientHellos carrying the same 0-RTT payload are detected and rejected, preventing multiple acceptances of the same data by a single server instance. This can be achieved by methods such as locally recording unique identifiers from recently received ClientHellos (e.g., PSK binders or nonces) and rejecting repeats, or by any alternative method that provides equivalent or stronger anti-replay guarantees. Prerequisites include the server supporting 0-RTT and having mechanisms to track or uniquely identify ClientHello messages, though the exact implementation may vary based on operational constraints.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"8. 0-RTT and Anti-Replay\"\nRule: Such a guarantee can be accomplished by locally recording data from recently received ClientHellos and rejecting repeats, or by any other method that provides the same or a stronger guarantee.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "8. 0-RTT and Anti-Replay -> 8.3. Freshness Checks",
    "sentence": "When a new ClientHello is received, the expected_arrival_time is then compared against the current server wall clock time and if the times differ by more than a certain amount, 0-RTT is rejected, though the 1-RTT handshake can be allowed to complete.",
    "enhanced_sentence": "This rule governs the freshness check mechanism for 0-RTT data in TLS 1.3, which applies when a server receives a new ClientHello message containing a pre-shared key (PSK) for 0-RTT resumption. The server must compute the expected_arrival_time by combining the adjusted session ticket creation time (creation_time + estimated_RTT) with the client's reported ticket_age (derived from the obfuscated_ticket_age minus ticket_age_add). This expected_arrival_time is then compared against the server's current wall clock time. If the absolute time difference exceeds a configured tolerance window (typically on the order of seconds to account for clock skew and network delays), the server MUST reject 0-RTT early data to mitigate replay risks, though it SHOULD still allow the 1-RTT handshake to proceed normally. This mechanism requires that the server encodes sufficient timing information in the session ticket and that the client provides accurate ticket_age values. Note that this check occurs only at ClientHello receipt and does not prevent replays within the tolerance window or monitor timing of subsequent early data records.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"8. 0-RTT and Anti-Replay -> 8.3. Freshness Checks\"\nRule: When a new ClientHello is received, the expected_arrival_time is then compared against the current server wall clock time and if the times differ by more than a certain amount, 0-RTT is rejected, though the 1-RTT handshake can be allowed to complete.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "8. 0-RTT and Anti-Replay -> 8.3. Freshness Checks",
    "sentence": "Both the NewSessionTicket and ClientHello messages might be retransmitted and therefore delayed, which might be hidden by TCP.",
    "enhanced_sentence": "When implementing the 0-RTT freshness checking mechanism, servers must account for potential message delays caused by retransmissions of both NewSessionTicket (sent by server) and ClientHello (sent by client) messages. These retransmissions may occur at the TLS layer but remain hidden by TCP's reliable delivery mechanism, which can mask underlying delays. This rule applies during the processing of a ClientHello containing a pre-shared key for 0-RTT data, specifically when comparing the expected_arrival_time (calculated from ticket creation time and client-provided ticket_age) against the server's current time. The expected outcome is that servers should incorporate a tolerance window (typically on the order of seconds) to accommodate these potential delays rather than immediately rejecting 0-RTT when small timing mismatches occur. This rule requires that the server has implemented the freshness checking mechanism described in Section 8.2, including proper encoding of adjusted_creation_time in tickets and correct calculation of expected_arrival_time using the client's obfuscated_ticket_age and ticket_age_add values.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"8. 0-RTT and Anti-Replay -> 8.3. Freshness Checks\"\nRule: Both the NewSessionTicket and ClientHello messages might be retransmitted and therefore delayed, which might be hidden by TCP.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "6. Alert Protocol -> 6.2. Error Alerts",
    "sentence": "unsupported_extension: Sent by endpoints receiving any handshake message containing an extension known to be prohibited for inclusion in the given handshake message, or including any extensions in a ServerHello or Certificate not first offered in the corresponding ClientHello or CertificateRequest.",
    "enhanced_sentence": "The `unsupported_extension` alert is a fatal error that MUST be sent by an endpoint when it receives a handshake message containing an extension that violates TLS 1.3 extension negotiation rules. This applies in two specific scenarios: 1) when an extension is included in a handshake message type where that extension is explicitly prohibited by the specification, or 2) when the server includes any extension in a ServerHello or Certificate message that was not first offered by the client in the corresponding ClientHello or CertificateRequest. This rule ensures proper extension negotiation flow and prevents unexpected extension processing. Upon sending or receiving this alert, both parties MUST immediately terminate the connection without further data exchange.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"6. Alert Protocol -> 6.2. Error Alerts\"\nRule: unsupported_extension: Sent by endpoints receiving any handshake message containing an extension known to be prohibited for inclusion in the given handshake message, or including any extensions in a ServerHello or Certificate not first offered in the corresponding ClientHello or CertificateRequest.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "6. Alert Protocol -> 6.2. Error Alerts",
    "sentence": "decrypt_error: A handshake (not record layer) cryptographic operation failed, including being unable to correctly verify a signature or validate a Finished message or a PSK binder.",
    "enhanced_sentence": "decrypt_error: A fatal alert that MUST be sent when any handshake-layer (not record-layer) cryptographic operation fails during the TLS 1.3 handshake process. This includes failures in signature verification (e.g., CertificateVerify message), Finished message validation, or PSK binder verification. The alert applies specifically during the handshake phase when cryptographic operations are being performed to establish session security. Upon detecting such a failure, the implementation MUST immediately send this alert and terminate the connection without processing any further data. This alert serves as a cryptographic integrity check failure indicator for handshake messages and helps prevent protocol downgrade attacks and man-in-the-middle attacks by ensuring all cryptographic operations complete successfully before proceeding. Prerequisites include successful parsing of handshake messages and proper key derivation up to the point of failure.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"6. Alert Protocol -> 6.2. Error Alerts\"\nRule: decrypt_error: A handshake (not record layer) cryptographic operation failed, including being unable to correctly verify a signature or validate a Finished message or a PSK binder.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "6. Alert Protocol -> 6.2. Error Alerts",
    "sentence": "unrecognized_name: Sent by servers when no server exists identified by the name provided by the client via the \"server_name\" extension (see RFC6066 Extensions: Extension Definitions).",
    "enhanced_sentence": "unrecognized_name: This fatal alert is sent by servers during the TLS handshake when the client's \"server_name\" extension (RFC6066) specifies a hostname that does not match any valid server configuration at the receiving endpoint. This rule applies when the server receives a ClientHello containing the server_name extension but cannot resolve the provided name to a valid service. Upon sending this alert, the server MUST immediately terminate the connection as it cannot proceed with a handshake for an unrecognized server identity. This mechanism prevents clients from connecting to unintended or misconfigured services and ensures proper server name indication (SNI) handling. The alert should only be sent if the server explicitly supports the server_name extension but cannot match the provided name.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"6. Alert Protocol -> 6.2. Error Alerts\"\nRule: unrecognized_name: Sent by servers when no server exists identified by the name provided by the client via the \"server_name\" extension (see RFC6066 Extensions: Extension Definitions).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "6. Alert Protocol -> 6.2. Error Alerts",
    "sentence": "bad_certificate_status_response: Sent by clients when an invalid or unacceptable OCSP response is provided by the server via the \"status_request\" extension (see RFC6066 Extensions: Extension Definitions).",
    "enhanced_sentence": "bad_certificate_status_response: This fatal alert MUST be sent by clients when the server provides an invalid or unacceptable OCSP response through the \"status_request\" extension (RFC6066) during certificate status verification. This rule applies during the handshake phase when the client has requested certificate status information and the server's response fails validation checks (e.g., invalid signature, expired response, or incorrect certificate matching). Upon detecting such an error, the client MUST immediately send this alert and terminate the connection without processing further data. This ensures that clients do not proceed with connections where certificate revocation status cannot be reliably verified, maintaining the security guarantees of certificate-based authentication.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"6. Alert Protocol -> 6.2. Error Alerts\"\nRule: bad_certificate_status_response: Sent by clients when an invalid or unacceptable OCSP response is provided by the server via the \"status_request\" extension (see RFC6066 Extensions: Extension Definitions).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "6. Alert Protocol -> 6.2. Error Alerts",
    "sentence": "no_application_protocol: Sent by servers when a client \"application_layer_protocol_negotiation\" extension advertises only protocols that the server does not support (see RFC7301 Application-Layer Protocol Negotiation Extension).",
    "enhanced_sentence": "no_application_protocol: This fatal alert is sent by servers during the TLS handshake when the client's \"application_layer_protocol_negotiation\" (ALPN) extension contains a list of protocols that the server does not support. This rule applies after the server processes the ClientHello and determines that none of the client-advertised application protocols (e.g., HTTP/2, HTTP/1.1) are acceptable for the connection. Upon sending this alert, the server MUST immediately terminate the connection without proceeding further. This ensures that both parties avoid attempting to communicate over an incompatible application protocol. The prerequisite is that the client must have included the ALPN extension in its ClientHello, and the server must have evaluated the offered protocol list against its own supported protocols.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"6. Alert Protocol -> 6.2. Error Alerts\"\nRule: no_application_protocol: Sent by servers when a client \"application_layer_protocol_negotiation\" extension advertises only protocols that the server does not support (see RFC7301 Application-Layer Protocol Negotiation Extension).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions",
    "sentence": "All implementations MUST send and use these extensions when offering applicable features: \"supported_versions\" is REQUIRED for all ClientHello, ServerHello, and HelloRetryRequest messages.",
    "enhanced_sentence": "All implementations MUST include and process the \"supported_versions\" extension in all ClientHello, ServerHello, and HelloRetryRequest messages to indicate and negotiate the TLS protocol version being used. This rule applies during the initial handshake phase when establishing or resuming a TLS 1.3 connection. The expected outcome is proper version negotiation, ensuring both parties agree on a compatible TLS version and preventing version downgrade attacks. This requirement is mandatory regardless of other extensions or features being used, and implementations must send this extension even if no other extensions are included. Failure to include \"supported_versions\" where required will result in a handshake failure with a \"missing_extension\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions\"\nRule: All implementations MUST send and use these extensions when offering applicable features: \"supported_versions\" is REQUIRED for all ClientHello, ServerHello, and HelloRetryRequest messages.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions",
    "sentence": "\"signature_algorithms\" is REQUIRED for certificate authentication.",
    "enhanced_sentence": "The \"signature_algorithms\" extension (Section 4.2.3) is REQUIRED for certificate authentication in TLS 1.3. This extension MUST be included in the ClientHello message when the client is attempting to negotiate TLS 1.3 and not using a pre-shared key (PSK). It specifies the set of signature algorithms the client supports for verifying server certificates and CertificateVerify messages. If this extension is absent when required, the server MUST abort the handshake with a \"missing_extension\" alert. This requirement ensures that both parties can agree on cryptographically secure signature schemes for certificate-based authentication.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions\"\nRule: \"signature_algorithms\" is REQUIRED for certificate authentication.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions",
    "sentence": "\"supported_groups\" is REQUIRED for ClientHello messages using DHE or ECDHE key exchange.",
    "enhanced_sentence": "When a client initiates a TLS 1.3 handshake using DHE or ECDHE key exchange (as indicated by the presence of the \"key_share\" extension), it MUST include the \"supported_groups\" extension in its ClientHello message. This extension lists the client's supported finite field or elliptic curve groups for key exchange, enabling the server to select a mutually supported group and proceed with the handshake. Failure to include this extension when using DHE or ECDHE key exchange will result in the server aborting the handshake with a \"missing_extension\" alert. This requirement applies only if the client is not using a pre-shared key (PSK) for key agreement.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions\"\nRule: \"supported_groups\" is REQUIRED for ClientHello messages using DHE or ECDHE key exchange.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions",
    "sentence": "\"psk_key_exchange_modes\" is REQUIRED for PSK key agreement.",
    "enhanced_sentence": "The \"psk_key_exchange_modes\" extension is REQUIRED for any handshake using PSK key agreement. This extension governs the client's signaling of supported PSK key exchange methods (e.g., PSK-only or PSK with (EC)DHE) and must be included in the ClientHello when a \"pre_shared_key\" extension is present. The server uses this information to select an appropriate PSK mode and proceed with the handshake. Failure to include this extension when attempting PSK key agreement will result in the server aborting the handshake with a \"missing_extension\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions\"\nRule: \"psk_key_exchange_modes\" is REQUIRED for PSK key agreement.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions",
    "sentence": "\"key_share\" is REQUIRED for DHE or ECDHE key exchange.",
    "enhanced_sentence": "The \"key_share\" extension (Section 4.2.8) is REQUIRED for all TLS 1.3 handshakes using DHE or ECDHE key exchange. This extension must be included in the ClientHello message when offering DHE/ECDHE key exchange and must contain at least one KeyShareEntry (though an empty vector is permitted). It is used to transmit the client's ephemeral key share for the key exchange. The extension MUST be sent if the \"supported_groups\" extension is present, and vice versa. Failure to include this extension when required will result in the server aborting the handshake with a \"missing_extension\" alert. This rule applies to all TLS 1.3-compliant implementations unless overridden by an application profile standard.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions\"\nRule: \"key_share\" is REQUIRED for DHE or ECDHE key exchange.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions",
    "sentence": "\"pre_shared_key\" is REQUIRED for PSK key agreement.",
    "enhanced_sentence": "When a TLS 1.3 implementation intends to use a pre-shared key (PSK) for key agreement, it MUST include the \"pre_shared_key\" extension in the ClientHello message. This extension is required to signal the server's supported PSK identities and binders for authentication. The rule applies during the initial handshake negotiation when PSK-based key exchange is proposed. If the client omits this extension while attempting PSK key agreement, the server MUST abort the handshake with a \"missing_extension\" alert. Additionally, the client MUST also include the \"psk_key_exchange_modes\" extension to indicate supported PSK exchange patterns. Note that if the ClientHello does not contain a \"pre_shared_key\" extension, it must instead include both \"signature_algorithms\" and \"supported_groups\" extensions for certificate-based authentication.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions\"\nRule: \"pre_shared_key\" is REQUIRED for PSK key agreement.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions",
    "sentence": "Such a ClientHello message MUST meet the following requirements: If not containing a \"pre_shared_key\" extension, it MUST contain both a \"signature_algorithms\" extension and a \"supported_groups\" extension.",
    "enhanced_sentence": "When a client initiates a TLS 1.3 handshake (indicated by the presence of a \"supported_versions\" extension containing 0x0304), the ClientHello message must adhere to the following requirement: If the ClientHello does not include a \"pre_shared_key\" extension (indicating that PSK key agreement is not being used), it must include both a \"signature_algorithms\" extension (to specify acceptable signature schemes for certificate authentication) and a \"supported_groups\" extension (to list acceptable elliptic curve or finite field groups for key exchange). This ensures the handshake can proceed with authenticated key exchange mechanisms. Failure to include these mandatory extensions when required will result in the server terminating the connection with a \"missing_extension\" alert.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions\"\nRule: Such a ClientHello message MUST meet the following requirements: If not containing a \"pre_shared_key\" extension, it MUST contain both a \"signature_algorithms\" extension and a \"supported_groups\" extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions",
    "sentence": "A client is considered to be attempting to negotiate using this specification if the ClientHello contains a \"supported_versions\" extension with 0x0304 contained in its body.",
    "enhanced_sentence": "A client is considered to be attempting to negotiate using TLS 1.3 if its ClientHello message includes a \"supported_versions\" extension containing the value 0x0304 (which denotes TLS 1.3). This rule applies during the initial handshake phase when the client indicates its supported protocol versions. When this condition is met, the ClientHello must also comply with additional mandatory extension requirements: if no \"pre_shared_key\" extension is present, it must include both \"signature_algorithms\" and \"supported_groups\" extensions; and if \"supported_groups\" is included, \"key_share\" must also be present (and vice versa). Failure to meet these requirements will result in the server aborting the handshake with a \"missing_extension\" alert. This rule ensures proper adherence to TLS 1.3 negotiation semantics and extension dependencies.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions\"\nRule: A client is considered to be attempting to negotiate using this specification if the ClientHello contains a \"supported_versions\" extension with 0x0304 contained in its body.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions",
    "sentence": "Servers receiving a ClientHello which does not conform to these requirements MUST abort the handshake with a \"missing_extension\" alert.",
    "enhanced_sentence": "When a server receives a ClientHello that indicates an attempt to negotiate TLS 1.3 (as determined by the presence of 0x0304 in the \"supported_versions\" extension), the ClientHello must comply with mandatory extension requirements: if not using a pre-shared key, it must include both \"signature_algorithms\" and \"supported_groups\" extensions; and if either \"supported_groups\" or \"key_share\" is present, the other must also be included. If the ClientHello fails to meet these structural requirements, the server MUST immediately terminate the handshake by sending a \"missing_extension\" alert, as the message is improperly formed for TLS 1.3 negotiation. This rule applies during the initial handshake phase before any key exchange or authentication occurs.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions\"\nRule: Servers receiving a ClientHello which does not conform to these requirements MUST abort the handshake with a \"missing_extension\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions",
    "sentence": "Additionally, all implementations MUST support the use of the \"server_name\" extension with applications capable of using it.",
    "enhanced_sentence": "All implementations MUST support the \"server_name\" extension (as defined in RFC6066, Section 3) for applications that are capable of using it, such as those requiring virtual hosting or server name indication. This rule applies during the ClientHello phase of the TLS 1.3 handshake, where clients must include the extension when connecting to servers that host multiple domains. The expected outcome is that the client provides the intended server name, enabling the server to select the appropriate certificate and complete the handshake. Prerequisites include the client’s awareness of the target server name and the absence of conflicting application profile standards. Servers may enforce this extension and terminate connections with a \"missing_extension\" alert if it is not provided when required.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions\"\nRule: Additionally, all implementations MUST support the use of the \"server_name\" extension with applications capable of using it.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions",
    "sentence": "In the absence of an application profile standard specifying otherwise, a TLS-compliant application MUST implement the following TLS extensions: Supported Versions (\"supported_versions\"; Section 4.2.1), Cookie (\"cookie\"; Section 4.2.2), Signature Algorithms (\"signature_algorithms\"; Section 4.2.3), Signature Algorithms Certificate (\"signature_algorithms_cert\"; Section 4.2.3), Negotiated Groups (\"supported_groups\"; Section 4.2.7), Key Share (\"key_share\"; Section 4.2.8), and Server Name Indication (\"server_name\"; Section 3 of RFC6066).",
    "enhanced_sentence": "In the absence of an application profile standard specifying otherwise, a TLS-compliant application MUST implement the following TLS extensions: Supported Versions (\"supported_versions\"; Section 4.2.1), Cookie (\"cookie\"; Section 4.2.2), Signature Algorithms (\"signature_algorithms\"; Section 4.2.3), Signature Algorithms Certificate (\"signature_algorithms_cert\"; Section 4.2.3), Negotiated Groups (\"supported_groups\"; Section 4.2.7), Key Share (\"key_share\"; Section 4.2.8), and Server Name Indication (\"server_name\"; Section 3 of RFC6066). This rule applies during the handshake phase when constructing and processing ClientHello, ServerHello, and HelloRetryRequest messages. The expected outcome is that compliant implementations can successfully negotiate TLS 1.3 parameters and features, ensuring interoperability and security. Prerequisites include the absence of a conflicting application profile standard. Specific behavioral requirements include: All implementations MUST send and use these extensions when offering applicable features. \"supported_versions\" is REQUIRED for all ClientHello, ServerHello, and HelloRetryRequest messages. \"signature_algorithms\" is REQUIRED for certificate authentication. \"supported_groups\" and \"key_share\" are REQUIRED for DHE or ECDHE key exchange (each requiring the other when present). A ClientHello indicating TLS 1.3 negotiation MUST contain both \"signature_algorithms\" and \"supported_groups\" extensions unless using PSK. Servers MUST abort the handshake with a \"missing_extension\" alert if these requirements are not met. Additionally, all implementations MUST support \"server_name\" where applicable, and servers MAY require it, terminating connections with a \"missing_extension\" alert if absent.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions\"\nRule: In the absence of an application profile standard specifying otherwise, a TLS-compliant application MUST implement the following TLS extensions: Supported Versions (\"supported_versions\"; Section 4.2.1), Cookie (\"cookie\"; Section 4.2.2), Signature Algorithms (\"signature_algorithms\"; Section 4.2.3), Signature Algorithms Certificate (\"signature_algorithms_cert\"; Section 4.2.3), Negotiated Groups (\"supported_groups\"; Section 4.2.7), Key Share (\"key_share\"; Section 4.2.8), and Server Name Indication (\"server_name\"; Section 3 of RFC6066).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions",
    "sentence": "Servers MAY require clients to send a valid \"server_name\" extension.",
    "enhanced_sentence": "Servers MAY require clients to send a valid \"server_name\" extension (as defined in RFC6066 Section 3) to indicate the intended destination hostname when establishing a TLS 1.3 connection. This rule applies during the ClientHello message exchange in the handshake protocol flow. When enforced, servers that require this extension SHOULD terminate the connection with a \"missing_extension\" alert if the ClientHello does not contain a valid \"server_name\" extension. This requirement is particularly relevant for servers hosting multiple virtual hosts on a single IP address, where the extension is necessary for proper host selection and certificate presentation. The rule applies only when clients are attempting to negotiate TLS 1.3, as indicated by the presence of the \"supported_versions\" extension with value 0x0304 in the ClientHello.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions\"\nRule: Servers MAY require clients to send a valid \"server_name\" extension.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions",
    "sentence": "Servers requiring this extension SHOULD respond to a ClientHello lacking a \"server_name\" extension by terminating the connection with a \"missing_extension\" alert.",
    "enhanced_sentence": "When a server requires the \"server_name\" extension (as defined in RFC6066) for proper operation—such as selecting the correct certificate or service context—and receives a ClientHello message that does not include this extension, the server SHOULD terminate the TLS 1.3 handshake by sending a \"missing_extension\" alert. This applies only if the server is configured to mandate the extension and the client’s omission prevents the server from proceeding. The rule is intended to enforce explicit client indication of the intended server name, ensuring compliant behavior when the extension is obligatory. Note that the \"server_name\" extension is mandatory-to-implement for all TLS 1.3 implementations, but its use may be required by specific server configurations or application profiles.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions\"\nRule: Servers requiring this extension SHOULD respond to a ClientHello lacking a \"server_name\" extension by terminating the connection with a \"missing_extension\" alert.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions",
    "sentence": "If containing a \"supported_groups\" extension, it MUST also contain a \"key_share\" extension, and vice versa.",
    "enhanced_sentence": "This rule applies to TLS 1.3 ClientHello messages that indicate an attempt to negotiate using TLS 1.3 (as determined by the presence of a \"supported_versions\" extension containing 0x0304). When a client includes either a \"supported_groups\" extension (which lists the elliptic curve or finite field groups it supports for key exchange) or a \"key_share\" extension (which contains one or more cryptographic shares for key establishment), it MUST include both extensions. This ensures that the client is properly prepared for elliptic curve or finite field Diffie-Hellman (ECDHE/DHE) key exchange, as both the list of supported groups and the actual key share material are required for the handshake to proceed. Failure to include both extensions when either is present will result in the server aborting the handshake with a \"missing_extension\" alert. Note: An empty KeyShare.client_shares vector is permitted, but the extension itself must be present.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"9. Compliance Requirements -> 9.2. Mandatory-to-Implement Extensions\"\nRule: If containing a \"supported_groups\" extension, it MUST also contain a \"key_share\" extension, and vice versa.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "8. 0-RTT and Anti-Replay -> 8.2. Client Hello Recording",
    "sentence": "If the expected_arrival_time is in the window, then the server checks to see if it has recorded a matching ClientHello.",
    "enhanced_sentence": "When implementing time-window-based anti-replay protection for 0-RTT data in TLS 1.3, if the server has validated the PSK binder and computed an expected_arrival_time that falls within the configured recording window, the server must check whether it has previously recorded a matching ClientHello (using a storage key derived from validated sections such as ClientHello.random or the validated PSK binder). If a matching ClientHello is found, the server must either abort the handshake with an \"illegal_parameter\" alert or accept the PSK while rejecting 0-RTT data. If no match is found, the server accepts the 0-RTT data and stores the ClientHello for the duration of the window. This rule applies after PSK binder validation and expected_arrival_time calculation, and is critical for preventing replay attacks while maintaining state efficiency in distributed systems.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"8. 0-RTT and Anti-Replay -> 8.2. Client Hello Recording\"\nRule: If the expected_arrival_time is in the window, then the server checks to see if it has recorded a matching ClientHello.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "8. 0-RTT and Anti-Replay -> 8.2. Client Hello Recording",
    "sentence": "If a matching ClientHello is found, the server either aborts the handshake with an \"illegal_parameter\" alert or accepts the PSK but rejects 0-RTT.",
    "enhanced_sentence": "When implementing anti-replay protection by recording ClientHello messages within a time window (using the obfuscated_ticket_age to determine expected_arrival_time), if a server receives a ClientHello with an expected_arrival_time within the recording window and finds a matching ClientHello already stored (indicating a potential replay), the server MUST either abort the handshake entirely by sending an \"illegal_parameter\" alert or accept the PSK for resumption but reject any 0-RTT data, falling back to a 1-RTT handshake. This rule applies only after the server has validated the PSK binder and confirmed the expected_arrival_time is within the recording window. If using probabilistic data structures (e.g., Bloom filters) that may yield false positives, the server MUST NOT abort the handshake and MUST only reject 0-RTT. The storage key for matching MUST be derived only from validated sections of the ClientHello (e.g., the validated binder or ClientHello.random) to prevent storage bypass attacks.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"8. 0-RTT and Anti-Replay -> 8.2. Client Hello Recording\"\nRule: If a matching ClientHello is found, the server either aborts the handshake with an \"illegal_parameter\" alert or accepts the PSK but rejects 0-RTT.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "8. 0-RTT and Anti-Replay -> 8.2. Client Hello Recording",
    "sentence": "An alternative form of anti-replay is to record a unique value derived from the ClientHello (generally either the random value or the PSK binder) and reject duplicates.",
    "enhanced_sentence": "This rule applies during the TLS 1.3 handshake when a server receives a ClientHello with 0-RTT data enabled. It governs an anti-replay mechanism where the server records a unique value derived from the ClientHello—typically either the ClientHello.random or the validated PSK binder—and rejects any duplicate ClientHellos to prevent replay attacks. The server must first verify the PSK binder as specified in Section 4.2.11 and compute the expected_arrival_time to determine if the ClientHello falls within a defined recording window. If a duplicate is detected, the server must either abort the handshake with an \"illegal_parameter\" alert or accept the PSK but reject 0-RTT data. Servers may use storage mechanisms with false positives (e.g., Bloom filters), but in such cases, they must only reject 0-RTT without aborting the handshake. This approach is particularly useful in distributed systems where storing all ClientHellos is impractical, though it may offer weaker anti-replay guarantees due to potential inconsistencies in storage.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"8. 0-RTT and Anti-Replay -> 8.2. Client Hello Recording\"\nRule: An alternative form of anti-replay is to record a unique value derived from the ClientHello (generally either the random value or the PSK binder) and reject duplicates.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "8. 0-RTT and Anti-Replay -> 8.2. Client Hello Recording",
    "sentence": "If no matching ClientHello is found, then the server accepts 0-RTT and then stores the ClientHello for as long as the expected_arrival_time is inside the window.",
    "enhanced_sentence": "When implementing the anti-replay mechanism using ClientHello recording, if the server receives a ClientHello with a valid PSK binder and an expected_arrival_time within the recording window, and no matching ClientHello (based on a unique storage key derived from validated sections such as the ClientHello.random or the PSK binder) is found in the server’s storage, then the server MUST accept 0-RTT data and store the ClientHello for the duration that the expected_arrival_time remains within the window. This rule applies during the TLS 1.3 handshake after PSK binder validation and expected_arrival_time calculation, and ensures that duplicate ClientHellos are detected to prevent replay attacks while allowing legitimate 0-RTT resumptions. Prerequisites include a correctly configured recording window and validated PSK binder; implementations must also ensure storage consistency, especially in distributed systems, to avoid false negatives or replays across zones.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"8. 0-RTT and Anti-Replay -> 8.2. Client Hello Recording\"\nRule: If no matching ClientHello is found, then the server accepts 0-RTT and then stores the ClientHello for as long as the expected_arrival_time is inside the window.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "8. 0-RTT and Anti-Replay -> 8.2. Client Hello Recording",
    "sentence": "The server MUST derive the storage key only from validated sections of the ClientHello.",
    "enhanced_sentence": "When implementing anti-replay protection by recording ClientHellos within a time window, the server MUST derive the storage key used for duplicate detection only from validated sections of the ClientHello—specifically, either the verified PSK binder (for the preferred identity) or the ClientHello.random value. This rule applies after the server has successfully verified the PSK binder as described in Section 4.2.11 and before storing the ClientHello for replay checks. By adhering to this requirement, the server prevents attackers from manipulating unverified parts of the ClientHello (such as binders for non-preferred PSK identities) to bypass replay detection, ensuring that only cryptographically validated data influences storage decisions, thereby maintaining the integrity of the anti-replay mechanism without causing false negatives or unnecessary handshake abortions.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"8. 0-RTT and Anti-Replay -> 8.2. Client Hello Recording\"\nRule: The server MUST derive the storage key only from validated sections of the ClientHello.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "8. 0-RTT and Anti-Replay -> 8.2. Client Hello Recording",
    "sentence": "If the ClientHello contains multiple PSK identities, then an attacker can create multiple ClientHellos with different binder values for the less-preferred identity on the assumption that the server will not verify the less-preferred identity (as recommended by Section 4.2.11).",
    "enhanced_sentence": "When implementing anti-replay protection by recording ClientHello messages to detect duplicates, if the ClientHello contains multiple PSK identities, then an attacker can create multiple ClientHellos with different binder values for the less-preferred identity on the assumption that the server will not verify the less-preferred identity (as recommended by Section 4.2.11). This rule applies during the server's processing of a ClientHello in 0-RTT handshakes, after the server has verified the PSK binder of the preferred identity but before storing the ClientHello for replay detection. To prevent this attack, the server MUST derive the storage key only from validated sections of the ClientHello—specifically using either the validated PSK binder (of the preferred identity) or the ClientHello.random—to ensure that any tampering with unverified identities does not bypass duplicate detection. The expected outcome is that replay attempts using manipulated binders for non-preferred identities are correctly identified and rejected, maintaining the integrity of the anti-replay mechanism without aborting the handshake unnecessarily.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"8. 0-RTT and Anti-Replay -> 8.2. Client Hello Recording\"\nRule: If the ClientHello contains multiple PSK identities, then an attacker can create multiple ClientHellos with different binder values for the less-preferred identity on the assumption that the server will not verify the less-preferred identity (as recommended by Section 4.2.11).\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "9. Compliance Requirements -> 9.3. Protocol Invariants",
    "sentence": "For this to work, implementations MUST correctly handle extensible fields: A client sending a ClientHello MUST support all parameters advertised in the ClientHello.",
    "enhanced_sentence": "To ensure secure and compatible extensibility across TLS versions, implementations MUST correctly handle extensible fields. Specifically, during the TLS handshake, when a client sends a ClientHello message, it MUST support all parameters (such as cipher suites, extensions, and other advertised options) included in that message. This rule applies to all TLS endpoints and middleboxes and is critical for interoperability, as it prevents servers from selecting unsupported parameters that could cause handshake failures. Adherence to this requirement allows newer clients to negotiate preferred parameters with newer servers while maintaining backward compatibility with older deployments.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"9. Compliance Requirements -> 9.3. Protocol Invariants\"\nRule: For this to work, implementations MUST correctly handle extensible fields: A client sending a ClientHello MUST support all parameters advertised in the ClientHello.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "8. 0-RTT and Anti-Replay -> 8.2. Client Hello Recording",
    "sentence": "If the binder for B is part of the storage key, then this ClientHello will not appear as a duplicate, which will cause the ClientHello to be accepted, and may cause side effects such as replay cache pollution, although any 0-RTT data will not be decryptable because the data will use different keys.",
    "enhanced_sentence": "When implementing anti-replay protection using ClientHello recording (as described in Section 8.2), if the server includes the PSK binder value for a less-preferred identity (e.g., identity B) in the storage key used to detect duplicate ClientHello messages, an attacker can modify that binder without detection—since the server only validates the preferred identity's binder (e.g., identity A). This causes the modified ClientHello to be treated as unique rather than a replay, resulting in its acceptance. Although 0-RTT data attached to such a ClientHello will not be decryptable (due to key mismatch), this scenario can lead to replay cache pollution and unnecessary storage consumption. To prevent this, the server MUST derive the storage key only from validated portions of the ClientHello, such as the validated binder or the ClientHello.random.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"8. 0-RTT and Anti-Replay -> 8.2. Client Hello Recording\"\nRule: If the binder for B is part of the storage key, then this ClientHello will not appear as a duplicate, which will cause the ClientHello to be accepted, and may cause side effects such as replay cache pollution, although any 0-RTT data will not be decryptable because the data will use different keys.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "8. 0-RTT and Anti-Replay -> 8.2. Client Hello Recording",
    "sentence": "If the validated binder or the ClientHello.random is used as the storage key, then this attack is not possible.",
    "enhanced_sentence": "When implementing anti-replay protection using ClientHello recording, the server MUST derive the storage key exclusively from either the validated PSK binder (from the server's preferred PSK identity) or the ClientHello.random value. This applies after the server has verified the PSK binder as specified in Section 4.2.11 and computed the expected_arrival_time within the recording window. Using unvalidated sections of the ClientHello (such as binders from non-preferred PSK identities) as storage keys creates a vulnerability where attackers can modify those sections without detection, allowing replay cache pollution through duplicate ClientHellos that appear unique. By using only validated components as the storage key, the server ensures that any modification to the ClientHello will result in a different storage key, making replay attacks detectable and preventing the acceptance of duplicate 0-RTT connections.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"8. 0-RTT and Anti-Replay -> 8.2. Client Hello Recording\"\nRule: If the validated binder or the ClientHello.random is used as the storage key, then this attack is not possible.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "9. Compliance Requirements -> 9.3. Protocol Invariants",
    "sentence": "A server receiving a ClientHello MUST correctly ignore all unrecognized cipher suites, extensions, and other parameters.",
    "enhanced_sentence": "During the TLS 1.3 handshake, when a server receives a ClientHello message, it MUST correctly ignore all cipher suites, extensions, and other parameters that it does not recognize. This rule applies to ensure backward and forward compatibility, allowing newer clients to introduce features without breaking interoperability with older or differently configured servers. The server should proceed with the handshake by selecting only from the recognized and supported parameters, effectively treating unrecognized elements as if they were not present. This behavior is required regardless of the TLS version indicated in the ClientHello, as it upholds the protocol's extensibility principles and prevents interoperability failures when endpoints support different feature sets. Prerequisites include the server correctly parsing the ClientHello structure and distinguishing between recognized and unrecognized elements without error. The expected outcome is a successful handshake using mutually understood parameters, or a graceful failure if no common parameters exist, without disruption due to unknown options.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"9. Compliance Requirements -> 9.3. Protocol Invariants\"\nRule: A server receiving a ClientHello MUST correctly ignore all unrecognized cipher suites, extensions, and other parameters.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "7. Cryptographic Computations -> 7.1. Key Schedule",
    "sentence": "The key derivation schedule is: PSK -> HKDF-Extract = Early Secret -> Derive-Secret(., \"ext binder\" or \"res binder\", \"\") = binder_key -> Derive-Secret(., \"c e traffic\", ClientHello) = client_early_traffic_secret -> Derive-Secret(., \"e exp master\", ClientHello) = early_exporter_master_secret -> Derive-Secret(., \"derived\", \"\") -> (EC)DHE -> HKDF-Extract = Handshake Secret -> Derive-Secret(., \"c hs traffic\", ClientHello...ServerHello) = client_handshake_traffic_secret -> Derive-Secret(., \"s hs traffic\", ClientHello...ServerHello) = server_handshake_traffic_secret -> Derive-Secret(., \"derived\", \"\") -> 0 -> HKDF-Extract = Master Secret -> Derive-Secret(., \"c ap traffic\", ClientHello...server Finished) = client_application_traffic_secret_0 -> Derive-Secret(., \"s ap traffic\", ClientHello...server Finished) = server_application_traffic_secret_0 -> Derive-Secret(., \"exp master\", ClientHello...server Finished) = exporter_master_secret -> Derive-Secret(., \"res master\", ClientHello...client Finished) = resumption_master_secret.",
    "enhanced_sentence": "This rule governs the TLS 1.3 key derivation process, which applies during the handshake phase to generate all cryptographic secrets used for encryption, authentication, and key export. The schedule must be followed when establishing a TLS 1.3 connection, whether using pre-shared keys (PSK), (EC)DHE key exchange, or both. Prerequisites include having the necessary input secrets (PSK and/or (EC)DHE shared secret) and the handshake messages for transcript hashing. The expected outcome is a complete set of derived secrets: binder_key for PSK verification, early/handshake/application traffic secrets for encrypted communication in respective phases, and master secrets for export and resumption purposes. Each derivation step uses HKDF-Extract and Derive-Secret functions with specific labels and message transcripts, ensuring proper context separation and forward secrecy. If PSK is not available, a zero-value of Hash.length bytes must be used instead, maintaining the derivation structure.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"7. Cryptographic Computations -> 7.1. Key Schedule\"\nRule: The key derivation schedule is: PSK -> HKDF-Extract = Early Secret -> Derive-Secret(., \"ext binder\" or \"res binder\", \"\") = binder_key -> Derive-Secret(., \"c e traffic\", ClientHello) = client_early_traffic_secret -> Derive-Secret(., \"e exp master\", ClientHello) = early_exporter_master_secret -> Derive-Secret(., \"derived\", \"\") -> (EC)DHE -> HKDF-Extract = Handshake Secret -> Derive-Secret(., \"c hs traffic\", ClientHello...ServerHello) = client_handshake_traffic_secret -> Derive-Secret(., \"s hs traffic\", ClientHello...ServerHello) = server_handshake_traffic_secret -> Derive-Secret(., \"derived\", \"\") -> 0 -> HKDF-Extract = Master Secret -> Derive-Secret(., \"c ap traffic\", ClientHello...server Finished) = client_application_traffic_secret_0 -> Derive-Secret(., \"s ap traffic\", ClientHello...server Finished) = server_application_traffic_secret_0 -> Derive-Secret(., \"exp master\", ClientHello...server Finished) = exporter_master_secret -> Derive-Secret(., \"res master\", ClientHello...client Finished) = resumption_master_secret.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "8. 0-RTT and Anti-Replay -> 8.2. Client Hello Recording",
    "sentence": "Because this mechanism does not require storing all outstanding tickets, it may be easier to implement in distributed systems with high rates of resumption and 0-RTT, at the cost of potentially weaker anti-replay defense because of the difficulty of reliably storing and retrieving the received ClientHello messages.",
    "enhanced_sentence": "This rule applies when implementing the alternative anti-replay mechanism that records unique values derived from ClientHello messages (such as the random value or PSK binder) rather than storing all outstanding tickets. The mechanism is triggered during the processing of a ClientHello in a 0-RTT handshake, after the server has verified the PSK binder and computed the expected_arrival_time. \n\nThe expected outcome is that servers in distributed systems can more easily handle high volumes of resumption and 0-RTT connections without maintaining unbounded state, but at the cost of potentially weaker replay protection due to challenges in reliably storing and retrieving ClientHello records across distributed nodes. \n\nPrerequisites include: the server must have implemented a time-window based recording system using obfuscated_ticket_age, must derive storage keys only from validated sections of the ClientHello, and must handle cases where multiple PSK identities are present by using either the validated binder or ClientHello.random as the storage key to prevent cache pollution attacks. The mechanism is particularly suitable for systems where global consistency of ClientHello storage is impractical, but implementers should be aware that it provides weaker anti-replay guarantees compared to storing all outstanding tickets.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"8. 0-RTT and Anti-Replay -> 8.2. Client Hello Recording\"\nRule: Because this mechanism does not require storing all outstanding tickets, it may be easier to implement in distributed systems with high rates of resumption and 0-RTT, at the cost of potentially weaker anti-replay defense because of the difficulty of reliably storing and retrieving the received ClientHello messages.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "9. Compliance Requirements -> 9.3. Protocol Invariants",
    "sentence": "In TLS 1.3, a client receiving a CertificateRequest or NewSessionTicket MUST also ignore all unrecognized extensions.",
    "enhanced_sentence": "During the TLS 1.3 handshake or post-handshake phase, when a client receives a CertificateRequest (requesting client authentication) or a NewSessionTicket (providing a session resumption ticket), it MUST ignore any extension within these messages that it does not recognize. This rule ensures backward and forward compatibility by allowing new extensions to be added to these messages without breaking interoperability with older or newer implementations. The client must process the message normally, skipping any unknown extensions, and must not abort the connection or signal an error solely due to the presence of unrecognized extensions. This behavior is required regardless of the client’s support for other extensions and applies only to extensions within the specified messages; other message components must still be validated according to the protocol specification.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"9. Compliance Requirements -> 9.3. Protocol Invariants\"\nRule: In TLS 1.3, a client receiving a CertificateRequest or NewSessionTicket MUST also ignore all unrecognized extensions.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "9. Compliance Requirements -> 9.3. Protocol Invariants",
    "sentence": "A middlebox which forwards ClientHello parameters the middlebox does not understand MUST NOT process any messages beyond that ClientHello.",
    "enhanced_sentence": "This rule applies to TLS middleboxes that forward (rather than terminate) TLS handshakes. When a middlebox receives a ClientHello containing parameters (such as extensions or cipher suites) that it does not understand, it MUST NOT attempt to parse, interpret, or modify any subsequent messages in the handshake or application data flow. The middlebox MUST forward all such messages unmodified. This requirement ensures that the middlebox does not interfere with newer TLS features or extensions that it does not support, preserving interoperability between endpoints that may negotiate parameters unknown to the middlebox. The rule is in effect immediately after processing the ClientHello and applies for the duration of the TLS connection.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"9. Compliance Requirements -> 9.3. Protocol Invariants\"\nRule: A middlebox which forwards ClientHello parameters the middlebox does not understand MUST NOT process any messages beyond that ClientHello.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "11. IANA Considerations",
    "sentence": "IANA has added the cipher suites listed in Appendix B.4 to the registry.",
    "enhanced_sentence": "IANA has added the cipher suites listed in Appendix B.4 to the TLS Cipher Suites registry, as part of the TLS 1.3 protocol specification. This action applies during the protocol's standardization and maintenance phase, ensuring that the cipher suites defined for TLS 1.3 are formally registered and available for implementation. The expected outcome is that these cipher suites are recognized in the IANA registry with their Value and Description columns populated from Appendix B.4, and both the DTLS-OK and Recommended columns marked as \"Y\" for each entry. Prerequisites include the cipher suites being defined and documented in Appendix B.4 of the specification, and the registry update follows the allocation policy where values with the first byte in the range 0–254 decimal are assigned via Specification Required [RFC8126].",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"11. IANA Considerations\"\nRule: IANA has added the cipher suites listed in Appendix B.4 to the registry.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "9. Compliance Requirements -> 9.3. Protocol Invariants",
    "sentence": "In particular, the middlebox MUST generate its own ClientHello containing only parameters the middlebox understands, and the middlebox MUST generate a fresh ServerHello random value, rather than forwarding the endpoint's value.",
    "enhanced_sentence": "When a middlebox terminates a TLS connection, it MUST act as a compliant TLS server to the client and a compliant TLS client to the server. This rule applies specifically during the TLS handshake phase when the middlebox is generating its own ClientHello to send to the server. The middlebox MUST construct a new ClientHello that includes only parameters (such as cipher suites and extensions) that it fully understands and supports, rather than blindly forwarding the client's original parameters. Additionally, the middlebox MUST generate a fresh, cryptographically random value for the ServerHello.random field when responding to the client, instead of reusing or forwarding the server's random value. This ensures that the middlebox does not inadvertently advertise unsupported features or weaken the cryptographic properties of the handshake. Prerequisites include the middlebox having a valid certificate acceptable to the client and properly verifying the server's certificate. The expected outcome is that the middlebox maintains separate, compliant TLS connections with each endpoint without interfering with extensibility or security.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"9. Compliance Requirements -> 9.3. Protocol Invariants\"\nRule: In particular, the middlebox MUST generate its own ClientHello containing only parameters the middlebox understands, and the middlebox MUST generate a fresh ServerHello random value, rather than forwarding the endpoint's value.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "11. IANA Considerations",
    "sentence": "IANA has updated the TLS ExtensionType Values registry to include a TLS 1.3 column which lists the messages in which the extension may appear.",
    "enhanced_sentence": "IANA has updated the TLS ExtensionType Values registry to include a TLS 1.3 column, which specifies the protocol messages (e.g., ClientHello, ServerHello, EncryptedExtensions, CertificateRequest, or NewSessionTicket) in which each extension is permitted to appear during a TLS 1.3 handshake or post-handshake exchange. This update applies to all extensions defined for TLS 1.3, ensuring that implementers can verify correct usage contexts as defined in Section 4.2 of the specification. The column is initially populated from that section, with extensions not listed there marked as not applicable to TLS 1.3. This change supports interoperability by clarifying extension placement rules and preventing misuse in unsupported messages.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"11. IANA Considerations\"\nRule: IANA has updated the TLS ExtensionType Values registry to include a TLS 1.3 column which lists the messages in which the extension may appear.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  },
  {
    "heading": "11. IANA Considerations",
    "sentence": "IANA has updated the TLS ExtensionType Values registry to include the key_share, pre_shared_key, psk_key_exchange_modes, early_data, cookie, supported_versions, certificate_authorities, oid_filters, post_handshake_auth, and signature_algorithms_cert extensions with the values defined in this document and the Recommended value of Y.",
    "enhanced_sentence": "IANA has updated the TLS ExtensionType Values registry to include the key_share, pre_shared_key, psk_key_exchange_modes, early_data, cookie, supported_versions, certificate_authorities, oid_filters, post_handshake_auth, and signature_algorithms_cert extensions with the values defined in this document and the Recommended value of Y. This update applies to TLS 1.3 and later, ensuring that these critical extensions are formally recognized and recommended for use in the protocol. The rule governs the registration and allocation of extension types, which are used during the TLS handshake to negotiate parameters such as key exchange methods, supported versions, and authentication details. This action is a prerequisite for implementations to correctly interpret and process these extensions. The expected outcome is that compliant TLS 1.3 implementations will support these extensions as standardized, promoting interoperability and security. The registry update follows the policy where values with the first byte in the range 0-254 are assigned via Specification Required, and those with the first byte 255 are reserved for Private Use.",
    "final_prompt": "You are analyzing a rule from the tls 1.3 protocol specification.\n        \nContext: This rule appears under the section \"11. IANA Considerations\"\nRule: IANA has updated the TLS ExtensionType Values registry to include the key_share, pre_shared_key, psk_key_exchange_modes, early_data, cookie, supported_versions, certificate_authorities, oid_filters, post_handshake_auth, and signature_algorithms_cert extensions with the values defined in this document and the Recommended value of Y.\n        \nYour task is to enhance this rule by providing additional context that would help developers understand:\n1. What specific protocol behavior this rule governs\n2. When this rule applies in the protocol flow\n3. What the expected outcome should be when this rule is followed\n4. Any prerequisites or conditions that must be met\n        \nPlease provide an enhanced version of this rule that includes necessary context while maintaining technical accuracy. Keep the enhancement concise but comprehensive.\n        \nFormat your response as:\nEnhanced Rule: [your enhanced version here]\n"
  }
]